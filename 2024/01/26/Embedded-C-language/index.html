<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Embedded C language | Zhixiong's island</title><meta name="author" content="Zhixiong Zhang"><meta name="copyright" content="Zhixiong Zhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C语言在单片机编程的一些重要应用">
<meta property="og:type" content="article">
<meta property="og:title" content="Embedded C language">
<meta property="og:url" content="http://zzx686a.github.io/2024/01/26/Embedded-C-language/index.html">
<meta property="og:site_name" content="Zhixiong&#39;s island">
<meta property="og:description" content="C语言在单片机编程的一些重要应用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2024-01-26T11:04:36.000Z">
<meta property="article:modified_time" content="2024-02-16T14:21:03.160Z">
<meta property="article:author" content="Zhixiong Zhang">
<meta property="article:tag" content="C language programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/images/bear.png"><link rel="canonical" href="http://zzx686a.github.io/2024/01/26/Embedded-C-language/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":50},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Embedded C language',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-16 22:21:03'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/xxx.css"><meta name="generator" content="Hexo 6.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./images/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> menu</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> list</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> about</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery"><i class="fa-fw fa-solid fa-image"></i><span> Picture</span></a></div><div class="menus_item"><a class="site-page" href="/message"><i class="fa-fw fa-solid fa-message"></i><span> Message</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Zhixiong's island"><span class="site-name">Zhixiong's island</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> menu</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> list</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> about</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery"><i class="fa-fw fa-solid fa-image"></i><span> Picture</span></a></div><div class="menus_item"><a class="site-page" href="/message"><i class="fa-fw fa-solid fa-message"></i><span> Message</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Embedded C language</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-26T11:04:36.000Z" title="发表于 2024-01-26 19:04:36">2024-01-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-16T14:21:03.160Z" title="更新于 2024-02-16 22:21:03">2024-02-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>61分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Embedded C language"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="嵌入式C语言与算法"><a href="#嵌入式C语言与算法" class="headerlink" title="嵌入式C语言与算法"></a>嵌入式C语言与算法</h1><p><img src="/2024/01/26/Embedded-C-language/image-20240115231828910.png" alt="image-20240115231828910"></p>
<p><img src="/2024/01/26/Embedded-C-language/image-20240115232323794.png" alt="image-20240115232323794"></p>
<p>简述C语言中的基础知识<br>    1).数据类型(常用char, short, int , long, signed, unsigned, float, double, sizeof)<br>    2).运算和控制( &#x3D;, +, -, *, while, do-while, if, else, switch, case, continue, break)<br>    3).数据存储(static, extern, const, volatile)<br>    4).结构(struct, enum, union, typedef)<br>    5).位操作和逻辑运算(&lt;&lt;, &gt;&gt;, &amp;, |, ~, ^)<br>    6).预处理(#define, #include, #if…#elif…#else…#endif等)</p>
<img src="/2024/01/26/Embedded-C-language/image-20240119170447733.png" alt="image-20240119170447733" style="zoom:67%;">

<h2 id="1-char-short-int数据类型"><a href="#1-char-short-int数据类型" class="headerlink" title="1.char short int数据类型"></a>1.char short int数据类型</h2><p>对于单片机开发来说，是至关重要的。因为单片机有8位、16位、32位。如果不注意数据类型，不注意数据长度，那么在编写代码的时候，很容易就会造成数据溢出，导致程序出现bug，而且还很难发现原因。</p>
<p>如果熟悉stm32单片机开发的同学，看官方的例程时，使用的数据类型往往都是重新定义过的类型，很少有直接使用原始数据类型的，比如GPIOIO口设置。</p>
<p>为什么要这样做吗？不嫌麻烦吗？自己平时写程序的时候，往往都是直接使用数据类型的默认名，也依然可以正常使用，没什么问题。但是官方为什么一定要重新定义一次数据类型呢？</p>
<p>个说白了就是大局观的问题，因为官方比我们个人更具有大局观。个人面对的可能也只有几个平台和几款单片机。而官方面对的是多个平台和多种单片机的，这就不得不考虑数据兼容问题了。比如在32位单片机上的算法移植到8位单片机上，代码运行起来后，到处都是数据溢出。要挨个去修改变量的数据类型，那么这时候，作为开发者来说，奔溃不奔溃？抓狂不抓狂？</p>
<p>所以为了解决这个问题，官方就会在每个平台下，给数据类型，重新命名一次，如果需要更换平台，那么只需要替换这个数据重命名的头文件即可。</p>
<p>在32位单片机中int是32位，而在8位单片机中long 才是32位。那么在32位单片机上的int型变量，如果直接移植到8位单片机上的话，那么肯定就会出现数据溢出的问题。</p>
<p>那么如果使用了重命名后的新变量类型 uint32_t ，不论在8位和32位的单片机上，这个数据都会是32位，这样通过数据类型的重定义，就避免了，同样的数据类型，在不同平台上长度不一致的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> 			<span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> 		<span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> 			<span class="type">uint32_t</span>;</span><br></pre></td></tr></table></figure>

<p>不同平台数据类型所占字节对比：</p>
<p>（1个字节有8位）</p>
<p><img src="/2024/01/26/Embedded-C-language/image-20240113193817299.png" alt="image-20240113193817299"></p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>见”union共同体”章节</p>
<h4 id="实例应用"><a href="#实例应用" class="headerlink" title="实例应用"></a>实例应用</h4><p>1.<em>智能家居：网关协议，mac地址上报？</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *mac=<span class="string">&quot;192.168.31.84&quot;</span></span><br><span class="line"><span class="type">char</span> mac_array[<span class="number">4</span>]=&#123;<span class="number">192</span>,<span class="number">168</span>,<span class="number">31</span>,<span class="number">84</span>&#125;</span><br></pre></td></tr></table></figure>

<p>mac地址如上所示为”192.168.31.84”，为了将其上传到服务器，在定通讯协议时，会和服务器的同事沟通好，收到下面这样一个mac_array数组时，就在每两个数之间加一个小数点来表示mac地址。</p>
<p>即我们将mac地址转化为一个char类型的数组上传到服务器。</p>
<p>提问：<strong>为什么mac_array数组的类型用char,而不用int等数据类型？</strong></p>
<p>答：你可以把数据类型当成一个容器来存放数字，只是它们的容量不同，比如</p>
<p>char占用1个字节的内存空间，一个字节有8位，能存放0~255之间的数字，因此char类型很适合表示0-255之间的整数，这个范围完全满足IP地址中每个字段的需求。</p>
<p>如果使用int类型，它通常占用4个字节的内存空间，0-65535，对于用来储存仅需0-255之间的数值而言过于庞大，将浪费大量存储空间，因此在这种情况下，使用char类型更为合适</p>
<p>2.<em>奶茶机器人：温度采集，小数点如何上报云端？</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> temp = <span class="number">37.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> temp_array[<span class="number">2</span>] = &#123;<span class="number">37</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>服务器发过来unix时间戳 :1607143247，一般是发的hex，即发的是5FCB0F4F，我们接受这串数据，并将其重新解析为时间</p>
<p>5FCB0F4F  	{0x5F,0xCB,0x0F,0x4F} </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> time_buffer[<span class="number">4</span>]=&#123;<span class="number">0x5F</span>,<span class="number">0xCB</span>,<span class="number">0x0F</span>,<span class="number">0x4F</span>&#125;;<span class="comment">//十六进制的一位等于四位二进制</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> time;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">u8Tou32B</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (((((((<span class="type">unsigned</span> <span class="type">int</span>)buffer[<span class="number">0</span>])&lt;&lt;<span class="number">8</span>)|buffer[<span class="number">1</span>])&lt;&lt;<span class="number">8</span>)|buffer[<span class="number">2</span>])&lt;&lt;<span class="number">8</span>)|buffer[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    time=u8Tou32B(time_buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time =%ld s\n&quot;</span>,time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5FCB0F4F  	{0x5F,0xCB,0x0F,0x4F} </p>
<p>u8Tou32B函数的作用是将一个包含四个字节的unsigned char数组转换成一个unsigned int类型的32位无符号整数，就是把5F,CB,0F,4F拼起来。</p>
<p>继续对上面的u8Tou32B函数进行优化得</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">u8Tou32B_optimized</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;result, buffer, <span class="keyword">sizeof</span>(result));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    time = u8Tou32B_optimized(time_buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time = %u s\n&quot;</span>, time); <span class="comment">// 使用%u正确打印无符号整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-位操作"><a href="#2-位操作" class="headerlink" title="2.位操作"></a>2.位操作</h2><h3 id="位，字节，进制"><a href="#位，字节，进制" class="headerlink" title="位，字节，进制"></a>位，字节，进制</h3><p>1个字节&#x3D;8个二进制位</p>
<h4 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h4><p>0b开头，只有0，1，一个字节有8位，该字节能表示的最大数字是把所有位都设置为1：(11111111)&#x3D;256,因此1字节可储存0~255范围内的数字。</p>
<p>通常unsignedchar 用1字节表示的范围是0<del>255，而signed char 用1字节表示的范围是-128</del>+127.</p>
<h4 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h4><p>0x开头，用0~15表示数字（0-9，10-15为A-F）</p>
<p><em><strong>每个十六进制位都对应一个4位的二进制数（即4个二进制位）</strong></em>（2^4&#x3D;16,即一个四位的二进制数可以表示从0到15的所有整数值），那么两个十六进制位恰好对应一个8位字节。第一个十六进制表示前4位，第2个十六进制位表示后4位</p>
<p>不同类型数据的转换可见union共同体章节</p>
<h3 id="位逻辑运算符"><a href="#位逻辑运算符" class="headerlink" title="位逻辑运算符"></a>位逻辑运算符</h3><p><img src="/2024/01/26/Embedded-C-language/image-20240113211004993.png" alt="image-20240113211004993"> </p>
<p>位与&amp;:对于每个位，只有两个对象中相应的位都为1时，结果才为1        &amp;&#x3D;</p>
<p>（10010011）&amp;（00111101）&#x3D;（00010001）	</p>
<p>常见用法: ch&amp;&#x3D;0xff(0xff二进制形式是11111111，这个掩码保持ch中最后8位不变，其它位都设置为0)			   </p>
<p>位或|:只要有一个1就为1								       |&#x3D;</p>
<p>（10010011）|（00111101）&#x3D;（10111111）</p>
<p>0x20|0x0C&#x3D;0x2C</p>
<p>位异或^:</p>
<p>取反~:把0变为1，1变为0</p>
<p>在c语言中，<code>!</code>和<code>~</code>均表示取反。</p>
<p>这两个符号的区别在于：</p>
<ul>
<li><strong><code>!</code></strong> : 代表<strong>逻辑取反</strong>，即：把非0的数值变为0，0变为1;</li>
<li><em><strong>*<code>~</code>*</strong></em> : 表示<strong>按位取反</strong>，即在数值的二进制表示方式上,将0变为1，将1变为0。</li>
</ul>
<h3 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h3><p>按位与运算符常用于掩码（mask）。所谓掩码指的是一些设置为开（1）或关（0）的位组合</p>
<p>常见用法: ch&amp;&#x3D;0xff(0xff二进制形式是11111111，这个掩码保持ch中最后8位不变，其它位都设置为0)</p>
<h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>左移&lt;&lt;:  将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）</p>
<p>（10001010）&lt;&lt;2&#x3D;(001010000)</p>
<p>右移&gt;&gt;:  (10001010)&gt;&gt;2&#x3D;(00100010)</p>
<h4 id="1-设置或检查特定的标志位"><a href="#1-设置或检查特定的标志位" class="headerlink" title="1.设置或检查特定的标志位"></a><strong>1.设置或检查特定的标志位</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xEventGroupSetBits(g_xEventCar,(<span class="number">1</span>&lt;&lt;<span class="number">1</span>));</span><br><span class="line"><span class="comment">//在二进制中，数字 1 通常表示为 `0001`。当你把它向左移动 1 位时，每一位都向左移动一位，最右边补上一个 0。所以，`1 &lt;&lt; 1` 的结果会是 `0010`，相当于bit1置1</span></span><br><span class="line"><span class="comment">//1&lt;&lt;0就是1保持不变，仍是0001,相当于bit0置1</span></span><br></pre></td></tr></table></figure>



<h4 id="2-从较大单元中提取一些位"><a href="#2-从较大单元中提取一些位" class="headerlink" title="2.从较大单元中提取一些位"></a>2.从较大单元中提取一些位</h4><p>此处可链接到“十六进制”章节中</p>
<p>（<em><strong>每个十六进制位都对应一个4位的二进制数（即4个二进制位）</strong></em>（2^4&#x3D;16,即一个四位的二进制数可以表示从0到15的所有整数值），那么两个十六进制位恰好对应一个8位字节。第一个十六进制表示前4位，第2个十六进制位表示后4位）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE_MASK 0xff</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> color =<span class="number">0x002a162f</span>;<span class="comment">//一个十六进制位对应四个二进制位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> blue,green,red;</span><br><span class="line"></span><br><span class="line">red=color&amp;BYTE_MASK;<span class="comment">//取color低8位</span></span><br><span class="line">green=(color&gt;&gt;<span class="number">8</span>)&amp;BYTE_MASK;<span class="comment">//将color右移8位（8个二进制位），再用掩码取低8位，则可使green取color中间8位</span></span><br><span class="line">blue=(color&gt;&gt;<span class="number">16</span>)&amp;BYTE_MASK;<span class="comment">//将color右移16位（16个二进制位)，再用掩码取低8位，则可使blue取color高8位</span></span><br></pre></td></tr></table></figure>



<p><img src="/2024/01/26/Embedded-C-language/image-20240114140043073.png" alt="image-20240114140043073"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_SET_INPUT_POS:</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(data, &amp;(odrive_set-&gt;input_pos), <span class="number">4</span>);<span class="comment">//4个字节 32位 ，input_pos也是32位，复制到data数组中  uint8_t data[8]  ，yi会将数组前四位补齐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//odrive_set-&gt;vel_ff  vel_ff有16位 两个字节 ,data的一个元素的类型是uint8_t,有8位</span></span><br><span class="line">       data[<span class="number">4</span>] = odrive_set-&gt;vel_ff &amp; <span class="number">0x00FF</span>;<span class="comment">//保留低8位</span></span><br><span class="line"><span class="comment">//packetlength &amp; 0x00FF中的&amp;是先把&amp;两边的值转换成二进制形式，然后在进行按位运算</span></span><br><span class="line">       data[<span class="number">5</span>] = odrive_set-&gt;vel_ff &gt;&gt; <span class="number">8</span>;<span class="comment">//取高8位</span></span><br><span class="line"></span><br><span class="line">       data[<span class="number">6</span>] = odrive_set-&gt;current_ff &amp; <span class="number">0x00FF</span>;</span><br><span class="line">       data[<span class="number">7</span>] = odrive_set-&gt;current_ff &gt;&gt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       header.RTR = CAN_RTR_DATA;</span><br><span class="line">       header.DLC = <span class="number">8</span>;</span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h2><p>float candy[365];	&#x2F;<em>内含365个float类型元素的数组</em>&#x2F;</p>
<h2 id="4-结构体struct"><a href="#4-结构体struct" class="headerlink" title="4.结构体struct"></a>4.结构体struct</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><strong>结构</strong>体是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
<p>结构体中的数据成员可以是基本数据类型（如 int、float、char 等），也可以是其他结构体类型、指针类型等。</p>
<p>关键字–struct, union, typedef</p>
<p>运算符: . ,-&gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title function_">xxx</span><span class="params">(标签，这个结构体的名字)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​	xxx(变量定义);</span><br><span class="line"></span><br><span class="line">&#125;xxx(结构变量);</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明结构类型</span></span><br><span class="line"><span class="comment">/*1*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> daty;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span>;</span><span class="comment">/*定义某种结构类型的变量*/</span></span><br><span class="line"><span class="comment">/*2*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;p1,p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*3*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;p1,p2;</span><br><span class="line"><span class="comment">/*4*/</span></span><br><span class="line"><span class="keyword">typedef</span> &#123;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> daty;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;today;</span><br><span class="line"></span><br><span class="line">today Today1;</span><br></pre></td></tr></table></figure>

<p>在一般情况下，标签、变量定义，结构变量这 3 部分至少要出现 2 个</p>
<h4 id="tyepedef-struct"><a href="#tyepedef-struct" class="headerlink" title="tyepedef struct"></a>tyepedef struct</h4><p>typedef是类型定义的意思。typedef <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=struct&spm=1001.2101.3001.7020">struct</a> 是为了使用这个结构体方便。</p>
<p>具体区别在于:<br> 若struct <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=node&spm=1001.2101.3001.7020">node</a> {}这样来定义结构体的话。在申请node 的变量时，需要这样写，struct node n;<br> 若用typedef，可以这样写，typedef struct node{}NODE; 。在申请变量时就可以这样写，NODE n;<br> 区别就在于使用时，是否可以省去struct这个关键字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;Stu;</span><br><span class="line">于是在声明变量的时候就可：Stu stu1;</span><br><span class="line">如果没有<span class="keyword">typedef</span>就必须用<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>;</span>来声明</span><br><span class="line">这里的Stu实际上就是<span class="class"><span class="keyword">struct</span> <span class="title">Student</span>的别名。</span></span><br></pre></td></tr></table></figure>

<h4 id="例-odrive-stm32驱动代码（可作为使用结构体时的模板）"><a href="#例-odrive-stm32驱动代码（可作为使用结构体时的模板）" class="headerlink" title="例 odrive&amp;stm32驱动代码（可作为使用结构体时的模板）"></a>例 odrive&amp;stm32驱动代码（可作为使用结构体时的模板）</h4><p>建立结构声明（模板），定义结构变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*odrive.h*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> axis_error;</span><br><span class="line">  <span class="type">uint32_t</span> axis_current_state;</span><br><span class="line">  <span class="type">uint32_t</span> motor_error;</span><br><span class="line">  <span class="type">uint32_t</span> encoder_error;</span><br><span class="line">  <span class="type">uint32_t</span> sensorless_error;</span><br><span class="line">  <span class="type">float</span> encoder_pos_estimate;</span><br><span class="line">  <span class="type">float</span> encoder_vel_estimate;</span><br><span class="line">  <span class="type">int32_t</span> encoder_shadow_count;</span><br><span class="line">  <span class="type">int32_t</span> encoder_cpr_count;</span><br><span class="line">  <span class="type">float</span> iq_setpoint;</span><br><span class="line">  <span class="type">float</span> iq_measured;</span><br><span class="line">  <span class="type">float</span> sensorless_pos_estimate;</span><br><span class="line">  <span class="type">float</span> sensorless_vel_estimate;</span><br><span class="line">  <span class="type">float</span> vbus_voltage;</span><br><span class="line">&#125; OdriveAxisGetState_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>把odrive_set_axis0()声明为一个OdriveAxisSetState_t（在odrive.h定义的结构体）类型的变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*odrive.c*/</span></span><br><span class="line">OdriveAxisSetState_t odrive_set_axis0;</span><br><span class="line">OdriveAxisSetState_t odrive_set_axis1;</span><br></pre></td></tr></table></figure>



<h4 id="结构的初始化"><a href="#结构的初始化" class="headerlink" title="结构的初始化"></a>结构的初始化</h4><p>struct date today&#x3D;{07,31,2014};</p>
<h4 id="结构成员"><a href="#结构成员" class="headerlink" title="结构成员"></a>结构成员</h4><p>在C语言中，访问结构体成员时选择使用.或-&gt;主要取决于你当前操作的对象是<strong>结构体实例本身</strong>还是<strong>指向该结构体的指针</strong>：</p>
<p>•使用.（点号）的情况：当直接操作一个已知的结构体变量时，通过.来访问其内部成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>;</span></span><br><span class="line">stu1.name=<span class="string">&#x27;&#x27;John Doe&#x27;</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string">stu1.age = 20;</span></span><br></pre></td></tr></table></figure>

<p>•使用-&gt;（箭头）的情况：当操作的是指向结构体的指针时，用-&gt;来访问该指针所指向的结构体的成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">stuP</span>;</span></span><br><span class="line">stuP = &amp;stu1; <span class="comment">// 或者 stuP = malloc(sizeof(struct Student));</span></span><br><span class="line"></span><br><span class="line">stuP-&gt;name = <span class="string">&quot;Jane Smith&quot;</span>; <span class="comment">// 使用 -&amp;gt; 访问结构体指针 stuP 所指向的结构体的成员</span></span><br><span class="line">stuP-&gt;age = <span class="number">22</span>;</span><br></pre></td></tr></table></figure>


<p>简而言之，如果你有一个结构体变量名，就用.；如果你有一个指向结构体的指针，就用-&gt;。</p>
<h4 id="结构指针"><a href="#结构指针" class="headerlink" title="结构指针"></a>结构指针</h4><p>和数组不同，结构变量的名字不是结构变量的地址，必须使用&amp;运算符</p>
<h4 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h4><p>向函数传递结构体的信息：1.传递结构体成员  2.传递结构体地址  3.传递结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  GPIO_PIN_RESET = <span class="number">0</span>,</span><br><span class="line">  GPIO_PIN_SET</span><br><span class="line">&#125;GPIO_PinState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> MODER;    <span class="comment">/*!&lt; GPIO port mode register,               Address offset: 0x00      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> OTYPER;   <span class="comment">/*!&lt; GPIO port output type register,        Address offset: 0x04      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> OSPEEDR;  <span class="comment">/*!&lt; GPIO port output speed register,       Address offset: 0x08      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> PUPDR;    <span class="comment">/*!&lt; GPIO port pull-up/pull-down register,  Address offset: 0x0C      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> IDR;      <span class="comment">/*!&lt; GPIO port input data register,         Address offset: 0x10      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ODR;      <span class="comment">/*!&lt; GPIO port output data register,        Address offset: 0x14      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> BSRR;     <span class="comment">/*!&lt; GPIO port bit set/reset register,      Address offset: 0x18      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> LCKR;     <span class="comment">/*!&lt; GPIO port configuration lock register, Address offset: 0x1C      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AFR[<span class="number">2</span>];   <span class="comment">/*!&lt; GPIO alternate function registers,     Address offset: 0x20-0x24 */</span></span><br><span class="line">&#125; GPIO_TypeDef;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*传递结构体地址*/</span></span><br><span class="line">GPIO_PinState <span class="title function_">HAL_GPIO_ReadPin</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span><span class="comment">//第一位GPIO_TypeDef* GPIOx是传入结构体的地址，以便在这个函数中使用这个结构体</span></span><br><span class="line">&#123;</span><br><span class="line">  GPIO_PinState bitstatus;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GPIO_PIN(GPIO_Pin));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((GPIOx-&gt;IDR &amp; GPIO_Pin) != (<span class="type">uint32_t</span>)GPIO_PIN_RESET)<span class="comment">//操作对象是指向结构体的指针，访问该结构体成员时用-&gt;</span></span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = GPIO_PIN_SET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = GPIO_PIN_RESET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bitstatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p><em><strong>typedef 在 MDK 用得最多的就是定义结构体的类型别名和枚举类型了。</strong></em>(typedef struct, typedef enum)</p>
<p>利用typedef可以为某一类型自定义名称(为现有类型创建一个名称)，它没有创建任何新类型，只是为某个已存在的类型增加了一个方便使用的标签。</p>
<p>1.为经常出现的类型创建一个方便，易识别的类型名。</p>
<p>2.常用于给复杂的类型命名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用BYTE表示1字节的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> BYTE</span><br><span class="line"><span class="comment">//随后可以用BYTE来定义变量</span></span><br><span class="line">BYTE x,y[<span class="number">10</span>],*z;</span><br><span class="line"><span class="comment">//#define也可发挥上面同样的功能</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE unsigned char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以把typedef用于结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span></span><br><span class="line">    <span class="type">float</span> real;</span><br><span class="line">    <span class="type">float</span> imag;</span><br><span class="line">&#125;COMPLEX;</span><br><span class="line"><span class="comment">//然后可用COMPLEX类型代替complex结构</span></span><br><span class="line">用<span class="keyword">typedef</span>来命名一个结构类型时，可以省略该结构的标签。（见例odrive&amp;stm32驱动代码）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以为结体定义一个别名 GPIO_TypeDef，这样我们就可以在其他地方通过别名 GPIO_TypeDef 来定义结构体变量了。</p>
<p>方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> __IO <span class="type">uint32_t</span> CRL;</span><br><span class="line"> __IO <span class="type">uint32_t</span> CRH;</span><br><span class="line">…</span><br><span class="line">&#125; GPIO_TypeDef;</span><br></pre></td></tr></table></figure>

<p>Typedef 为结构体定义一个别名 GPIO_TypeDef。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_TypeDef _GPIOA,_GPIOB;</span><br></pre></td></tr></table></figure>

<p>GPIO_TypeDef 就跟 struct _GPIO 是等同的作用了</p>
<h3 id="enum枚举"><a href="#enum枚举" class="headerlink" title="enum枚举"></a>enum枚举</h3><p>enum枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。（一个被命名的整形常数的集合 ）</p>
<p>枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure>



<p>我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MON  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TUE  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WED  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THU  4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRI  5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAT  6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUN  7</span></span><br></pre></td></tr></table></figure>



<h4 id="声明枚举类型"><a href="#声明枚举类型" class="headerlink" title="声明枚举类型"></a>声明枚举类型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="枚举变量的定义"><a href="#枚举变量的定义" class="headerlink" title="枚举变量的定义"></a>枚举变量的定义</h4><p>我们可以通过以下三种方式来定义枚举变量</p>
<p><strong>1、先定义枚举类型，再定义枚举变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">day</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>2、定义枚举类型的同时定义枚举变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure>

<p><strong>3、省略枚举名称，直接定义枚举变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure>

<h4 id="typedef-enum"><a href="#typedef-enum" class="headerlink" title="typedef enum"></a>typedef enum</h4><p>是不是感觉和enum没什么区别，确实在一般的使用中两个的结果是差不多的。</p>
<p>但是如果你想定义一个和DAY类型一样的集合的情况下，使用typedef enum更方便</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">举例子：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> &#123;</span> MON, TUE=<span class="number">2</span>, WED, THU, FRI, SAT, SUN  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">workday</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">restday</span>;</span></span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> &#123;</span> MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN  &#125;DAY_TYPE; </span><br><span class="line"></span><br><span class="line">DAY_TYPE workday,restday;</span><br></pre></td></tr></table></figure>

<p>（此处用法与typedef struct一样）</p>
<p>枚举（enum）成员的值默认是整型，并且从0开始递增。虽然枚举类型本身不直接支持十六进制的声明方式，但你可以手动为枚举成员赋值，这个值可以是任何整数常量，当然包括十六进制表示的整数</p>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  MSG_CO_NMT_CTRL = <span class="number">0x000</span>,      <span class="comment">// CANOpen NMT Message REC</span></span><br><span class="line">  MSG_SET_INPUT_POS = <span class="number">0x00C</span>,    <span class="comment">// 输入的电机目标位置</span></span><br><span class="line">  MSG_SET_INPUT_VEL = <span class="number">0x00D</span>,    <span class="comment">// 输入的电机目标转速-------###</span></span><br><span class="line">  MSG_CLEAR_ERRORS = <span class="number">0x018</span>,     <span class="comment">// 清除错误</span></span><br><span class="line">  MSG_CO_HEARTBEAT_CMD = <span class="number">0x700</span>, <span class="comment">// CANOpen NMT Heartbeat SEND</span></span><br><span class="line">&#125; Odrive_Commond;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用于switch case中：</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">odrv_write_msg</span><span class="params">(Axis_t axis, Odrive_Commond cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">switch</span>(cmd)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> MSG_GET_ENCODER_COUNT:</span><br><span class="line">        header.RTR = CAN_RTR_REMOTE;  <span class="comment">//数据帧的优先级大于远程帧，当有多个设备向一个ID同时发送数据时，用远程帧可以有效地避免总线冲突，即ID收到消息后会先回发数据帧，再处理远程帧</span></span><br><span class="line">        header.DLC = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MSG_SET_CONTROLLER_MODES:</span><br><span class="line">        data[<span class="number">0</span>] = odrive_set-&gt;control_mode;</span><br><span class="line">        data[<span class="number">4</span>] = odrive_set-&gt;input_mode;</span><br><span class="line">        header.RTR = CAN_RTR_DATA;</span><br><span class="line">        header.DLC = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MSG_SET_TRAJ_ACCEL_LIMITS:</span><br><span class="line">        <span class="built_in">memcpy</span>(data, &amp;(odrive_set-&gt;traj_accel_limit), <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp_word, &amp;(odrive_set-&gt;traj_decel_limit), <span class="number">4</span>);</span><br><span class="line">        data[<span class="number">4</span>] = tmp_word[<span class="number">0</span>];</span><br><span class="line">        data[<span class="number">5</span>] = tmp_word[<span class="number">1</span>];</span><br><span class="line">        data[<span class="number">6</span>] = tmp_word[<span class="number">2</span>];</span><br><span class="line">        data[<span class="number">7</span>] = tmp_word[<span class="number">3</span>];</span><br><span class="line">        header.RTR = CAN_RTR_DATA;</span><br><span class="line">        header.DLC = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//enum枚举常用于状态表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NORMAL,</span><br><span class="line">    CHANGE,</span><br><span class="line">&#125; FSMMode_e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PASSIVE = <span class="number">1</span>,    <span class="comment">// 阻尼</span></span><br><span class="line">    FALL = <span class="number">2</span>,       <span class="comment">// 卧倒</span></span><br><span class="line">    FIXEDSTAND = <span class="number">3</span>, <span class="comment">// 固定站立</span></span><br><span class="line">    FREESTAND = <span class="number">4</span>,  <span class="comment">// 自由站立</span></span><br><span class="line">    TROTING = <span class="number">5</span>,    <span class="comment">// 对角步态</span></span><br><span class="line">    WALKING = <span class="number">6</span>,    <span class="comment">// 行走步态</span></span><br><span class="line">    JUMP = <span class="number">7</span>,       <span class="comment">// 跳跃</span></span><br><span class="line">    JUMP2 = <span class="number">8</span>,      <span class="comment">// 跳跃2</span></span><br><span class="line">    JUMPL = <span class="number">9</span>,</span><br><span class="line">    JUMPL2 = <span class="number">10</span>,</span><br><span class="line">    JUMPR = <span class="number">11</span>,</span><br><span class="line">    JUMPR2 = <span class="number">12</span>,</span><br><span class="line">    catJUMP = <span class="number">13</span>,</span><br><span class="line">    catJUMP2 = <span class="number">14</span>,</span><br><span class="line">&#125; FSMState_e;</span><br></pre></td></tr></table></figure>





<h2 id="5-指针"><a href="#5-指针" class="headerlink" title="5.指针"></a>5.指针</h2><h3 id="指针偏移"><a href="#指针偏移" class="headerlink" title="指针偏移"></a>指针偏移</h3><p>指针可以作为数组用，数组号表示指针基地址偏移，很多代码都这么用的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span>  <span class="title function_">test</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buffer)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			buffer[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第16行，memcpy函数从packet[1]的地址开始复制，数据依次复制到packet[1],packet[2],packet[3],packet[4]中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> floatVal;</span><br><span class="line">    <span class="type">uint8_t</span> byteVal[<span class="keyword">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">  &#125; data;</span><br><span class="line"></span><br><span class="line">  data.floatVal = val;<span class="comment">//共同体 val给共同体的data.floatVal后 如果用data.byteVal 共同体内data.floatVal中的数据会转变为byteVal[sizeof(float)]类型</span></span><br><span class="line">  <span class="built_in">memcpy</span>(bytes, data.byteVal, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//共同体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendPacket</span><span class="params">(<span class="type">float</span> angle, <span class="type">float</span> x, <span class="type">float</span> y)</span> &#123;<span class="comment">//float有4个字节，32位</span></span><br><span class="line">  <span class="type">uint8_t</span> packet[<span class="number">14</span>];   <span class="comment">// 数据包共14个字节</span></span><br><span class="line">  <span class="comment">// 填充帧头</span></span><br><span class="line">  packet[<span class="number">0</span>] = FRAME_HEADER;</span><br><span class="line">  <span class="comment">// 填充数据</span></span><br><span class="line">  floatToBytes(angle, &amp;packet[<span class="number">1</span>]);</span><br><span class="line">  floatToBytes(x, &amp;packet[<span class="number">5</span>]);</span><br><span class="line">  floatToBytes(y, &amp;packet[<span class="number">9</span>]);</span><br><span class="line">  <span class="comment">// 填充帧尾</span></span><br><span class="line">  packet[<span class="number">13</span>] = FRAME_TAIL;</span><br><span class="line">  <span class="comment">// 使用串口发送数据包</span></span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, packet, <span class="keyword">sizeof</span>(packet), HAL_MAX_DELAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>所谓函数指针即定义一个<em><strong>指向函数的指针变量</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span> x, <span class="type">int</span>  y);  <span class="comment">//注意：这里的括号不能掉，因为括号()的运算优先级比解引用运算符*高</span></span><br></pre></td></tr></table></figure>

<p>这个函数的类型是有两个整型参数，返回值是个整型。对应的函数指针类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*) (<span class="type">int</span> a, <span class="type">int</span> b);  </span><br></pre></td></tr></table></figure>

<p>对应的函数指针<strong>定义</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span> x, <span class="type">int</span>  y);  <span class="comment">//参数名可以去掉，并且通常都是去掉的。这样指针p就可以保存函数类型为两个整型参数，返回值是整型的函数地址了。</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>我们一般可以这么使用，通过函数指针调用函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxValue</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;    </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = <span class="literal">NULL</span>;  <span class="comment">//定义一个与maxValue兼容的指针</span></span><br><span class="line">p = maxValue;<span class="comment">//将这个指针指向maxValue函数</span></span><br><span class="line">p(<span class="number">20</span>, <span class="number">45</span>);  <span class="comment">//通过指针调用</span></span><br></pre></td></tr></table></figure>


<p><strong>应用案例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FSMMode_e mode;</span><br><span class="line">    FSMState_e currentState;</span><br><span class="line">    FSMState_e nextState;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//回调函数</span></span><br><span class="line">    <span class="type">void</span> (*enter)(<span class="type">void</span>);<span class="comment">/*函数指针*/</span>  </span><br><span class="line">    <span class="type">void</span> (*run)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">exit</span>)(<span class="type">void</span>);</span><br><span class="line">&#125; FSM_t;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FSM_t FSM ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (FSM.nextState)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FIXEDSTAND:</span><br><span class="line">        FSM.enter = FixedStand_Enter;<span class="comment">//将FSM.enter这个指针指向FixedStand_Enter函数</span></span><br><span class="line">        FSM.run = FixedStand_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = FixedStand_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">case</span> TROTING:</span><br><span class="line">        FSM.enter = Troting_Enter;</span><br><span class="line">        FSM.run = Troting_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Troting_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> WALKING:</span><br><span class="line">        FSM.enter = Walking_Enter;</span><br><span class="line">        FSM.run = Walking_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Walking_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> JUMP:</span><br><span class="line">        FSM.enter = Jump_Enter;</span><br><span class="line">        FSM.run = Jump_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Jump_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在C语言中，void (*enter)(void);、void (*run)(void); 和 void (*exit)(void); 这三个成员是函数指针类型。</p>
<p>具体解释如下：</p>
<ol>
<li><pre><code class="c">void (*enter)(void);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这是一个指向无参数且返回值为 void 的函数的指针。在结构体 FSM_t 中，它表示一个函数指针，当 FSM（有限状态机）进入某个状态时，可以通过调用这个函数指针指向的函数来执行相应的“进入”动作。</span><br><span class="line"></span><br><span class="line"> 2. ```c</span><br><span class="line">    void (*run)(void);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>同样是一个指向无参数且返回值为 void 的函数的指针。在状态机中，当处于某个状态并需要运行该状态的行为或处理逻辑时，可以调用这个“run”函数指针指向的函数。</p>
<ol start="3">
<li><pre><code class="c">void (*exit)(void);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">依然是一个函数指针，指向无参数且返回值为 void 的函数。当 FSM 状态机从当前状态退出时，会调用这个“exit”函数指针指向的函数，用于执行离开状态时所需的动作或清理工作。</span><br><span class="line"></span><br><span class="line">因此，在实现一个基于此结构体的状态机时，你需要为每个状态分别定义对应的 enter、run 和 exit 函数，并将它们的地址赋给相应状态的 FSM_t 结构体实例中的这三个函数指针成员。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在C语言中，结构体（struct）可以包含各种数据类型，包括**基本数据类型、指针类型**等。在这个特定的FSM_t（有限状态机）结构体定义中，使用函数指针的主要原因是为了实现灵活且可扩展的设计。</span><br><span class="line"></span><br><span class="line">​	1.	灵活性：***通过将函数作为成员变量（以指针形式存在），可以在不同的实例中为这些函数赋予不同的具体实现，使得状态机的行为可以根据需求动态改变。***</span><br><span class="line"></span><br><span class="line">​	2.	扩展性：在设计模式上，这种方式符合面向对象编程中的“多态”思想。***每个状态可以有自己的enter、run和exit行为，只需要提供相应的函数实现即可。***</span><br><span class="line"></span><br><span class="line">​	3.	解耦合：函数指针将函数的具体实现与结构体（状态机）的定义解耦合，使得状态机的定义更简洁，逻辑更清晰，也方便后期维护和扩展。</span><br><span class="line"></span><br><span class="line">​	4.	高效性：虽然使用函数指针调用会引入一次间接寻址，但在很多情况下，这并不会对性能造成显著影响，而带来的设计优势远大于此微小的性能损耗。总结一下，这里使用函数指针而非直接定义函数，主要是为了构建一个更加灵活、可扩展、高内聚低耦合的状态机模型。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在C语言中，结构体（struct）不能直接包含函数。函数在C语言中不是一种数据类型，因此无法像变量那样存储在结构体中。但是，可以通过存储函数的指针来达到类似的效果，就像上述FSM_t结构体中的enter、run和exit成员那样。</span><br><span class="line"></span><br><span class="line">所以，准确地说，结构体内不能直接定义函数，但可以存储函数的地址，即函数指针，间接实现调用关联函数的功能。</span><br><span class="line"></span><br><span class="line">#### 回调函数</span><br><span class="line"></span><br><span class="line">应用：</span><br><span class="line">1.*送餐机器人：底盘移动到目标位置后，通知应用程序*</span><br><span class="line"></span><br><span class="line">2.*智能音箱：网络状态改变后，通知应用程序*</span><br><span class="line"></span><br><span class="line">3.*四足机器人项目FSM状态机也有用到回调函数的思想*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">//工具代码</span><br><span class="line">typedef struct&#123;</span><br><span class="line">int status;</span><br><span class="line">void (*statusChange)(); //存储后续要调用的回调函数地址</span><br><span class="line">&#125;T_Device;</span><br><span class="line"></span><br><span class="line">T_Device g_ Device;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">名称：回调函数</span><br><span class="line">作用：将传入的用户函数的地址赋给g_Device.statusChange,当满足条件时，执行该用户函数</span><br><span class="line">*/</span><br><span class="line">//void (*pstatusChange)(int status) 定义了一个指向函数的指针变量 pstatusChange，该函数没有返回值，并且接受一个整型参数 status。</span><br><span class="line">void addCallbackFunc(void (*pstatusChange)(int status))&#123;//将函数的地址传入并赋给g_Device.statusChange，这样g_Device.statusChange指向函数的入口地址</span><br><span class="line">g_Device.statusChange = pstatusChange ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void run()&#123;</span><br><span class="line">	g_Device.status = 10;</span><br><span class="line">    if(g_Device.status == 10)&#123;</span><br><span class="line">        if(g_Device . statusChange != NULL)&#123;</span><br><span class="line">        g_Device.statusChange(g_Device.status);//callBack(10);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//用户代码</span><br><span class="line">void callBack(int status )&#123;&#125;</span><br><span class="line">    printf(&quot;callBack\n&quot;);</span><br><span class="line">    printf(&quot;status = %d\n&quot; ,status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    addCallbackFunc(callBack);//将 `callBack` 函数的地址作为参数传递给了 `addCallbackFunc` 函数，</span><br><span class="line">    run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>在 <code>main</code> 函数中调用 <code>addCallbackFunc(callBack);</code> 时，发生了以下事件：</p>
<ol>
<li><code>callBack</code> 是用户定义的一个函数，其原型为 <code>void callBack(int status)</code>。</li>
<li>当调用 <code>addCallbackFunc(callBack)</code> 时，将 <code>callBack</code> 函数的地址作为参数传递给了 <code>addCallbackFunc</code> 函数。</li>
<li>在 <code>addCallbackFunc</code> 函数内部，这个传入的参数 <code>pstatusChange</code> 被赋值给全局变量 <code>g_Device</code> 的成员 <code>statusChange</code>，即 <code>g_Device.statusChange = pstatusChange;</code>。因此，现在 <code>g_Device.statusChange</code> 指向了 <code>callBack</code> 函数的入口地址。</li>
<li>这样一来，就实现了回调函数的注册。当设备状态改变且满足触发条件时（如在 <code>run</code> 函数中），可以通过调用 <code>g_Device.statusChange(g_Device.status);</code> 来执行 <code>callBack</code> 函数，<strong>并将设备状态作为参数传递进去，从而实现对状态变化的响应和处理。</strong></li>
</ol>
<p>提问：为什么不能直接用if(g_Device.status&#x3D;&#x3D;10)，而非要用回调函数，这是多此一举吗</p>
<p>使用回调函数并不一定是在做无用功，它在某些情况下具有以下优点：</p>
<ol>
<li><strong>解耦合</strong>：通过回调函数，我们可以将处理状态变化的逻辑从设备状态管理代码中分离出来。这样可以使代码结构更加清晰，也<strong>更容易维护和扩展</strong>。例如，在本例中，具体的设备状态改变后的处理行为（即<code>callBack</code>函数中的内容）可以由用户自定义，而不是硬编码在<code>run</code>函数里。</li>
<li><strong>灵活性</strong>：当设备状态改变时，不同的应用程序可能需要执行不同的操作。使用回调函数允许我们在运行时动态地根据需要来指定要执行的操作，增加了程序的灵活性。</li>
<li><strong>事件驱动编程</strong>：回调函数是事件驱动编程模型的重要组成部分。在这种模式下，当某个特定事件（如设备状态改变）发生时，系统调用预先注册好的回调函数，<strong>而非直接在触发事件的地方编写处理逻辑。</strong></li>
</ol>
<p>所以，并不是多此一举，而是为了实现更灵活、解耦的软件设计和开发。当然，在简单场景下，如果状态改变后的处理逻辑固定且无需复用，直接写在<code>if(g_Device.status==10)</code>判断后也是可行的，但在复杂项目或者需要扩展性的情况下，回调函数就显得尤为重要了。</p>
<h3 id="void-修饰指针使用规则"><a href="#void-修饰指针使用规则" class="headerlink" title="void 修饰指针使用规则"></a>void 修饰指针使用规则</h3><p>void *</p>
<p>void 指针可以指向任意类型的数据，就是说可以用任意类型的指针对 void 指针对 void <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC&spm=1001.2101.3001.7020">指针赋值</a>。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a；</span><br><span class="line"><span class="type">void</span> *p；</span><br><span class="line">p=a；</span><br></pre></td></tr></table></figure>

<p>void 指针可以任意类型的数据，可以在程序中给我们带来一些好处，函数中形为指针类型时，我们可以将其定义为 void 指针，这样函数就可以接受任意类型的指针。如：</p>
<pre><code>void * memcpy(void *dest, const void *src, size_t len);
void * memset ( void * buffer, int c, size_t num );
</code></pre>
<p>这样，任何类型的指针都可以传入 memcpy 和 memset 中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型。</p>
<h2 id="6-常见关键词"><a href="#6-常见关键词" class="headerlink" title="6.常见关键词"></a>6.常见关键词</h2><h3 id="define宏定义关键词"><a href="#define宏定义关键词" class="headerlink" title="define宏定义关键词"></a>define宏定义关键词</h3><p>语法：<code>#define 标识符 字符串</code></p>
<ul>
<li><p>“标识符”为所定义的<strong>宏名</strong></p>
</li>
<li><p>“字符串”可以是<strong>常数</strong>、<strong>表达式</strong>、<strong>格式串</strong>等</p>
<p>#define SYSCLK_FREQ_72MHz 72000000</p>
</li>
</ul>
<h3 id="ifdef-条件编译"><a href="#ifdef-条件编译" class="headerlink" title="ifdef 条件编译"></a>ifdef 条件编译</h3><p>当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 标识符</span></span><br><span class="line">程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>作用是：当标识符已经被定义过(一般是用#define 命令定义)，则对程序段 1 进行编译，否则编译程序段 2。 其中#else 部分也可以没有，即：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span></span></span><br><span class="line">程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h3 id="extern变量声明"><a href="#extern变量声明" class="headerlink" title="extern变量声明"></a>extern变量声明</h3><p>在一个文件中定义的全局变量，如果在其它文件里想使用，需要在前面加上extern</p>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>有时候，我们希望函数中局部变量的值在<strong>函数调用结束之后不会消失，而仍然保留其原值</strong>。即它所占用的存储单元不释放，在<strong>下一次调用该函数时，其局部变量的值仍然存在，也就是上一次函数调用结束时的值</strong>。这时候，我们就应该将该局部变量用关键字 static 声明为“<strong>静态局部变量</strong>”。</p>
<p>静态变量的作用：<strong>保持变量内容的持久性</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt;= <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">            count();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">count</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*声明一个静态局部变量*/</span></span><br><span class="line">    <span class="type">static</span> num = <span class="number">0</span>;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该代码中，我们通过在 count() 函数里声明一个静态局部变量 num 来作为计数器。因为静态局部变量是在编译时赋初值的，且只赋初值一次，在程序运行时它已有初值。以后在每次调用函数时就<em><strong>不再重新赋初值，而是保留上次函数调用结束时的值</strong></em>。这样，count() 函数每次被调用的时候，静态局部变量 num 就会保持上一次调用的值，然后再执行自增运算，这样就实现了计数功能。同时，它又避免了使用全局变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_ChangeState</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C语言中，当一个函数前加上 static 关键字时，意味着该函数具有内部链接性（internal linkage），即该函数的作用范围被限制在当前编译单元内。对于这个函数而言，这意味着只有定义它的源文件以及包含它所在的头文件的其他源文件可以访问此函数，不会成为外部全局符号，从而避免不同编译单元之间产生符号冲突。</p>
<h3 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h3><p>程序开发人员可以在变量定义后，在程序的其他位置引用和修改变量。但程序中定义的一些变量，如圆周率PI&#x3D;3.14，黄金分割比例 g&#x3D;0.618，<em><strong>这些变量只需要被引用，不应该被修改</strong></em>。C语言中可以使用 const关键字修饰变量。</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> pi = <span class="number">3.141592612</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,pi);</span><br></pre></td></tr></table></figure>



<h3 id="IO-volatile"><a href="#IO-volatile" class="headerlink" title="__IO(volatile)"></a>__IO(<strong>volatile</strong>)</h3><p><strong>volatile</strong>的含义为 <code>允许硬件改变变量的数值</code> 。告诉编译器不要优化这些代码</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/QWQ_DIODA/article/details/116712401">volatile 形变量可以被硬件改变</a>，在需要<strong>硬件</strong>改变变量的场合中不可或缺！！</p>
<p><img src="/2024/01/26/Embedded-C-language/image-20240114110255039.png" alt="image-20240114110255039"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__IO <span class="type">uint16_t</span> ADC_ConvertedValue;  <span class="comment">// 用于保存转换后的ADC值 </span></span><br><span class="line"><span class="comment">// 中断服务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (ADC_GetITStatus(ADCx,ADC_IT_EOC)==SET) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 读取ADC的转换值</span></span><br><span class="line">		ADC_ConvertedValue = ADC_GetConversionValue(ADCx);</span><br><span class="line">	&#125;</span><br><span class="line">	ADC_ClearITPendingBit(ADCx,ADC_IT_EOC);<span class="comment">//清除ADCx的中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task1Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;Task1&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task2Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;Task2&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task3Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="string">&quot;Task3&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_LCDCanUse = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> g_calc_end = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> g_time = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> g_sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务1 计算加法，并计算加法运算的时间，然后删除任务</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CalcTask</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">  g_time = system_get_ns();</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    g_sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  g_calc_end = <span class="number">1</span>;</span><br><span class="line">  g_time = system_get_ns() - g_time;</span><br><span class="line">  vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务2 当计算任务没有结束时，一直执行while循环，直到计算任务结束,g_cal_end变为1，则可进行后面的打印信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdPrintTask</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LCD_PrintString(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;waiting&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (g_calc_end == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印信息 */</span></span><br><span class="line">    <span class="keyword">if</span> (g_LCDCanUse)</span><br><span class="line">    &#123;</span><br><span class="line">      g_LCDCanUse = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      LCD_ClearLine(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      len = LCD_PrintString(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;Sum:&quot;</span>);</span><br><span class="line">      LCD_PrintHex(len, <span class="number">0</span>, g_sum,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      LCD_ClearLine(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">      len = LCD_PrintString(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;Time(ms):&quot;</span>);</span><br><span class="line">      LCD_PrintSignedVal(len, <span class="number">2</span>, g_time/<span class="number">1000000</span>);</span><br><span class="line">      g_LCDCanUse = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  xTaskCreate(CalcTask, <span class="string">&quot;task1&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">  xTaskCreate(LcdPrintTask, <span class="string">&quot;task2&quot;</span>, <span class="number">128</span>, &amp;g_Task2Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>没有加volatile时，经过<strong>debug</strong>，发现程序一直会卡LcdPrintTask的while (g_calc_end &#x3D;&#x3D; 0);处，<strong>尽管在debug时显示g_calc_end为1还是一直卡在那里</strong>。这是因为在编译器做了一些优化，第一次使用这个变量时，它会去读内存，把这个变量的值读进CPU的某个寄存器，以后在任务2的那个while循环里，它一直都是去判断那个<strong>寄存器</strong>，但是那个寄存器得到的是这个变量原始的，老的值，它并<strong>没有每次都去内存里面读这个变量，更新那个寄存器</strong>，这是不对的，因为这个变量，是在其他任务里面被修改了，你去使用这个变量时，每次都应该去读内存，怎么办呢，<strong>在变量前加一个volatile就好了，告诉编译器，不要去优化它</strong>。</p>
<p>​	“在多任务环境下，编译器通常会对变量进行优化以提高代码执行效率。当一个变量被标记为 volatile 时，它告诉编译器这个变量的值可能在程序控制范围之外发生变化（例如由中断服务程序、硬件操作或者其他并发任务修改），因此每次访问该变量时都会从内存中重新读取。<em>编译器对变量的优化通常基于以下几种情况</em>：</p>
<ol>
<li><p><strong>局部性原理</strong>：编译器假设在一段连续执行的代码中，如果一个变量没有被显示地修改（比如通过赋值、函数调用或指针间接访问），其值就不会改变。因此，在循环内多次读取同一变量时，编译器可能会将该变量从内存加载到寄存器中，并在整个循环期间使用寄存器中的值，以减少对内存的访问。</p>
</li>
<li><p><strong>数据流分析</strong>：编译器会进行数据依赖性分析，如果它能确定某个变量在当前作用域内不会受外部因素影响而改变，即使这个变量是全局的，也可能对其进行优化。</p>
</li>
<li><p><strong>跨函数优化</strong>：编译器还可能进行跨函数优化，例如当函数没有明确的副作用或者编译器能够推断出函数内部对全局变量的修改不会影响到当前上下文时，也会选择不重新加载变量。”</p>
<p>应当在以下情况下考虑使用 <code>volatile</code> 关键字来修饰变量：</p>
<ul>
<li>变量可能被<strong>中断服务程序修改</strong>。</li>
<li>变量位于<strong>多线程环境且不同线程间共享并修改该变量</strong>。</li>
<li>变量与硬件寄存器映射相关，硬件可能会在软件不可见的情况下更改它们的值。</li>
<li>变量用于信号量、事件标志或其他同步机制。</li>
</ul>
</li>
</ol>
<h3 id="union共同体（联合体）"><a href="#union共同体（联合体）" class="headerlink" title="union共同体（联合体）"></a>union共同体（联合体）</h3><h4 id="实现不同类型数据的转换"><a href="#实现不同类型数据的转换" class="headerlink" title="实现不同类型数据的转换"></a>实现不同类型数据的转换</h4><p><strong>C语言的union联合体，可实现不同类型数据的转换</strong></p>
<p>结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。联合体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</p>
<p><em>简单说就是你给联合体的一个变量赋值，然后表示联合体其中的另一个变量，之前那个赋值了的变量会自动赋给你要表示的这个量，从而实现不同类型数据的转换。</em></p>
<p><img src="/2024/01/26/Embedded-C-language/image-20240114200704804.png" alt="image-20240114200704804"></p>
<p><img src="/2024/01/26/Embedded-C-language/image-20240114192714039.png" alt="image-20240114192714039"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memcpy函数有三个参数，第一个是目标地址（通常是数组的某一位的地址，即将数据从数组的这一位开始复制），第二个是源地址，第三个是数据长度。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> floatVal;</span><br><span class="line">    <span class="type">uint8_t</span> byteVal[<span class="keyword">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">  &#125; data;</span><br><span class="line"></span><br><span class="line">  data.floatVal = val;<span class="comment">//共同体 val给共同体的data.floatVal后 如果用data.byteVal 共同体内data.floatVal中的数据会转变为byteVal[sizeof(float)]类型</span></span><br><span class="line">  <span class="built_in">memcpy</span>(bytes, data.byteVal, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//共同体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *destin, <span class="type">void</span> *source, <span class="type">unsigned</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>以source指向的地址为起点，将连续的n个字节数据，复制到以destin指向的地址为起点的内存中。</strong><br>函数有三个参数，第一个是目标地址（通常是数组的某一位的地址，即将数据从数组的这一位开始复制），第二个是源地址，第三个是数据长度。<br>数据长度（第三个参数）的单位是字节（1byte &#x3D; 8bit）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> floatVal;</span><br><span class="line">    <span class="type">uint8_t</span> byteVal[<span class="keyword">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">  &#125; data;</span><br><span class="line"></span><br><span class="line">  data.floatVal = val;<span class="comment">//共同体 val给共同体的data.floatVal后 如果用data.byteVal 共同体内data.floatVal中的数据会转变为byteVal[sizeof(float)]类型</span></span><br><span class="line">  <span class="built_in">memcpy</span>(bytes, data.byteVal, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//共同体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendPacket</span><span class="params">(<span class="type">float</span> angle, <span class="type">float</span> x, <span class="type">float</span> y)</span> &#123;<span class="comment">//float有4个字节，32位</span></span><br><span class="line">  <span class="type">uint8_t</span> packet[<span class="number">14</span>];   <span class="comment">// 数据包共14个字节</span></span><br><span class="line">  <span class="comment">// 填充帧头</span></span><br><span class="line">  packet[<span class="number">0</span>] = FRAME_HEADER;</span><br><span class="line">  <span class="comment">// 填充数据</span></span><br><span class="line">  floatToBytes(angle, &amp;packet[<span class="number">1</span>]);<span class="comment">//从packet[1]的地址开始复制，数据依次复制到packet[1],packet[2],packet[3],packet[4]中</span></span><br><span class="line">  floatToBytes(x, &amp;packet[<span class="number">5</span>]);</span><br><span class="line">  floatToBytes(y, &amp;packet[<span class="number">9</span>]);</span><br><span class="line">  <span class="comment">// 填充帧尾</span></span><br><span class="line">  packet[<span class="number">13</span>] = FRAME_TAIL;</span><br><span class="line">  <span class="comment">// 使用串口发送数据包</span></span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, packet, <span class="keyword">sizeof</span>(packet), HAL_MAX_DELAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_ChangeState</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	1.	static：</p>
<p>​	在C语言中，当一个函数前加上 static 关键字时，意味着该函数具有内部链接性（internal linkage），即该函数的作用范围被限制在当前编译单元内。对于这个函数而言，这意味着只有定义它的源文件以及包含它所在的头文件的其他源文件可以访问此函数，不会成为外部全局符号，从而避免不同编译单元之间产生符号冲突。</p>
<p>​	2.	inline：</p>
<p>​	inline 关键字提示编译器尝试将函数体直接插入到每个调用该函数的地方（即“内联”），而不是通过正常的函数调用机制（如压栈、跳转等）。这样做的目的是减少函数调用的开销，尤其是当<em><strong>函数体较小且频繁调用时，能够提高程序运行效率。</strong></em><br>​	注意，尽管有 inline 关键字，但是否真正进行内联处理由编译器决定，编译器会根据实际情况判断是否采纳程序员的建议。</p>
<p>综合上述解释，在状态机的上下文中，static inline void FSM_ChangeState() 函数可能用于快速切换状态，由于其内联特性，编译器可能会将状态切换的相关操作直接嵌入到调用处，以提升代码执行速度，并且由于是静态函数，其使用和实现细节被隐藏在当前编译单元内，不对外部模块可见，有助于封装和管理复杂度。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p><img src="/2024/01/26/Embedded-C-language/image-20240114192455610.png" alt="image-20240114192455610"></p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="串口数据包通讯协议"><a href="#串口数据包通讯协议" class="headerlink" title="串口数据包通讯协议"></a>串口数据包通讯协议</h2><p>uint8_t packet[14];  &#x2F;&#x2F;packet数组的一位是一个字节,此packet含14个字节</p>
<p>串口接收鲁棒性高，采用校验帧头、帧尾以及数据长度的方式，确保接收数据的稳定性。</p>
<p>之前一直没用过帧头帧尾，主要是之前用串口传输的数据量都不大，如果要传输多种数据，就需要用帧头帧尾确保数据传输的准确性</p>
<p>(STM32通讯系列–串口通讯】使用标准库、HAL库实现任意长度数据的收发（包含帧头、帧尾校验，配套完整开源程序）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44343584/article/details/125654421?ops_request_misc=%7B%22request_id%22:%22166299541816800182785614%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=166299541816800182785614&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-125654421-null-null.142">https://blog.csdn.net/qq_44343584/article/details/125654421?ops_request_misc=%7B%22request%5Fid%22%3A%22166299541816800182785614%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=166299541816800182785614&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-125654421-null-null.142</a> )</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//packet.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;packet.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> host 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> host<span class="comment">//发送数据包</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> packet_received = <span class="literal">false</span>;<span class="comment">//是否收到完整的数据包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转换单精度浮点数为字节</span></span><br><span class="line"><span class="comment">//@param1:浮点数</span></span><br><span class="line"><span class="comment">//@param2:字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> floatVal;</span><br><span class="line">    <span class="type">uint8_t</span> byteVal[<span class="keyword">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">  &#125; data;</span><br><span class="line"></span><br><span class="line">  data.floatVal = val;<span class="comment">//共同体 val给共同体的data.floatVal后 如果用data.byteVal 共同体内data.floatVal中的数据会转变为byteVal[sizeof(float)]类型</span></span><br><span class="line">  <span class="built_in">memcpy</span>(bytes, data.byteVal, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//共同体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* memcpy用法:</span></span><br><span class="line"><span class="comment">void *memcpy(void *destin, void *source, unsigned n);</span></span><br><span class="line"><span class="comment">以source指向的地址为起点，将连续的n个字节数据，复制到以destin指向的地址为起点的内存中。</span></span><br><span class="line"><span class="comment">函数有三个参数，第一个是目标地址，第二个是源地址，第三个是数据长度。</span></span><br><span class="line"><span class="comment">数据长度（第三个参数）的单位是字节（1byte = 8bit）。</span></span><br><span class="line"><span class="comment">一个float类型的函数有4个字节</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendPacket</span><span class="params">(<span class="type">float</span> angle, <span class="type">float</span> x, <span class="type">float</span> y)</span> &#123;</span><br><span class="line">  <span class="type">uint8_t</span> packet[<span class="number">14</span>];   <span class="comment">// 数据包共14个字节</span></span><br><span class="line">  <span class="comment">// 填充帧头</span></span><br><span class="line">  packet[<span class="number">0</span>] = FRAME_HEADER;</span><br><span class="line">  <span class="comment">// 填充数据</span></span><br><span class="line">  floatToBytes(angle, &amp;packet[<span class="number">1</span>]);</span><br><span class="line">  floatToBytes(x, &amp;packet[<span class="number">5</span>]);</span><br><span class="line">  floatToBytes(y, &amp;packet[<span class="number">9</span>]);</span><br><span class="line">  <span class="comment">// 填充帧尾</span></span><br><span class="line">  packet[<span class="number">13</span>] = FRAME_TAIL;</span><br><span class="line">  <span class="comment">// 使用串口发送数据包</span></span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, packet, <span class="keyword">sizeof</span>(packet), HAL_MAX_DELAY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析数据包</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// 定义缓冲区大小  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义缓冲区和指针</span></span><br><span class="line"><span class="type">uint8_t</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">uint8_t</span>* p_buffer = buffer;<span class="comment">//指向buffer缓冲区首地址的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义标志位，表示是否接收到完整的数据包</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> packet_received = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析数据包的函数 将数据包中数据赋给 angle x y</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ParseDataPacket</span><span class="params">(DataPacket* packet)</span> &#123;</span><br><span class="line">  <span class="type">uint8_t</span>* p = buffer + <span class="number">1</span>; <span class="comment">// 跳过帧头</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;packet-&gt;angle, p, <span class="keyword">sizeof</span>(<span class="type">float</span>)); <span class="comment">//buffer[1] buffer[2] buffer[3] buffer[4]</span></span><br><span class="line">  p += <span class="keyword">sizeof</span>(<span class="type">float</span>);<span class="comment">//指向buffer[5]</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;packet-&gt;x, p, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//buffer[5] buffer[6] buffer[7] buffer[8]</span></span><br><span class="line">  p += <span class="keyword">sizeof</span>(<span class="type">float</span>);<span class="comment">//指向buffer[9]</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;packet-&gt;y, p, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//buffer[9] buffer[10] buffer[11] buffer[12]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在串口接收中断中调用此函数，将接收到的数据存入缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HandleReceivedData</span><span class="params">(<span class="type">uint8_t</span> data)</span> &#123;</span><br><span class="line">  <span class="comment">// 如果缓冲区已满，清空缓冲区</span></span><br><span class="line">  <span class="keyword">if</span> (p_buffer &gt;= buffer + BUFFER_SIZE) &#123;</span><br><span class="line">    p_buffer = buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将数据存入缓冲区</span></span><br><span class="line">  *p_buffer++ = data;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断是否接收到完整的数据包</span></span><br><span class="line">  <span class="keyword">if</span> (p_buffer - buffer &gt;= <span class="keyword">sizeof</span>(DataPacket) + <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查帧头和帧尾是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (buffer[<span class="number">0</span>] ==FRAME_HEADER &amp;&amp; buffer[<span class="keyword">sizeof</span>(DataPacket) + <span class="number">1</span>] == FRAME_TAIL) &#123;</span><br><span class="line">      <span class="comment">// 接收到完整的数据包</span></span><br><span class="line">      packet_received = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空缓冲区</span></span><br><span class="line">    p_buffer = buffer;<span class="comment">//指针重新指向buffer数组首地址</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主函数中调用此函数，处理接收到的数据包</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ProcessReceivedData</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 如果接收到完整的数据包，则解析数据包</span></span><br><span class="line">  <span class="keyword">if</span> (packet_received) &#123;</span><br><span class="line">    DataPacket packet;</span><br><span class="line">    ParseDataPacket(&amp;packet);<span class="comment">//处理之后定义的packet中angle x y就有数据了 可以直接调用 eg: packet.angle</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理解析后的数据包，例如将数据包的内容显示到LCD屏幕上</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除标志位</span></span><br><span class="line">    packet_received = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**********************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 在主函数中循环调用此函数，以处理接收到的数据</span></span><br><span class="line"><span class="comment">//void Loop() &#123;</span></span><br><span class="line"><span class="comment">//  // 处理接收到的数据包</span></span><br><span class="line"><span class="comment">//  ProcessReceivedData();</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//  // 继续执行其他任务</span></span><br><span class="line"><span class="comment">//  // ...</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在中断中</span></span><br><span class="line"><span class="comment">//void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    // 读取接收数据寄存器</span></span><br><span class="line"><span class="comment">//    uint8_t data = (uint8_t)(huart-&gt;Instance-&gt;RDR &amp; 0xFF);</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    // 处理接收到的数据</span></span><br><span class="line"><span class="comment">//    HandleReceivedData(data);</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    // 继续启动接收中断</span></span><br><span class="line"><span class="comment">//    HAL_UART_Receive_IT(huart, &amp;data, 1);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PACKET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRAME_HEADER 0x7E   <span class="comment">// 帧头</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRAME_TAIL 0x7F     <span class="comment">// 帧尾</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> angle;</span><br><span class="line">  <span class="type">float</span> x;</span><br><span class="line">  <span class="type">float</span> y;</span><br><span class="line">&#125; DataPacket;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span>;<span class="comment">//转换单精度浮点数为字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendPacket</span><span class="params">(<span class="type">float</span> angle, <span class="type">float</span> x, <span class="type">float</span> y)</span>;<span class="comment">//发送数据包</span></span><br><span class="line"><span class="comment">//bool parsePacket(uint8_t* packet, float* angle, float* x, float* y);//解析数据包</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ParseDataPacket</span><span class="params">(DataPacket* packet)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ProcessReceivedData</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*PACKET_H*/</span></span></span><br></pre></td></tr></table></figure>

<h2 id="环形缓冲区"><a href="#环形缓冲区" class="headerlink" title="环形缓冲区"></a>环形缓冲区</h2><p><strong>环形缓冲区</strong>是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F&spm=1001.2101.3001.7020">嵌入式</a>系统中十分重要的一种数据结构，比如在<strong>串口</strong>处理中，串口中断接收数据直接往环形缓冲区丢数据，而应用可以从环形缓冲区取数据进行处理，这样数据在读取和写入的时候都可以在这个缓冲区里循环进行，程序员可以根据自己需要的数据大小来决定自己使用的缓冲区大小，<strong>不用担心数组越界</strong>。</p>
<p><strong>队列</strong>的基本概念：队列 (Queue)：是一种先进先出(First In First Out ,简称 FIFO)的线性表，只允许在一端插入（入队），在另一端进行删除（出队）。</p>
<p>队列头就是指向已经存储的数据，并且这个数据是待处理的。下一个CPU处理的数据就是1；而队列尾则指向可以进行写数据的地址。</p>
<p><strong>队列是什么</strong></p>
<p>队列是一种很常见的数据结构，满足先进先出的方式，如果我们设定队列的最大长度，那就意味着进队列和出队列的元素的数量实则满足一种动态平衡。</p>
<p>如果我们把首次添加入队列的元素作为一个一维坐标的原点，那么随着队列中元素的添加，坐标原点到队尾元素的长度会无穷无尽的增大，随这之前添入的元素不断出列，对头对应的下标点也在不断增大。这样，进队列和出队列的元素的数量就对应到对头和队尾下标点的移动</p>
<p>因此我们评判一个队列长度是否溢出原先约定的最大长度，实则就是在评判队尾坐标点与队头坐标点之间的差值，无论是出队列还是入队列，队头和队尾的坐标都在不断增大</p>
<p><img src="/2024/01/26/Embedded-C-language/84497721b6c4413c8558e4266b886ddc.png" alt="img"></p>
<p><strong>front指针和rear指针的引入</strong></p>
<p>虽然队尾和队头的下标在不断增大，但是我们对于队列的研究只需要局限在队头与队尾之间的元素，坐标原点到队头之间的元素已经算作出列元素，并不需要研究。因此我们不妨将队列在逻辑上放入一个事先设定容量的一维数组中，只要这个数组的容量是队列中元素的个数+1就行，为什么要这么设定待会再讲。我们想要达到的目的是，无论出列还是入列，本质上是通过修改数组中元素的值，那些已经出列的元素所在的下标位需要放置新入列的元素，并在逻辑上保证新入列元素位于队尾就行。</p>
<p>因此，我们不得不得引入头指针front和尾指针rear，对指针指向的数组下标对应空间进行操作，来修改数组中元素的值。</p>
<p><strong>front指针和rear指针的理解</strong></p>
<p>front：初始值为0，对应索引位待出列，若当前指向的数组下标的元素要出列，则先执行出列动作(实际上不用操作，出列的索引位可以被新入队的元素覆盖)，随后front指针就要向后一位，即front++</p>
<p>rear：初始值为0，对应索引位待入列，若当前指向的数组下标有元素要入列，则先执行入列动作（索引位元素赋值），随后front指针就要向后一位，即rear++</p>
<p><strong>队列最大长度匹配数组容量导致一种错误的解决方案</strong></p>
<p>这就会有一个问题，随着队列中元素的不断更迭，front和rear很快就会超过数组容量，造成数组索引越界</p>
<p><img src="/2024/01/26/Embedded-C-language/dd50472cf4ba4aad8fe5e565ccfe39de.png" alt="img"></p>
<p>比如上图所示，front&#x3D;2，也就是说已经有两个元素出列了，因此rear&#x3D;5与rear&#x3D;6对应的两个元素理应可以入列，但是我们发现数组maxsize&#x3D;5，不存在索引位5和6，强行对这两个下标赋值会造成索引越界异常indexOutException 。但是我们发现此时数组中索引位0和1都空着，完全可以将这两个位置利用起来，因此我们可以想办法让实际的rear值转化为等效的rear值，也就是是让rear&#x3D;5转化为rear&#x3D;0，同理rear6转化为rear&#x3D;1。怎么做到呢？无疑是通过取余！</p>
<p>每次新元素入队后， 执行rear&#x3D;(rear)%maxSize操作，随后执行rear++操作右移rear指针</p>
<p>像上图中的rear&#x3D;rear%5乍一看好像没问题，但实际上这种取余方式是有问题的，出现这种取余方式的根源在于我们想让队列最大长度与数组容量保持一致，下文会详细说明这种解决方案的错误之处。</p>
<p><strong>指针的往复移动：逻辑上的环形</strong></p>
<p>出队和入队的方向是从右向左，而front与rear指针的移动方向却是从左到右循环往复（指向数组末尾后按照取余算法又重置为数组开头），因此我们可以把单向数组在逻辑上理解成环形数组，指针的循环往复移动理解成按照顺时针或逆时针（只要规定某一方向就好）单向移动</p>
<p>  环形队列小知识：</p>
<p>  环形队列是在实际编程极为有用的数据结构,它有如下特点。</p>
<p>  它是一个首尾相连的FIFO的数据结构，采用数组的线性空间,数据组织简单。能很快知道队列是否满为空。能以很快速度的来存取数据。</p>
<p>   因为有简单高效的原因，甚至在硬件都实现了环形队列。 </p>
<p>   环形队列广泛用于网络数据收发，和不同程序间数据交换（比如内核与应用程序大量交换数据,从硬件接收大量数据）均使用了环形队列。</p>
<p><strong>队列为空的判别</strong></p>
<p>我们怎么判断队列为空呢？</p>
<p>如果我们按照指针从左到右的方向移动，当front指针和rear指针重合时，front指针对应的索引位之前的索引位都已经出列完毕，而rear指针对应的索引位以及之后的所有索引位还未有元素入列。</p>
<p>所以队列是否为空的判别：front&#x3D;&#x3D;rear</p>
<p><img src="/2024/01/26/Embedded-C-language/a053efb0385e4714b8889ecd98ba2d31.png" alt="img"></p>
<p><strong>rear&#x3D;rear%maxSize解决方案的问题</strong></p>
<p> 入队图示<br>下图展示了maxSize&#x3D;5的数组中，front&#x3D;0保持不变，元素依次入列直到满载，rear指针的移动情况：</p>
<p><img src="/2024/01/26/Embedded-C-language/42a1d7c1976b4e7db62cd01c7b7c2fdc.png" alt="img"></p>
<p> front&#x3D;rear&#x3D;0的歧义<br> 可以看到，如果我们认为队列容量与数组容量应该持平，那么当第五个元素50入列后，本来rear&#x3D;4执行了rear++的操作后，rear&#x3D;5，随后rear将会通过取余算法rear&#x3D;rear%maxSize重置为0，这是我们解决方案的核心！</p>
<p>但关键点就在这里，我们发现空载时front&#x3D;rear&#x3D;0，满载时依然有front&#x3D;rear&#x3D;0！这样子我们就无法判断front&#x3D;rear时，队列是空还是满，因此rear&#x3D;rear%maxSize这种解决方案是不被允许的</p>
<p><strong>新的解决方案：置空位的引入</strong></p>
<p>新的解决方案<br>       每次新元素入队后， 执行rear&#x3D;(rear+1)%maxSize操作，该操作包含rear++操作</p>
<p>置空位的引入<br>       并且我们人为规定，数组中必须留有一个索引位不得放置元素，必须置空！！！如何实现我们的人为规定呢？那就要先探索当数组满载后front和rear指针之间有啥关系</p>
<p> 入队图示<br>下图展示了maxSize&#x3D;5的数组中，front&#x3D;0保持不变，元素依次入列直到满载，rear指针的移动情况：</p>
<p><img src="/2024/01/26/Embedded-C-language/fc276df1cfb14836b200b9ab1791347a.png" alt="img"></p>
<pre><code>   人为的让最后一位置空，所以当元素40入列后，数组已经满载

   满载后数据之间的关系：
</code></pre>
<p>front&#x3D;0<br>rear&#x3D;(rear+1)%maxSize&#x3D;(3+1)%5&#x3D;4  (注： 执行完arr[rear]&#x3D;40，再执行  rear&#x3D;(rear+1)%maxSize)<br>(rear+1)%maxSize&#x3D;(4+1)%5&#x3D;0&#x3D;front<br>       当我们认为的满载发生后，最后一位置空，发现此时rear和front之间的关系为(rear+1)%maxSize&#x3D;(4+1)%5&#x3D;0&#x3D;front，因此这个关系可以作为满载的条件</p>
<pre><code>   因为处于满载状态，我们无法再往队列添加元素，只能从队列取出元素，也就是进行出列的操作，而一旦我们执行了出列的操作，比如将索引位i=0上的元素10出列后，则front右移，即执行front=(front+1)%maxSize操作，最终front=1。

   若随后又添加元素入列，即在索引位i=4上添加元素50，随后又会执行rear=(rear+1)%maxSize操作，最终rear=0。

   rear=0≠front=1，此时就不会出现之前那种错误方案中 rear=front=0导致歧义的情况，而一旦 rear=front=0，必然表示队列为空，因此这种解决方案是行得通的
</code></pre>
<p><strong>队列为满的判别</strong></p>
<p>​      当我们认为的满载发生后，最后一位置空，发现此时rear和front之间的关系为(rear+1)%maxSize&#x3D;(4+1)%5&#x3D;0&#x3D;front，因此这个关系可以作为满载的条件</p>
<p><strong>队列中元素的个数</strong></p>
<p>​      numValid&#x3D;(rear+maxSize-front)%maxSize，大家可以带入数据验证一下</p>
<pre><code> 实际上：

   当rear在front之后(这里指的是数组中索引位的前后，并非逻辑上的前后)，有效数据个数=rear-front=(rear+maxSize-front)%maxSize

   当rear在front之前(这里指的是数组中索引位的前后，并非逻辑上的前后)，有效数据个数=(rear+maxSize-front)%maxSize
</code></pre>
<p><strong>值得注意的一些细节</strong></p>
<p>细节1<br>      置空位虽然是人为引入的，但这不意味这置空位的位置是随意的，实际上，只有队列满后才会将剩下的位置作为置空位，一旦置空位出现，rear和front永远不可能指向同一个索引位，因为你会惊奇的发现置空位恰号将rear和front隔开了.</p>
<pre><code> 置空位就像一把锁，一旦上锁就只能通过出队列操作解锁
</code></pre>
<p>继续执行获取元素操作出队列（解锁）：</p>
<p><img src="/2024/01/26/Embedded-C-language/bda71bd117674644bbe8c8c44c782aa3.png" alt="img"></p>
<p>上图中60入列后满载，可以看到置空位再次出现，但30➡40➡50➡60➡置空位 形成了逻辑上的闭环</p>
<p>细节2<br>从闭环的角度理解，front永远不可能在循环中超过rear，最多只能和rear相遇。</p>
<p>因为置空位的出现，rear不可能拉front一圈，也就避免了rear在超过front的情况下主动与front相遇</p>
<p>下图中的maxSize-1对应的就是置空位，rear是无法越过置空位的。只有front主动顺时针追赶上rear，它俩才会相遇，而此时队列内就没有元素，为空</p>
<p><img src="/2024/01/26/Embedded-C-language/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Mjk2NDE3,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p> 细节3<br>队列的最大长度queueMaxsize&#x3D;数组容量arrayMaxSize-1  （由于置空位要占一位）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RINGBUFF_LEN 256;</span></span><br><span class="line"><span class="comment">//定义一个缓冲区结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 Head;           </span><br><span class="line">    u16 Tail;</span><br><span class="line">    u8 Ring_Buff[RINGBUFF_LEN];</span><br><span class="line">&#125;RingBuff_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*若想更灵活，可以用动态内存分配方式（如使用指针）来实现可变长度的缓冲区</span></span><br><span class="line"><span class="comment">typedef struct</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">u16 Head;</span></span><br><span class="line"><span class="comment">u16 Tail;</span></span><br><span class="line"><span class="comment">u8* Ring_Buff;</span></span><br><span class="line"><span class="comment">&#125;RingBuff_t;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 初始化函数，传入所需长度</span></span><br><span class="line"><span class="comment">void RingBuff_Init(RingBuff_t rbuff, size_t len)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Head = 0;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Tail = 0;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Ring_Buff = (u8)malloc(len * sizeof(u8));</span></span><br><span class="line"><span class="comment">    if (!rbuff-&gt;Ring_Buff) &#123;</span></span><br><span class="line"><span class="comment">    // 处理内存分配失败的情况...</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">在C语言中，u8* Ring_Buff; 是一个指向无符号8位整型（通常代表字节）的指针。它本身并不是一个数组，但可以用来指向一块内存区域，这块内存可以被当作数组来处理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当你通过 malloc 函数为 Ring_Buff 分配了足够长度的内存后，你就可以像操作数组那样对这块内存进行读写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个ringBuff的缓冲区</span></span><br><span class="line">RingBuff_t ringBuff;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化环形缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RingBuff_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//初始化相关信息</span></span><br><span class="line">   ringBuff.Head = <span class="number">0</span>;</span><br><span class="line">   ringBuff.Tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">u8 <span class="title function_">Write_RingBuff</span><span class="params">(u8 data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ringBuff.Head=(ringBuff.Tail+<span class="number">1</span>)%maxSize) <span class="comment">//缓冲区满</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> FLASE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ringBuff.Ring_Buff[ringBuff.Tail]=data;<span class="comment">//在Tail对应索引位写入数据</span></span><br><span class="line">    ringBuff.Tail=(ringBuff.Tail+<span class="number">1</span>)%RINGBUFF_LEN; <span class="comment">//ringBuff.Tail++; 防止越界非法访问</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读数据</span></span><br><span class="line"><span class="number">10u</span>8 Read_RingBuff(u8 *rData)</span><br><span class="line"><span class="number">11</span>&#123;</span><br><span class="line"><span class="number">12</span>   <span class="keyword">if</span>(ringBuff.Head==ringBuff.Tail)<span class="comment">//判断非空</span></span><br><span class="line"><span class="number">13</span>    &#123;</span><br><span class="line"><span class="number">14</span>       <span class="keyword">return</span> FLASE;</span><br><span class="line"><span class="number">15</span>    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">16</span>   *rData = ringBuff.Ring_Buff[ringBuff.Head];<span class="comment">//先进先出FIFO，从缓冲区头出</span></span><br><span class="line"></span><br><span class="line"><span class="number">18</span>   ringBuff.Head = (ringBuff.Head+<span class="number">1</span>)%RINGBUFF_LEN;<span class="comment">// ringBuff.Head++;防止越界非法访问</span></span><br><span class="line">    </span><br><span class="line"><span class="number">20</span>   <span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure>



<h2 id="基于状态机"><a href="#基于状态机" class="headerlink" title="基于状态机"></a>基于状态机</h2><p>当“喂一口饭”、“回一个信息”都需要花很长的时间，无论使用前面的哪种设计模式，都会退化到轮询模式的缺点：函数相互之间有影响。可以使用状态机来解决这个缺点，示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态机</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        喂一口饭();</span><br><span class="line">        回一个信息();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main函数里，还是使用轮询模式依次调用2个函数。</p>
<p>关键在于这2个函数的内部实现：<strong>使用状态机，每次只执行一个状态的代码，减少每次执行的时间</strong>，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 喂一口饭(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 舀饭 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 喂饭 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 舀菜 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 喂菜 */</span></span><br><span class="line">            <span class="comment">/* 恢复到初始状态 */</span></span><br><span class="line">            state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> 回一个信息(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 查看信息 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 打字 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 发送 */</span></span><br><span class="line">            <span class="comment">/* 恢复到初始状态 */</span></span><br><span class="line">            state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以“喂一口饭”为例，函数内部拆分为4个状态：舀饭、喂饭、舀菜、喂菜。每次执行“喂一口饭”函数时，都只会执行其中的某一状态对应的代码。以前执行一次“喂一口饭”函数可能需要4秒钟，现在可能只需要1秒钟，就<strong>降低了对后面“回一个信息”的影响。</strong></p>
<p>同样的，“回一个信息”函数内部也被拆分为3个状态：查看信息、打字、发送。每次执行这个函数时，都只是执行其中一小部分代码，降低了对“喂一口饭”的影响。</p>
<p><strong>使用状态机模式，可以解决裸机程序的难题：假设有A、B两个都很耗时的函数，怎样降低它们相互之间的影响。但是很多场景里，函数A、B并不容易拆分为多个状态，并且这些状态执行的时间并不好控制。所以这并不是最优的解决方法，需要使用多任务系统。</strong></p>
<h2 id="FSM状态机"><a href="#FSM状态机" class="headerlink" title="FSM状态机"></a>FSM状态机</h2><p>首先初始化FSM状态机，FSM_Init(PASSIVE);</p>
<p>在一个while(1)中运行FSM_Run();</p>
<p>在外部触发条件下使用FSM_SetState( )来设置想切换的模式;此过程中FSM模式变为CHANGE模式（FSM.mode &#x3D; CHANGE;）</p>
<p>FSM的下一个状态变为FSM.nextState &#x3D; state；  </p>
<p>这样在FSM_Run();中 首先运行FSM.exit();  即当前的状态的exit函数，然后使用FSM_ChangeState();函数将FSM的进入，运行，退出函数改成要切换的状态所对应的  （每一个状态写一个单独的.c.h文件，然后所有.h文件放到FSM.h中，FSM.c文件直接用FSM.h就行）</p>
<p>​    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FSM.enter = Passive_Enter;</span><br><span class="line"></span><br><span class="line">FSM.run = Passive_Run;</span><br><span class="line"></span><br><span class="line">FSM.<span class="built_in">exit</span> = Passive_Exit;</span><br></pre></td></tr></table></figure>



<p>然后就是该状态的进入函数，此时切换状态这一过程已经结束了，FSM模式变为NOMARL模式，然后运行该状态的运行函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*FSM.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FSM.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">FSM_t FSM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态切换 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_ChangeState</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 当前状态为下一个状态 */</span></span><br><span class="line">    FSM.currentState = FSM.nextState;</span><br><span class="line">    <span class="comment">/* 设置当前函数指针 */</span></span><br><span class="line">    <span class="keyword">switch</span> (FSM.nextState)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FIXEDSTAND:</span><br><span class="line">        FSM.enter = FixedStand_Enter;</span><br><span class="line">        FSM.run = FixedStand_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = FixedStand_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">case</span> TROTING:</span><br><span class="line">        FSM.enter = Troting_Enter;</span><br><span class="line">        FSM.run = Troting_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Troting_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WALKING:</span><br><span class="line">        FSM.enter = Walking_Enter;</span><br><span class="line">        FSM.run = Walking_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Walking_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> JUMP:</span><br><span class="line">        FSM.enter = Jump_Enter;</span><br><span class="line">        FSM.run = Jump_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Jump_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 有限状态机初始化 */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_Init</span><span class="params">(FSMState_e state)</span></span><br><span class="line">&#123;</span><br><span class="line">    FSM.currentState = state;</span><br><span class="line">    FSM.nextState = state;</span><br><span class="line">    FSM_ChangeState();</span><br><span class="line">    FSM.enter();</span><br><span class="line">    FSM.mode = NORMAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 有限状态机运行 */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_Run</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (FSM.mode == NORMAL)</span><br><span class="line">    &#123;</span><br><span class="line">        FSM.run(); <span class="comment">// In normal mode, run current state.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (FSM.mode == CHANGE)</span><br><span class="line">    &#123;</span><br><span class="line">        FSM.<span class="built_in">exit</span>(); <span class="comment">// In changing mode, run the exit function for previous state,</span></span><br><span class="line">        FSM_ChangeState();</span><br><span class="line">        </span><br><span class="line">        FSM.enter(); <span class="comment">// and run the enter function for next state.</span></span><br><span class="line">        FSM.mode = NORMAL;</span><br><span class="line">        FSM.run(); <span class="comment">// then run the run function for current state.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 有限状态机设置状态 */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_SetState</span><span class="params">(FSMState_e state)</span></span><br><span class="line">&#123;</span><br><span class="line">    FSM.mode = CHANGE;</span><br><span class="line">    FSM.nextState = state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*FSM.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FSM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_FixedStand.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Passive.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Troting.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Fall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Walking.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Jump.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Jump2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_JumpL.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_JumpL2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_JumpR.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_JumpR2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_catJump.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_catJump2.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NORMAL,</span><br><span class="line">    CHANGE,</span><br><span class="line">&#125; FSMMode_e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PASSIVE = <span class="number">1</span>,    <span class="comment">// 阻尼</span></span><br><span class="line">    FALL = <span class="number">2</span>,       <span class="comment">// 卧倒</span></span><br><span class="line">    FIXEDSTAND = <span class="number">3</span>, <span class="comment">// 固定站立</span></span><br><span class="line">    FREESTAND = <span class="number">4</span>,  <span class="comment">// 自由站立</span></span><br><span class="line">    TROTING = <span class="number">5</span>,    <span class="comment">// 对角步态</span></span><br><span class="line">    WALKING = <span class="number">6</span>,    <span class="comment">// 行走步态</span></span><br><span class="line">    JUMP = <span class="number">7</span>,       <span class="comment">// 跳跃</span></span><br><span class="line">    JUMP2 = <span class="number">8</span>,      <span class="comment">// 跳跃2</span></span><br><span class="line">    JUMPL = <span class="number">9</span>,</span><br><span class="line">    JUMPL2 = <span class="number">10</span>,</span><br><span class="line">    JUMPR = <span class="number">11</span>,</span><br><span class="line">    JUMPR2 = <span class="number">12</span>,</span><br><span class="line">    catJUMP = <span class="number">13</span>,</span><br><span class="line">    catJUMP2 = <span class="number">14</span>,</span><br><span class="line">&#125; FSMState_e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FSMMode_e mode;</span><br><span class="line">    FSMState_e currentState;</span><br><span class="line">    FSMState_e nextState;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*enter)(<span class="type">void</span>); <span class="comment">//函数指针，见前面章节</span></span><br><span class="line">    <span class="type">void</span> (*run)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">exit</span>)(<span class="type">void</span>);</span><br><span class="line">&#125; FSM_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> FSM_t FSM;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FSM_Init</span><span class="params">(FSMState_e state)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FSM_Run</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FSM_SetState</span><span class="params">(FSMState_e state)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/01/26/Embedded-C-language/image-20240116005300807.png" alt="image-20240116005300807"></p>
<h2 id="PID算法"><a href="#PID算法" class="headerlink" title="PID算法"></a>PID算法</h2><p><em><strong>概念</strong></em></p>
<p>PID，就是“比例（proportional）、积分（integral）、微分（derivative）</p>
<p>它可以将需要控制的物理量带到目标附近</p>
<p>它可以“预见”这个量的变化趋势</p>
<p>它也可以消除因为散热、阻力等因素造成的静态误差</p>
<p><strong>kP</strong></p>
<p>实际写程序时，<strong>就让偏差（目标减去当前）与调节装置的“调节力度”，建立一个一次函数的关系</strong>，就可以实现最基本的“比例”控制了~<br>kP越大，调节作用越激进，kP调小会让调节作用更保守。</p>
<p>刚才我们有了P的作用。你不难发现，只有P好像不能让平衡车站起来，水温也控制得晃晃悠悠，好像整个系统不是特别稳定，总是在“抖动”。</p>
<p><strong>kD</strong> </p>
<p><em><strong>阻尼</strong></em>， kD参数越大，向速度相反方向刹车的力道就越强。</p>
<p><strong>KI</strong> </p>
<p>设置一个积分量。只要偏差存在，就不断地对偏差进行积分（累加），并反应在调节力度上。</p>
<p>I的作用就是，减小静态情况下的误差（消除稳态误差），让受控物理量尽可能接近目标值。</p>
<p>在使用时还有个问题：需要设定积分限制。防止在刚开始加热时，就把积分量积得太大，难以控制。</p>
<p><em><strong>使用</strong></em></p>
<p><em><strong>需要及时更新数据，一般是写个while循环使用pid_calc，延时几毫秒更新1次</strong></em></p>
<p>1.DJ</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PID.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PID初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PID_Init</span><span class="params">(PID_t *pid, <span class="type">float</span> kp, <span class="type">float</span> ki, <span class="type">float</span> kd, <span class="type">float</span> max_out, <span class="type">float</span> max_iout)</span></span><br><span class="line">&#123;</span><br><span class="line">    pid-&gt;Kp = kp;</span><br><span class="line">    pid-&gt;Ki = ki;</span><br><span class="line">    pid-&gt;Kd = kd;</span><br><span class="line">    pid-&gt;max_out = max_out;</span><br><span class="line">    pid-&gt;max_iout = max_iout;</span><br><span class="line">    pid-&gt;err[<span class="number">0</span>] = pid-&gt;err[<span class="number">1</span>] = <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PID计算, 输入反馈值和预期值</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">PID_Calc</span><span class="params">(PID_t *pid, <span class="type">float</span> fdb, <span class="type">float</span> <span class="built_in">set</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pid-&gt;<span class="built_in">set</span> = <span class="built_in">set</span>;</span><br><span class="line">    pid-&gt;fdb = fdb;</span><br><span class="line">    pid-&gt;err[<span class="number">1</span>] = pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">    pid-&gt;err[<span class="number">0</span>] = pid-&gt;<span class="built_in">set</span> - pid-&gt;fdb;</span><br><span class="line"></span><br><span class="line">    pid-&gt;Pout = pid-&gt;Kp * pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">    pid-&gt;Iout += pid-&gt;Ki * pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">    pid-&gt;Dout = pid-&gt;Kd * pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid-&gt;Iout &gt; pid-&gt;max_iout)</span><br><span class="line">    &#123;</span><br><span class="line">        pid-&gt;Iout = pid-&gt;max_iout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid-&gt;Iout &lt; -pid-&gt;max_iout)</span><br><span class="line">    &#123;</span><br><span class="line">        pid-&gt;Iout = -pid-&gt;max_iout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid-&gt;out = pid-&gt;Pout + pid-&gt;Iout + pid-&gt;Dout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid-&gt;out &gt; pid-&gt;max_out)</span><br><span class="line">    &#123;</span><br><span class="line">        pid-&gt;out = pid-&gt;max_out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid-&gt;out &lt; -pid-&gt;max_out)</span><br><span class="line">    &#123;</span><br><span class="line">        pid-&gt;out = -pid-&gt;max_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pid-&gt;out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PID_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PID_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">float</span> Kp;</span><br><span class="line">    <span class="type">float</span> Ki;</span><br><span class="line">    <span class="type">float</span> Kd;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> max_out;  <span class="comment">// 最大输出</span></span><br><span class="line">    <span class="type">float</span> max_iout; <span class="comment">// 最大积分输出</span></span><br><span class="line">    <span class="type">float</span> err[<span class="number">2</span>];   <span class="comment">// 误差及上一次误差</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="type">float</span> fdb;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> out;</span><br><span class="line">    <span class="type">float</span> Pout;</span><br><span class="line">    <span class="type">float</span> Iout;</span><br><span class="line">    <span class="type">float</span> Dout;</span><br><span class="line">&#125; PID_t;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PID_Init</span><span class="params">(PID_t *pid, <span class="type">float</span> kp, <span class="type">float</span> ki, <span class="type">float</span> kd, <span class="type">float</span> max_out, <span class="type">float</span> max_iout)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">PID_Calc</span><span class="params">(PID_t *pid, <span class="type">float</span> fdb, <span class="type">float</span> <span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>2.电机位置环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*pid.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_pid.h&quot;</span></span></span><br><span class="line"><span class="comment">//1 0.10 0.1</span></span><br><span class="line"><span class="type">float</span> Position_KP=<span class="number">0.5</span>,Position_KI=<span class="number">0.00</span>,Position_KD=<span class="number">0.09</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Position_PID</span><span class="params">(<span class="type">int</span> reality,<span class="type">int</span> target)</span></span><br><span class="line">&#123; 	</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> Bias,Pwm,Last_Bias,Integral_bias;</span><br><span class="line">     </span><br><span class="line">    Bias=target-reality;                            <span class="comment">/* 计算偏差 */</span></span><br><span class="line">    Integral_bias+=Bias;	                        <span class="comment">/* 偏差累积 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Integral_bias&gt; <span class="number">3000</span>) Integral_bias = <span class="number">3000</span>;   <span class="comment">/* 积分限幅 */</span></span><br><span class="line">    <span class="keyword">if</span>(Integral_bias&lt;<span class="number">-3000</span>) Integral_bias =<span class="number">-3000</span>;</span><br><span class="line">    </span><br><span class="line">    Pwm = (Position_KP*Bias)                        <span class="comment">/* 比例环节 */</span></span><br><span class="line">         +(Position_KI*Integral_bias)               <span class="comment">/* 积分环节 */</span></span><br><span class="line">         +Position_KD*(Bias-Last_Bias);             <span class="comment">/* 微分环节 */</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(Pwm&gt;<span class="number">4000</span>) Pwm=<span class="number">4000</span>;</span><br><span class="line">		<span class="keyword">if</span>(Pwm&lt;<span class="number">-4000</span>) Pwm=<span class="number">-4000</span>;</span><br><span class="line">		<span class="comment">/*if(Pwm&gt;0&amp;&amp;Pwm&lt;1000)</span></span><br><span class="line"><span class="comment">			Pwm=1000;</span></span><br><span class="line"><span class="comment">		if(Pwm&lt;0&amp;&amp;Pwm&gt;-1000)</span></span><br><span class="line"><span class="comment">			Pwm=-1000;*/</span></span><br><span class="line">		</span><br><span class="line">    Last_Bias=Bias;                                 <span class="comment">/* 保存上次偏差 */</span></span><br><span class="line">    <span class="keyword">return</span> Pwm;                                     <span class="comment">/* 输出结果 */</span>              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><em><strong>应用案例</strong></em></p>
<p><strong>循迹</strong>（写的不太好，看看就行）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_linewalking2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		bsp_GetLineWalking1(&amp;SADC1);</span><br><span class="line">		<span class="keyword">if</span>(SADC1)</span><br><span class="line">		&#123;</span><br><span class="line">			Systick_Delay_ms(<span class="number">5</span>);</span><br><span class="line">			bsp_GetLineWalking1(&amp;SADC1);</span><br><span class="line">			<span class="keyword">if</span>(SADC1)</span><br><span class="line">			&#123;</span><br><span class="line">				car_STOP();</span><br><span class="line">				Systick_Delay_ms(<span class="number">5</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		Car_Run(<span class="number">10</span>,<span class="number">0.5</span>,<span class="number">3000</span>,<span class="number">3000</span>,<span class="number">3000</span>,<span class="number">3000</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Car_Run</span><span class="params">(<span class="type">float</span> kp,<span class="type">float</span> kd, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	MOTOR1_state(GO);       </span><br><span class="line">	MOTOR2_state(GO);</span><br><span class="line">	MOTOR4_state(GO);</span><br><span class="line">	MOTOR3_state(GO);       </span><br><span class="line">	</span><br><span class="line">	Speed_1(PWMA(kp,kd,a));Speed_2(PWMB(kp,kd,b));Speed_3(PWMC(kp,kd,c));Speed_4(PWMD(kp,kd,d));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">PWMA</span> <span class="params">(u16 kp,u16 kd, u16 basic)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> error;</span><br><span class="line">	<span class="type">double</span> mistake;</span><br><span class="line">	<span class="type">double</span> fix1speed;</span><br><span class="line">	u16 fix2speed;</span><br><span class="line">	u16 olderror;</span><br><span class="line">	u16 der;</span><br><span class="line">	<span class="type">int</span> PWM;</span><br><span class="line">	<span class="type">int</span> P;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	  mistake= Get_Adc(ADC_CHANNE_ML) - Get_Adc(ADC_CHANNE_MR);<span class="comment">//左-右 F7-F9</span></span><br><span class="line">		mistake=mistake/<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span> (mistake&gt;<span class="number">200</span>) error=<span class="number">200</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (mistake==<span class="number">200</span>) error=<span class="number">200</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (mistake&gt;<span class="number">0</span>&amp;&amp;mistake&lt;<span class="number">200</span>)error = mistake;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mistake&lt;<span class="number">0</span>&amp;&amp;mistake&gt;<span class="number">-200</span>) error=-mistake;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (mistake==<span class="number">-200</span>) error=<span class="number">200</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (mistake&lt;<span class="number">-200</span>) error=<span class="number">200</span>;</span><br><span class="line">	  fix1speed = kp*error;</span><br><span class="line">		olderror=error;</span><br><span class="line">		der=error-olderror;</span><br><span class="line">		fix2speed= kd*der;</span><br><span class="line">		<span class="keyword">if</span> (Get_Adc(ADC_CHANNE_ML)&gt;Get_Adc(ADC_CHANNE_MR)) PWM = basic + fix1speed+fix2speed;  <span class="comment">//左边大于右边 说明黑线靠右  左轮应加速</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Get_Adc(ADC_CHANNE_ML)&lt;Get_Adc(ADC_CHANNE_MR)) PWM = basic - <span class="number">1</span>* (fix1speed+fix2speed);<span class="comment">//   黑线偏左   左轮应减速    3是电机正转和反转在相同pwm下速度不同</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Get_Adc(ADC_CHANNE_ML)== Get_Adc(ADC_CHANNE_MR)) PWM =basic;</span><br><span class="line">		<span class="keyword">if</span> (PWM&lt;<span class="number">0</span>) PWM=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> PWM=PWM;</span><br><span class="line">		</span><br><span class="line">	  <span class="keyword">return</span> PWM;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>电机位置环</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Pos_ctrl_ML</span><span class="params">(<span class="type">float</span> rotationNum)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> Moto = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Target_Position=Num_Encoder_Cnt(rotationNum,ENCODER_RESOLUTION,MOTOR_REDUCTION_RATIO);</span><br><span class="line">		Read_Encoder(<span class="number">5</span>);</span><br><span class="line">		Encoder_Cnt+=Encoder_cnt;<span class="comment">//每次读完清空是为了累加从每次起始点开始的脉冲数</span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">if</span>(Encoder_Cnt==Target_Position)</span><br><span class="line">    &#123;</span><br><span class="line">      Set_PWM_ML(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      Moto = Position_PID(Encoder_Cnt,Target_Position); </span><br><span class="line">      Set_PWM_ML(Moto);</span><br><span class="line">      Set_PWM_MR(Moto);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;Encoder_Cnt=%d\tTarget_Position=%d\tccr=%d\t\r\n&quot;,Encoder_Cnt,Target_Position,Moto);</span></span><br><span class="line">		HAL_Delay(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*pid.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_pid.h&quot;</span></span></span><br><span class="line"><span class="comment">//1 0.10 0.1</span></span><br><span class="line"><span class="type">float</span> Position_KP=<span class="number">0.5</span>,Position_KI=<span class="number">0.00</span>,Position_KD=<span class="number">0.09</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Position_PID</span><span class="params">(<span class="type">int</span> reality,<span class="type">int</span> target)</span></span><br><span class="line">&#123; 	</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> Bias,Pwm,Last_Bias,Integral_bias;</span><br><span class="line">     </span><br><span class="line">    Bias=target-reality;                            <span class="comment">/* 计算偏差 */</span></span><br><span class="line">    Integral_bias+=Bias;	                        <span class="comment">/* 偏差累积 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Integral_bias&gt; <span class="number">3000</span>) Integral_bias = <span class="number">3000</span>;   <span class="comment">/* 积分限幅 */</span></span><br><span class="line">    <span class="keyword">if</span>(Integral_bias&lt;<span class="number">-3000</span>) Integral_bias =<span class="number">-3000</span>;</span><br><span class="line">    </span><br><span class="line">    Pwm = (Position_KP*Bias)                        <span class="comment">/* 比例环节 */</span></span><br><span class="line">         +(Position_KI*Integral_bias)               <span class="comment">/* 积分环节 */</span></span><br><span class="line">         +Position_KD*(Bias-Last_Bias);             <span class="comment">/* 微分环节 */</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(Pwm&gt;<span class="number">4000</span>) Pwm=<span class="number">4000</span>;</span><br><span class="line">		<span class="keyword">if</span>(Pwm&lt;<span class="number">-4000</span>) Pwm=<span class="number">-4000</span>;</span><br><span class="line">		<span class="comment">/*if(Pwm&gt;0&amp;&amp;Pwm&lt;1000)</span></span><br><span class="line"><span class="comment">			Pwm=1000;</span></span><br><span class="line"><span class="comment">		if(Pwm&lt;0&amp;&amp;Pwm&gt;-1000)</span></span><br><span class="line"><span class="comment">			Pwm=-1000;*/</span></span><br><span class="line">		</span><br><span class="line">    Last_Bias=Bias;                                 <span class="comment">/* 保存上次偏差 */</span></span><br><span class="line">    <span class="keyword">return</span> Pwm;                                     <span class="comment">/* 输出结果 */</span>              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://zzx686a.github.io">Zhixiong Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://zzx686a.github.io/2024/01/26/Embedded-C-language/">http://zzx686a.github.io/2024/01/26/Embedded-C-language/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://zzx686a.github.io" target="_blank">Zhixiong's island</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-language-programming/">C language programming</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/images/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/images/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/images/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/28/blog-building/" title="Blog Building"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Blog Building</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/22/hello-world/" title="Hello World"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./images/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Zhixiong Zhang</div><div class="author-info__description">Fortune favors the bold</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/633279373?spm_id_from=333.1007.0.0"><i class="fa-brands fa-bilibili"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://tool.gljlw.com/qq/?qq=3457109829" target="_blank" title="QQ"><i class="fa-brands fa-qq" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://mbd.pub/o/author-bmyalmln" target="_blank" title="store"><i class="fa-solid fa-store" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">wechat zzxshangan2024</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">嵌入式C语言与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-char-short-int%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1.char short int数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.1.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">实例应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">2.位操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%EF%BC%8C%E5%AD%97%E8%8A%82%EF%BC%8C%E8%BF%9B%E5%88%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">位，字节，进制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">二进制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">十六进制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">位逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A9%E7%A0%81"><span class="toc-number">1.2.3.</span> <span class="toc-text">掩码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.4.</span> <span class="toc-text">移位运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AE%BE%E7%BD%AE%E6%88%96%E6%A3%80%E6%9F%A5%E7%89%B9%E5%AE%9A%E7%9A%84%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">1.设置或检查特定的标志位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%8E%E8%BE%83%E5%A4%A7%E5%8D%95%E5%85%83%E4%B8%AD%E6%8F%90%E5%8F%96%E4%B8%80%E4%BA%9B%E4%BD%8D"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2.从较大单元中提取一些位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.</span> <span class="toc-text">3.数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BB%93%E6%9E%84%E4%BD%93struct"><span class="toc-number">1.4.</span> <span class="toc-text">4.结构体struct</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tyepedef-struct"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">tyepedef struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B-odrive-stm32%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81%EF%BC%88%E5%8F%AF%E4%BD%9C%E4%B8%BA%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E6%97%B6%E7%9A%84%E6%A8%A1%E6%9D%BF%EF%BC%89"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">例 odrive&amp;stm32驱动代码（可作为使用结构体时的模板）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">结构的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">结构成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%8C%87%E9%92%88"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">结构指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.6.</span> <span class="toc-text">结构与函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typedef"><span class="toc-number">1.4.2.</span> <span class="toc-text">typedef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.4.3.</span> <span class="toc-text">enum枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">声明枚举类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">枚举变量的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typedef-enum"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">typedef enum</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%8C%87%E9%92%88"><span class="toc-number">1.5.</span> <span class="toc-text">5.指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%81%8F%E7%A7%BB"><span class="toc-number">1.5.1.</span> <span class="toc-text">指针偏移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.5.2.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void-%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">1.5.3.</span> <span class="toc-text">void 修饰指针使用规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="toc-number">1.6.</span> <span class="toc-text">6.常见关键词</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#define%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="toc-number">1.6.1.</span> <span class="toc-text">define宏定义关键词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ifdef-%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-number">1.6.2.</span> <span class="toc-text">ifdef 条件编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extern%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.6.3.</span> <span class="toc-text">extern变量声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.6.4.</span> <span class="toc-text">static关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.6.5.</span> <span class="toc-text">const关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-volatile"><span class="toc-number">1.6.6.</span> <span class="toc-text">__IO(volatile)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#union%E5%85%B1%E5%90%8C%E4%BD%93%EF%BC%88%E8%81%94%E5%90%88%E4%BD%93%EF%BC%89"><span class="toc-number">1.6.7.</span> <span class="toc-text">union共同体（联合体）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.6.7.1.</span> <span class="toc-text">实现不同类型数据的转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memcpy"><span class="toc-number">1.6.8.</span> <span class="toc-text">memcpy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inline"><span class="toc-number">1.6.9.</span> <span class="toc-text">inline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.6.10.</span> <span class="toc-text">强制类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%8C%85%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.1.</span> <span class="toc-text">串口数据包通讯协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.2.</span> <span class="toc-text">环形缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">2.3.</span> <span class="toc-text">基于状态机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FSM%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">2.4.</span> <span class="toc-text">FSM状态机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PID%E7%AE%97%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">PID算法</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/05/%E9%9A%8F%E7%AC%94/" title="随笔"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="随笔"/></a><div class="content"><a class="title" href="/2024/02/05/%E9%9A%8F%E7%AC%94/" title="随笔">随笔</a><time datetime="2024-02-05T13:59:17.000Z" title="发表于 2024-02-05 21:59:17">2024-02-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/03/%E9%98%9F%E5%88%97/" title="队列"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="队列"/></a><div class="content"><a class="title" href="/2024/02/03/%E9%98%9F%E5%88%97/" title="队列">队列</a><time datetime="2024-02-03T02:59:32.000Z" title="发表于 2024-02-03 10:59:32">2024-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/01/Keil5/" title="Keil5"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Keil5"/></a><div class="content"><a class="title" href="/2024/02/01/Keil5/" title="Keil5">Keil5</a><time datetime="2024-02-01T07:17:57.000Z" title="发表于 2024-02-01 15:17:57">2024-02-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/30/vscode-keil/" title="Vscode&amp;Keil"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vscode&amp;Keil"/></a><div class="content"><a class="title" href="/2024/01/30/vscode-keil/" title="Vscode&amp;Keil">Vscode&amp;Keil</a><time datetime="2024-01-30T13:48:03.000Z" title="发表于 2024-01-30 21:48:03">2024-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/30/Robotics/" title="Robotics learning path"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Robotics learning path"/></a><div class="content"><a class="title" href="/2024/01/30/Robotics/" title="Robotics learning path">Robotics learning path</a><time datetime="2024-01-30T13:08:24.000Z" title="发表于 2024-01-30 21:08:24">2024-01-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Zhixiong Zhang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'ereDBpr82BMDhIAqKQA37n4j-gzGzoHsz',
      appKey: 'eyRRFW9XAfz5jAjj7liOHcFH',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const disqus_config = function () {
    this.page.url = 'http://zzx686a.github.io/2024/01/26/Embedded-C-language/'
    this.page.identifier = '/2024/01/26/Embedded-C-language/'
    this.page.title = 'Embedded C language'
  }

  const disqusReset = () => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addGlobalFn('themeChange', disqusReset, 'disqus')

  const loadDisqus = () =>{
    if (window.DISQUS) disqusReset()
    else {
      const script = document.createElement('script')
      script.src = 'https://.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if ('Valine' === 'Disqus' || !true) {
    if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      GLOBAL_CONFIG_SITE.isPost && getCount()
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><div class="aplayer no-destroy" data-id="7351616036" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>