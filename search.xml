<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>随笔</title>
      <link href="/2024/02/05/%E9%9A%8F%E7%AC%94/"/>
      <url>/2024/02/05/%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="b5da2c7d85d08edfb065555db5a836884ad75f30d36eae1ae4c75d1c811ebb6c">34257ab2b37d2b24b0d1614cb5aa327a55c3ce6bb3c0184b8f9cad65cf52642bc1953eed5d87ff580668cb035bb9b61690cef2a23f2d2222060cb5f37d7eaac177e4e71de35fe4f8f8c7a136a9ce05f411ada3b54374618c14e4cb93234c14be2c802de868d8f39eb127a6940a70857a178ab6f9f714d7dd3a2dd0a0cbc08da24befd54bfb888e93b33e539728cb7795734e9026b949a060a41b7a2ae22385c7cdeea933203e24a9bb98bd16292491b5e864ae30f927a2ee14a6132eaff4e94ca6caa4e933aa635e8c8a13eb40eb526676726fac0e9db3944844cc72083afb60a239948eea5d2bc85f94d7232625e76f5aa75ee9ce8b3ac34668f56a3acb632ff02044f18026c2c61d2de3f37517a4e9c823daf7e1f82393a9cb469adb75b842101631381cd50e0a98973c095058607601726546676f1fdc60d87c73d41810f573b90e657e0745a57e9284cb8028a5dc7a023058eba8d125f3e0cb0296e197933bfd4d7765ee491b5a611f6bfdc7ef04851f8060caa3889a53e025fb9919f436f4f840adeda2d503c60c1769c46d02216e37a51e848a31fdff6b784367dd5619fc29b9504fd466040fee91150407c18e10b55996afd8007c7ee252d7dc20189b43b9b60b2e25c1586572b7183a61b9cffc6c8f60c24a647721f2b174553a81d38363fb817401bd02f1f6481d824f38a094048d809915cf1266f85b354bd0d19056cf5e21bf2332bcd98fd4328dad3bb86cc62491138421a5f88c64d9bd7e21304c1e0eb14492e89e0c0b5f033ba75f0b65b2746cfdcbb04b4f0b8937d5edbd2346ce9ea0638dd80659c99b815cc93991ff0f2a9f58a0318f52c4c7049801deb44c9a757a539167a5d981cf664d6c7dfb6a11b057f6aa62d5a0731ae563232cd3375e1fca7e25377defe5e51739ceaa4253a5ce9a535c28e920ee1ec362434adc89adee49b5f1f2bdb9fae62a42e9524ea5917a8d96355bd9cb10dd506c23760c18693feebe62e0b40ab5dad36471eee32d91f9ec0483452fa8b520253605c8c6585bbee4e3fff543172efefe1e63279812e1dbad1a2dc98e1fe7138082f17e4e1ec650031824382142a85c9cd2ca80018f38bd447de59917d07f5c47dd1eb3de8884a4ddeef95d529d835c4c086f2725e1d77d2c9c9b743f1f37c1ff7bc897c90289367c551f5dbe2e7955e515bec27dfb81cdeb8ab1ae3528e71270b3ef7130e052a8ef1bf8d252d03b47bca78b394529768a0ae40503c03043a87a723dd1037b9d35d566d845fcc872e777cad7ca508ac56269daa9c302806532ff5583743f3c0af27fa999198743cec3858a8991653fce7a7cdec07cec88fd7346b570f769dcb79404ffd4002f93201493416f88e7ca5d7b826a5d68fc79cbd3e431cff1f57eef7694caa96e64305e07e1c28edce8f5910f5362f7274e2f302f62f519013c7d189099bce583f501baea185d84864e17c1b5667e957dddda56dc4bbbf4fb52a0d1fea5734c04e4677234b07af140ac81c7f17ab0ffedfda89752884f6c21b5343cb807c23200e3d7326d29a2364a8502197ad753dcec21a4662f20a2438f6386ba1c11f8b70543adf48dae1f478d35331f9bb1b26d493c1e5e75f0562dc23c242d8ada963c461fc66c2144aa77702de36d9f4937cf660af88217780213ae8f2eac8ea803509fea2f7e8dcd9df508ff0211b0df40d0ecf63677368fa475c9fdb98cdcbffd388fcf294fc08185f59d00125a64fdf172eaa741a106ae7a505908c50e701cc48f110f55129b0ea295f182d01e2529c37520eaf177800bda42b830f1342f273383e4f12dca40dc0ff0666a64e1ed43dfde5b547a60b8c5db1d3bd570af9d02b03d91f5dcd01827862ae6a0e7b841ea042fc40a1c1e579a10175032618b52990407b0030183b01875017e3b4531cc0cbce7c96eab75cd361912d970dff42dc36cdc0ce6ba927740f5e9e62a2b7506f0a99346057a471cfdb7ac1e17d054082a5415fa1cd8ff15ae58f47ab5575563b11bb339a499e0732715b72ff36f3776bff0368862d42ad46ee62bb63cbc4344468fea63ca843619e8564a2afd69faa7956646230ad6c049df3c117bc9a991cb289abacbc1978b3540c9796295ad7afb073f0d1fb92baa96f403e4e7b39a4da60a08589415c67821c99106b66e7be9d0ccc8d1e29b0469e33742ebc3092b682d253eb7f5d6be2963c3552f4c599100723d32d0245f053cf2ea7ea3ee6bb68aeccf230c8eb1dbdd5257a1ee60e79c38b7ad4dd629f1b1940aba5f815a85b8bb1a3c32c58307b9072b19a918b3fa862231eb7804383a614878cd1633217a0cafd3d783aea10dd3b9042b7c4f6ea126873f347ac520874d348076b396a5b098c03d1ea481a343e0c43ede3ebdd2609b0512091f186b0fd5ccb1376d606c9818aaf39081945a0c7ed1aa767567b617c1943a7a6e9734daf3ea5ff4f1a10aac01b0475f1759dc1c05a5c857fb653bdf7e767f5c5d968415a800a58c5252fa73daf15416eec3c2b84a14fb862ae27d0911f52b6a9b0e5893602c6ca7914bbc010d6ee20b02ac0c2436fed4d15bd7769849baab4b011a8a88d9a43386773b54cad23f5a2111ccd3345e5c7dba844185b673e10c47f5cd62c361ca4e8ced06863e2094c276d0bf004b594904eca6a72955cc76ac65de4bfc230699f77e9ff3a8218152596ec04fe4441e19248433826a44dd712da638ca70bf6589ae10008f0496709d7be91411830e204fe355d77eb0b51d4fbe9905b7ef6e9818dc7ab1df1c4058b98ac63c21716150a2a3111bc2988f85500ae1a6d59744220dfbf88ae1f65dd71e4dd87b0d8f15f0441a53d4551414f1fae0c7b5ac5aa9d5cacffe379ec085aa3c75af590d8be54675d090288d22774d76090aaf23b4c56f00dba5155ee66f5b8c9ef16b7d9200509788d1947cb81b1b9f088292d5e989b1314d09e9e860d7c8b824f079fb4adf5d680bc623154ffa54e7e3626d50d46c36b0699ecdb4a33af6e385ea9978dc3243c8af9b5524bd626eb0f80e8f785427e91bd30c8c1559008d816466d250510f68b95323029cb6d8ff34e6516dc73156d008779d68ba7e574e44c8978cd9f60600a0b3a4039f2610dfa950571d49d3c7ebcfbd15513166e5d8b34ff32b31b2e8623527c90bb1b5ca8370467a7d0640039cf4549023a344846ba7d091dfb3be53e9054e06782fa8e97c6148fb51b7ea6d72f7901626fa18938550f7d2bc7a770cd816a5258ae47a24ca784fe9eb0460cb6ad58f9ef3cc5ef9671bf402476d91c50821f25d38c2e66542423ecc5084f390ba01a7fd21bd373aa8931940eb685677d77a8187046fa94d650d6e16b2298e5c49241fcbf8ff1e2922e33b7a19c6f1717ded88372fd226ac10537260da6dd5af162a1e48973177a20f963cd6319ba263d36eea6c9cc6aa8f67d51a1741de76a2181522e3bf12ef0ec6b3c24eb894e1a556d505e12357b002a0c6f3b62c557f8be05e772d2f5fae4357a543f93b6f0bab04b9ccd3f8bb757d3a631363bdc311f737d91c06edface1aaae17fafe144521eb39ef15b784abfd4a5abd1e4807f8af796427e5411d2861eb9b3d0e627ec4997919075a73fb3c1b66b9c6943406337210e4ba9ddd28195845916e0c9c399b04d201a14a0642bb68f4de12a72d267aacc6b0ca1ee8b25aac020d232b20d1947833ed8aa006a9eb653653f5ca663df024b682c27bfc5b0c3831143fa760600b636facbe3cb10270a9a0e6c0fd28ed60883127106bbadac3965a2b0a40bc53fe85b3d209b632d150873cc1c340d89b3acdf05391fe1e97d496d31cd187c0b456decfe63296bbc2020c6cb31b42a4ddab6f552ae18abb6cb8ba599611f99e5f2cd1fe621b304b2e79ca77d917ef5fa1ecc386788a9d9c75b93d6e5929111a7e19a83aa754e02f3e1251a5486a26ef4900721cb6842b06616e72513e9d9210230f55aa17c3aba522b56a1a289472185928d13a66d474afe3d524d48acb30372eb244a3f6bb37e685ca1a81609bc7fa4d223f957ef0636a2c88895ce1af765904c297ad2d4f19fa1f4c63c5b316d6d94618eca74131c72b784c824f1d07c8474bcee1bfa298b37af88e2e2e5e03697be1ba9af15165b50029765470f3d7d1895ee8a7c5aea33c3f3d9ddf5b39c3d22e7beda37aef28032a570d3a75cd0b1d80396c28260d49f600864ab4826d75a7fa913dc8465b8d0ab25597488384405ad5ba3e2dfbc89b8128afa5b9f22c48bc3cbdb84845a2324fec44b6dab1f776270edf151d9104b400f31a817184bfad04b13b9b6963dc2b43a2bbbb660bcdcff311f2d27613fd1e0c5fb6e95453ac6746990219e128e670238d166b0e051488c77d9f3e53eddaec57a93cc933fd2dde9ebbb0fee5d5d253c1f37bc158e3401ee5ca1fe71bb75bca7b7710695bec286b72fc5d9542697c03ba68968ad5fedbef7b8478b7fa77c80065fac987c08f66f3d3139fd2d11ad20a2e714076e26296ee9a3fcd4bd50f8d7e0ae08b3d6f35677dce791eb1c72f04bfa26ce6461c84f192ff41c909664c56be852d0e43fb50b09981713728732f8d5557b80b81826f82399e2bda9ca34401d20fdd2df8281ddebec6555d591e654643111eebc2e98c632d3045a8e462c8feb72f6bbfc752fe580fe182d5e876b3e5460bf668c7fe69a13bbe9cff1e3a400481d3b9fdf51fca8f424fd90eea1cc1e4bfb432d2d06822b6832f37d723fca84a694c6502e1f62b470483b5c61de761a9f1a9885a7f9a088939271f83d63f1a087ad5e1c4d2fcbe23eb86f1e84b576e612e398139cc950f9e412e3c985fb30eaf5c42555691b6dd8065fdf94e569140ca2cd617ca0a130c675ccf8490d3fec635e9e592354c6201ab81a1f48b3c81f474ea9e4a0b872fffe32ff0f2c37528cb49d4cfb0daeaaa07b496e3b63f2294f7a9ae100fe42143911f931c707bd8096f90a7067b3a46af7563ecc53f280c306724769b5a9eee4a9d54211ce9489d86946f1dbbdd7099cd36703147ff58be40f1876d8d54eb3b212cdbfa991247ab7602d10330783d96d347b39ac01b65bd306ba827ac2079cd04794af3857f725bae333a3f43f5d5dfa8b42de9886db98e29d682aa432ceb79ed3a4177f1694cc8f530205675dd874c8966da182f8df74dedd4d8150a0d18c98388328c352992064d7d2802a53fdb9623af03933bcf3646af84db345c63a73c36c1817d288b330c669564bd0d0d8393332097eefe5c6b635aa86d7e0776b922a5cb3ba9c697f177b0125be2d76ef63a04e404a5638256ebd2ffd420976d16ddf5f8e2f1d2b3d966dbd292ab9d7d170ac77f0e9ada82c5b7e2e86634564a0f7a3a122831755b0bf3043a4e0727aefc990ddc4681e5f1c6bc4256c7e173373915320ad252f2a988400d9589a7ec2b24efc09bae203feb8bace4a39cd1428883450f6dda164d75bb0e1541bfa01378abadadb338f5b2309c10d9b79641b2d6bb8a88976d563fa3c11378875a35e56594cc13bdc0e6b6baf1033d9bbcb6fe85659e0582e6c4d366b132169b1f7cd09dddc22fe34229d028a260903801d81cd8115ccc838c573e46ffbc9d20d7c7b638c09e5c59e1e209d062cb5e4fec6ac1525e7d0e29e65c90184261c1999a31a25f6a7c5e3ccc336bc92860f40a93450160d507792a83f8d22857c552ee096a39a325d08730328d9212ced59d4cdfa61b653468f90335c8cb0868e05be1348f3e61858f50dfd2323d6953bd7d926e04e3ba47caaa7bab7d6e1c748d197b5644d1accf8cec4976d0fede1260860b8221884677c912b303d4b1b8a0e985770aa0af334d873d41e130545f0c72e95719311617aedc098414bea18293678e9f5ceb06e79d0f268a9efd86d317f8057133c8303c93e485d7e418cb76d8f351742223502e64278cc095d07fc2564a8b40cae745860fd1ce4571e643cd794de28ccf5dc17aec208c26e135c078bc859b3c0a5bb2e74efe3cf4824a8c8d2c340f00efb21b9eeee34a296d1ce4fe9758b83d18bbf51a2a183c19c89d7cca4d064ec043138547861381a1510825cfde392900db14e9cd2c9c209f90e11c5239c26c2f5205dfbd4db6c1bb85ac34825d9e164803126ff7526fd77e3b606071832a5c061c33bfbdeb0f3575260d67305f2756f02c79239f9bc872d8950e6133c3049b0791e47cfa57aaccf8f45fd39099d2347f561c391a84cff0393a1e835704e30b6cc164de8ddec7b6901a94d006f99314eaa438c5d57cc2748d4ba19c62648963f1afb7bdc6f795170ad5645874107fd4a0c28090a2e4e9d59cd3dee694701b693a57b281b9121cc84406ea7cb21af121e226b1bdd673f2fd7c87d824734ce100d57b247e9be29d556b921d16b16d968c1bef0bfa9274cfeda57741379a524ae3333992d3d506bbfb8145aa0bd45b297f831a0cdebf90ed08e415e8d632b4bc5ded1a111be06bb78e3a2fe67421e4834603451609fd0808a04303b8ba580599aecbd2ddbddb8758e810948b17aed2ed22e87da6c58d9cddd78be90f6c82a0befb58e1f9b5f3760a34859b961b56d9869590e90d1f0c8496cedc66fe7706bd0eadd1862338e64990bd38f9944867bff6d0cbfe2071693718482f5530e6f6f2073e16f2048a18dea0234a5a7750ade506ec1af5c037ad7e746eb4a547fc1a5c29351d2d160ec9131190c5fa3a104ba4633cefbdfd8251a1a89ad445eeeeb8aee7afcd0fc278f37c116a1e914a3fb28c47be26d4d78d0615e182091dd6ef7ce49ea9598db0cae612fc54c4a914f3b3048ec1a3b9a4370defa2189a74e8e2a6930f51ba0e0c892c8517c8059d0e54b7cabc3b75ca1f6625951439669ac41027d5a152452f020cf1d98cc4f5050ee7bfb4afe3f1b22903ee5c52fe978fd8dd9ea13f119925c0f84c5067a41bc7553f3b4d84ef882e379366658cd2cee97565e7febd95082b39b7fd9d70c1cf59a470a948244379f308110a8e34c0bc124cfb2cb552f3985da7ec2267bc8cee3098c66cdedd18df7d8915c9f0bf71e987b35098a1363dcd6d2916333f2609f79f501fa51cc179d41f9a608cc6bb522e050b45c7cfe4e44f14edafe5c84b2b39c8e459769895b000db4b6457a2661b1f713926e6bdae9067707ef4891f5521c4dcbc5476a604ca4eacde38a2b8d79123e36308787fe37efa1068e4eb6512351c9e5faf7aea08d6c1c5911b09375ce48e07bedd43087b2790e1c2eb56971b69fe8830661075ff03a108f011cd5f17aabc80581a5e27c20c43b0fc0ef5cdf47fd6b9e0275296f99f9a8fbffc232bb3a587aa7201f03f7b6e57bbe5a97ace89c4b910a457acaf1bf9daa4afede45ca2be4f0f9ac9dab90265c93d1a95f7610119de9931a448281e573527d5b0c1998d8f39cb1b065edab4d43aa7ff376fe659143c6f17c4ce5606564ddaf2a0692c5cda10b1327a04f45c216e01b486bfc2e2ab904afe46b132a229857d70e0c7c75131fbf156f4099816992f072c24f13f73ece57219b456fb541473af7c7e7324ed557c33f33f552784d84899a6bba6ba7bdb72eefa651f56fcd3a9134f27bc39e0189c0854c6cea16f3b3d2310aaf4b0b87eb0b9a3995e8b3ac684ce3feac4b2f83df7fd09f305bd5b4faa932626428b714410f846f790be6985931b93c2085fbcdda12e5597bec9b6ead549236193a236e8969e2b44558afe75d5bd0dd398467a551b0ee25f8eec2ec501e8e3fe636ce13c73f655755aec09d51b06184a60b1439a9d7a023e3462367686069e86a1c99dff2ffd67f0796c67defb4cd1d6f705805a20b0e5575f5817a8f9e6d4f1c73ba36244264067a48ec11da18d9ccc2fa44c2ede552f1bfd9d4c9195ab02a2a7facef2952383dd9344fb5675efa4362675d0aa503056b3969eeb8c1fa86ed165b17a6df5da706679b559a9c4a7d18d0af8b8f5b982dc9a4ad84c5ae2d02f0eea4ad417677a618f501ac7bf90c10db01474dac73084d381f873a01c0dcee284dab843d61c28a8427d8b1ef1d270acb024df70d26f153bc7ab747de4e2c4756dbeef9d6033b62edbb2bebdfe27111cd16a4d2966369b911a64b617eb8baf54292cd9cb2edd46520d86407155682281d02d28a3bd66b886ef1b1111d0b6e31cf619f4e38c8814b05fd6502bb2e5ae0522e5106f6f2c7ad677c12934be85a3632f635cc5c439dd2ed9802e185e9b215dd13821653a93b18100ad3badd5a50a9d6be6a23b845056b7b7bb119b14b1b563dea2a47907b49a03075bdd20078a2349707c3a83350465d7f0193af7735c7b97d00ca24f6c8e419aacc19d2b8eb32ac5da1888b608cdf582bbb35438cda83751ffe436a62bdfb5fad6e1907e02c4130788141fe8a79d348b4fb0fda373e5f7688f7ae10b763bd50a8f7bbbcb1e188e1ae4a7c5637f69243db7844e8515698c2405c0a3896257407a70258dc30769f34c08ba3a82ec60450cce7506d4a20d6fc23f3106e047b8df27e3d57ae4ce124eefeca73416f9a4b7d7e84da963308355c50fb2e9db836d72de497b7747f39f5d6167dd52e3183a89486197b77900dfb204ad87ffd6799c424472d120dc728088551d131e3826f3ce18daed4719a9a87a659a5fd8806337e5daf76fc36b0613667abf9549d192b42283bf23be4a78d090515f7cdf3219017212f76f7c9b7c0368e710f633d1265f126fa9dd17ccccd54b8eaf3c248e400eef99073b9d2bb926e0405b5e6835c4c953120aa58131f8b735529ef772e79194f2eca4de2d3b582ffbdab45747225e2d620cbdd58ace67a3c6b8255c930be0054176a01dbd3e83f66ae6bfc321c4d1e13856c140481cc3aede6ea9978a741c8987b96e0cebd794c33b5cbc1dc23227ef746ef9994e7e89e9bad65150b7772a2bd9fe6b9f28fc317ea5ef074c4e540c7928823986399a253eea66da8069aa49064706f22eb3d064a19b69e9ad1f1bf2d1138e9ed081bd56d452656dc6ca054b1c41571d8bf39f4d60ecd914d93467fe7af69b6792d4fb9bb1f586c95864c61c4398de228081cffb96c57a0320e05cdaaf5bf719c048485b7c96a09e2873713fc9d7d4fdd2c202251f6bb75b401abe00451c2a3938205e8a314df0c6786c93cb69e10a4564a9db1d1bfec449e32d9a14878c14316517efd10a92f90f8ca5f30b0220a18784c9da377ab876d9b543e1a10ffa8d691bf7eff43a4ae864cea79b14dd5a6544ca0fa6eb843e5502701dcdf04219453d9d60489466a1087ccf974f3a7c6364869d264db8204d6d15d5180df2ef8a72381ca46cae485273e370c62d4e10e5aa885dbb45842ae374b8195b84b74837e5b26a0f876adc776be0148493774e4185f4e6089a1be7fb04e84cfc7224392d7c8ebfbe1834637065a41aa2179f792375737f25f22071525c18af8a83da1a53e994041eedec9b131936f4aadf3e7492fb76d21e7562ce5b726dd05a3004105bbf459cfc02d5fcfaff71246a94427e0e059a809fcdc757cfd1189476107e5bb5cf55dff56678c6d90a6f151c0484576e355e212441ff4c7014347163d097b36b95fbe0354b17c2fff3a34fe48148d4a3293686de5906bcea429457bca6ca26fa7e7958ba897aff2844c442fc5330ebc0e25744a9bc0f991f65250a8b62a17ae62df03233be34da37e4eff03f74d455ecda63f5b75cee36a2322875582774be90a71f36c89e63b6b7212ed240921595a297a055655a7a31b135125858edf8efcd60d4e673f53fad73af53beb2b8d0777027c479209ace253c7d1c13038e393dbfcc2c4f616b8d30b406ba5c32173a811cd64a867f706b926f4417959b0f01c9e69c2354f9550a8ffdfb19431bd57f001c17b8d351f89225e2914338898d52b6679fa39c219f8faa8b6b74ea3b368a36b200e011f226f1babec661435e7db0cf8e211d23c04430d80a0c0aaf904de1108f07b9f693f9fad875ed8cc90915af4c31da5a4f3ab030ad344a5f7a32c4cd80085940dd70bd70549f527c3045df4210ac45790dfc59545d7ea26575bec528333fe3436f971d7800ccc0287ec2ed8190db3e35dd16aab7ccf065b94d40819fed06e87c52b6cba00790e8469c15fed678dfd7f71fd1555a06a304870866e79ebff6d39545bdce883b9cfbc12e4a4ff38ad902d94d067b5200516574ec0ca59301e8ef9b3cb04ee01dc66d58335950087294fd473d92355ebd4936d4d776368c62a215ee0bf8549e356cc434809835a87e0437340cd59f1189fe2adc1991aa3a14f0179528a4fa2d6f1c0d3a2beca5b4f48bfb0aa7c810941fa084c801e67245c0fd6512f4f5040b4f375e163cfdfe54a67591a8caf966533ef58cb9f8506a647a93b800e503ca2798511c0b4b2b98630cf450919e846b8c64e290b2907d3baafed135a048d69635ce8429a6be5954282ac2a1968ba12cc1488948977d9c75c82a591ddd2549b331a5aa284843a2b7ba88d01eb224bea83ada05518dc87c679497a60c9645f0fa9f0c4dd3861e11cbca1cc41dc6d98c8f01dbf614ba6565f6341fb13752eebf347eea264898daf978955f870ac99040c35427e70884558dd63a830ab14da0a72ec1baec1024482702fd669d8b11deaaaf17e7631138ada2a55319341fb2440dc16ae69f48eb03885b66fabcc4d4433561fc8a5921ddae6f8388ba74b6cd278165446a4179b1028e60935995862cf066cb48e80899a2e2dfaef5538fed5c8d1920b123fab9a83d444df6524896989c33c77ae8bd3f66e58f6eef03b68985be0f78eb80ea2638307892a67d395b74adac6ac67a6e41333bf88971dd5f64d48ce8cdf3efcd125776788a143b97bd33e9ea9acd2254efc432b2577664282a6dbe5c451b885f9f7851276466aff478f4c6bd143a9135fb498b45efd6f20f676999ff437e2c6c5a89922a8c51b6654cbeb79245fd8ec5dd3340cd8717701b31d1edd93bd9a2958a3eb08b4116ad3d4f1404c1e95f655fe64ec5f32dff74d74baf90e9aa643978eb7b402746285d44170f1a22bed059f1fafbb5ee6bff13c499a28b171d212b98e51d76adbb3b2cc2421703fa0090034964719a5c6c448a545d8269f3ed54737058f3ce0199996ed74f866c727ea1dfac8637b96445b4491b4e97adf09bdec17e0545350a57a794d7538cf1b56c3f282bc40e6661d57570f99373967d8957115f78476611509d2621f8194e3b37aa65b3b2c34e812da65037c43006160d9a0e84e88f3e4d49e4d6d2dfff09f464e94bd3f5af72021785e25ab3324cd4345e48e380e2a6ee9908ff6d064179f30079f42bffa0eee4fcf46d88322f8ac577869ad64c84045fce71b2d34a67f72caa8646ad1a2be04e5b42044e282d336cfa7b934ce756fd01c188bf16911018531d1d782e3d1a84201b1027b8ab2721210dbfb4c8d05c62942b605d72b214bbcc542e05cb9d5131aa1e0ddedc1b1b280c27379d2b4b1f1040f76d86be3f7c159f0708871e4cbfbb8c0a95d64ba9b0b8df575776d710e4ad560af989571c2bb1aae1f37a13b75651df16611169e7fd11e65d165287ecec9d6d3ae4958010980d897f1dcac3bc0ec0baa0dee67c59f388c3b228df5ddf9de68aa75a9a585c8ad107d92d6e0d7fd863b19de9e1ff66e69d8b01252b9469b4609c4c2c54c0bdcc40c881a67757609183650d9cb30b2e1d1ba5ea67ed97941372b2b4bdd67b26a1c3185336a4f4eb39e78fe54c3a569bb315f090bbc7bc5cf18b8d427da54e12d353da84310b910e82434b5f9731d390ad67a43d37ad515e7514d431cf5973ef5777cdeddbd364d3c311d67c63d70216679dc51a445559d49863813dc665bea6e2c0ca44e12999be9cebdefcc372b931e0a79bc1ad9c4053235e44fa14a54745565c80004f6a5463a0ad1c97b1fecd70fb2a42e02f3df30c76e442f3e405346edb17bceaf3f3756d65303b653f89c9a71788e35030f5b3ecf5e72da1bf9e130634a1974f81b0faad5007e332667f9045da6f9f6e5282714e09fc0d1ffcdd85f735c99a11594a0449ab162e4838225fe8303be1c82dab8a81fff94cea362de564299e51ab00b59d15a0b529e9ebb13f4c78c888d2b540fc1a04b5b81d1a2fa14ac59dbb3a4f98a3e53645115c658bcbeac405fe426f194b6b72bc6deac1afd788ba3de74fcaa3a459a435d55681f13112be867fe8b0a756714b10e05197f6066c95a8f27bc3453a64481fb64d81233dc53a6dc1175b6f36e983be894c6dbc06df009cc4b327b76984cd6097adefbfa8781d45840316ae9b2dbf44997d51358089de6e7b94d4baccd4e15550661d56f9762ac07ffdfe9de421f0cc8c57af0d8d004e39f6986b3ec2d52875cd18e5ce8e23464cef7dbcc0beb8c8be9fe5ac18942d06a0316550f0a8f7ce0156a1ef7a8f087a9c290a8983ae35ec48b358b774684241f14c8f5eb0ff3c9bff7ba11e883434ca6a6ec5ceccab83c0a4f11ac7b923f05a65f68b78bf7f580e2303e47e142641687e590df16bcc3f2442cb315a85e72df836027d4ef54bc7e9d07b16f313536b24f012605879052c7eba6f2c9251b39a9f7acb2f2d03ab4398cb3b2dbc6d07c497b1090e123771c380c37062c1e7600b296cc253f9057e8cc7f4efc25984a034bc289c199658899ff82aa6bea9f24f2d32398e1f9758a644be0b53891ba52c384e2e0b8c7fb576321bdd841f1f60742ad464cc9a7bc1b8e7025d80592dfb87be3286ce0dec23111f0b673f2f695443f132d3fcc40df3014a9ed9a1e91aa4d6707b9a97063235cdf6a9a7db6abfcbc511f554468b9de19409d3bf1e6781f76490577dcdab791c1c970286b8c1dfd50b1b816d99999c1f99c1644b5c7a561769b3c05d94f492dcfa9f43b098c4f040380db847fd8ef7a006cb1c45976b9eb8f4ee9f57e42bfb96a56e3414101c7b25ab1d21f03729d4a76cc8bd1d8b6cba50915787d7b85fcb86395cdb2db395e707aaa23098efc90e85e7554015e819af33015c2e6beabe097688c2d8723af8b62d6bf588f332e78a57b8645424615c8cc2e10a41b1a7faa81c36f3a07fefca3c836f4aede81c4a6df0be76f1408cdc8011371056020aac5b0e7d2dc65fd4ec3c4bad1067b961de07ea6cba1c833c714d8efb195d72a4eef8accecfd1a1de7521298c536465bc24b39183e4c708b984cb25bea0c7fb7d8c57f10b0d77b8233311636b1acca906622a0085fe27661f22f89d394552f226ba2052c5406b20a8d60d9357a1b828c427b83c59cc75be954c836c09c11982cb1b700975f6d5824f2680218757b80467cc390c2d824b29bfb90a75277cde88d04f473ec880c5fc5e0b6609aa170e18535fb8ec4456cbf50784a05c62ad2891861d0e49f629153f3652fa8fd357774a519d7a447ce29c66734a68e3f17f164832a6c02a6adf8e8bb74f6114607c0bdd11d2ca1abdc77d0106baa065f62e37e7ece59b4b92e9f01c1409da0b7eef2c6ff8bc98ce7a830d5c9b0ab218d2cd45d8fd3e11fef5d810a4894337df7b19b5574b7c4efb6fe4e6ddf3547bb82e20b990885fc9fd9b9a65929c5309ce28cb300884ae313db1d47bb0dd617dca35bed71f714984ace4d56b3dae5d2961bfb44e64968684c767bf95d1b3d23b077cdf5a53c13501f6bf4c29621b6271a978c8fe18baffb11c5209e75ed0f31425759cacca40d9b568ab374536e0a5722350220079e7765f830c676c0f94ab54b2c745eded7ff0a1a183ad87446179d42d3628530248abf65813ce2d04fde320b84ded1616842b0fa935d89b7b9368ed05ad178680872649e951171c72d60e72648f38af8da5c48587d1fc32d9a953f014c651981e2b905e13afd97cfcf23332f2eb57b5d8f0787d9a3e179babf47bcc3a2dafd24d8bfdd5eec4c8ead0e14d68e2ccf50386460b4b247b851c95b280dba91759b7d166919bfd5759d728587fb17b21bbb59d0cca9b343215dde56a8f4710809a3157a5dcea7cae74325af56469b39d0154f5bb8fcc08a8dc816e113cfa64caf3bd0b1dd5bea9d4a56242d3073cffc53853a3c9f18c96398ea2cca0152d3193f178da9a8dc92e60c2259d39e4a8afc3d23759292227577f12be0c9253a6ad9383638936df65549dcc0f222bf6d9326dbcdf679667212a61e7eabaf3c37e711e51b9c0c4e70952c325750bbea96e7e23f93a2bc6642a1e8556ce04e88db4df6ee12086f45f81d2ffeeaeac6cc69ff3a70c4659d571d46f9680d6b8ef91f9e2e2e3773d1c6c947bbc032352ed53b5077397eb16ee5342d45317809e4a18a46c28659f052bfbbc94c15e726bc382bc7cdf8c4fdb64a924029635fe9de811695b3b859884c5dd0b8704c1369ebbb6e3d9c77763b8118df531fbd150095c815f91a6d02daf52e5cc8b30126252a120be71583e8476f645f1e224e5ae27b3469da225290e2e45c36bfd7f89b3e7b0dfa694960e692ebd1730681dd4d1590c4dfd1b8d9f52b22bfa2726784bbc94bbe6c950dd5ab5decba233167f442680caf6a240ee863eecb1f45704524beba8ba176783fe2c3db9ad8b4866d3c10e924c73558fead67e5fbcef5f714ab0f7e85611a5ab2c1e332b92c1f7f16c4ebd926642af999786c670f59a8be817fa1847f73b3f058f449cd39d2efe516f42e73fb51e596d7ee53e9429421eb35356f0a6937eabefaeff2fbe092278fa3261ff696091689eccccc76c2554fb8ce835d184f80b3613a6fae55ca2ffa6e6e56089a865436922df424805ac80e30683f4c8fa1f45356a60d7e24c8c22f255a748e135e5f2540889c7194c969833e26d3b0381adb93a104ede9d58b1ad3d20c9ddd073b388bad5e939292e883af43378347882ade5df0ef5edbf3ab001a7be668bcd75c837f485dbebc3f9edaed718ef8889d5c895a8336a4f2fe4ff944bbf0bb4b19f115c9d4d35a2320aada3c352b21946ce334305551f4f660edc9fb0a341a716a2cc85381b325dee1f4eaf63649061d934a82b26ac2683880aced8c79eeb746215c51aab492ef163623abf16d839438a318b27f5d7bcf26e7d5d81eea60113088b2594a6f3428ca6a69dcc2a7d8c26864dfb821816e9ed6185d711c41f2437b7c9db0868467459917feb16a13bb6f2674852b19a5c7c684f641134a51fc4b752d63303ff8ca63d49c8969d6591c4b2b63008c367cb203ab9b5cba63b89a9308406f00c1730a839d199d468abfa5fd9e5ad1d26ffe11d221139ce72c75bf1565f2d52bfc60846767f0afffcac6c3ffc7fb1bba0feedbe7447712428ef270eaa5206b3f78071afdf34a4ebe1aa876dd6a9cf828577eac9770f6a11860bb3a428ea030351b0a622e691077fd908ce361423b6dae5c90bc517d1afe216f491e2318f2040053f040cc0c6a3268acb5edf4ed3c5bfab3e497b8d37e0cf4fbb1f26631778d07620b179dfa04af713dcd52cb1dece4f9b9d98721f06625edbf4854cfea82ae6f60c00ed0071c68ef83dbe6ec8ff5119da7f18b84cfc4f2987ca383f79c7beed98de7f3008e29517d36d1c721e9e0dcb26489420d517a206cfe716de39133b4ba932ef47ee7bbc28196db707f503dba68533328bc9e7a91752f1420f4a02d1ed2b04b681aa533096c23c9cb30d98d5a41f04889d40706706e38fb3c54632af4d5a579b0b12faa895a4a8cc6fefcd498bd1de626a176bb101c4252c342cfa04a09709365848099458f669000d06f66dbb28a5f5d80b04ea963d139a8263c0e74c108f0b75c731e4c6d43b2bcfadf3c641aa4ebc6c62bd4cdfde64582d2aea737666829bc6b67902e88ea359d0e5c663b627535233cf8e5f32a5051488694dc9ac4a53a4b34dbb85064bd64767e4ff3b33b20b5e0ff2dd5b03517dc9cd23fd0c8fe60676f775f248d6552e68b2f0f2073052bcdac660a975928c300f01414fcf0b4c596fbc5e488c85c646a57a5728d18fa77a2502739ee0405b0c1bf9ed359fac0c757e7fe7a6eda89b41de16b4bea488f829441a4f131a8e631105fd7822b84c4c7e24899adb99dfc92c88ec2194ba03e3b5eaa12b8feea958aa9a7f065a88c3148252e904927c85fa6ee950ffdf12271a0d855018190f1fb16cc3b53db132e04e42cf79a91570e3e29f80448685cde10fdd82e595602957b1b052d47a71f63d4d85880ce7e97c32c916a063cab456e021e66f32d2b7a94543c8b5b52bc8021d7dd1b611c5aad731b411b01a4da1a9b3a994924792e0e8b7dd2338644082519b4c56fa9dab6c4b77124797d0c409d6f7f08a5d31b4f664b0ff40d4c4c7d950a89e505536186c4b5823eac202f60e9a0e560d9ce4a17e7b94500560f7578a179cee854d8964ec2a24f0ec6465dbaaa2ee271eeef42302ac0eefd62241206f51e8969dd6348a85799ad07b9ebc870631b91b063a9948387eba64942823a972072dbf8b7c60931c15d1172bff4e369ecf7bafa89da46713a7f180cccffa392da2ba874b2103cfcaf976dcb2f66fbe8ffc0ea9a20ba77b8eeef1fc024ea2b93dbe2658142aec1d05ae2be018c2da5d9c17e41e69c88fea449f27eab4ca0ad29831207ee0d245be44cd4c656830b2ac6ff70498029d6b3ee45b8463311f1aa8040771946ec4593e2c4d0f4b1f4af3cf1c2030ca7dd3dfeedf1e1cf8532c670e3436418963a6b0ed71b3bce6cff5eee08fe8df6fd7f0d1101dde35b9ca5b1c3b7de7b823ef220d2eb0f2acda25ce898f80add9ebd7a648e93d3c51e9259e7005ea82c4c8093ea435e6004f92bcd70bb4f7c9dce0c07565deb4aff52464e5e7cb3dbc81632b5aa47522e6b8892373b878a8ec7b67a62546c82ede44206b9be0a6aa2be8fdac6b5e492f0a8b8c2c515931205fece5f3aac8a7770037045416583a7461cd3f27cff814e21d470e6d6c919615a37a2f08cd4905c6ff76c833c0c15ccb6f1c4ea6d5e3275675406390d785a5c6413b6190420172c8146a925a13f197d4203135c5c4e6b84e09de114fd822ec698174f446ce64bed3ddc0cbe5c5f1fead539a1dc09a28990a220fe753966802e1207c8b27f85a88dc477c6b78f915876a34ae72521b67e0deadc99750efdd2a68897102952abe924fe638047e6fbf4fb56eacc75d4f80a7f404ae043b9fbb6ca153f05ad647b673548589f6821f04c626a47117d263b508f9df9d9c676bdc76f27afdce05eea47570628e53842d04a771d84e2e28a52d170ef3e55df5670d217043f9116defa34fb7c7ab93aa1912739466e62495d50769892994cd974374d3414b99e9565e268b6134a9eae639db98864a20566ed5afb660396cfab81600a0cac72f9a3a0eb8bf6ef731d642a07a6817105b7a2a7504974cd1ad35d4bf963c36b35992b681caad597e94b6a12b2b4f565816468885f891a1fef0d9f56ac8066b8b706b8106becd00520fbf19ec073ecf76ae88eb261d6fad162a6b6d84854e1bc4350243f35d8494dd4f904fcf7a3ae16dfd9205be971aed92e6184d1ceee1cd70b2fc2991e557d215c196958bf854180219ca763417932a78b9efd057965733b6e019ab186fd10eafc75505d6bd102f98edef5ad77169ebb0c0d458b958b9eea6afffd22dc236b2307238e7396ebdb7493bbada85d0355c9563edca2257e660393221b544bfb2145651664a47e1ecd733a762eac8b62c9bf90d1bed186980027c0a9599d83eeaab84dd5ab94866cc82615379a20dc746228fc1bff0849be467536fc81186e2c8225f6825b8cd62790748c75f2a5feb920457465745e876875f7d86b0befa8807308bc25a163d2b05f0d5b56a2d0eada8dba1498f44106dfadca8741a55a038fa6a1d88144a3b32cc84e140a72b8d1e3654ecf4b5be6c02ad2346a299e3681e3392e970274b13253dc5500c37257a027ad2d922308c10edad33b5eeeb3ecf576516a5ef33e20792128138df646bc4c22f73f410d9292b28420fd2d8e005a027b3e4b038eebaf128760a199dcd3b0f47e03809ea8955d22c095d36531d8967d2dc433805685510178bad80ee8f125b06f6500d973e9e85b1ab97d8fb09bec7bd82e778737f9f8ca7200ca728a8bcfa376a2de27d3f0825c465bacdb3f38d3fea06f0b1b118450c46bac91c8e8f4ed4d15346a0e5587b9bc545c08214028b1d484ddbaa4b0493000ae20dea4ed2d16c468daa4766ad2e319dac6876cd27442b88e0a0b73b71cdd8eecf838d5de7e9f1f67f4b5162173a0de45e907c42749318414673b7f92001dae2299be5c77025886f438f033ab973ba0d6ebef9778216363f4e4ad1ebd8ff8c675ef6bc44e8613decc45fa403afab14e81ce7c745353439288602e659540c9a1314469b74c3ea3c25942ee00444b265442b93557014a3899afcbc5dbfadd971baf6a7ac649a68e1d686d0728f1990c388716d56bb05318041ee98f7ae1cd6c2695212fe42e59b1cabd46f37402f306a12080198f0e3339d4773e654431e353cd7451c5ac418f8dd0f7572e078f32cc27c1e83df92d66991d3e963fb8d5977cc77890c4b5ac8af7e84326cd72eb79b23df5bfbe91f7f1d68dc1005774700e2feefd2331321151c880b997ac75181c1a0332ca2c1af9331ecde850f7e88ff8cb14e2451f4ff0f2054397a103bd4549c0b1f7615ca37151c9aebe9b5d8af102a56fea42fb6df3de3b52150244b61478afc21beb12bf133b1bc4c1cd94402d7cb28726af8e6f7657f77369a18ab58d5413acd2da4e4b03f352f9136866ed4a5f653aa8e5ebc5ce173c4f1d0cfa24d12905e26e53db6ff8e55f1e8079fe21beec8985e207c14787c4d3c3ba64ac2fabdaf4fd3efa51c6d7b22748583d1a68b0631050e8b0f511785f580fb682147aa5eab68f29f11d084ac0ffd980edf008519ab5bad59ef54b79315e22f6398dfd841b8eb91b581bb9a9210d47003a09987be02b1fdaeeca3d6db824096231b046c33cd82ea3bdab32bac442a7c77d2f7cae18cf359a37d6291894c63ee658e40c053325631b6138225215f3b3612bc482a7ae6cfa78b4c6cd550c23cb72525364251f455918b0ec89cc659fd37e9db77855bc8ad41e325561a50a74002363e0f0697444f875b348a15cd042559ca496a2ef743f3653be39961aa4fb5ebdeacc4301939508b98febb28ae21e13760d9d6e6a2e9a158d7b7c344b267976b5001bee3b07610041f02feaf8694e80f030deec0e12ea7665904fee3dc724e42fc1a69832f3c44d3e1db47ed7cde6f16000663745e7b70d406fbe868da29f141a1fe150e6ee630dcd9ea4a75e568f4dce129ff89ab918582a5c4b2f8a039a99c10187012c4aef62685ccf56c456485cf945c9643b9ea382ca97e66d273409598a1479737166ac38e24d396726c28a0c2c8457907af96df2a92a8cfd5e9ed2099cfc615988eec483127d35bf548c64348dd8f07eeb9e3591ea0ff7e23403a15264f590513b0e5781422f0b2ceee9c17ad8ad06ac8eff573f303a8331bd82611d2ed9a73173e1efbb6298ec587a69518be85daac2c21a522747d30a2aeb72464cbe5a7ee5486976015d95be191eec019513b2c33f22d9ec1a1df1be1ab47206955b9dd6326e805744f78e9ba6a0f970c239329d0620a178dafd984380b7432a6682e35012eb1792e5896468dd0893654bb43250d47be467a11d55c24f75978fba9602930a1cdaa181be96928afbb4a543bde860e5126838f2ae9d6cf37ddbce1e1ac9ea2b6455d91158783a0b3179887ce2839c58b4d6debc269cef933f09c9f70d426e93d69da08fa104d8b2a8d114c742e024a90ed04b086cc0a6808adee3b18da0765032d258e4a1cc4b949ebd7f56d90e35bb175628411d24e386ffa290b4524dfafab635cf625fc57f7dc559e8cd03020a6e8bca68b9c4d3a9ed9696b03c7527d6e32705677d1f149cccbdf2165ef33c363d6f9cef6b79419f8b706ed3be8cd18a7c5e75466d08a8e26513b5b502d7519ca75cbe03299ce7fba63d1e3b57be53a3f7c339418d7f5f4b3ac8c156fd02dcb5fc2f1ade056bb9720eb2fbd3377f568e133d0ceb5b40aea6e03c7a142eca5ad274bbdac013a7e3c913bcd2ebd7c2215c7908be50dec9333e052616f03f9082a00271345b67cff704461ebfac4b05be90dad12d1b49df29c9227df9922a07a3a101e7957075098d9261e4706a5891cd20808c2af7903e853b0e7000a5935d3f80818f2d28a44df711f80b5a3b22f8801852eab1ab0cd4d83b4cf56aa9800ab2b7255cc7dae118a152728a0bc0de7147fb49790f5e01f83d3fff038f74fd271572be374880faeae1f495d26b6226066332202a66120ad94925f02a470be50dd815cc71648e3a399cf19c4561d274df2a4a76fc28f1c831c7a04dc5c7faf72c24df0ef261456b2a1039a3cc1639fd5e8d83b5523a9d1b41136b0bfea67a45e2789d12e6edd3a4c61aa3dcaf16f3586fb66638aed1dfec06292ae11bef440f8c49c06677bca13060a09d1e7ee0e637922ced7e42fa606f60488d57d42bd8700cdfa6e95c4a59507943b01dc15f9e614c5949626a6f15fb6511eac80c2e846a7dcb404310781ae275d801906bce20c193c67b28a5c38d94bf4eb31db3bbed808e6383dcf4283c601e307ad5991617f382096baffb57b088b99d627b80fdf0a95a51a043c1bacc9b092b12b3f0f974a733eed7c025fe85d74628bd6abf50906f4d872df899f2bd7032ddb7748a722b7e37366fc186d8acda69a1830e7718cfa1da569fb4900a49452194a6836f77a2a2ce3896c0cd859291332399b505f7d2e3875d5c8a9f0c57cf37cd97adcf09421f87aae55ff618280047c63ee6f99d8090344048512d608e22037b6e436f6ba5aaae7d1b98ddea150e9bab7617f61c22918a830a1f03bffdc58ece79c44f38dc5c04ffe91a8ce83722ddb5fc3f0c58f338b68e9ca56cb4befdf87c55bcd23e08a4732493e757121f3db4c526a2b292bcd2190d2c0f7be2e87480ef46eeb9bf80137f757a1a0f935af6a1401ee3efac939a2e9f78644503ef290ae507bfd64e0949cc686c0f27efd7b768c7b777a05fd05ca6da086b958d6a8d45bc8554ce06278c3bf61f0eb7b715dfb0485176e432557a02643b0eb258fa380639bc8366cbb5c12b0fce5213f7980ce88000e91517d4e02b65971863c46c36b0b0b41b4d8748e1b594f2de458d48d4dcc8f2e1c96f784ba73e51f33722fc2cfcd6507a238767a7405fc42052bb92aa4147d44ee1be1e2b481bbc5652574abf10faf8dc7087a389e1da22f0268bcb81c9620211f3c4706fb84abc4b248f1c4a33c579f62bd6099bfac29be68c2dbf9a1beb1c881eefd07ee086ce15e3eb8e9e4b0b216dcc812c6ca09c35b6ca98db199f743397ef0471da42ebb0989f3343e832264448643f9cfe59f1f7f918f44322d7f439b75ae31179fa39cc08533e93f15d8cc4d52403fa4eb3a5a414b448c394262406b28f4c98b9b1e11002a320238c77fdfb535bebf8471e0a67fc542b32b900916abce57e6df04555206e0fe8ed29cc9c66ac9765084b8fee802aad11e2b4a8c86430bed1d9a2f077c53eff40210e5697b39d8b20f5520abcbb52d5a27db0fad1264e53ffa2185fdaa7b70410e2987a39c17698554ab29458ace05d544154ac6dc2b5432bd52cab29a956d51d1c8b9f68f9a9fe579e87fa9ffbc5df3b5d7f1e034cc908d8f6bdfcdb0931b830040e167e454fedb8f8b544576aa860048b767a40b075e617f4c97c90e07fab252930ab2ac382015ebb4fee3e0a1afd510d57fa5aaf4d9b51a248bcdb27639e5e151fc70b519a6852bb4b5b0d47503e99afb9283a430443c9ec8db934764e2d60244b13e195eac1c6650cd09484fc1090132f6d03a7c02ac2f33bf9543b8c829769393da3d036f7ba1f5bdba85e44f8217a6dd25526ae41f97ed71018388ce56ce1628c4f3880856858c1d5a2464477e08be3f5dd32b3c3b0a84620be6b2ebfd9d25bd0bdb2b263aa6b1be8cd73459a4c466e89dbfb9d457b4c54765375727767cc22d7e0481c6781a53467400e998f293f941a3e03bdc9191139118386de48e217370792fbeb62af8a1f10cde2c5a4f951fddfe955a6bfe02665434d33ce3ee1a5f9e767c0f3181b61454ba0d544e75b6c4d0447c084ca397521dcb8822c3c4e7191e41f273ddb0f748e3b83b8e73ddf0a5d420d2bc678720097f489ec0ba7e74b177036a295b4735387deffb14a142c6fc1201a738c1de6698f1eb770485077b9fa8da123010ac8eec7b4be31b66fd988696a3d32858807d50f4f067ebc227af5eed67333f3a6787f694613502ad45a2473c69d1a468d31f00a8ec48c7631c0b26d6d6fecebc7a06fa5ae3c0c4a83d561f884f66c4373c7f2e0d040b311b298551f971cfa4387e88013a23f565efc72d510fb849fa28c88e2e7f8af3a01a0e4ea01ce59178daa7b9e5051bc5273cbbdc46298bcc57e88a19091b45b10e1270e06efc883c7705c78de8595d8207be83c0641ff6fa77516b32dc3ee673899bc2267fb382593a3d1aebd606d43259cce4b6d4bea67829998667b0db6aa6d9138aa84be121a8d0ebb14b201ac1aeb79ab885584ba559da53e16848851925da525a0497cf64966735674e02fc8ea317387854fe8f85e8aa466beb10b22637f45a50d4453d200b61612bcfc0de5f2bf646e2264ed2c095993b1a547092f70f3248663e10e335ddc1e31452568c61041a9176490073b26ec1a531f83542a0d41e06ef2e19d142c45f0b4825c99b0845f27f86b879f765bac394166681e5d7aad503492b28d2800809ef1dbea998464fefe139b8347a2bf78f04ca4b9ba85811ba96465bee2a308abbee58597d5c264ee3ae6498a44053d3849c1588a6b5c1a954ec6c7b3538b80a054c47b7c8f8f195a54aa0b49da7b3ca469971198c97d38667427bd4b8be4167bd7a5e1cd1fa32027cd453c89527003a16e9b23bcaf6c1476f33505cca0e109bd7f786cccb423cc43ea7043a259c30a909d479f3a855fc42291a51535e2a4aa48d9ac5416ac95d03dbe8318574f079d0b87b8beb7225418a663649be5fdd50b90a803b0cf006bc642cb5201fbbf607cab3cef27ce1e5039a9c1778334a92cc446966907dd9afe607ad0b5386fd1123487dc545953c6ebafcda55269569875b14dbd00afa2e445db002ba90f056846d975fdd1b08d69c7896eda0af236ad2cb4117b2c814945005b6f10a0979fb623d77eaddae6f2b3d60859aa153fa3d0f334eb8b8332671ad9cfaaa662ec59e2489ad2ea1e3f380b85ab44f93da3296fc47cba0aa587048afa8d4dd6990562d76cf3025add279255807bb7c72ef9133beff11a5e18815ea603f0e0c6ef66336106a3582bb11a7d736cd069ae0e7b7e1144f47344030af7c6cfbdf82bc1752df0395511cc6c349e00c58f7822793ab5c42281a55d22ec91df49ca91afb56f6c68b45b7363e8e898178a97839d5f719738ef946bc58edde3df3b6a999bee1527dc38dd72622a22f6abd1bc325a1b087bf373a85b58056d8c0f0b174f2595c9743a6bb213991c432c5d3116aee3b59fa7cebd9c9504306b952d5580965d74c2c10901f9b69a8faadcf91c0414b94d976dd8547138b54f10414c08e01b84ae225f984b1ff357bfbea232bb38be446405e4e7c147a2c93622248bb8226c3625e04d853516619fbf9b1b2ca12fd12f9fae64c350710b1351ce7b171e6254caaa3ab45b6986718d510a631d9e5354262203121dc2e514d4b048375af82d9048d6cd491ceb5cf28694409d0375a31c9f6755990e6befb558e9ed64f6aa5c024fa7d45b9cd68c2cea2845c357afe2d417e9566abc0d8068492e070b748d100907d75bc6b9779d1e1f370f4656a8828ff0f2e43e879fad6e276dfe83ee5d8f2e36a74e875d706e97474bdd0a9933fe173467601b18da48eda8e36a011be942124d07547840a4eb8e9d9d62e6535dc97fe5d2acab9d7f1fc35245584c1b99d7db73d7614a8bced3dce85de0aeb9a64e24e2302ef98e41662bc9c38ced4be4f3004c5bc4f6ecd9444b737c2cac8c01c818801b51ec03f2146b091778c2bbd372015365a11386719441da3282909aa9eb2ded2bdabf071acc3c385fa4d45f2755cc352df7aae1ee6672429ba4f37b0d6d58d0d6440de28b93c0ceb44d2393e9bc9fae80cb953bbac33eb7383d61c56bdb9dfc7a1a79605e0e06fa12dbe812eaa41f88e85f6aa06a1b35e97d58afdd7dc88e0796b2daf66f10b3cc54848167798c5dbe8f4c02c37dc669b7f8ae4e2f1d2183bef3a92dac74c8ba1231065bb2332a20c24ff1a78d238d82928ec04bc15eef815bbbf4c2da33402baa7b1acd862743ad56fb1b50c3a3c4d891ef020ef7df3a595ec113df419e46dceb658ceeae7fb2099c722422b683e20e041cd18b47527b0d847a2f2680d9cc775ba1476ec98364fd96748bafdc5c5b4f340107461c560592317cf58ad3ce57eb3b0806784de19f5ea9cb7131089f07583981a16b0869b7a7cae9f484281d00a7bc749d090a03e9b50e772ed33b6e75fae728db7b0f3d58bcc34eaca01a4a0dd392e119e8b607817e6f47a080da45895ecf657ac2e30000313207dfbc743632e33d1e1f0b61b962d332867dc4748cccbd4a8b9dbfd285ba116be5bdc644bdad69b51d1bd9657e7b5f912482334eceec5db526ba4f73067f176d8ca4da7301aec62a08467e4a89640730326d1046cd1a8dbd49820b13691b8055e6f69a9fd91a11282a4818edf3231df90e87aadbb7f419edeaff79fb79027cd4e2d8cc24ef6f2f1c70cd4d917d70f8908a33acf748f5b45586f1ee5f541ce9e988546d07972f4182fb04ec69ffe310e39411540fe8f530aabcc4c947bd81d127f1db3368bcbb13b3daa579537f776f4d07999cc38db37d98aa3d7df978f368c5129ac84b6e7888fb3aaa57e2f157755120691353b89fd7e41121d1bc160e62acddbee293d6c4928492fce1c08db881164498f8104a89cf2e604f37f855cee402f44e91b800005e9ac732e843dba991f11a68f730c960f2419643919409551ecc9e99dd71256f48aed5cf183a5dfc22c2f384ed1c6748eca36173d8cfe43257564217237c895c9a8264a2dc5d3641e495054a12e82871b08bbbd219bf7d505d9bd44612ae600280f032f3f8006f801f1a3ba1eedc9a9e913b825f6249be57d040069df5f61b2379c19a3ce2c8c36280537f2bedde8cb99c35d07dd51f755745b07d4724d30e6e07ff59236e7d5f77feebc31603c7b2016b2b92c060b06cef64c87d095c02b536f51311aff469c5b3eb6d83512adf355d7e585d73f962d30e1d8f3f2a936409a6c9e55bc69cfe1d0a00d02c712145cec346e41909f0175d20bf28587a1df4997de3976bb0427f0640006a3f072eba0d157178773c586fa595cec2d042ecbcf0fe8b9f1bdccb1d0c318dda089dc4f76e7ff7b744e32ee9edef9280c13f25931c3de7f0bf10888e8e7b097183dc8d015aea88872fc7e8310d3d9d3fddc899491ccd443329d302c8cd3e5ed09b6811704d94570356f5343b85675fab6cd220a1ff85c3b6f53a57d352619996996c0807638d54704a03d571666cb6f5f9406924a19da7ebaf2b5d692a0f2ad7bf4f0081855d8437edd53ce8c7ddeb4d6ec1a700c23ae900e266e07b3ff24bbd0c4966544d8f8c3207d1e83930da6d7c7c813752ca9861a01a6c1a462afc37370e48126ebd0c4e452eb904649aeb835c9ad862582b635b836182af2cc8423e86c914df1327ca2128088f9d66620499cc7383a8a3b90dbbd17f5b9c66e70c12a488f26be36a0937bbca0afb76168964acd06c92af97260a58a074dcb7e7aca58711c2021903ac031f4e2100d9f7d1ec818a93499a74db5e8405788c6506987c2e830978f4b4d6c883e3d659f4765aeb87c7b96a6b70a9690abbcebd4cd7854540937435057c477feabf444dee12dd6bde4ebd2afde8c2934380b09d2cdaf3a230e4e028e30746059ace7c124153ee6c1944ffebee5b843be1d3a5251c4bb6d38baacbc3296f2384705594aebf2b9db13b0b49f0f0acdf339b9600c3d4bf6f430f40cb185b4b0a9571f5cca98138a2a4d10e12119180839d7e23b11e6927a01d968ccf3bd39b04c7fc7a44f4fef3b1518a7dc6c356ffefc1543b516110e468b5c3d00130210edcb9f211eb65bec95b02f57f852e853d83613db319137ed5822f59c433973bef83acfbd62c81904365d03c736ad2de5ef19bf81627096be92af8f1040583bf27281a1c2026f6c38ba0b7901c845be82863c95c4183e19517c4dd5166664ea2db486da83afb13353f05abcb19cdebcbea57e348e63bedebc8962f2938a696406520f314b41a14ada35b31123d67b5fc0b72d4d0f20b3d681515b1972f0a342e6e862f25e0ec683decb8d273ce1fddbb876ef9ec828a8b31b0caef6847d053a6fd8eca7d2c0481df170a025fea42ac9f0791aae64d7e3fd4dcc9b20a8f5d6d70d80c8016ac0a15e2d79b86e1f6d8a88f2f4c366fef84d882db8466a95a3c894de50885242e4a1fc2c1449d4c3358e95c5d3101e7ef76b5129fbd4ae706ffd6a22c29130cb9fe1644832029caae14a7cb14c3bfe5b2430759f262ec38c9c22651eab1d9c37c1fe732f63a9085ba566fe2a5441243df07a20b4c661ef799a26a413b16c7bca38915cbc8fd74ada506bd7a69d167f4b9be7a13a43f95a934465ac32464f27714b2186af510674c612e069c941a5b81725049a3f182cd83c19c137eb97dc0668fa06de3b7d6f4e2d6794ba527d20396e000fcefa9530574d13f88b0db2736def6002efca50d6d5b69b56f91143a4f4565d780c211a71a25422d9e5954020ea5cba766539bdca0ada6cbb31f442646a607ab509ad958b528f6674018e90d937a4d3b42a0d74387ce8c2fd0cfd6508c97c94381648f3ce309b2c8d742d264df8e662ea55e10092af2ade05ee685a0773f4b75725f82118898729d0d6f43ca5c20ae0eb9ff81eec67fe98565cac4384efb986688b80aca2cdb22e8df2e2b53501f82da2f0b4f2b2b330533af9b7b0cf9d5ed2e828512adc6f0363bfcf83e5f813995c59c55d5cbddfe3bab3c45260427b51b91fd290e76f46f1af252635eebd64b22c9e878c963a2306f9e2fb29802a687f83040cfc014b92f1f7825c690adeb8cf4191a34ebfa896e1bd231660a5ef1d65df12114914d51d31b606819f9f1322838b1c3a75d95d3aa875bab354944a8da69c5eed9866ba9fcd988673bc713c75c40d8ea817b75dd3b8f5826dfcecc7383b4b9d1fc82875f76b77b768c067c36922fd16b6b3790e4b54f698c679f57e413e2e7002b7376a7371db1096575d3a8223c40ec2b835c130b7b79f5645f7fa222506784302854a0c8857d5055e65a680940fe9f67de1e135f3e042de5c2aa0241d5f7edd6bb6e463cbea3483080dae8b8f43d14ee372c9a0002d4b55388c2221e65f824e230e5c4d15c635ce57b9ee4b5850a054d5b3ccfe9a7954e4c68d91d49e4d57e6a8f7367c530373623c505fa2b3aa53f0e487153878e09213b2f28bc56397ca30e5ffee94c2809f7a166d1b85b56231e401aefc2eeb21ccdcfca1b61750a501ef44cb8a17b1df539483371b5e8fb3d53ee64dc70fa45e976ab4a9c6fae18e41e35aca4e1a4bcb73c52b75ff2df9f603f888be5674413c1d78e8142db592b6fffcb09c038b031f30393a2045fbdfd281cb6669d96227ed534912c36dc488976950bb7a96804a530ff2c1a88704f8c5ec95ea85b2c9b1c2f39b768343034e3332b0caf15270a2f46ff877a799f3c6a467312ad4b7f835b8220c4f42a82a59d40c77f402bd3b5e63b69684229c2c0cc1a58d66f492de92a9651ed82f111c1c3f8952e0558b501b023456459dae8c6657a2cae461547e05123dac33f3de166d350fc1ceeecbafae8fada8d25719d90b01545314e601f9919f8ea22bc1cfed7442170bacd66a28c99e7e5c783fccdaf014dd31aa56310e943e6597e4e7d75ea1537bbafbb7ec52c0f3c9435b878a4574feed609d1eb8792d12f0d17992b0639c51b1b6baefd9ce82f46844cda87bfeb63b64e2d9cebbb797fd725755a8d521cb60177c0b0b95e8e7c9307ec5fa906e771181e8ebc71363d90f5778ce2903f0d1ca2978b463d095cb3d753c8170b61f477646c9464d0c996167166887c8580b290e0866aa793af7dc1b5f69009ddd4358d33f5d0f061be286fb16d91d8e3c584cb2df1241f11b888ccd560adaac61130d000b271061b959a5755c6b62a6693dd9569806a3e9ad7f13f04206d05127f087a7a58d6dc3d44734d560f245ba65445110ef14695ce2bedfaf2b138aa22c54b27e77cf45b3257e8df11915f09dea9ae72bb4eaaafcd4edb50fa0db5674d2e2ac357c77f184fc59b52d55d64aea72d8c353dd9047439188f9b0a3344bc9540b1d9e94cb0215a8ba1aafbe8dfa20c2bdf373016d7986570d6508713eefe2a0c15aeffe501d2548ecc5ddb649fe3f36dfad8c369031653aecedbe5308eb6a85070621faff37fd13172345847aec261c0287fa12f95853223590bc66d07e2e03500d736cb5c3286baac6e25be5cec1cdacabee840669f6e0eb6a6fad7b20a61f3db2ccc9cfa4f8549ed3a0490291766efb2ec48f6e715d31882048e769e4114d7168e9eb2a7a3f3301d9d09fe6a7fd1619a61a52d507973f554db662b40d0a927c067b9fcfba13eaa36d28e08a6566e63ac35e7f4165c16ddf7579b4995f2ff6f2c2d97377393685b52d7fb4d4f2dc87856534a475fbd8ce758b9975ffc7f91310cae18a1cfb4e95bbfb1b467682accdb1f520d25110325cbddb251331e4a0fb5ede4e4835580ae0e92a1b3e4162bb1dad93ba81fa138a5727257fa202486cd035c0e7e44b677a433072f1f74c46b461e2a60217c062732dbfdc193e3abf5dc8974438b5158e02e629ce9b6cb9285df885b9f941d528645937537a442f950303547aa968162953e4df182e5589955aed6dadf75fe84519a6dc0b7774fcd58fe4217a573a4c4aee692150149b04102804f3f122315545901bd64fbb20bbf6dc377f4b001d3dd928b8bee051ebdaf394a5ad387510924b9db76bb6cd75682b6b2736ec4a2db757f057aa8bd29411d76a20e7370650504f7f838279e2fcc9424972291bd913b759fb481aabea88d456d8062b0ccd7d0211e19dd4706da9c3a41831d2d6c257310c14819fad43613d1037c547266b99bfe206fb1de13d68c2816acd787dc5a8e93134b40b6681e924241015470b98ed51cdc4af8c8fd4097639ea3788858e63921f5a48e599c7a845223e20a8952598212ea64d226d4e6f943cfd6f88b411e1af0b7e30fd4b006aee1daa31ec415946513d337004506cb10ea16e95f32982cd898f98af528a715bf94293469e289fae114512a1bfbcf7cf95160815b7ef20ebd830b867d519f26c37bfbeeacebd6b5d5059a6d605e864b50cc5e51b95381c8ca7a97df5eb0ae2576f4b04c59d042d91d1ae289adb481d81f9b45597b91257952f09e2ff85774418fc3e197191581d1f0dec50e935514e322ee3eaa93eefffddcb044672b8a07714a2c9eeba8f1f151ca52b821e41372e9496c9fec8816e9b2d5471ed2f5ef1cae7cf3c9ebcf89c9549db2cd8b978cefd3c20f9eef06f2b328a8eb416262f1a421a5daef142f758bb366cac0e5ff30de474dcfe0877dedef3becd3a24dd72d179444d7c588ef042d1b10fd9ba876c959adb7df6d0f56e834494b387ca0ebc9d82ae428c11cc90c8395f38d2f45acf89c2ca4711cb29ca78f3359ee0973b151c105d24a11e223766b4835a4d2b9c3eab59497356343f39941b96ade99ea91948c5eed81c5026b2fe235c96338b4ac2dbd83311bba10f2480278130957458ea2a9ec643208dc8c1638e53bd5e7b3293566080cd477982038a82bee2db44b933cf1474c1fe10d41772a4a9cc3c90ac04309ddc7579abaaf23b041d778c5e3df0f7406bdb82fa61900d3a955ab6df35a0a6a4e1ad366373b5406f5f8e8144288f9371cd23b53e6df237c228b848406a679c138043a9e14a6aa9b0531fe934a46be345fcdb346e728dd854591815bf0fc6ac837028f7b0e0cea0530a8bdd40f9ce76a47a3303f4441e3e13de53cdc7259d33f84d1d411100372101e231edd00687a3f49fc2eb2a729afd070bffd71eddd250604f28e8b0da58099b66882410399b882731ed8f966ec950582859315826f3d0990c985cf16026f1a3281b30c423924be105c0461f89533961de3549fde4e8cbeca55a3da5e0cd597111be9d7f7bfed2ea5e84a63c64de72327d3ec8379be6a94e669c8301d4cfa2cedfc73b5089a48329ffbfbd46a7520a933ef7af444e9bd219e38e011461ca9f425302b492ec2cf8251b88b38179845a331ffecb1ed15bd4dbbdc36a7ae6054b571948390c4239b7834a4aa678bb51b5c50ed3936062197f5fa486bea85d6b3bceb896cfe5ec5f08165a776095baea71a658557ee52571ea0ae00dfd2430979e4d1f5796c071dccb3b4c557acb5ec051279fd41ab72f29ae2280d743b18fb8d79778abbdfde89bb52c17acd2f9cb80bf0cac6f9392160fcbe87ceab81bbe88d2b8b7cbe01f9f3b001efcf0c3a4a6ef1a9e77fe15083f59f0dddb741dd9962e7eb51af85248d5ad75ee568fb711b1d35e73eb8ee86da3afb8329489d98faca9778d2356d8e63bf8c265a8d15862e64f35d4c4ffea81fd543ae175e087fda6d851cb11421aede6f23f9b659563bd2cac25c51c7fa8211b90c8d5d8b2dd18f5632f88fc06c2a7f0f70f06eb6e6cc50ce6cd5995985a11a2968522d81f15df3c35f8d18124169ad5ff57f583d87b9b6352dee3c9da42deba93838dd66062db84286bb5d6aaa4873d4f0bdf674c21e169d51614256cae406c5f9bae5de682465602ea8cff8ec0b25242db2965a0ac382cbdbebfb4ff9e66719879efa925c649c370fcaa8fd5fdc14bb599b09a5dcc965de172f0a987622e9f0e522c2da95feb50ddf7f31cbce753eb50ebd9758a2dd9ca57f47bb3b3b639ef5bde862f5c1c088bc273e84777f108530b3daf7e70ffee12949ade0e66bb8b745ab8c63f0982fb8886e015129776ab8f2bc15d5d8cfb7912e177b50d4ca296300f07410fadc8b5e39987ad504254454d8131056e787462faab3983afc1f9b725c05e5607d3d87c8a6e4c8c3ff3b1c6c4950d94bc37e40632bbd503224177a6de10ea3f536477cbed21cae87bca344c320a54293009f42a5ab0faf031f96d527907306b3cb3d8b43d07d00bd739d85120d93cf8768464be7e9c71f78abc1349dd1b2f2319a16e03f538252087a4798facb699c0529d3aa15dc600e472e3f4fa751fccbaaadb8554cc8074c6abf266258d47892de0549168c5ae1cd9199267f84d1cfed16648a64b31f46baf9de8e5bb1efc0c7c132ca3e539fedb58926741aa0de79895c4e60392d5814c700f20d6997eac30c09c99272f3e80df94e111b304775b91c860a68a6d87c9d92dda16806899796ef70c945e22f9002047cdfe7c64c5c67579c297d54eb1ac877f80dec5a982668263b1d928c9465a2e6cc86963ce65a012f86c20b5bd0548d1cfd8223614f18423fc9d40c68e558ee7afcc8e963d19b2159331604306a0b3bd7209c18c8fb4cc33d06b0bf76c3819e62a7bc4626bde9e61a25abbfd3097b55ea4f46cf6f846fa5b80e241a94c34b1d7c25e5befb74018b37fefdd164c064d07ef72693a05beeb2142f5d442c3e448a2c8cf22d0e2fed88bb689ac6c1428f72b1d56204c5947d4f94b4b48c1afe1319b186f67d16a86a8a1e2a0b4bedec583e36d01683d6db6c6bfb9cc18fd9625eab1ea2449cbfc81834d11c906f89300deeea5830793a13b4ba3074aada128491908fd76171e8d8aba4e161c778edea2212cd13e26fe97417fb1003f3118525f73f598bfaf623b84bd5f2743732f549393113ce5b5ac8510b724ffb1c8925bd3f063694404c1d4fe71ed81a2c171d6beeaeff3d84ea818dba47373a63531917dedaa22f22234c32d4d249970d393baa75b4bacd23785149bab329dce257d6449390f1d7ece976cd747f44df5fabfc1a989130390bf27dc1aa7211f5ccbcfc88545b7658c5ccbfc2eacc6f325ded9f5745bdb5b03d4d05a818fff2ea21eb2ceaa042be72f9d1683511fbc775debc83247abe01ac313df3134b840c77a37adc348d1d1117b0a274511bb2d0443e9f23869e97945cc55dbeeca09df4faabb5280511f34c9b87929f25b78fec6077598fe4540aac606cf4d6a664991b24ea83835b1a244c2de8038e536bfa662a7c6f10435d8b8e7c3f52aa9e87a5c80cc0e7bfe591c47dd0e022403533b48773517bb42992033b656c98c4035c7125c2769d6708a5029261ca3d3ace5be45617e4333aeffcc4c0b1ad947816de54d796027a69b367313552b9b7756d820a9cda3e9a90db73ef134b3592a594f3851f168ed525abaae735d60e702f23a2ff26c378b203988be964ec768cca2f2373e98a3f7bc8a88b7f67e69b67173bbe38f37a47ba8f86b53d2e931c7dc137a8e3c344bd6a4bc456907a727f3761ebaaf5e7efe0eb658a9ba8104e507c59222467b0ce8cab6e0eaab078fd1948911fba09054f8d66817969a1f19e8806823f404b4559d07e71c49ab1db36029e95b066926a2dfd1013dd6981cda3b66d946a155204a40f33f19cf9433e830b5e01c297f9c111f9a2020bf1c7dd73bb8026361ee05cfee5c0cbb760f57213247e9c2d4618350da84005d42e19bbf5fdc9696652168d31da13c35468dcaccca575e3e95f314fe7f566633ca8f019807dabd2a5feb06527a3c8b9b1d4a43b01cf2c9dae6aa6624183015fdc96d56263f09de57356b5bfdb4a3ef4f72eebd9ea5a6604ea52fdcefb5da6aa93fda6cb57032e2b95bcdcccd558dd4a8470ab7dd891f247ec437b34d34c10f931476d509f6276779cb192ffaf1dfbb40c34244ef3a70d5b8f0da84f6d768492715e8d76896e90730ff21f77c4b770d1e7a1b615ef3e2a5122df0c82b36e0ed6f711c96342177ab7e0f4276c88d83c4f746a378a789dbf0b4a5e93f8b0822db34dc8e91a27f39e3826cf041877c33d397010e4b0aa0248f2bdc7b886203f2c54561db54b2060405bbb6e6229e05969a48128b48d33f75bf4e668772729ec5c85bc76e4283c87ede2c618fc2041ff935d642f7dd944d20ead01beab4956ac009ee8f5f4fee289cebcf9eff302e13bed4e14907f8a632ec410e95c6eae1d6c571517a000ecab18a3ef990781f2a46ae5be93cffdba31a04b4263131f4212d99b9bfa5f72fa58b9c7813865f8ece6dd718c17edf76867dd01786ae70830d2840ed88eb81756fafac44d7500c525d01be239695b7063b5ee76372a5f8d9afcbaf7abfe197ab8241daf3eb8c5bc040e35dfa77eec7ba004389d330c75654fcab250049e4e9554732ff7af97e32f624554f8905957727dc45b8d13b065cf31f30e945364dc4268b6861b3bcca2b22087e9912984da300a8bde67c41a950f9643d64fb1017f0f9b4a99a9024d83b60fae103e6ee05cef01d1d1bed7cdd1b2cb540732fc26d604e2ccacf2e7b64a814811dfb6694f8013d87620ebcd109095222dfdaa86ca33ec2e9ba58ecb535250eda045473ca800b8cb246608bffbf7ea6aee1551c0d5434b0f8bde4208fcf22c0a6bd494e3261cde14b484fcff08e0c4f06588fd29b36733375281</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2024/02/03/%E9%98%9F%E5%88%97/"/>
      <url>/2024/02/03/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="http://t.csdnimg.cn/DY7gy">http://t.csdnimg.cn/DY7gy</a></p><p><strong>环形缓冲区</strong>是<a href="https://so.csdn.net/so/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F&spm=1001.2101.3001.7020">嵌入式</a>系统中十分重要的一种数据结构，比如在<strong>串口</strong>处理中，串口中断接收数据直接往环形缓冲区丢数据，而应用可以从环形缓冲区取数据进行处理，这样数据在读取和写入的时候都可以在这个缓冲区里循环进行，程序员可以根据自己需要的数据大小来决定自己使用的缓冲区大小，<strong>不用担心数组越界</strong>。</p><p><img src="/2024/02/03/%E9%98%9F%E5%88%97/image-20240203112201743.png" alt="image-20240203112201743"></p><p><strong>队列</strong>的基本概念：队列 (Queue)：是一种先进先出(First In First Out ,简称 FIFO)的线性表，只允许在一端插入（入队），在另一端进行删除（出队）。</p><p>队列头就是指向已经存储的数据，并且这个数据是待处理的。下一个CPU处理的数据就是1；而队列尾则指向可以进行写数据的地址。</p><h2 id="队列是什么"><a href="#队列是什么" class="headerlink" title="队列是什么"></a><strong>队列是什么</strong></h2><p>队列是一种很常见的数据结构，满足先进先出的方式，如果我们设定队列的最大长度，那就意味着进队列和出队列的元素的数量实则满足一种动态平衡。</p><p>如果我们把首次添加入队列的元素作为一个一维坐标的原点，那么随着队列中元素的添加，坐标原点到队尾元素的长度会无穷无尽的增大，随这之前添入的元素不断出列，对头对应的下标点也在不断增大。这样，进队列和出队列的元素的数量就对应到对头和队尾下标点的移动</p><p>因此我们评判一个队列长度是否溢出原先约定的最大长度，实则就是在评判队尾坐标点与队头坐标点之间的差值，无论是出队列还是入队列，队头和队尾的坐标都在不断增大</p><p><img src="/2024/02/03/%E9%98%9F%E5%88%97/84497721b6c4413c8558e4266b886ddc.png" alt="img"></p><h2 id="front指针和rear指针的引入"><a href="#front指针和rear指针的引入" class="headerlink" title="front指针和rear指针的引入"></a><strong>front指针和rear指针的引入</strong></h2><p>虽然队尾和队头的下标在不断增大，但是我们对于队列的研究只需要局限在队头与队尾之间的元素，坐标原点到队头之间的元素已经算作出列元素，并不需要研究。因此我们不妨将队列在逻辑上放入一个事先设定容量的一维数组中，只要这个数组的容量是队列中元素的个数+1就行，为什么要这么设定待会再讲。我们想要达到的目的是，无论出列还是入列，本质上是通过修改数组中元素的值，那些已经出列的元素所在的下标位需要放置新入列的元素，并在逻辑上保证新入列元素位于队尾就行。</p><p>因此，我们不得不得引入头指针front和尾指针rear，对指针指向的数组下标对应空间进行操作，来修改数组中元素的值。</p><h2 id="front指针和rear指针的理解"><a href="#front指针和rear指针的理解" class="headerlink" title="front指针和rear指针的理解"></a><strong>front指针和rear指针的理解</strong></h2><p>front：初始值为0，对应索引位待出列，若当前指向的数组下标的元素要出列，则先执行出列动作(实际上不用操作，出列的索引位可以被新入队的元素覆盖)，随后front指针就要向后一位，即front++</p><p>rear：初始值为0，对应索引位待入列，若当前指向的数组下标有元素要入列，则先执行入列动作（索引位元素赋值），随后front指针就要向后一位，即rear++</p><h2 id="队列最大长度匹配数组容量导致一种错误的解决方案"><a href="#队列最大长度匹配数组容量导致一种错误的解决方案" class="headerlink" title="队列最大长度匹配数组容量导致一种错误的解决方案"></a>队列最大长度匹配数组容量导致一种错误的解决方案</h2><p>这就会有一个问题，随着队列中元素的不断更迭，front和rear很快就会超过数组容量，造成数组索引越界</p><p><img src="/2024/02/03/%E9%98%9F%E5%88%97/dd50472cf4ba4aad8fe5e565ccfe39de.png" alt="img"></p><p>比如上图所示，front&#x3D;2，也就是说已经有两个元素出列了，因此rear&#x3D;5与rear&#x3D;6对应的两个元素理应可以入列，但是我们发现数组maxsize&#x3D;5，不存在索引位5和6，强行对这两个下标赋值会造成索引越界异常indexOutException 。但是我们发现此时数组中索引位0和1都空着，完全可以将这两个位置利用起来，因此我们可以想办法让实际的rear值转化为等效的rear值，也就是是让rear&#x3D;5转化为rear&#x3D;0，同理rear6转化为rear&#x3D;1。怎么做到呢？无疑是通过取余！</p><p>每次新元素入队后， 执行rear&#x3D;(rear)%maxSize操作，随后执行rear++操作右移rear指针</p><p>像上图中的rear&#x3D;rear%5乍一看好像没问题，但实际上这种取余方式是有问题的，出现这种取余方式的根源在于我们想让队列最大长度与数组容量保持一致，下文会详细说明这种解决方案的错误之处。</p><h2 id="指针的往复移动：逻辑上的环形"><a href="#指针的往复移动：逻辑上的环形" class="headerlink" title="指针的往复移动：逻辑上的环形"></a>指针的往复移动：逻辑上的环形</h2><p>出队和入队的方向是从右向左，而front与rear指针的移动方向却是从左到右循环往复（指向数组末尾后按照取余算法又重置为数组开头），因此我们可以把单向数组在逻辑上理解成环形数组，指针的循环往复移动理解成按照顺时针或逆时针（只要规定某一方向就好）单向移动</p><p>  环形队列小知识：</p><p>  环形队列是在实际编程极为有用的数据结构,它有如下特点。</p><p>  它是一个首尾相连的FIFO的数据结构，采用数组的线性空间,数据组织简单。能很快知道队列是否满为空。能以很快速度的来存取数据。</p><p>   因为有简单高效的原因，甚至在硬件都实现了环形队列。 </p><p>   环形队列广泛用于网络数据收发，和不同程序间数据交换（比如内核与应用程序大量交换数据,从硬件接收大量数据）均使用了环形队列。</p><h2 id="队列为空的判别"><a href="#队列为空的判别" class="headerlink" title="队列为空的判别"></a>队列为空的判别</h2><p>我们怎么判断队列为空呢？</p><p>如果我们按照指针从左到右的方向移动，当front指针和rear指针重合时，front指针对应的索引位之前的索引位都已经出列完毕，而rear指针对应的索引位以及之后的所有索引位还未有元素入列。</p><p>所以队列是否为空的判别：front&#x3D;&#x3D;rear</p><p><img src="/2024/02/03/%E9%98%9F%E5%88%97/a053efb0385e4714b8889ecd98ba2d31.png" alt="img"></p><h2 id="rear-rear-maxSize解决方案的问题"><a href="#rear-rear-maxSize解决方案的问题" class="headerlink" title="rear&#x3D;rear%maxSize解决方案的问题"></a>rear&#x3D;rear%maxSize解决方案的问题</h2><p> 入队图示<br>下图展示了maxSize&#x3D;5的数组中，front&#x3D;0保持不变，元素依次入列直到满载，rear指针的移动情况：</p><p><img src="/2024/02/03/%E9%98%9F%E5%88%97/42a1d7c1976b4e7db62cd01c7b7c2fdc.png" alt="img"></p><p> front&#x3D;rear&#x3D;0的歧义<br> 可以看到，如果我们认为队列容量与数组容量应该持平，那么当第五个元素50入列后，本来rear&#x3D;4执行了rear++的操作后，rear&#x3D;5，随后rear将会通过取余算法rear&#x3D;rear%maxSize重置为0，这是我们解决方案的核心！</p><p>但关键点就在这里，我们发现空载时front&#x3D;rear&#x3D;0，满载时依然有front&#x3D;rear&#x3D;0！这样子我们就无法判断front&#x3D;rear时，队列是空还是满，因此rear&#x3D;rear%maxSize这种解决方案是不被允许的</p><h2 id="新的解决方案：置空位的引入"><a href="#新的解决方案：置空位的引入" class="headerlink" title="新的解决方案：置空位的引入"></a>新的解决方案：置空位的引入</h2><p>新的解决方案<br>       每次新元素入队后， 执行rear&#x3D;(rear+1)%maxSize操作，该操作包含rear++操作</p><p>置空位的引入<br>       并且我们人为规定，数组中必须留有一个索引位不得放置元素，必须置空！！！如何实现我们的人为规定呢？那就要先探索当数组满载后front和rear指针之间有啥关系</p><p> 入队图示<br>下图展示了maxSize&#x3D;5的数组中，front&#x3D;0保持不变，元素依次入列直到满载，rear指针的移动情况：</p><p><img src="/2024/02/03/%E9%98%9F%E5%88%97/fc276df1cfb14836b200b9ab1791347a.png" alt="img"></p><pre><code>   人为的让最后一位置空，所以当元素40入列后，数组已经满载   满载后数据之间的关系：</code></pre><p>front&#x3D;0<br>rear&#x3D;(rear+1)%maxSize&#x3D;(3+1)%5&#x3D;4  (注： 执行完arr[rear]&#x3D;40，再执行  rear&#x3D;(rear+1)%maxSize)<br>(rear+1)%maxSize&#x3D;(4+1)%5&#x3D;0&#x3D;front<br>       当我们认为的满载发生后，最后一位置空，发现此时rear和front之间的关系为(rear+1)%maxSize&#x3D;(4+1)%5&#x3D;0&#x3D;front，因此这个关系可以作为满载的条件</p><pre><code>   因为处于满载状态，我们无法再往队列添加元素，只能从队列取出元素，也就是进行出列的操作，而一旦我们执行了出列的操作，比如将索引位i=0上的元素10出列后，则front右移，即执行front=(front+1)%maxSize操作，最终front=1。   若随后又添加元素入列，即在索引位i=4上添加元素50，随后又会执行rear=(rear+1)%maxSize操作，最终rear=0。   rear=0≠front=1，此时就不会出现之前那种错误方案中 rear=front=0导致歧义的情况，而一旦 rear=front=0，必然表示队列为空，因此这种解决方案是行得通的</code></pre><h2 id="队列为满的判别"><a href="#队列为满的判别" class="headerlink" title="队列为满的判别"></a>队列为满的判别</h2><p>​      当我们认为的满载发生后，最后一位置空，发现此时rear和front之间的关系为(rear+1)%maxSize&#x3D;(4+1)%5&#x3D;0&#x3D;front，因此这个关系可以作为满载的条件</p><h2 id="队列中元素的个数"><a href="#队列中元素的个数" class="headerlink" title="队列中元素的个数"></a>队列中元素的个数</h2><p>​      numValid&#x3D;(rear+maxSize-front)%maxSize，大家可以带入数据验证一下</p><pre><code> 实际上：   当rear在front之后(这里指的是数组中索引位的前后，并非逻辑上的前后)，有效数据个数=rear-front=(rear+maxSize-front)%maxSize   当rear在front之前(这里指的是数组中索引位的前后，并非逻辑上的前后)，有效数据个数=(rear+maxSize-front)%maxSize</code></pre><h2 id="值得注意的一些细节"><a href="#值得注意的一些细节" class="headerlink" title="值得注意的一些细节"></a>值得注意的一些细节</h2><p>细节1<br>      置空位虽然是人为引入的，但这不意味这置空位的位置是随意的，实际上，只有队列满后才会将剩下的位置作为置空位，一旦置空位出现，rear和front永远不可能指向同一个索引位，因为你会惊奇的发现置空位恰号将rear和front隔开了.</p><pre><code> 置空位就像一把锁，一旦上锁就只能通过出队列操作解锁</code></pre><p>继续执行获取元素操作出队列（解锁）：</p><p><img src="/2024/02/03/%E9%98%9F%E5%88%97/bda71bd117674644bbe8c8c44c782aa3.png" alt="img"></p><p>上图中60入列后满载，可以看到置空位再次出现，但30➡40➡50➡60➡置空位 形成了逻辑上的闭环</p><p>细节2<br>从闭环的角度理解，front永远不可能在循环中超过rear，最多只能和rear相遇。</p><p>因为置空位的出现，rear不可能拉front一圈，也就避免了rear在超过front的情况下主动与front相遇</p><p>下图中的maxSize-1对应的就是置空位，rear是无法越过置空位的。只有front主动顺时针追赶上rear，它俩才会相遇，而此时队列内就没有元素，为空</p><p><img src="/2024/02/03/%E9%98%9F%E5%88%97/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Mjk2NDE3,size_16,color_FFFFFF,t_70.png" alt="img"></p><p> 细节3<br>队列的最大长度queueMaxsize&#x3D;数组容量arrayMaxSize-1  （由于置空位要占一位）</p><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RINGBUFF_LEN 256;</span></span><br><span class="line"><span class="comment">//定义一个缓冲区结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 Head;           </span><br><span class="line">    u16 Tail;</span><br><span class="line">    u8 Ring_Buff[RINGBUFF_LEN];</span><br><span class="line">&#125;RingBuff_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*若想更灵活，可以用动态内存分配方式（如使用指针）来实现可变长度的缓冲区</span></span><br><span class="line"><span class="comment">typedef struct</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">u16 Head;</span></span><br><span class="line"><span class="comment">u16 Tail;</span></span><br><span class="line"><span class="comment">u8* Ring_Buff;</span></span><br><span class="line"><span class="comment">&#125;RingBuff_t;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 初始化函数，传入所需长度</span></span><br><span class="line"><span class="comment">void RingBuff_Init(RingBuff_t rbuff, size_t len)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Head = 0;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Tail = 0;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Ring_Buff = (u8)malloc(len * sizeof(u8));</span></span><br><span class="line"><span class="comment">    if (!rbuff-&gt;Ring_Buff) &#123;</span></span><br><span class="line"><span class="comment">    // 处理内存分配失败的情况...</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">在C语言中，u8* Ring_Buff; 是一个指向无符号8位整型（通常代表字节）的指针。它本身并不是一个数组，但可以用来指向一块内存区域，这块内存可以被当作数组来处理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当你通过 malloc 函数为 Ring_Buff 分配了足够长度的内存后，你就可以像操作数组那样对这块内存进行读写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个ringBuff的缓冲区</span></span><br><span class="line">RingBuff_t ringBuff;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化环形缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RingBuff_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//初始化相关信息</span></span><br><span class="line">   ringBuff.Head = <span class="number">0</span>;</span><br><span class="line">   ringBuff.Tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">u8 <span class="title function_">Write_RingBuff</span><span class="params">(u8 data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ringBuff.Head=(ringBuff.Tail+<span class="number">1</span>)%maxSize) <span class="comment">//缓冲区满</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> FLASE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ringBuff.Ring_Buff[ringBuff.Tail]=data;<span class="comment">//在Tail对应索引位写入数据</span></span><br><span class="line">    ringBuff.Tail=(ringBuff.Tail+<span class="number">1</span>)%RINGBUFF_LEN; <span class="comment">//ringBuff.Tail++; 防止越界非法访问</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读数据</span></span><br><span class="line"><span class="number">10u</span>8 Read_RingBuff(u8 *rData)</span><br><span class="line"><span class="number">11</span>&#123;</span><br><span class="line"><span class="number">12</span>   <span class="keyword">if</span>(ringBuff.Head==ringBuff.Tail)<span class="comment">//判断非空</span></span><br><span class="line"><span class="number">13</span>    &#123;</span><br><span class="line"><span class="number">14</span>       <span class="keyword">return</span> FLASE;</span><br><span class="line"><span class="number">15</span>    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">16</span>   *rData = ringBuff.Ring_Buff[ringBuff.Head];<span class="comment">//先进先出FIFO，从缓冲区头出</span></span><br><span class="line"></span><br><span class="line"><span class="number">18</span>   ringBuff.Head = (ringBuff.Head+<span class="number">1</span>)%RINGBUFF_LEN;<span class="comment">// ringBuff.Head++;防止越界非法访问</span></span><br><span class="line">    </span><br><span class="line"><span class="number">20</span>   <span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环形缓冲区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keil5</title>
      <link href="/2024/02/01/Keil5/"/>
      <url>/2024/02/01/Keil5/</url>
      
        <content type="html"><![CDATA[<h1 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h1><p><strong>转载自</strong>：<a href="https://blog.csdn.net/u012749085/article/details/126830777">https://blog.csdn.net/u012749085/article/details/126830777</a></p><p>实例调试：</p><p><a href="https://www.bilibili.com/video/BV1Jw411i7Fz?p=25&vd_source=a9d487fcf1a579639c6348eb5a9321db">https://www.bilibili.com/video/BV1Jw411i7Fz?p=25&amp;vd_source=a9d487fcf1a579639c6348eb5a9321db</a></p><p>9:25~11:05</p><h2 id="基本调试操作"><a href="#基本调试操作" class="headerlink" title="基本调试操作"></a>基本调试操作</h2><p>    首先点击”Debug-&gt;Start&#x2F;Stop Debug Session”或下图2位置，进入调试。<br><img src="/2024/02/01/Keil5/9261723051f340f5aeed4eb814510373.png" alt="9261723051f340f5aeed4eb814510373"><br>    如果前面工程配置里选择了复位调试，则进入调试后，会停在main函数头部<br><img src="/2024/02/01/Keil5/edca277b4e14435289c0f4b8d61f8129.png" alt="edca277b4e14435289c0f4b8d61f8129"></p><h3 id="复位（Reset）"><a href="#复位（Reset）" class="headerlink" title="复位（Reset）"></a>复位（Reset）</h3><p>对程序进行复位操作，根据烧录器不同的复位方式配置会触发不同的复位类型。<br><img src="/2024/02/01/Keil5/431db5f05a5a4f8a9241b3297ba354f7.png" alt="431db5f05a5a4f8a9241b3297ba354f7"></p><h3 id="全速运行（Run）"><a href="#全速运行（Run）" class="headerlink" title="全速运行（Run）"></a>全速运行（Run）</h3><p>：使当前程序开始正常全速运行，直到程序遇到断点时停止。<br><img src="/2024/02/01/Keil5/126e06525a784dd38a9254a7cc7439f0.png" alt="126e06525a784dd38a9254a7cc7439f0"></p><h3 id="停止运行（Stop"><a href="#停止运行（Stop" class="headerlink" title="停止运行（Stop)"></a>停止运行（Stop)</h3><p>当程序全速运行时，点击此按键可停止程序运行，停的是当前点击时的程序运行位置。<br><img src="/2024/02/01/Keil5/01978f3c724c4fe1ae60e9760eb4a47d.png" alt="01978f3c724c4fe1ae60e9760eb4a47d"></p><h3 id="单步调试（Step）"><a href="#单步调试（Step）" class="headerlink" title="单步调试（Step）"></a>单步调试（Step）</h3><p>根据当前调试的窗口的语言，执行单条语句。如果遇到函数，则会进入函数内部。如果是在反汇编窗口中，则只执行一条汇编指令。<br><img src="/2024/02/01/Keil5/4b6afae81ba943c08d0132be4bcf0dc5.png" alt="4b6afae81ba943c08d0132be4bcf0dc5"></p><h3 id="单步跳过调试（Step-Over）"><a href="#单步跳过调试（Step-Over）" class="headerlink" title="单步跳过调试（Step Over）"></a>单步跳过调试（Step Over）</h3><p>如果是在C语言窗口中，则是按单条语句执行，与单步调试不同的是，遇到函数不会进入函数内部，而是直接全速运行函数，并跳到下一条语句。<br><img src="/2024/02/01/Keil5/1733c1bed7fa4337a2518bdb4b7224a6.png" alt="1733c1bed7fa4337a2518bdb4b7224a6"></p><h3 id="单步返回调试（Step-Out）"><a href="#单步返回调试（Step-Out）" class="headerlink" title="单步返回调试（Step Out）"></a>单步返回调试（Step Out）</h3><p>如果是在C语言窗口中，则是直接全速运行当前函数后面所有内容，直到函数返回上一级。<br><img src="/2024/02/01/Keil5/0bb2a0a028a944878718e1acb6015ad8.png" alt="0bb2a0a028a944878718e1acb6015ad8"></p><h3 id="插入-移除断点"><a href="#插入-移除断点" class="headerlink" title="插入&#x2F;移除断点"></a>插入&#x2F;移除断点</h3><p>如果当前光标所在行未有断点，则插入断点（前提是当前行可以插入，如果无法插入会显示一个感叹号），在有断点的情况下则是移除断点。插入断点后，当前行前面会有个红圆表示断点位置。也可以通过直接点击红圆位置进行插入&#x2F;移除断点的操作。另一种断点方式，是通过指令来控制，当然也可以使用Keil提供的界面化操作，设置某个变量读或写时触发断点。不过目前貌似有部分芯片不支持这种操作。注：断点最多只能打7个。<br><img src="/2024/02/01/Keil5/5e09882eba154da695506d661cc6008a.png" alt="5e09882eba154da695506d661cc6008a"></p><p>    使能&#x2F;禁止断点：开启或禁止当前光标所在行的断点。禁止后红圆变成白圆。<br><img src="/2024/02/01/Keil5/c2a18ac2d197488c89d53693f22fb0be.png" alt="c2a18ac2d197488c89d53693f22fb0be"></p><p>    禁止所有断点：禁止当前所有的断点。<br><img src="/2024/02/01/Keil5/b42659b410604a88ab3c433d924b5aa6.png" alt="b42659b410604a88ab3c433d924b5aa6"></p><p>    删除所有断点：删除所有断点。<br><img src="/2024/02/01/Keil5/3c3c10be6e59420eb579ec7eb2a98972.png" alt="3c3c10be6e59420eb579ec7eb2a98972"></p><h2 id="调试窗口"><a href="#调试窗口" class="headerlink" title="调试窗口"></a>调试窗口</h2><h3 id="变量查看窗口"><a href="#变量查看窗口" class="headerlink" title="变量查看窗口"></a>变量查看窗口</h3><p>——Watch1，Watch2</p><p>    通过”View-&gt;Watch Windows-&gt;Watch1、Watch2”可以选择打开Watch窗口，也可以在工具栏<img src="/2024/02/01/Keil5/90b073560ba849b7ba3c658ad2c4f5cd-1.png" alt="90b073560ba849b7ba3c658ad2c4f5cd-1">这里打开。再点击一次则可以关闭。</p><p><img src="/2024/02/01/Keil5/76e14a916c584a70b49dc8a0136d4c23.gif" alt="76e14a916c584a70b49dc8a0136d4c23"></p><p>    通过选中一个变量，右键添加入对应的Watch窗口，可以追踪查看当前变量的变化状态。注意，只有全局变量可以全程监视，临时变量只有在进入当前函数中才可监视到其数据，用static关键词修饰的变量无法监视。<br><img src="/2024/02/01/Keil5/dbe562eff930488cb804bc827cdb04cf.gif" alt="dbe562eff930488cb804bc827cdb04cf"></p><p>    如果当前变量没有实时更新，则需要点击”View-&gt;Periodic Window Update”将其勾选上。<br><img src="/2024/02/01/Keil5/1265f5d49d684580ba808bbeb3ef554b.png" alt="1265f5d49d684580ba808bbeb3ef554b"><br>    在”Watch”窗口中，可以查看当前变量名称、值、数据类型，如果当前变量类型为结构体，则可以以对应的结构形式进行展开查看。<br><img src="/2024/02/01/Keil5/324b2248d8d84028a4c363d0f95ac1b7.png" alt="324b2248d8d84028a4c363d0f95ac1b7"></p><h3 id="内存查看窗口"><a href="#内存查看窗口" class="headerlink" title="内存查看窗口"></a>内存查看窗口</h3><p>——Memory</p><p>    通过”View-&gt;Memory Windows-&gt;Memory1&#x2F;2&#x2F;3&#x2F;4”打开Memory窗口，也可以通过工具栏Memory窗口<br>这个图标打开。打开的状态下再按一次则可关闭。</p><p><img src="/2024/02/01/Keil5/3ef3ddae558949199d25fbecaf1f27ac-1.png" alt="3ef3ddae558949199d25fbecaf1f27ac-1"><br>    在Memory窗口中输入想要查看内存的起始地址，另外右上角的锁可以把当前界面锁定下来。<br><img src="/2024/02/01/Keil5/e0e6df70592546a590f315a11de0e0f3.gif" alt="e0e6df70592546a590f315a11de0e0f3"><br>    另外如果查看的是Ram的地址，那其中的数据也可以直接通过此窗口进行修改。<br><img src="/2024/02/01/Keil5/1f94d24204584c39890962c5cdbedbf9.gif" alt="1f94d24204584c39890962c5cdbedbf9"></p><h3 id="系统视窗"><a href="#系统视窗" class="headerlink" title="系统视窗"></a>系统视窗</h3><p>——System Viewer Windows（这个根据不同芯片会有不同的展示）</p><p>    可以在”Peripherals”选项栏中选择”System Viewer”系统视窗中对应的外设，选择”Core Peripherals”则是内核调试窗口。另外系统视窗也可以通过工具栏中<img src="/2024/02/01/Keil5/1063891a98944597b35ab22eb677fe99.png" alt="1063891a98944597b35ab22eb677fe99">这个位置可以打开。<br>    这个窗口用于查看当前单片机外设及内核寄存器的值，在调试外设底层时经常会使用到。<br>    在这个窗口中可以直接修改外设寄存器的值，当然部分只读寄存器是无法修改的，有些则是需要在特定条件下才可以设置生效，具体就得看对应的芯片手册里寄存器的说明了。<br><img src="/2024/02/01/Keil5/4a171f6094dc4835a67b6bdb97da575e.gif" alt="4a171f6094dc4835a67b6bdb97da575e"></p><h3 id="调度关系窗口"><a href="#调度关系窗口" class="headerlink" title="调度关系窗口"></a>调度关系窗口</h3><p>——Call Stack Window</p><p>    可以在”View-&gt;Call Stack Window”打开此窗口，也可以在工具栏在这里插入图片描述这个位置打开 。<br>在这里插入图片描述<br>    这个窗口用于查看当前程序调度关系，当出现有进入硬件错误异常调试时可以快速定位到是哪里触发的异常。这个窗口是的调度关系是从当前程序堆栈里获取的数据并将其图形化，所以如果当前堆栈数据被破坏，则此窗口也将无法查看调度关系。<br>    该窗口里显示的调度关系是从下至上调用的，最上面的表示当前程序所处的函数。展开对应的函数，可以查看各层调用函数跳转之前保存的一些临时变量等信息。<br>在这里插入图片描述</p><h3 id="寄存器窗口"><a href="#寄存器窗口" class="headerlink" title="寄存器窗口"></a>寄存器窗口</h3><p>——Register Window</p><p>    该窗口可在”View-&gt;Registers Window”处打开，也可以在工具栏<img src="/2024/02/01/Keil5/abf2e937414b4dd581fc726c4b0c6813.png" alt="abf2e937414b4dd581fc726c4b0c6813">这个位置打开。</p><p><img src="/2024/02/01/Keil5/7e3a1bd9811247438e1bfcaf96d6fa2a.gif" alt="7e3a1bd9811247438e1bfcaf96d6fa2a">    这个窗口用于查看当前内核的相关寄存器，如汇编里常说的15个通用寄存器。当然调试中比较常用的是其中的SP、LR、PC三个寄存器。SP为当前栈的地址位置，PC为当前程序地址，LR为函数跳转前的地址，即当前函数返回的地址。<br><img src="/2024/02/01/Keil5/fb99ad40b4dd410abd262ceef2d86ea7.png" alt="fb99ad40b4dd410abd262ceef2d86ea7"><br>    另外”Banked”中的MSP为当前程序系统主栈，PSP则为操作系统的任务栈，这两者的区别是，如果使用了操作系统，则当前任务中的所有调度关系使用的是任务栈，而类似中断这种内核的操作使用的是主栈；如果未使用操作系统，则只会使用主栈，不会使用任务栈。<br><img src="/2024/02/01/Keil5/8f85703656554426acdf336f03d5fede.png" alt="8f85703656554426acdf336f03d5fede"><br>    通过”Internal”可以查看当前是处在中断还是任务中，Mode为”Thread”表示是在线程&#x2F;任务中，或者是函数中（非中断)，为”Handle”表示是在中断中；Privilege为”Privelege”表示当前处于特权模式。Stack为”PSP”表示当前使用的是任务栈，为”MSP”则表示使用的是主栈。<br><img src="/2024/02/01/Keil5/a0acc7b34aff41b4a887cd35ccf95afc.png" alt="a0acc7b34aff41b4a887cd35ccf95afc"></p><h3 id="反汇编调试窗口"><a href="#反汇编调试窗口" class="headerlink" title="反汇编调试窗口"></a>反汇编调试窗口</h3><p>——Disassembly Window</p><p>    该窗口在”View-&gt;Disassembly Window”中可以打开，也可以在工具栏中<img src="/2024/02/01/Keil5/afb0592b40264def8902fe7b7afd619a.png" alt="afb0592b40264def8902fe7b7afd619a">这个位置打开。<br><img src="/2024/02/01/Keil5/4590aac5e1c5439d9bae08e55b115af2.gif" alt="4590aac5e1c5439d9bae08e55b115af2"><br>    该窗口是通过bin文件反汇编出来的汇编文件（汇编跟二进制原本就是一一对应的关系）。当设置了优化等级后，部分C语言的调试会变得困难（汇编跟C语言不是一一对应，而程序运行又是完全根据汇编来走的)，此时可能需要使用汇编窗口进行调试。</p><h3 id="命令窗口"><a href="#命令窗口" class="headerlink" title="命令窗口"></a>命令窗口</h3><p>——Command Window</p><p>    该窗口在”View-&gt;Command Window”中可以打开，也可能在工具栏<img src="/2024/02/01/Keil5/9d7f28936ba24fb697579edf39d7ff4f.png" alt="9d7f28936ba24fb697579edf39d7ff4f">这个位置打开。<br><img src="/2024/02/01/Keil5/0d449233d79a467ba66edb0bd2e658c4.gif" alt="0d449233d79a467ba66edb0bd2e658c4"><br>    这个窗口可用来输入一些控制命令，比如保存输出当前内存地址等。在命令窗口中输入如下导出指令，按下回车即可导出数据</p><pre><code>save filename startAddr,endAddr</code></pre><p>filename：导出数据的文件名，无论后缀是什么，导出的格式都是十六进制文件。没有输入路径时，文件自动保存在当前工程根目录下。<br>startAddr, endAddr：需要导出数据的起始地址和结束地址，也可以通过表达式写出来。</p><p>例如：</p><pre><code>save ExportData.hex 0x08000000, 0x08000000+0x2000函数地址表——Symbols Window</code></pre><p>    该窗口在”View-&gt;Symbols Window”中打开，也可能在工具栏在这里插入图片描述这个位置打开。<br>在这里插入图片描述</p><p>    可以查看当前所有程序的函数调用关系及其所在地址。</p><h3 id="串口调试窗口"><a href="#串口调试窗口" class="headerlink" title="串口调试窗口"></a>串口调试窗口</h3><p>——Serial Windows</p><p>    该窗口在”View-&gt;Serial Windows”中打开，也可以在工具栏<img src="/2024/02/01/Keil5/9fd418aa9fb44e3f8a1fd5115405765e.png" alt="9fd418aa9fb44e3f8a1fd5115405765e">这个位置打开。<br><img src="/2024/02/01/Keil5/d502d6586ae2490bbe15f8bc2f578a83-1706774116563-42.gif" alt="d502d6586ae2490bbe15f8bc2f578a83"><br>暂未使用过，后续再添加。</p><h3 id="逻辑分析窗口"><a href="#逻辑分析窗口" class="headerlink" title="逻辑分析窗口"></a>逻辑分析窗口</h3><p>——Analysis Windows</p><p>    该窗口在”View-&gt;Analysis Windows”中打开，也可以在工具栏在<img src="/2024/02/01/Keil5/9537a7eb27a445cb87feb4df0e988650.png" alt="9537a7eb27a445cb87feb4df0e988650">这个位置打开。<br><img src="/2024/02/01/Keil5/7f19e574ef214902922c21804ac11166.gif" alt="7f19e574ef214902922c21804ac11166"><br>    这个貌似只能在软件模拟仿真中使用，如果使用硬件调试，需要硬件支持。</p><h3 id="跟踪窗口"><a href="#跟踪窗口" class="headerlink" title="跟踪窗口"></a>跟踪窗口</h3><p>——Trace Windows</p><p>    该窗口可以在”View-&gt;Trace Windows”中打开，也可以在工具栏<img src="/2024/02/01/Keil5/b96037874d53409dac4c3714eabcb0fc.png" alt="b96037874d53409dac4c3714eabcb0fc">这个位置打开。<br>暂时未使用过，后续再添加。</p><h2 id="调试应用"><a href="#调试应用" class="headerlink" title="调试应用"></a>调试应用</h2><p><strong>HardFault（硬件错误）</strong></p><p>    这个可以算是最常见的一个问题了，在开发过程中多多少少会遇到过程序死机的问题，而死机的大部分原因都是进入的HardFault中断，即常说的硬件错误中断。要想知道这个怎么调试，首先得清楚这是什么，怎么触发。<br>    触发原因：内存溢出，堆栈溢出，数组越界，中断错误，除0（在某些编译器下会有错误）等。前面三个，可以归结为都是内存异常操作导致，但因为其出现方式不一样，所以调试方式也不同。<br>    从现象反推，当出现这个错误时，第一时间查看函数的调度关系，看最后是死在哪个位置。如果不是堆栈溢出，一般来说是可以直接查到进入硬件错误前的最后执行的代码位置的。当然内存溢出跟数组越界也有可能导致无法查看调度关系，因为这个调度关系就是从程序运行栈里取出数据进行展示，所以当栈数据被破坏，则无法使用此方式进行调试。<br>    知道死机位置后（其实大概率就是因为某个异常指针的引用导致的问题），此时就去查找异常指针出现的原因。首先从逻辑层面看，异常指针是否是因为某个逻辑给指针赋了个错误值。<br>    其次是数据越界的角度来看，在Map文件中查找该指针的内存地址，查看其内存前后是否存在一些数组或结构体，然后去检查前后数组或结构体的操作是否存在下标溢出，指针偏移错误等问题。<br>    还有最后一种，就是直接从内存里获取数据作为指针地址进行引用，此类用法一般是在日志操作或GUI中比较常用，这种情况就要去内存数据来源是否存在问题。<br>    除以上三种可能性外，还有一种可能对一些人是涉及知识盲区的，就是引用地址没有地址对齐。这一部分是涉及内核的一些知识。这里简单讲下，对于M0内核，指针引用地址需要根据其引用的数据类型进行对齐。比如以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> *p = <span class="number">0x20000001</span>;</span><br><span class="line">*p = <span class="number">20</span>;<span class="comment">/* 这句一执行就会导致异常 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种是操作指针本身的地址没有4字节对齐，也会出现问题。如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 实际这样子定义编译器会报错（在Keil中编译），这里只是为了直观表示 */</span></span><br><span class="line"><span class="type">uint32_t</span> *p __attribute__((at(<span class="number">0x20000001</span>)));</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">p = <span class="number">0x20000010</span>;<span class="comment">/* 这句一执行就会导致异常 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复位</strong>    </p><p>复位有几种类型，一是看门狗复位，二是软件复位，三是硬件复位。复位类型可以通过芯片自带的复位寄存器进行查看。不过查看前需要手动清除所有复位标志，不然其复位标志会一直保留着。<br>    先讲下看门狗复位，当单片机开启看门狗后，很多问题都会变成复位问题，比如上面说的HardFault，因为HardFault也是一个中断，只是默认中断里是一个While(1)的死循环，所以当进入中断后，一段时间没有喂狗操作，就会触发复位。或者一些操作陷入死循环的，均是同理。这里我们把这一类问题都归为死循环问题。处理方式，先把看门狗关掉，然后调试看停在哪个死循环中，如果是HardFault，那就看上面硬件错误的处理方式。如果是其他死循环，那就看是什么条件触发的。死循环的问题相对来说比较好找。<br>    另外一种比较难处理的看门狗复位问题，莫过于某些操作时间过长，导致喂狗不及时。比如读写Flash时，通常会关闭中断，当大量读写时，其操作时间不可小靓，未开看门狗的情况下会有肉眼可见的程序卡顿，开了看门狗的情况下则通常会触发程序复位。这种类型的问题，通过关闭看门狗可能也无法定位到具体位置，因为程序还可以正常执行，只是在某些程序段会变得比较卡顿。对于这种问题，最好的方式是通过代码对比，通过对比原本没出问题的代码和出问题代码的差异性，锁定问题大体出现的位置，再通过程序执行时间进行估算。也可以借助一个独立的定时器，在一些时间操作较长的可疑之处计时。比如程序调用了某个底层未开源函数，那可以在调用前后打印定时器的计数，来计算函数运行的时间。当然也可以通过Keil自带的调试计数值来计算运行时间。<br>    软件复位就比较好找了，一般是需要人为调试内核的复位接口进行复位，所以只要查看是哪些位置触发的调用复位函数的条件就可以锁定问题点。<br>    硬件复位就只能从外围电路进行切入了，考虑干扰、连锡等问题。当然有些硬件复位是通过一个硬件看门狗进行复位的，如果是这种应用，那参考内部看门狗的问题排查方式。</p><p><strong>逻辑时序类调试</strong></p><p>    时序类的用断点调试法就很难做到了，特别是那种时序要求很严格的。就比如Modbus通信，协议是规定了一帧数据中每两个字节间隔时间不能超过1.5字符。所以想要在一帧数据中，按一个字节一个字节断点调试从机是不可能的，主机不会给你休息的时间。这时候就必须得添加一些测试代码了，添加测试代码最重要的一个原则，是不能变更原本的功能。所以一般在数据流向的关键路径上添加一些监控变量，通过监控变量的变化来识别时序是否出现错误。<br>    另外也可以使用逻辑分析窗口，把对应的变量添加进窗口中，通过时间变化查看变量对应的变化关系，以此来判断逻辑时序是否正常。</p><p><strong>内存调试</strong></p><p>    如果有涉及boot或日志记录功能的编写，那肯定会涉及大量内存的对比及调试，这时候可以利用上面提到的小技巧，在命令窗口那里输入save filename.hex StartAddr, EndAddr把对应的内存数据打印出来。</p><p><strong>底层外设调试</strong></p><p>    这个打开对应外设的寄存器界面，对着芯片用户手册查看每个寄存器的功能进行调试，只有对寄存器功能熟悉了才有对应的调试手段。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、有时候在watch窗口中，变量值不会刷新，这时候就需要查看一下”View-&gt;Periodic Window Update”是否已勾选，如果没勾选，变量只有在第一次添加或停止调试时才会刷新。另外当窗口里一次性加载了一个很大的数组，当展开数组时，变量刷新也会变得很慢，并且软件会变卡顿。</p><p>2、当选择了非0级优化时，调试可能会变得困难，具体表现在断点调试。比如现在下面的代码，代码优化的关系，有可能把case0、1、2里的return 1都合并成一行，导致运行调试时，无论当前程序进入了哪个分支，使用断点时都只会进其中一个。所以当开启代码优化等级后，需要注意断点调试将变得不可信。另外优化编译后，有部分代码也将无法打断点（被优化的代码）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (xx)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">&#123;</span><br><span class="line">do_something0();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line">do_something1();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">&#123;</span><br><span class="line">do_something2();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时应该去看汇编的实现，其执行顺序与汇编一致。</p><p>3、目前发现有部分工程在一些电脑上调试时，打断点后在删除断点之前退出调试，会导致Keil崩溃，只能结束进程重启。</p><p>4、当开启内部看门狗并且未打开调试关看门狗功能时，停止运行一段时间后会复位。</p><p>5、在全速运行时，有时打断点会无效，取消断点也无效，貌似是Keil本身的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vscode&amp;Keil</title>
      <link href="/2024/01/30/vscode-keil/"/>
      <url>/2024/01/30/vscode-keil/</url>
      
        <content type="html"><![CDATA[<p>前言：之前一直用的keil软件开发stm32的工程，越来越觉得keil的界面模糊不好看，于是尝试转移到vscode平台，目前实现的功能是cubemx生成工程文件后可用vscode打开并编译烧录，如果有调试需求还是在keil上。使用Vscode搭配keil，更加优雅的进行开发</p><p>对比图：</p><img src="/2024/01/30/vscode-keil/image-20240131162907970.png" alt="image-20240131162907970" style="zoom:67%;"><img src="/2024/01/30/vscode-keil/image-20240131162933189.png" alt="image-20240131162933189" style="zoom:60%;"><h1 id="1-安装MinGW"><a href="#1-安装MinGW" class="headerlink" title="1.安装MinGW"></a>1.安装MinGW</h1><p>把MinGW压缩包解压到常用的一个位置，</p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;新建-&gt;添加，将MinGW的bin文件夹路径复制到新建的环境变量中。</p><h1 id="2-安装Keil-Assistant插件"><a href="#2-安装Keil-Assistant插件" class="headerlink" title="2.安装Keil Assistant插件"></a>2.安装Keil Assistant插件</h1><p>安装后，右键点击扩展设置，将你的keil软件的UV4.exe的路径粘贴上去</p><p><img src="/2024/01/30/vscode-keil/image-20240130220057873.png" alt="image-20240130220057873"></p><p>然后如果安装成功的话，vscode左栏就会出现</p><p><img src="/2024/01/30/vscode-keil/image-20240130220235274.png" alt="image-20240130220235274"></p><p>依次为编译，烧录，重编译</p><h1 id="3-遇到的问题"><a href="#3-遇到的问题" class="headerlink" title="3.遇到的问题"></a>3.遇到的问题</h1><p>1.点击编译后出现</p><p>“文件名，目录或卷标语法不正确”</p><p>然后发现是在添加路径到Keil Assistant时路径开头写错了</p><p>2.修复第一个问题后，再次编译，出现</p><p><img src="/2024/01/30/vscode-keil/%7BWEJS9SE%25J%7BMGCUP6EYHMG.png" alt="{WEJS9~SE%J{MGCUP6EYHMG"></p><p>解决：先打开settings.json文件</p><p><img src="/2024/01/30/vscode-keil/image-20240130221023430.png" alt="image-20240130221023430"></p><p>把代码中的[U+202A]删掉即可，到此，可以正常编译和烧录。</p><p>目前的功能满足现在的使用需求，后面有时间可以学习下用GCC编译链开发STM32，学习下makefile,cmake,openocd相关的知识。</p><p><a href="https://www.bilibili.com/video/BV1Hi4y1r7b3/?spm_id_from=333.999.0.0&vd_source=a9d487fcf1a579639c6348eb5a9321db">https://www.bilibili.com/video/BV1Hi4y1r7b3/?spm_id_from=333.999.0.0&amp;vd_source=a9d487fcf1a579639c6348eb5a9321db</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vscode&amp;Keil </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Robotics learning path</title>
      <link href="/2024/01/30/Robotics/"/>
      <url>/2024/01/30/Robotics/</url>
      
        <content type="html"><![CDATA[<p>转载自</p><p>机器人工程师学习计划 - YY硕的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/22266788">https://zhuanlan.zhihu.com/p/22266788</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>很多朋友私信问我对机器人和人工智能感兴趣，该怎么展开学习。最近稍微有点空，我写写我的看法。</p><p>两年前，我在知乎回答<a href="https://www.zhihu.com/question/20435673/answer/29927998">如何定义「机器人」？ - YY硕的回答</a>中试图给机器人做出一个比较仔细的定义，我觉得机器人和人工智能最大的区别在于是否要和物理世界进行交互。今年初在另一篇知乎回答里<a href="https://www.zhihu.com/question/36653316/answer/85774195">对机器人或人工智能的研究会帮助我们更好的了解人类自己吗？ - YY硕的回答</a>我说到传感器是和物理世界交互的基础。后来，我又在知乎回答<a href="https://www.zhihu.com/question/45766810/answer/100301388">有哪些与控制、机器人等相关的 quotes？ - YY硕的回答</a>中提到莫拉维克悖论（<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Moravec%27s_paradox">Moravec’s paradox</a>），谈到了机器人学里公认的难题是在物理世界中实现类人的活动能力。</p><p>把之前的回答再翻出来是为了支持以下观点：机器人学的核心问题是做好和物理世界的交互。现在主流的机器人学分支里，处理与物理世界的交互的学科分为三类：传感器和处理算法（激光雷达，多目视觉，融合算法）；多刚体系统动力学控制（工业机器人动力学控制和接触力控制）；机器人自主移动（locomotion不知道该怎么翻译，轮式、足式、飞行等移动机器人的研究）。我建议对机器人学有兴趣的同学着重在这几个问题上面。</p><p>另外，根据世界第一的机器人教育机构卡耐基梅隆大学的机器人学博士的课程分类方式（</p><p><a href="https://link.zhihu.com/?target=https://www.ri.cmu.edu/wp-content/uploads/2017/01/COSAug2016.pdf">https://www.ri.cmu.edu/wp-content/uploads/2017/01/COSAug2016.pdfwww.ri.cmu.edu/wp-content/uploads/2017/01/COSAug2016.pdf</a></p><p>），机器人学有四个核心领域：</p><ol><li>感知。视觉传感器、图像传感器、触觉和力传感器、惯导等。</li><li>认知。人工智能、知识表达、规划、任务调度、机器学习等。</li><li>行为。运动学、动力学、控制、manipulation和locomotion等。</li><li>数学基础。最优估计、微分几何、计算几何、运筹学等。</li></ol><p>结合卡耐基梅隆大学的核心课程要求，我觉得我定义的机器人学核心问题算是基本没跑偏的。本文后面谈到的机器人项目都是以上述观点和课程要求为基础。</p><p>一些可能有争议性的观点：</p><ol><li>机器人学是富人的活动。虽然工业越来越发达，但好的开发板和电机还是非常贵。如果要下定决心学习机器人学并且做出实物，你必须找到做实物出来的资金。要么是自己花钱，要么就得找学校的机器人社团，或者找什么愿意资助年轻人学习的贵人。另外现在没有任何一本完整的书可以教你怎么造一个四旋翼空中机器人或者大狗机器人，你需要参考十几本不同的教科书，这些书不管中文版还是英文版都很贵。</li><li>机器人学是屠龙之术。这话是Ninebot创始人说的。虽然最近几年，平衡车、扫地机器人、多旋翼飞行器让机器人学开始进入人们的生活，但是可行的商业应用还是很少，而且已有的机器人和理论都还很难解决好与物理世界交互这件事情。所以一定要确保自己在机器人学这个道路上同时练好了能去其他行当吃饭的技能，比如编程、机械设计和硬件设计。也要做好心理准备，接受自己有可能在学会屠龙之术以后几年都造不出对社会有用的东西的事实。</li><li>基于上述所说的观点，如果是已经工作之后才想要学习机器人的话，可能已经太迟了，因为很可能<strong>兴趣战胜不了客观限制因素</strong>。如果作为兴趣去学习，只能学到做巡线小车和舵机机械臂什么的，可能也满足不了中二病的创造欲。</li></ol><p>个人认为机器人学是一个艰苦的道路，想要成为一个独挡一面的机器人工程师需要多年理论和实践的同步训练。理论学习和动手实践的过程还要互相排好时间表，在做某个实践项目的同时去学习最相关理论往往可以达到事半功倍的效果，但是同时那些不太相关的理论会看起来非常枯燥，因此如何妥善安排自己的实践项目也是很重要的事情。</p><p>这篇文章里我计划介绍一个电子工程、机械工程和计算机专业学生从大学一年级到研究生二年级的机器人学习计划，基本是我对自己过去学习方式的一个总结。按照这个方法来学习，能够成为一个能力全面，但是稍微偏软件一点的机器人工程师。这个六年的学习计划，估算下来，全年中每天在上课和完成课程要求之外要投入学习时间6-8个小时，这些时间一方面用于阅读课程知识的英文教材，一方面用于阅读其他学科的教材，一方面用于实践项目。</p><p>机器人工程师在大型项目里的定位类似于飞机系统里的总体设计师。和机械工程师、硬件工程师、软件工程师、算法工程师、控制工程师比起来，机器人工程师参与某个具体技术的时间较少，但是能够听得懂所有工程师说的话，能够作为不同模块间的协调人，带领整个团队去攻坚。当然如果机器人工程师能够在一个领域达到那个领域的工程师的优秀水平，肯定更好。</p><p>由于时间仓促，再加上个人水平有限，文章中如有纰漏和错误，恭请读者指出，谢谢。如果同学还有什么想知道的内容和教材，也欢迎留言交流。</p><h2 id="大一"><a href="#大一" class="headerlink" title="大一"></a><strong>大一</strong></h2><p>刚上大一，你的机器人生涯开始了。先看看学校的校园网能不能翻墙，不能的话自己去买个一年一百多块钱的VPN，先确保自己能上Google，不要心疼VPN的钱，这能让你在之后的职业生涯里节省上万块钱。然后去注册一个gmail账号，再注册stackoverflow账号，再注册github的账号，再注册CSDN账号，注册完登录上去逛逛，暂时先不要问为什么。</p><p>英语水平一定程度上会是机器人工程师水平的限制因素，英语是同学们在大学最该努力学的一门课，而且不止要把它当成课，要当成一种技能，当成生活的一部分。当你开始努力学习一些高级的机器人知识以后，有可能会非常难以找到中文的参考资料，这个时候如果啃不下英文的资料，进步速度和眼界就会受到很大影响。因此大一的时候要多看看红宝书，看看美剧。</p><p>不管是什么专业背景的同学，大学一年级一定要上好的课是微积分和线性代数。线性代数的重要性需要特别强调。一般来说，<strong>优秀的工程师和科学家在职业生涯中要学至少五次线性代数</strong>，大一学一遍、学凸优化的时候学一遍、学线性系统的时候学一遍、学机器学习的时候学一遍……如果在第一遍学的时候就看到对的书，刷到对的题，那么以后的学习会轻松很多。</p><p>网上有很多对于如何学好线性代数的讨论，比如知乎问题<a href="https://www.zhihu.com/question/20534668">如何理解线性代数？ - 数学学习</a>。Matrix67大神的文章<a href="https://link.zhihu.com/?target=http://www.matrix67.com/blog/archives/4294">随记：我们需要怎样的数学教育？</a>也很有启发。我个人对学习线性代数的建议是两本书，一本叫做《Linear Algebra Done Right》，另一本叫做《Linear Algebra Done Wrong》（<a href="https://link.zhihu.com/?target=https://www.math.brown.edu/~treil/papers/LADW/book.pdf">https://www.math.brown.edu/~treil&#x2F;papers&#x2F;LADW&#x2F;book.pdf</a>），我比较喜欢的是Done Wrong这本书，第一它是免费的，第二只需要读前6章两百页就够了，第三它页边距很大，打印出来有很多空白做练习题。另外一个较好的教材是<a href="https://link.zhihu.com/?target=http://open.163.com/special/opencourse/daishu.html">麻省理工公开课：线性代数</a>。不论如何，学线性代数一定要用国外的教材，千万不要用国内的教材。啃英文书很累，但是考虑到之后还要啃更多的英文书，线性代数已经算是很入门的了，一定要啃下来，同时还要刷足够多的课后题。</p><p>学完线性代数以后，一个自然而然的问题就是怎么能用计算机自己去计算矩阵的乘法、向量的乘法、向量的内积。因此引入了编程的学习。</p><p>不管同学的专业是什么，一定要在大学一年级尽早开始学编程。至于用哪种语言开始学习编程，我推荐Python，比较好的教材是<a href="https://link.zhihu.com/?target=http://open.163.com/special/opencourse/bianchengdaolun.html">麻省理工学院公开课：计算机科学及编程导论</a>，比较好的Python开发学习环境是Anacoda (<a href="https://link.zhihu.com/?target=http://www.continuum.io/downloads">http://www.continuum.io/downloads</a>)。熟悉Python以后，同学就可以开始玩玩Python的数值计算包Numpy，这个时候线性代数题基本上也刷的差不多，可以通过Numpy帮助自己解决线性代数问题了。</p><p>对任何人来说，Python是一把瑞士军刀，你可以用他干很多东西，比如自动回复邮件、自动收集信息。但是真要去造机器人，合适的工具并不是瑞士军刀，而是C&#x2F;C++这样简单粗暴的锤子和螺丝刀般的工具。在学习Python学到一定程度的时候（比如你听说有一种叫做cython的东西），最好开始学习C，而且要强迫自己练习用C的一维数组和指针来实现矩阵的加法、乘法、求逆等操作。之所以有高级的Python或者Java（不要问我Java哪里高级了）这些语言以后我们还需要去学C，是因为机器人上常用的不是完整的电脑，而是计算量有局限的嵌入式系统，嵌入式系统开发基本只能用C或者更低级的语言。</p><p>学习C我个人入门用的是清华大学出版的《<a href="https://link.zhihu.com/?target=http://product.dangdang.com/8880276.html">C++语言程序设计</a>》。虽然这个书标题是C++，但其实没什么太大问题。不过国内的C语言教材都有个巨大的问题是不引导学生去用Linux。近年来更好的一个教材是<a href="https://link.zhihu.com/?target=http://songjinshan.com/akabook/zh/index.html">http://songjinshan.com/akabook/zh/index.html</a>，这个网站的教材非常好，因为他教育学生用Linux环境作为程序编译的环境，而且还引入了一些计算机体系结构的介绍。</p><p>IT行业的程序员都会争论高级语言和低级语言哪个好，Linux和Windows哪个好，而对于机器人工程师来说，从现在到可预见的未来里，C是最好的语言，Linux是最好的操作系统，这都毋庸置疑。甚至对于Linux的发行版该选哪个，我们都是很少有质疑的：Ubuntu（<a href="https://link.zhihu.com/?target=http://www.ubuntu.com/global">The leading OS for PC, tablet, phone and cloud</a>）。原因是机器人操作系统ROS（<a href="https://link.zhihu.com/?target=http://www.ros.org/">ROS.org | Powering the world’s robots</a>）是基于Ubuntu开发的，因此在Ubuntu上运行最稳定。注意Ubuntu出了一个中文版叫做Kylin，个人感觉比较坑，建议大家不要装中文版。Ubuntu 作为一个开源操作系统，总是在快速迭代，2016年8月比较稳定的版本是14.04和16.04，建议同学安装14.04。</p><p>当你把C学得差不多，开始要学写包含多个头文件的程序时，一定要同时学习makefile的知识。这时候要上网去搜“Makefile详解”（<a href="https://link.zhihu.com/?target=http://tieba.baidu.com/p/591519800">Makefile详解（超级好）_mingw吧</a>）这篇文章看。</p><p>我自己在大学一年级的时候还学习了HTML和Javascript，到大一结束的时候已经能够熟练用Javascript手写一些动态页面。我个人觉得HTML和Javascript也是机器人工程师必备的技术，而不只是软件工程师的玩具。这是因为web技术实际上已经渗透到了编程的方方面面，比如json开始是Javascript里的一种object定义的方式，但现在已经成为了一种很标准的数据交互、参数配置的格式。另外AJAX能够帮助初学者理解一定的网络技术原理，而网络技术也是机器人工程师必备的技能。再者，制作GUI（图形用户界面）是常规debug的办法，而近年来一个流行的趋势是用webkit嵌入程序用HTML和Javascript作为图形界面的后端，而在机器人操作系统ROS（<a href="https://link.zhihu.com/?target=http://www.ros.org/">ROS.org | Powering the world’s robots</a>）里，通过rosbridge可以非常方便地把机器人程序的数据传递到websocket上，这句话看不懂没关系，反正你知道学学HTML和Javascript很重要就是了。更重要的是，HTML文档背后的DOM (Document Object Model)深刻地体现了面向对象的思想。大学中的面向对象程序设计一般都讲C++，在我看来应该讲HTML和Javascript。这一点不细说了，如果同学们去学习HTML和Javascript，自然会体会到。学习HTML和Javascript比较好的资料是<a href="https://link.zhihu.com/?target=http://www.w3schools.com/">http://www.w3schools.com/</a>，把网站左侧的“Learn HTML”、“Learn CSS”、“Learn Javascript”和“Learn JQuery”学完就行，别的部分还有很多花哨的技术，没有必要去学了。为了培养自己对Javascript的兴趣，可以上<a href="https://link.zhihu.com/?target=http://threejs.org/examples/">three.js &#x2F; examples</a>跪着看看热闹。</p><p>以上介绍的这些知识点、书和资料应该在大一期间就全部看完，然后利用大一的暑假好好巩固这些知识。比如开始用HTML和Javascript做一个自己的个人主页，刷一刷编程的题目，学用Python的奇技淫巧（比方说做一个自己的个人主页）。另外还可以抽时间学学数学知识，比如开始看看代数和离散数学。我大一的时候看到了两篇文章，认识到了数学的重要性，一个是MIT的CV大牛林达华写的[<a href="https://link.zhihu.com/?target=https://www.douban.com/group/topic/11115261/">转]MIT牛人解说数学体系</a>，另一个是前Goolge研究员吴军博士写的《数学之美》（<a href="https://link.zhihu.com/?target=https://book.douban.com/subject/10750155/">数学之美 (豆瓣)</a>）。当时林达华还在MIT读博士，而《数学之美》还没有成书。两篇文章看完以后我感觉自己整个人对数学的认识上了一个新的层次，此后一直在注意提高自己的数学水平，几年下来觉得收益很大。在之后的介绍里我还会多次强调需要学的数学知识和对应的教材。</p><h2 id="大二"><a href="#大二" class="headerlink" title="大二"></a><strong>大二</strong></h2><p>上大二的时候，你已经会了基本的编程知识和基本的数学知识。大二这一年应该投入在嵌入式系统的学习中，同时继续拓展自己多方面的能力。学校的机器人社团，比如做Robocon，RoboMasters的团队应该在招新了，赶快去加入，有了学长学姐的指导以及同辈朋友的鞭策，应该会进步的快一点。</p><p>大二应该掌握的技能：Solidworks画基本的机械图，基本的数字电路知识、数模转换，51单片机、AVR单片机、STM32单片机原理，UART、SPI、I2C、CAN等协议的原理和数据收发，STM32开发板的使用，电机转动和驱动的原理，PID的原理，调试四轮机器人底盘的移动，基本的传感器如陀螺仪、码盘、红外线、超声波的原理和读取方式，网络知识如配置IP配置路由器等，微电子焊接，金工技术。我在知乎回答<a href="https://www.zhihu.com/question/34670420/answer/59676472">如果程序员每天都浅尝辄止地学一些不同的新技术，长久以往，人会变成什么样子呢？ - YY硕的回答</a>里谈过机器人工程师需要的技能数量是IT行业全栈工程师技能数量的三倍以上，这些技能的基础都应该在大二开始积累。</p><p>如果同学们的专业是机械工程相关，那么大二的时候要深入学习solidworks做图，买机械加工手册学习各种机械的奇技淫巧。你的专业知识还不足以让你进行缜密的受力分析，不过你可以尽量多做一些机械结构出来感受它们的乐趣。</p><p>如果同学们的专业是硬件、电路相关，那么大二的时候要深入学习Altium Designer做图、制板、焊板。你要从现在开始，就给自己积累一个工作记录，可以就是简单的txt文件，记录你做过所有板子的bug、解决方案、学到的原理图、PCB layout的注意事项等等。积累很多年以后，你的这个工作记录会值很多钱。</p><p>学习这些技能的最好的方式，就是参加自己学校机器人社团的训练和方案设计。一般来说，学校的机器人社团招新之后会有训练和测试，让新人分组去做机器人，这个过程中如果愿意努力学，提高得会很快。如果你所在的大学是机器人比赛强校，比如西安交通大学，电子科技大学，哈尔滨工业大学，华中科技大学，东北大学等等（排名不分先后，没有提到你们学校名字的话我表示抱歉），那么你很幸运，你们学校的机器人社团有很好的积淀，有很多资源可以帮助你学习。基本上只要天天泡实验室，保证自己每天只睡6-7个小时（但还是要多去跑步、游泳保持身体健康），勤于向学长学姐请教，那么一定会提高得很快。</p><p>大二阶段特别要强调的是对动手能力的培养，包括机械材料的加工、电路焊接、制作导线和接头、连接路由器、配置网络、做网线等等。机械加工的工具有螺丝刀、锯、钻、锤子、车床、铣床、钻床，进阶选手可以学一下氧焊，这个比较危险，我没尝试过；电路焊接的工具有焊机、焊锡、洗板水、松香、吸锡器；制作导线的工具有剪子、剥线钳、夹头钳、网线钳各种钳；网络配置就是连连路由器插插网线，但是Linux系统下配置网络有时会非常麻烦，一定要多积累这方面的知识，因为将来你造的机器人多半会顶着一个无线路由器跑来跑去，甚至有的机器人上各个模块自己就能组起一个小局域网。这些技能的熟练掌握需要你花很多时间去做真正能用的机器人来练手。</p><p>对于该选择造一个怎么样的“真正能用的机器人”练手，最好的选择肯定是机器人比赛中的机器人。如果参加Robocon，你会跟着学长学姐们学着造有人那么高的巨大机械；如果参加RoboMasters，你会学着造比汽车还要灵活的机器人以及快速发弹的机构。其他一些小型的比赛比如飞思卡尔智能车，也是很好的训练，因为飞思卡尔智能车已经发展得很成熟，参加这个比赛的参赛资料就够学一阵子的，学完以后能够获得比较多的机器人技能。</p><p>如果没有太多学校机器人社团的资源，同学们还有一些小型的比赛比如挑战杯、大创比赛等等可以选择，以三五个人的小团队参与这些比赛。如果同学所在的学校连这些比赛都不组织大家参与，那就只好自己花钱了。国内开源机器人社区有很多资源可以利用来学习，比如自己买<a href="https://link.zhihu.com/?target=http://www.makeblock.com/">Arduino STEM educational Robot kits Building Platform</a>的各种开发套件做简单的机器人。Arduino的开发环境可能有些人不喜欢，因为它对硬件做了一级封装，如果更希望接触到单片机的本质，可以自己买STM32开发板学习。俗话说，没有什么嵌入式系统是一块STM32实现不了的，如果有，就用两块。STM32是ARM Cortex‑M家族中最为广泛应用的一款单片机，在网上也有很多的教材和开发板可供选择。在国内著名的电子论坛<a href="https://link.zhihu.com/?target=http://www.amobbs.com/forum-3020-1.html">STM32&#x2F;8 分论坛帖子清单 (amoBBS 阿莫电子论坛)</a>上，有很多参考资料，有问题也可以在这里和大家讨论学习。</p><p>如果你很想参加机器人比赛，身边也恰好有一些志同道合的小伙伴，但是学校不支持。没关系，来找我，我尽量通过大疆的关系说服你们学校支持你们参加RoboMasters。</p><p>虽然你是以机器人比赛为主线在探索机器人技术，但是要时刻记得，机器人比赛给你的理论方面的训练很差，还会让你养成一些坏习惯，比如凡事都希望用一些糙猛快的办法来解决。由于通常整个团队都没有太多的项目管理经验，到比赛前一段时间才会加紧功夫去做机器人，很多时候就会用“山寨”的办法去处理机器人的故障。比如说某个承重结构用久了会弯，为了赶比赛的进度，就拿锤子敲直了、再加一条辅助的结构在旁边继续用，而没有细致地去做建模、受力分析，思考是什么原因导致承重结构会变形。再比如说调PID参数就是生调乱改，而没有基于机器人的动力学模型去估测参数的大概范围。</p><p>大二的暑假，有可能你跟着学校的机器人队参加了一些机器人比赛。这是一个反思总结的好时机，为什么机器人队取得了这样那样的成绩？整个团队怎样才能更有效率？明年如何继续招新？暑假要把时间花在技术积累上面，这个时候可以回头思考思考之前准备比赛时用糙猛快的办法解决的问题如何能够细致地去解决。</p><p>如果大二的暑假没有参加机器人比赛，可以做一个舵机机器人，比如6条腿的蜘蛛，比如码垛机器人。舵机是机器人工程师的好朋友，一定要好好掌握。</p><p>另外你其他方面的能力也不能落下。大二结束的时候，你的Linux应该用的很熟练了，除了makefile，你也用起了cmake。你也应该开始理解Github存在的意义，因为你已经上去读了很多别人的代码，你也把自己的一些课程设计和小项目放在了Github上面。另外大二基本上了本专业一些比较难的基础课程，比如自动控制原理、机器学习、概率统计、材料和力学等课程，同学们会看到这些课程里又用到了线性代数和微积分的知识，以及建模的知识。这时候可以把大一的物理、线性代数和微积分再翻出来看看。</p><p>同学的学校应该给大二到大三的学生有开设面向对象的程序设计，一般用Java或C++教授。在面向对象的程序课里面，一定要积累3000行左右的代码的开发经验。经典的面向对象程序设计的练习通常是写游戏，比如俄罗斯方块，吃豆人等等，一定要自己能够做到完全手写一个完整的项目出来。</p><p>另外你可以开始学习Matlab当中的神器Simulink了。在大二这一年的学习中，你可能在不少课程里多多少少用到了Matlab。假设你已经在我的推荐下喜欢上了Python，你可能会觉得Matlab的计算工具没有比Python强多少；假设你自己在别人的推荐下喜欢上了mathematica（<a href="https://www.zhihu.com/question/27834147">Mathematica 到底有多厉害？ - Wolfram Mathematica</a>），你可能会觉得和Mathematica这种神一样的语言比起来，Matlab弱爆了。但是要注意的是，Matlab最强大的工具是Simulink，通过它你几乎可以仿真一切的物理系统和控制系统。我建议同学可以通过Simulink实现一个倒立摆，然后理解Matlab的强大之处。对此我强烈推荐一个很好的教材（<a href="https://link.zhihu.com/?target=http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction&section=SimulinkControl">http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction§ion=SimulinkControl</a>），它详细介绍了一些经典的控制系统如何分析以及用Simulink实现。然后我再强烈推荐一个讲Simulink里面一个更加和物理仿真贴近的工具Simscape（<a href="https://link.zhihu.com/?target=http://www.mathworks.com/help/control/examples/control-of-an-inverted-pendulum-on-a-cart.html">Control of an Inverted Pendulum on a Cart</a>）的文章。阅读并实现了这两篇文章里的内容，同学应该会对倒立摆有了比较深刻的认识。倒立摆是机器人学中一个非常重要的模型，因为火箭、导弹、双足机器人、四足机器人，基本都是倒立摆的变形。你自己实现出来的simulink模型一定要存好，以后可能还会再拿出来仔细看。</p><p>如果你按照我之前说的方法探索了一些HTML和Javascript的技术，那么JQuery，bootstrap，AngularJS你已经多多少少知道是怎么回事了。web后端的技术，比如PHP和MySQL，也可以了解一下，LAMP要学会怎么配置。如果有同学找你帮忙写小网站，尽量去帮个忙，帮别人做网站是提高自己系统编程能力的好练习。在做网站的过程中你可能还会顺便学一学如何用Photoshop和Illustrator让网站显得更漂亮。这些技能有最好，没空学也没关系。</p><h2 id="大三"><a href="#大三" class="headerlink" title="大三"></a><strong>大三</strong></h2><p>大三开始的时候，你可以在学校的机器人队里担任重要角色了，或者能够带领一个小团队参加小型的机器人比赛。你在系里甚至院里都小有名气了，可能有的人叫你大神，有的人觉得你技术还不错。但是一定要记得你现在的水平放到别的地方应该不算什么。每年我都往大疆的RoboMasters夏令营招进100个和你现在的水平相当的同学。</p><p>大三一定要培养出自己一个人独立造出一个完整机器人的能力，比如一个Robocon水平的机器人，或者一个RoboMasters的战车，或者一个四旋翼飞行器。</p><p>Robocon水平的机器人，涉及大量的机械设计，单片机开发，电机驱动的开发，码盘和超声波等传感器的读取，底盘运动学的计算，PID调试，任务调度逻辑的调试，舵机控制。RoboMasters的战车的机械部分简单一些，但是还需要进行云台的控制、发弹系统的控制、功率控制等方面的知识，另外你也可以不搞这些部分，学习学习视觉识别和自动打击，那么就要开始研究OpenCV（<a href="https://link.zhihu.com/?target=http://opencv.org/">OpenCV | OpenCV</a>）了。</p><p>四旋翼飞行器的机械部分最简单，但是算法比较复杂。对于大三学生来说，从零开始一步到位写一个稳定的飞控比较困难，因为飞控里面有很多细小的知识点要注意。目前我没有发现什么比较好的书籍推荐，已有的一些关于四旋翼系统的书要么太浅（上来就教你焊电路），要么太深（上来就教你state estimation），听说 <a href="https://www.zhihu.com/people/liu-top">@Liu Top</a>的exbot小组在写一个教材，我是非常期待的。学习四旋翼飞行器有下面几个步骤：</p><p>第一步：自己调一个小四轴飞起来</p><p>现在开源社区的人言必pixhawk，其实我觉得从学习的角度来说，pixhawk太贵，而且不适合学习，我比较推荐的是 <a href="https://link.zhihu.com/?target=https://chiplab7.taobao.com/">首页-第七实验室</a> 这家淘宝店卖的STM32F405飞控，买回来以后自己再随便买个机架（比如大疆F450）、接收机和遥控，就能按照飞控板附带的学习资料、调试软件飞起来。</p><p>第二步：看硬件图、读代码</p><p>chiplab7的飞控板附带一大堆学习资料，对加速度计、陀螺和磁感计都有很仔细的解释，硬件链路图也很详细。chiplab7淘宝掌柜的又很认真负责，我学用的时候，发现代码有bug和看不懂的地方，都可以直接找掌柜问。</p><p>看完代码以后，对一个飞控系统的基本模块：姿态解算、控制解算、混控输出、遥控器处理、嵌入式处理就很明白了。然而这里面有很多技术是需要另外学习的。除了基本的嵌入式编程以外，还有要把大二大三学的信号处理方面的知识再捡起来看看。因为飞行器在空中有振动，会让加速度计产生噪声，为了把这些噪声去除掉，需要对加速度计给出的信号做低通滤波处理，如何选择滤波器的参数呢？如果滤波滤得太狠，延迟就会比较大，对控制的表现会有影响；如果滤波滤得不够，可能会有一些低频的噪声偶尔会出现，导致加速度计的观测不能用。另外最重要的是要理解姿态解算和控制解算这两块知识。chiplab7的飞控板的代码采用的是最简单的互补滤波算法做为姿态解算模块，然后控制解算是对欧拉角的三个角度做闭环PID控制，基本都是基础的基础了。</p><p>第三步：小修小改加深理解</p><p>chiplab7的飞控是靠气压计定高的，飞行效果非常奔放。这时候可以淘宝买个20块钱的超声波模块，然后自己写个高度环去稳定飞控的定高表现。</p><p>我觉得这个过程至关重要，因为高度控制相对来说是个比较直观理解PID控制的方式，而且chiplab7的飞控加高度控制非常好加。工作量不大，因为改善效果很显著，所以可以让人很有成就感，加深继续学习的乐趣。</p><p>第四步：理解核心的数学和控制知识</p><p>这一部分大三是肯定来不及学的，但是我还是在这里列出来，因为这些知识你之后都需要慢慢学，我也会在之后不断重复提到这些知识点。</p><p>姿态解算和控制解算涉及的知识有：</p><ol><li>刚体姿态的表示、运动学方程和动力学方程。主要是对牛顿-欧拉方程的认识和理解、刚体姿态的欧拉角表示法、姿态与角速度的关系等等。</li></ol><p>这部分说复杂不复杂，说简单也不简单，我同样是没有找到一本完整的书全都介绍过的，是学了好几个不同的书和论文以后搞明白的。现在看起来是从维基百科入手比较靠谱。</p><ol start="2"><li>自动控制原理。讲PID的书和文章就多了去了，没有太多复杂的书。</li><li>线性估计基本原理。其实就是互补滤波：<a href="https://link.zhihu.com/?target=http://www.pieter-jan.com/node/11">Reading a IMU Without Kalman: The Complementary Filter</a> 。拿这个关键词百度各种搜就会了。</li></ol><p>第五步：重头开始造轮子</p><p>知乎著名网友vczh曾经说过，学习要抱着勇于造轮子的心态才能进步。所以在熟悉了别人飞控基础上，可以自己重头造一个飞控的轮子。可以自己从芯片开始重新画一个飞控板，读读STM32的芯片手册、读读各种传感器的芯片手册，自己手画一个飞控的原理图、做PCB layout、制板自己焊元件，全套花不了1000块钱，能够加深很多对硬件的理解。这一部分如果大三没空，也可以不搞了。</p><p>制造整个机器人的过程中要特别重视文档的积累。在你大三末期，你可能随着学校的机器人队备战比赛，你可能主力负责一台机器人。你应该自己列一个excel表格，把机器人用了几颗螺丝，几根导线，每个零件的规格是什么，都列出来。这个表格一方面可以用来帮助团队管理机器人的物料，一方面也是你自己的经验技术积累，将来你做的其他机器人可能多多少少都是Robocon、RoboMasters机器人的变形。</p><p>另一个积累是建一个自己的buglist，buglist包括什么呢，可以像冷大这样：<a href="https://www.zhihu.com/question/46824735/answer/115202408?from=profile_answer_card">做控制、机器人等算法工程师是怎样一种体验？ - 冷哲的回答</a>，就简单把一些自己的发生过的问题和最后的解决办法罗列下来。比如说“杜邦线接插位不稳固容易脱开，接好后应该用电工胶布再裹一圈”，“外发给淘宝加工的机械图纸，要特别注意和加工商沟通有没有漏掉一些细节，如沉头螺丝孔，关键的倒角”等等。你也可以帮其他机器人的问题也做这样的记录。buglist可以就是一个简单的文本文件，如果你一直往里面积累自己工作中的记录，等你将来工作了，这个文件可能会值很多钱。</p><p>大三的时候学校应该会开设软件工程的课程。不管你是不是这个专业，上不上这门课，都应该主动去听一听，甚至跟着课程的设计作业一起做一做。软件工程我觉得是机器人工程师必须具备的意识，因为一个机器人系统里涉及大量的硬件系统和软件功能，软件的部分往往还会涉及不同的语言、不同的编译环境、不同的开发工具链。几个人合作的话，大家的专业背景、编程习惯都不相同，这就导致不同的代码和模块之间的协议沟通非常复杂，必须尽早用UML和其他软件工程的工具帮助团队理解和互相沟通。</p><p>大三的时候学校应该还会开设操作系统原理和嵌入式系统原理的课程，而大二的时候讲过计算机组成原理（所谓的微机原理）。从大三开始同学需要开始体会实时操作系统和非实时操作系统的区别、原理以及使用时需要注意的地方。这是一个比较杂的知识点，我目前没有找到很好的教材去介绍。在STM32上，有freeRTOS，uCOS，Vxworks这么几种实时操作系统；Linux是一种非实时操作系统，但是可以通过打补丁变成实时操作系统。这些操作系统的细节在机器人开发中都会多多少少被涉及到，同学们可以随时上Google和CSDN去查大神们的介绍。</p><p>另外特别重要的一点是机器人系统里的嵌入式平台都有烧坏的可能性，有可能在某个嵌入式Linux平台上面辛辛苦苦写了一个多月代码，这个平台突然烧坏了，代码也就丢了。因此你的机器人如果有嵌入式Linux系统在里面，一定要尽早顶起来路由器，代码定时提交SVN或者git。</p><p>大三的暑假你可能会作为学校机器人队的主力去参赛了。备战比赛和参赛是一件磨练心性的事情。我在学生时代体会过和胜利擦肩而过的痛苦，体会过没机会再来一年的遗憾；也在负责大疆RoboMasters比赛的过程中被那些痛苦和遗憾的学生当做发泄的对象，非常有感触。我觉得参加机器人比赛，很努力，然后失败了，是一件让人快速成长的事情。同学如果有机会，一定应该参加至少一届机器人比赛。</p><p>大三的暑假你也可以选择来参加大疆的RoboMasters夏令营，关于夏令营大家可以看这个知乎问答了解更多：<a href="https://www.zhihu.com/question/49986388">参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新</a>。每年我们都在全国范围内寻找有一定技术基础的学生，让他们一起分组做一个自动机器人的挑战。这个夏令营，作为组织负责人，不谦虚地说，我觉得应该是全世界范围内最好的技术类夏令营。</p><p>大三的暑假有一件很重要的事情就是思考自己大四应该干什么。一般来说，你现在的能力保本校研究生肯定没有问题，当然你也可以选择考其他学校的研究生或者出国留学。虽然说你现在能力已经很全面了，但是你还需要2-3年的时间全面提升自己更多的能力，才能迈向卓越之路。不管是出国还是保研，最重要的目的是给自己争取到未来2-3年能够在一个优秀的环境中安心提升自己，有比较好的学习资源，能够参与到一些不错的项目中去。可能其他有些行当，出国留学始终是比在国内待着更好的选择，但是机器人行业并不是这样。我们国家这两年在机器人方面提高也很快，而且我们国家现在比较有钱。就像我开始说的那样，机器人是富人的活动，现在你在国内也能找到一些很有钱的实验室可以造比较牛逼的机器人。另外国外很多比较强的机器人公司也都在做比较敏感的军方项目，去找实习可能比较受限制。</p><p>出国去学机器人学方面的知识你有很多不错的选择，比如世界第一的机器人研究院卡耐基梅隆大学，或者麻省理工学院的CSAIL实验室。北美传统计算机四大名校（麻省理工学院，卡耐基梅隆大学，斯坦福大学，加州大学伯克利分校）里，除了斯坦福大学热火朝天在搞人工智能以外，其他几个学校的机器人研究都很不错。除了四大名校，你还有很多其他的选择，就像我开始说的那样，机器人是富人的活动，如果想接触到最好的机器人资源，你要选择有钱的实验室，而不是有名的实验室。</p><p>另外你还需要在大三的尾巴上选定自己将来的细分研究方向，而且开始往这个方向深挖，也就是我在文章开始提到的感知、认知、行为几个方向。当然同时你也不能放松其他方面的知识，尤其是数学基础。我在大三的暑假专门找数学系的同学给我开了个数学小讲座，学习了一点抽象代数的知识，对我后来学习密码学帮助很大。同时我也读了一些拓扑方面的教材（有一本很神奇的书叫做Topopogy Without Tears <a href="https://link.zhihu.com/?target=http://www.topologywithouttears.net/">http://www.topologywithouttears.net/</a>），这样才理解了为什么数学分析要用奇怪的符号去解释一些看起来很浅显的道理。</p><p>大三阶段的机器人工程师该学什么基础数学是众说纷纭的，在我看来，你要基本掌握“群是什么”，能够用代数的眼光去证明”det(AB) &#x3D; det(A)det(B)”，还要能理解“用一张纸就可以变出克莱因瓶”（当然是在四维空间里）。另外，你这个时候也要能够意识到自己需要再学一遍线性代数。</p><h2 id="大四"><a href="#大四" class="headerlink" title="大四"></a><strong>大四</strong></h2><p>大四开始了，你可以开始深挖自己的研究方向，同时也要开始学一些高级一点的通用技术和理论，这时候你和一般的机械、电子、计算机学生就不太一样了，你虽然也在狂编程，但也在狂学习物理和数学。通用技术包括ROS，simulink，gazebo和Vrep等工具。通用理论包括，再学一遍线性代数，学学凸优化、数值计算、旋转表示法等方面的知识。这些知识你在大四仅仅只能开一个头，因为你的大四要实习、毕业、考研、毕设，你会非常地忙。有些人会在大四进实验室和老师发论文，我个人觉得发论文这件事没必要操之过急。你的整个大学期间应该用在广泛涉猎各种各样的知识上面，而不是深入某一个细小的研究问题。</p><p>大四可以开始读一些著名入门书籍，我把这些书不分先后地列出来，你没有必要全部去读，而且每本书先读前几章就够了，能读多少尽量读多少。</p><ol><li>概率机器人学，<a href="https://link.zhihu.com/?target=https://www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623">https://www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623</a></li><li>凸优化，<a href="https://link.zhihu.com/?target=https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf">https://web.stanford.edu/~boyd&#x2F;cvxbook&#x2F;bv_cvxbook.pdf</a></li><li>线性系统理论，<a href="https://link.zhihu.com/?target=https://www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579">https://www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579</a></li><li>Multiple View Geometry in Computer Vision，<a href="https://link.zhihu.com/?target=http://www.robots.ox.ac.uk/~vgg/hzbook/">Multiple View Geometry in Computer Vision</a></li><li>线性估计，<a href="https://link.zhihu.com/?target=https://www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642">https://www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642</a></li><li>《机器学习》，周志华老师的书。</li><li>An Invitation to 3-D Vision，<a href="https://link.zhihu.com/?target=https://www.eecis.udel.edu/~cer/arv/readings/old_mkss.pdf">https://www.eecis.udel.edu/~cer&#x2F;arv&#x2F;readings&#x2F;old_mkss.pdf</a></li><li>Modern Control Systems，<a href="https://link.zhihu.com/?target=https://www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580">https://www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580</a></li><li>Rigid Body Dynamics，<a href="https://link.zhihu.com/?target=http://authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf">http://authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf</a>。说实话刚体动力学理论我没有找到特别好的书。但是刚体动力学理论很重要。</li><li>Feedback Systems: An Introduction for Scientists and Engineers，<a href="https://link.zhihu.com/?target=http://www.cds.caltech.edu/~murray/amwiki/index.php/Main_Page">FBSwiki</a></li></ol><p>就像我开始说的那样，这些书，大部分特别贵，还好有一些业界良心的作者放出了他们书的电子版。当然你也可以去一些名字都不能说的网站去找影印版。</p><p>在读上面这些书的时候，matlab，python都要放在手边，然后把书里面的知识尽量实践出来。很多教科书里都会在章节后面的习题里放一些写明是用matlab做的习题，要尽量多做一些这样的题。</p><p>你可能早就听说了ROS的大名，但是最好不要在大四之前去碰它。因为ROS用了很多操作系统和网络的底层技术。我在知乎回答<a href="https://www.zhihu.com/question/21958225/answer/20255931">高手可以谈谈ROS机器人操作平台开发的一些经验吗？ - YY硕的回答</a>里有简单的介绍。ROS的设计目标是把机器人的控制和传感器处理的软件和它的硬件隔离开，用上ROS以后，你可以方便地用到很多能直接跑的软件代码。但是ROS从入门到精通需要至少一年以上的时间，你必须不断地用，不断地尝试新的代码和硬件，才能对它熟悉起来。</p><p>ROS的可视化工具Rviz里面对于机器人旋转的表示用的是四元数，而在你之前研究四旋翼飞行器时，里面的代码表示旋转用的是欧拉角，做姿态解算用的可能是四元数。这个时候要开始有意识地去学习旋转表示法之间的区别和联系。</p><p>要重视大四期间的实习和毕业设计。很多大四的学生毕业设计都会非常颓地做一下，我觉得是不好的。要把做毕业设计的过程看做一个正式的项目。这个项目除了做好技术方面的工作，也要做好展示方面的工作。中国工程师的一大特点是，不会表达自己，可能做的东西水平很高，但是做出PPT就会犯字体花哨不正式、一页上面字太多，图文没有联系等表达上的问题。通过PPT介绍、展示自己的成果在工程师的职业生涯的任何一个阶段都非常重要，它甚至也一定程度上限制了机器人工程师能够达到的高度。只有能够把自己的成果清晰地表达给自己的团队，才能获得其他人的反馈、通过沟通提高团队的整体凝聚力和知识水平，这样自己在团队能够获得更多的认可，有助于团队整体工作效率的提高。我每年去参加几次学术会议，都在会议上感觉到一些中国的科研人员走到国际上以后，演讲能力很差就会导致他们的科研成果不受重视。当然其他国家的科研人员也是这样。</p><p>为了写出美观的技术报告和毕业论文，你可以开始学习Latex。Latex作为国际国内第一写作神器，学习资料在网上有很多。Latex的学习和使用同样也是需要不断地熟能生巧，多写多练就熟悉了。写毕业论文有个问题是怎么做出精美的矢量图，我推荐<a href="https://link.zhihu.com/?target=https://inkscape.org/en/">Draw Freely | Inkscape</a>，一个比Illustrator更轻量化、但是有些功能反而更强大的免费软件。</p><p>对于那些想申请出国留学的同学，你要做一个自己个人的成果展示，用网页的形式呈现比较好。把自己Github链接（如果你按我说的，大学第一天就申请Github账号，现在已经是一个三年的老油条了）、做过的机器人视频、写过的技术报告和文章（最好是英文的）放在上面。</p><p>关于毕业设计的选题，我推荐这么几个：</p><ol><li>手写双目视觉里程计。涉及到图像处理、特征匹配、位置解算、空间变换等等。</li><li>手写四旋翼飞行器基于GPS的轨迹规划。涉及到深挖四旋翼飞行器的运动原理、IMU原理、轨迹生成和优化等。</li><li>造一个被推了也不会倒的双足舵机机器人。涉及到舵机控制、倒立摆建模、动力学分析、PID控制、IMU原理等。</li><li>深度学习训练一个小车追人跑。涉及到深度学习工具包使用、数据集采集、数据集分析、小车控制等。</li><li>机械臂给人端茶倒水。这个相对来说土豪一点，因为能直接拿来用的机械臂都很贵，这个要看实验室有没有条件了。涉及到多自由度机械臂原理的学习、工具包的使用、轨迹规划等等。</li></ol><p>这几个项目要做好，都要持续投入三个月以上的时间以及一定的资金，每一个都是理论多于实践。当然同学们自己也可以自己选择自己的毕业设计题目，但是最好还是选做出来能跑能飞的东西，同时避免选择需要花大量时间去拧螺丝、焊板子的题目，尽量买现成的电机、开发板、3D打印结构，大四要多给自己留时间去看书和写代码。</p><p>大四到研究生之前的暑假，最好去一些比较不错的机器人公司实习一下，比如说大疆。当然你也可以继续做机器人比赛，比如RoboMasters和大疆的飞行器比赛。</p><h2 id="研究生一年级"><a href="#研究生一年级" class="headerlink" title="研究生一年级"></a><strong>研究生一年级</strong></h2><p>研究生的时候，你的目标比较清晰了，就是做一种机器人至少两年时间，并从中发掘出可以发表论文的知识点。上面我给出的书单里面，你要开始精读里面的几本。</p><p>如果做机器人视觉定位、传感器融合方面的研究，1、4、5、7四本书一定要精读。</p><p>如果做控制系统的研究，3、8、9、10一定要精读。</p><p>如果做规划算法的研究，那么还要读其他偏CS一些的书，比如讲A* search，random forest，图论方面知识的教材。由于我在这方面造诣不深，就不托大了。</p><p>如果学习随机系统的控制和最优控制，除了1、2、3，还要读一本神书Stochastic models estimation and control（<a href="https://link.zhihu.com/?target=https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf">https://www.cs.unc.edu/~welch&#x2F;kalman&#x2F;media&#x2F;pdf&#x2F;maybeck_ch1.pdf</a>）。</p><p>如果研究机器人视觉定位，几种常用的定位算法：PTAM（<a href="https://link.zhihu.com/?target=http://www.robots.ox.ac.uk/~gk/PTAM/">Parallel Tracking and Mapping for Small AR Workspaces (PTAM)</a>），ROS的标配VO（<a href="https://link.zhihu.com/?target=http://wiki.ros.org/viso2_ros">viso2_ros - ROS Wiki</a>），SVO（<a href="https://link.zhihu.com/?target=https://github.com/uzh-rpg/rpg_svo">GitHub - uzh-rpg&#x2F;rpg_svo: Semi-direct Visual Odometry</a>），LSD-SLAM（<a href="https://link.zhihu.com/?target=http://vision.in.tum.de/research/vslam/lsdslam">http://vision.in.tum.de/research/vslam/lsdslam</a>）ORB-SLAM（<a href="https://link.zhihu.com/?target=https://github.com/raulmur/ORB_SLAM2">GitHub - raulmur&#x2F;ORB_SLAM2: Real-Time SLAM for Monocular, Stereo and RGB-D Cameras, with Loop Detection and Relocalization Capabilities</a>），都必须自己学习之后全部跑一遍。只会用OpenCV的函数和这些工具包并不能说明你会视觉定位，必须要能自己手写出一个能用的才算。国内有一个很厉害的SLAM专家叫高翔，他的博客要关注一下：<a href="https://link.zhihu.com/?target=http://www.cnblogs.com/gaoxiang12/tag/%E6%9C%BA%E5%99%A8%E4%BA%BA/">机器人 - 标签</a>。由于SLAM这两年很火，研究的人很多，所以网上可以参考的资料也很多，比如<a href="https://link.zhihu.com/?target=https://github.com/hcdth011/ROS-Hydro-SLAM">https://github.com/hcdth011/ROS-Hydro-SLAM</a>，就在ROS上实现了几种定位算法的对比。</p><p>我现在非常不建议同学们选择从四旋翼飞行器的动力学控制里找问题作为研究课题。因为四旋翼飞行器的特点已经被研究透了。目前国际上对多旋翼飞行器的研究主要集中在造一些奇葩形状的飞行器，以及给多旋翼飞行器上安装一个机械臂去做力控制，这样做就对多旋翼飞行器控制的动力学造成了一些影响。因此需要同学对动力学和多自由度机械臂控制有比较深的认识。</p><p>自动导航和驾驶是这两年的热点，一方面汽车的自动化是大势所趋，另一方面多旋翼飞行器异军突起，产生了很多对自动飞行的需求。除了机器人视觉定位算法以外，同学还需要学习其他的传感器，以及这些传感器与视觉定位算法怎么融合。这里面有很多坑，比如计算量的问题，怎么保证融合算法不崩，怎么处理传感器的延时等等，都需要同学结合自己的项目去踩，坑踩得多了才能成长。如果大家想找一个多旋翼飞行器平台研究自动导航，我推荐大疆的M100，我已经在知乎回答<a href="https://www.zhihu.com/question/31586826/answer/65274168">RoboMasters2015夏令营是怎样的？ - YY硕的回答</a>里吹过一波M100，前面说过的今年夏令营的知乎回答<a href="https://www.zhihu.com/question/49986388">参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新</a>里也有人帮我吹了一波。</p><p>一些大学里学过的知识点，是必须结合研究生期间的项目的需求弄得很清楚的，比如三大变换（傅里叶变换，拉普拉斯变换，Z变换），旋转表示法（欧拉角、四元数、旋转矩阵），数值计算怎么防止矩阵出现数值问题等等。除了自己的项目，还需要把凸优化、卡尔曼滤波还有多自由度机械臂的控制学习一下。这三个领域的知识，是任何一种机器人都会用的到比较难的知识。</p><p>凸优化和凸优化的各种变形是非常重要的知识，因为各行各业里的研究问题，多半是会建立一个优化问题去解决的。上面提到的《Convex Optimization》<a href="https://link.zhihu.com/?target=https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf">https://web.stanford.edu/~boyd&#x2F;cvxbook&#x2F;bv_cvxbook.pdf</a>，也是一本神书，同学们一定要认真读一读。Matlab、Python、C++都有一些现成的工具包可以帮助你解优化问题，不过最好同学们能自己手写一些基本的优化算法，比如gradient descend，barrier method等等。另外现在主流的SLAM算法，后端都是通过一种叫做g2o的优化算法来出效果的。而且g2o能够整合bundle adjustment 和structure-from-motion这两大计算机视觉里的关键问题，可以说是一种很好的计算思想了，非常有必要学习一下g2o。</p><p>卡尔曼滤波在上面书单里的1和3都有提到，同时在神书Stochastic models estimation and control（<a href="https://link.zhihu.com/?target=https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf">https://www.cs.unc.edu/~welch&#x2F;kalman&#x2F;media&#x2F;pdf&#x2F;maybeck_ch1.pdf</a>）也有相当多的篇幅。卡尔曼滤波有好几种证明的方法，同学最好能自己学会1-2种。</p><p>多自由度的机械臂的难点在于机械臂的运动学正反解、运动学控制和动力学控制，基本是一个建模分析和数值算法实现的问题。如果你所在的学校没有一个财力雄厚的机器人实验室的话，你基本上没有机会接触到多自由度的机械臂。这时候之前学到的Simulink和就要学的Gazebo就派上用场了，你可以用Simscape里面的刚体搭一个多自由度机械臂，然后通过Simulink仿真去学习机械臂的控制；也可以用Gazebo的URDF语言写一个机械臂，然后通过Gazebo和ROS的接口去控制机械臂；也可以用ROS里面的著名工具包<a href="https://link.zhihu.com/?target=http://moveit.ros.org/">MoveIt! Motion Planning Framework</a>，不过MoveIt的问题是，他只能仿真运动学，而不能仿真动力学。工业领域对多自由度的机械臂控制通常用一个叫做D-H表示法的建模工具（<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters">Denavit</a>），这个东西我并不太会。我只会向同学们推荐我导师的著作《A mathematical introduction to robotic manipulation》（<a href="https://link.zhihu.com/?target=http://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf">http://www.cds.caltech.edu/~murray&#x2F;books&#x2F;MLS&#x2F;pdf&#x2F;mls94-complete.pdf</a>）。</p><p>有一个非常神奇的事实：《A mathematical introduction to robotic manipulation》这本机械臂控制领域的著名教材的第二章和计算机视觉领域的著名教材《An Invitation to 3-D Vision》的第二章基本是一样的，都在讲旋转表示法。这是因为所有的旋转表示法都可以归纳为一种优雅的李群结构：SO(3)群。而计算机视觉和机械臂控制都涉及到理解刚体的旋转，事实上用计算系统去观测和控制所有的刚体构成的系统，理解旋转都是很关键的问题。旋转表示法应该作为研究生阶段的一个重要学习的知识点。</p><p>李群和李代数是刚体旋转表示背后的数学理论，如果想要深挖一些，可以看这篇文章An elementary introduction to groups and representations的前50页（<a href="https://link.zhihu.com/?target=http://www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf">http://www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf</a>）。这是我自己读着觉得最好的文章，当然网上也有很多其他的介绍。</p><p>研究生阶段还要培养的一个能力是借助各种工具仿真机器人系统的能力。显然地，很多机器人系统真的造出来的话造价昂贵，需要在实际制造之前写一个比较真实的仿真系统出来测试算法。我觉得做仿真系统的能力直接衡量了机器人工程师的技术水平。当你开始要搭一个仿真系统的时候，第一步是通过欧拉方程和牛顿方程确定刚体的运动特点，甚至要自己写刚体二阶微分方程；第二步是确定刚体之间的互联关系，设计不同类型的关节，如果有软性连接需要加入弹簧阻尼模型；第三步是确定被仿真的刚体系统会不会和外界产生碰撞或者其他形式的力，如果有的话，需要设计合适的接触力和摩擦力仿真的模型。多旋翼飞行器的仿真是很简单的，不需要考虑什么接触力。但是多自由度机械臂基本都需要仿真接触力，不和物理世界去交互的机械臂只有很小的实用意义。而能够自行运动locomotion系统，比如双足、多足机器人，则涉及到更多的接触力，多到接触力都会影响仿真系统的数值稳定性。搭建一个仿真系统需要很强的系统建模能力和数值分析的能力，虽然Simulink、Gazebo、Vrep提供了不同程度的工具简化你的工作，但是要让仿真系统能够稳定运行，必须要能深入其中的细节。有些看起来很高大上的仿真工具，比如Nvida的PhysX，在仿真的时候是忽略掉科里奥利力的，如果不理解仿真的本质，可能就会忽略这一个重要的缺陷。</p><h2 id="研究生二年级"><a href="#研究生二年级" class="headerlink" title="研究生二年级"></a><strong>研究生二年级</strong></h2><p>你的学习计划接近尾声。现在你已经进入了一个很好的状态：看到一个机器人，能够很果断地分析出它用了什么传感器、执行器、计算平台大概是什么量级，他的执行机构能够承受多少力量。看到一个新的算法，能够大约判断清楚它的执行流程，在什么环节做了优化。看到一个新的没学过的知识，能够分析出它和你以前学过的什么知识有联系，你还需要再学什么才能弄明白这个知识点。</p><p>研究生二年级要深化第一年学到的那些技术和知识，要做到完整地读过四五本书，五十篇以上的论文。你已经积累了几万行代码的经验，也能熟练地谈论谁家的电机回差小，谁家的电机线性程度好。</p><p>你这个时候可以去写作一些论文，也可以开始学习一些更高级的技术和工具，比如用FPGA和GPU优化算法、魔改Linux内核、玩玩液压系统、了解更多机器学习的知识比如强化学习等等。你也可以从计算机图形学或者计算力学里面找到一些帮助你更好进行机器人仿真和系统分析的工具。由于你懂很多机器人方面的知识，你可以给学校的机器人队做指导，或者带队参加一些比较有挑战性的机器人比赛。</p><p>写到这里，我就不可能给出很多不同领域的指导了，因为随着学习的进一步深化，我自己熟悉的领域也在收缩。我只能对几个领域给出我的意见。</p><p>对视觉定位和传感器融合来说，SLAM急需新的突破，目前通过几何约束去实现loop closure看起来已经走入了死路，没法有更多的发展了，下一步可行的方向是与深度学习进行结合。具体的一些介绍可以阅读行业中大牛的一篇文章<a href="https://link.zhihu.com/?target=http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html">http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html</a>，记述了几个业界大牛们最新的观点。传感器融合技术，目前还有很多问题可以探索，因为传感器的延时、不均匀的信号，会给定位系统造成困扰，如何去除这些干扰，需要建立比较复杂的非线性优化问题，具体可以关注香港科技大学Shaojie Shen的工作。</p><p>对于多自由度机械手和机器人的locomotion来说，这里面还有非常多可以探索的研究问题。我前面提过接触力和摩擦力很难仿真，大神告诉我现在没有任何一种工具和理论能把接触力和摩擦力正确仿真出来，因此如何在机器人系统里妥善处理对这些力的控制，就是很难的问题了。现在业界的一个前沿发展方向，也是利用机器学习技术来帮助机器人学会处理这些外力，不过人类目前最优秀的多自由度机器人系统，Berkeley的Brett机器人，叠几块积木就要用十分钟（<a href="https://link.zhihu.com/?target=http://news.berkeley.edu/2015/05/21/deep-learning-robot-masters-skills-via-trial-and-error/">New ‘deep learning’ technique enables robot mastery of skills via trial and error</a>），显然还有很多提升的空间。这方面的问题同学可以关注知乎大神</p><p><a href="https://www.zhihu.com/people/70bcce80353eccd2938cbfa2ac856aab">@戴泓楷</a></p><p><a href="https://www.zhihu.com/people/0eeca981bb238839881694643181fa91">@周佳骥</a></p><p>。</p><p>最后我想再强调一遍表达能力的重要性。你可以从自己带的课程和机器人队入手，把自己这几年来学过的知识做成PPT讲给学生们听，然后让他们给你反馈。多做这样的练习，提升自己做演讲的能力，这将来会让你受益匪浅。</p><p>研究生二年级之后，你可以准备进机器人公司工作了，也可以根据你自己感兴趣的研究方向申请博士接着努力。由于你已经掌握了广博的知识和技能，你的职业生涯将会大有作为。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a><strong>结束语</strong></h2><p>我从2008年展开自己的机器人生涯。那一年波士顿动力刚刚发布他们的大狗机器人，Python还是很小众的语言，Ubuntu 8.04还很不稳定，Chrome还没有多少人知道。在之后的几年中我目击了深度神经网络的复兴，看到波士顿动力的机器人日渐强大，经历了ROS的起源和繁荣，帮助了大疆的崛起，深深为这个产业的未来感到激动。我希望这篇文章能够帮助更多的年轻人进入机器人学的海洋，为未来机器人学的继续发展贡献力量。</p>]]></content>
      
      
      <categories>
          
          <category> 机器人学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Robotics learning path </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS</title>
      <link href="/2024/01/29/FreeRTOS/"/>
      <url>/2024/01/29/FreeRTOS/</url>
      
        <content type="html"><![CDATA[<p>文档：</p><p><a href="https://rtos.100ask.net/zh/FreeRTOS/DShanMCU-F103/chapter6.html">https://rtos.100ask.net/zh/FreeRTOS/DShanMCU-F103/chapter6.html</a></p><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a><strong>项目介绍</strong></h1><p>裸机:</p><img src="/2024/01/29/FreeRTOS/image-20240116111924666.png" alt="image-20240116111924666" style="zoom:35%;"><p>freerots:</p><img src="/2024/01/29/FreeRTOS/image-20240116112000983.png" alt="image-20240116112000983" style="zoom:35%;"><img src="/2024/01/29/FreeRTOS/image-20240116112750136.png" alt="image-20240116112750136" style="zoom:67%;"><p>涉及到三个项目：音乐播放        打砖块游戏，汽车游戏</p><p><img src="/2024/01/29/FreeRTOS/image-20240116193203709.png" alt="image-20240116193203709"></p><p><img src="/2024/01/29/FreeRTOS/image-20240116201310758.png" alt="image-20240116201310758"></p><p>2-2,2-3讲自己创建一个freertos工程</p><p>从3.1开始正式讲freertos</p><h2 id="创建第一个多任务程序"><a href="#创建第一个多任务程序" class="headerlink" title="创建第一个多任务程序"></a>创建第一个多任务程序</h2><p>不同的嵌入式操作系统，如freertos,rt-thread,它们对相同的一个操作的函数名称不同，为了统一起来，增加了一个接口层cmsis_os ,我们直接用这个文件的函数就行了，这个函数会根据不同的操作系统进行选择相应的代码，这样你写出来的代码既可以运行在freertos也可以在rt-thread上。</p><p>创建工程时默认生成的任务，osThreadNew为cmsis_os中定义的函数</p><p><img src="/2024/01/29/FreeRTOS/image-20240117222125768.png" alt="image-20240117222125768"></p><p>我们要等会要用的是freertos的原生代码去创建任务</p><p><img src="/2024/01/29/FreeRTOS/image-20240117223144328.png" alt="image-20240117223144328"></p><p>在此创建自己的任务函数</p><p><img src="/2024/01/29/FreeRTOS/image-20240117224413771.png" alt="image-20240117224413771"></p><p>在此处创建自己的任务</p><p><img src="/2024/01/29/FreeRTOS/image-20240117224427446.png" alt="image-20240117224427446"></p><h1 id="ARM架构简明教程-硬件架构与汇编指令"><a href="#ARM架构简明教程-硬件架构与汇编指令" class="headerlink" title="ARM架构简明教程_硬件架构与汇编指令"></a>ARM架构简明教程_硬件架构与汇编指令</h1><p>我们去创建一个任务的时候，为什么要指定栈，你理解了栈之后，才能深入理解RTOS的本质，要想理解栈，你得对处理器的架构有所了解</p><p><img src="/2024/01/29/FreeRTOS/image-20240117225222942.png" alt="image-20240117225222942"></p><h2 id="ARM架构"><a href="#ARM架构" class="headerlink" title="ARM架构"></a>ARM架构</h2><p>CPU(计算)， 内存（RAM） ，FLSAH</p><p><strong>RISC</strong></p><p>ARM芯片属于精简指令集计算机(RISC：Reduced Instruction Set Computing)，它所用的指令比较简单，有如下特点：</p><p>① 对<strong>内存</strong>只有<strong>读、写</strong>指令</p><p>② 对于数据的<strong>运算</strong>是在<strong>CPU</strong>内部实现</p><p>③ 使用RISC指令的CPU复杂度小一点，易于设计</p><p><img src="/2024/01/29/FreeRTOS/09_arm.png" alt="09_arm"></p><p>对于上图所示的乘法运算a &#x3D; a * b，</p><p>在RISC中要使用4条汇编指令：</p><p>① 读内存a</p><p>② 读内存b</p><p>③ 计算a*b</p><p>④ 把结果写入内存</p><p><strong>提出问题</strong></p><p>问题：在CPU内部，用什么来保存a、b、a*b ？</p><p><strong>CPU内部寄存器</strong></p><p>CPU, 内存 , FLASH</p><p><img src="/2024/01/29/FreeRTOS/10_cpu.png" alt="10_cpu"></p><p>无论是cortex-M3&#x2F;M4，</p><p>还是cortex-A7，</p><p>CPU内部都有R0、R1、……、R15寄存器；</p><p>它们可以用来“暂存”数据。</p><p><img src="/2024/01/29/FreeRTOS/11_regs.png" alt="11_regs"></p><p>对于R13、R14、R15，还另有用途：</p><p>R13：别名<strong>SP</strong>(Stack Pointer)，栈指针</p><p>R14：别名<strong>LR</strong>(Link Register)，用来保存返回地址</p><p>R15：别名<strong>PC</strong>(Program Counter)，程序计数器，表示当前指令地址，写入新值即可跳转（往PC寄存器写入某个值，它就会跳过去执行对应的代码）</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><ul><li><p>读内存：Load</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line">LDR  R0, [R1, #4]  ; 读地址&quot;R1+4&quot;, 得到的4字节数据存入R0</span><br></pre></td></tr></table></figure></li><li><p>写内存：Stroe</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line">STR  R0, [R1, #4]  ; 把R0的4字节数据写入地址&quot;R1+4&quot;</span><br></pre></td></tr></table></figure></li><li><p>加减</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD R0, R1, R2  ; R0=R1+R2</span><br><span class="line">ADD R0, R0, #1  ; R0=R0+1</span><br><span class="line">SUB R0, R1, R2  ; R0=R1-R2</span><br><span class="line">SUB R0, R0, #1  ; R0=R0-1</span><br></pre></td></tr></table></figure></li><li><p>比较</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMP R0, R1  ; 结果保存在PSR(程序状态寄存器)</span><br></pre></td></tr></table></figure></li><li><p>跳转 (调用函数)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B  main  ; Branch, 直接跳转</span><br><span class="line">BL main  ; Branch and Link, 先把返回地址保存在LR寄存器里再跳转 （1.LR=返回地址（下一条指令），2.PC=调用函数的地址。 往PC寄存器写入某个值，它就会跳过去执行对应的代码）</span><br></pre></td></tr></table></figure><p>局部变量都保存在栈里。</p></li></ul><h3 id="C函数的反汇编"><a href="#C函数的反汇编" class="headerlink" title="C函数的反汇编"></a>C函数的反汇编</h3><p>C函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> a, <span class="keyword">volatile</span> <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> sum;</span><br><span class="line">    sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让Keil生成反汇编：（通过反汇编码，更好的理解栈）</p><p><img src="/2024/01/29/FreeRTOS/默认放置文件夹/Freertos/DShanMCU-F103开发板资料/5_程序源码/02_FreeRTOS程序/04_视频配套的文档/pic/12_keil_dis.png" alt="image-20230822132428937"></p><p>为例方便复制，制作反汇编的指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fromelf  --text  -a -c  --output=xxx.dis  xxx.axf</span><br></pre></td></tr></table></figure><p>C函数add的反汇编代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i.add</span><br><span class="line">add</span><br><span class="line">    0x08002f34:    b503        ..      PUSH     &#123;r0,r1,lr&#125;</span><br><span class="line">    0x08002f36:    b081        ..      SUB      sp,sp,#4</span><br><span class="line">    0x08002f38:    e9dd0101    ....    LDRD     r0,r1,[sp,#4]</span><br><span class="line">    0x08002f3c:    4408        .D      ADD      r0,r0,r1</span><br><span class="line">    0x08002f3e:    9000        ..      STR      r0,[sp,#0]</span><br><span class="line">    0x08002f40:    bd0e        ..      POP      &#123;r1-r3,pc&#125;</span><br></pre></td></tr></table></figure><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><h3 id="堆（heap）"><a href="#堆（heap）" class="headerlink" title="堆（heap）"></a>堆（heap）</h3><p>所谓堆，就是一块空闲的内存，你也可以管理这块内存，从其中取出（malloc）一部分，用完之后再把它释放(free)回去。</p><p>堆，heap，就是一块空闲的内存，需要提供管理函数 </p><ul><li>malloc：从堆里划出一块空间给程序使用</li><li>free：用完后，再把它标记为”空闲”的，可以再次使用</li></ul><h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 (stack)"></a>栈 (stack)</h3><p>栈是RTOS的基础,也是一块内存空间，CPU的SP寄存器指向它，可以用于<strong>函数调用，局部变量，多任务系统里保存现场</strong>，每一个任务都会有自己的栈。栈在内存（RAM）中。</p><p>栈，stack，函数调用时局部变量保存在栈中，当前程序的环境也是保存在栈中 </p><ul><li>可以从堆中分配一块空间用作栈</li></ul><p>提问1：LR被覆盖了，怎么办？</p><img src="/2024/01/29/FreeRTOS/image-20240118193830901.png" alt="image-20240118193830901" style="zoom:80%;"><p>答：在C入口，会首先划分出自己的栈，保存LR进栈里，保存局部变量，在每个函数的入口都会保存LR 以及必要的寄存器，以防后面操作将其覆盖</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g_cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">b_func</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">  a+=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">c_func</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">  a+=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">a_func</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  g_cnt=b_func(a);</span><br><span class="line">  g_cnt=c_func(g_cnt);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i=<span class="number">99</span>;</span><br><span class="line">a_func(i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码里，进入main函数后先调用a函数，然后在a函数中分别调用b,c函数</p><p>下面是对应的反汇编代码</p><p>第9行 BL a_func</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i.main</span><br><span class="line">    main</span><br><span class="line">        0x08000188:    b508        ..      PUSH     &#123;r3,lr&#125;</span><br><span class="line">        0x0800018a:    2063        c       MOVS     r0,#0x63</span><br><span class="line">        0x0800018c:    9000        ..      STR      r0,[sp,#0]</span><br><span class="line">        0x0800018e:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">        0x08000190:    f7ffffde    ....    BL       a_func ; 0x8000150</span><br><span class="line">        0x08000194:    2000        .       MOVS     r0,#0</span><br><span class="line">        0x08000196:    bd08        ..      POP      &#123;r3,pc&#125;</span><br></pre></td></tr></table></figure><p>a_func: 调用了b_func ,c_func</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a_func</span><br><span class="line">    0x08000150:    b501        ..      PUSH     &#123;r0,lr&#125;</span><br><span class="line">    0x08000152:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">    0x08000154:    f000f80c    ....    BL       b_func ; 0x8000170</span><br><span class="line">    0x08000158:    4904        .I      LDR      r1,[pc,#16] ; [0x800016c] = 0x20000004</span><br><span class="line">    0x0800015a:    6008        .`      STR      r0,[r1,#0]</span><br><span class="line">    0x0800015c:    4608        .F      MOV      r0,r1</span><br><span class="line">    0x0800015e:    6800        .h      LDR      r0,[r0,#0]</span><br><span class="line">    0x08000160:    f000f80c    ....    BL       c_func ; 0x800017c</span><br><span class="line">    0x08000164:    4901        .I      LDR      r1,[pc,#4] ; [0x800016c] = 0x20000004</span><br><span class="line">    0x08000166:    6008        .`      STR      r0,[r1,#0]</span><br><span class="line">    0x08000168:    bd08        ..      POP      &#123;r3,pc&#125;</span><br></pre></td></tr></table></figure><p>b_func</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b_func</span><br><span class="line">    0x08000170:    b501        ..      PUSH     &#123;r0,lr&#125;</span><br><span class="line">    0x08000172:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">    0x08000174:    1c80        ..      ADDS     r0,r0,#2</span><br><span class="line">    0x08000176:    9000        ..      STR      r0,[sp,#0]</span><br><span class="line">    0x08000178:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">    0x0800017a:    bd08        ..      POP      &#123;r3,pc&#125;</span><br></pre></td></tr></table></figure><p>c_func</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c_func</span><br><span class="line">        0x0800017c:    b501        ..      PUSH     &#123;r0,lr&#125;</span><br><span class="line">        0x0800017e:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">        0x08000180:    1c80        ..      ADDS     r0,r0,#2</span><br><span class="line">        0x08000182:    9000        ..      STR      r0,[sp,#0]</span><br><span class="line">        0x08000184:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">        0x08000186:    bd08        ..      POP      &#123;r3,pc&#125;</span><br></pre></td></tr></table></figure><p>对应的栈区域以及里面的内容</p><img src="/2024/01/29/FreeRTOS/image-20240118204432237.png" alt="image-20240118204432237" style="zoom:80%;"><p>提问2：<strong>局部变量</strong>在栈中是如何分配的？</p><p><img src="/2024/01/29/FreeRTOS/image-20240118231052162.png" alt="image-20240118231052162"></p><p>变量ch,buf,uch这三个变量没加volatile，它们优先使用寄存器来表示（随着变量越来越多，寄存器不够用，就在栈里分配空间）；变量i用了volatile,它在栈里给你分配了空间</p><p>提问3：为什么每个RTOS任务都有自己的栈？</p><p>每个任务都有自己的调用关系，自己的局部变量和现场</p><p><img src="/2024/01/29/FreeRTOS/image-20240119153109460.png" alt="image-20240119153109460"></p><p>​           </p><p>恢复现场：找到任务的结构体，得到任务的栈，SP地址，将寄存器的值从栈里恢复到CPU里面</p><h1 id="FreeRTOS源码结构概述"><a href="#FreeRTOS源码结构概述" class="headerlink" title="FreeRTOS源码结构概述"></a>FreeRTOS源码结构概述</h1><h2 id="FreeRTOS目录结构"><a href="#FreeRTOS目录结构" class="headerlink" title="FreeRTOS目录结构"></a>FreeRTOS目录结构</h2><p>使用STM32CubeMX创建的FreeRTOS工程中，FreeRTOS相关的源码如下:</p><p><img src="/2024/01/29/FreeRTOS/image1.png" alt="img"></p><p>主要涉及2个目录：</p><ul><li>Core <ul><li>Inc目录下的FreeRTOSConfig.h是配置文件</li><li>Src目录下的freertos.c是STM32CubeMX创建的默认任务</li></ul></li><li>Middlewares\Third_Party\FreeRTOS\Source <ul><li>根目录下是<strong>核心文件</strong>，这些文件是通用的</li><li>portable目录下是移植时需要实现的文件 <ul><li>目录名为：[compiler]&#x2F;[architecture]</li><li>比如：RVDS&#x2F;ARM_CM3，这表示cortexM3架构在RVDS工具上的移植文件</li></ul></li></ul></li></ul><p>7.2核心文件 FreeRTOS的<strong>最核心</strong>文件只有2个：</p><ul><li><p>FreeRTOS&#x2F;Source&#x2F;tasks.c</p></li><li><p>FreeRTOS&#x2F;Source&#x2F;list.c</p><p>其他文件的作用也一起列表如下：</p><p><img src="/2024/01/29/FreeRTOS/image2.jpg" alt="image2"></p></li></ul><h2 id="移植时涉及的文件"><a href="#移植时涉及的文件" class="headerlink" title="移植时涉及的文件"></a>移植时涉及的文件</h2><p>移植FreeRTOS时涉及的文件放在 <strong>FreeRTOS&#x2F;Source&#x2F;portable&#x2F;[compiler]&#x2F;[architecture]</strong> 目录下，比如：RVDS&#x2F;ARM_CM3，这表示cortexM3架构在RVDS或Keil工具上的移植文件。 里面有2个文件：</p><ul><li>port.c</li><li>portmacro.h</li></ul><h2 id="头文件相关"><a href="#头文件相关" class="headerlink" title="头文件相关"></a><strong>头文件相关</strong></h2><p> 头文件目录</p><p>FreeRTOS需要3个头文件目录：</p><ul><li>FreeRTOS本身的头文件：</li></ul><p>Middlewares\Third_Party\FreeRTOS\Source\include</p><ul><li>移植时用到的头文件：</li></ul><p>Middlewares\Third_Party\FreeRTOS\Source\portable[compiler][architecture]</p><ul><li>含有配置文件FreeRTOSConfig.h的目录：Core\Inc</li></ul><p> 头文件</p><p>列表如下：</p><p><img src="/2024/01/29/FreeRTOS/image3.jpg" alt="image3"></p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong>内存管理</strong></h2><p>文件在Middlewares\Third_Party\FreeRTOS\Source\portable\MemMang下，它也是放在“portable”目录下，表示你可以提供自己的函数。</p><p>源码中默认提供了5个文件，对应内存管理的5种方法。</p><p>后续章节会详细讲解。</p><p><img src="/2024/01/29/FreeRTOS/image4.jpg" alt="image4"></p><h2 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h2><p>在Core\Src\main.c的main函数里，初始化了FreeRTOS环境、创建了任务，然后启动调度器。源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Init scheduler */</span></span><br><span class="line">  osKernelInitialize();  <span class="comment">/* 初始化FreeRTOS运行环境 */</span></span><br><span class="line">  MX_FREERTOS_Init();    <span class="comment">/* 创建任务 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Start scheduler */</span></span><br><span class="line">  osKernelStart();       <span class="comment">/* 启动调度器 */</span></span><br></pre></td></tr></table></figure><h2 id="数据类型和编程规范"><a href="#数据类型和编程规范" class="headerlink" title="数据类型和编程规范"></a>数据类型和编程规范</h2><p><strong>数据类型</strong></p><p>每个移植的版本都含有自己的portmacro.h头文件，里面定义了2个数据类型：</p><ul><li>TickType_t： <ul><li>FreeRTOS配置了一个周期性的时钟中断：Tick Interrupt</li><li>每发生一次中断，中断次数累加，这被称为tick count</li><li>tick count这个变量的类型就是TickType_t</li><li>TickType_t可以是16位的，也可以是32位的</li><li>FreeRTOSConfig.h中定义configUSE_16_BIT_TICKS时，TickType_t就是uint16_t</li><li>否则TickType_t就是uint32_t</li><li>对于32位架构，建议把TickType_t配置为uint32_t</li></ul></li><li>BaseType_t： <ul><li>这是该架构最高效的数据类型</li><li>32位架构中，它就是uint32_t</li><li>16位架构中，它就是uint16_t</li><li>8位架构中，它就是uint8_t</li><li><strong>BaseType_t通常用作简单的返回值的类型，还有逻辑值，比如pdTRUE&#x2F;pdFALSE</strong></li><li><strong>在 RTOS 中，函数的返回值不仅仅局限于0、1和-1这样的简单逻辑值，它还可能表示优先级、任务句柄等多种信息，这些信息在某些情况下可能需要用到较大的数据宽度。因此，使用 <code>BaseType_t</code> 可以灵活适应各种情况。</strong></li></ul></li></ul><p><strong>变量名</strong></p><p>变量名有前缀：</p><p><img src="/2024/01/29/FreeRTOS/image5.jpg" alt="image5"></p><p><strong>函数名</strong></p><p>函数名的前缀有2部分：返回值类型、在哪个文件定义。</p><p><img src="/2024/01/29/FreeRTOS/image6.jpg" alt="image6"></p><p><strong>宏的名</strong></p><p>宏的名字是大小，可以添加小写的前缀。前缀是用来表示：宏在哪个文件中定义。</p><p><img src="/2024/01/29/FreeRTOS/image7.jpg" alt="image7"></p><p>通用的宏定义如下：</p><p><img src="/2024/01/29/FreeRTOS/image8.jpg" alt="image8"></p><h2 id="内存分配（栈）"><a href="#内存分配（栈）" class="headerlink" title="内存分配（栈）"></a>内存分配（栈）</h2><p>为了让FreeRTOS更容易使用，这些内核对象一般都是动态分配：用到时分配，不使用时释放。使用内存的动态管理功能，简化了程序设计：不再需要小心翼翼地提前规划各类对象，简化API函数的涉及，甚至可以减少内存的使用。</p><p>注意：我们经常”堆栈”混合着说，其实它们不是同一个东西：</p><ul><li><p>堆，heap，就是一块空闲的内存，需要提供管理函数 </p><ul><li>malloc：从堆里划出一块空间给程序使用</li><li>free：用完后，再把它标记为”空闲”的，可以再次使用</li></ul></li><li><p>栈，stack，函数调用时局部变量保存在栈中，当前程序的环境也是保存在栈中 </p><ul><li>可以从堆中分配一块空间用作栈</li></ul><img src="/2024/01/29/FreeRTOS/Temp\Temp\image1.png" alt="image1" style="zoom:80%;"></li></ul><p>FreeRTOS中内存管理的接口函数为：pvPortMalloc 、vPortFree，对应于C库的malloc、free。</p><p>cubemx中关于栈的配置：</p><img src="/2024/01/29/FreeRTOS/image-20240120112427199.png" alt="image-20240120112427199" style="zoom:67%;"><p><img src="/2024/01/29/FreeRTOS/image-20240120113241290.png" alt="image-20240120113241290"></p><p>用一个ucHeap数组来表示堆</p><p><img src="/2024/01/29/FreeRTOS/image-20240120112644538.png" alt="image-20240120112644538"></p><img src="/2024/01/29/FreeRTOS/image-20240120113523411.png" alt="image-20240120113523411" style="zoom:80%;"><p>heap4会合并相邻的空闲buffer，所以可解决碎片问题，一般都有heap4，如果有多块内存用heap5</p><p><img src="/2024/01/29/FreeRTOS/image-20240120114435751.png" alt="image-20240120114435751"></p><p>比如你想知道你分配的3072字节的栈空间够不够用，你可以让程序跑一段时间，然后调用这个函数来看看，如果它接近个位数或十位数，则容量很危险，我们要把栈空间分配大一点</p><h1 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h1><p>三要素：函数，栈，优先级</p><p>TCB:任务控制块（任务结构体）</p><p>任务控制块(TCB)通常包含了以下内容：</p><ul><li>任务堆栈指针：指向任务堆栈的顶部。</li><li>任务优先级：表示该任务的优先级等级。</li><li>任务状态：如运行、就绪、阻塞、挂起等。</li><li>延时计数器和超时时间：用于处理任务延时和超时唤醒。</li><li>其他可能的信息：如任务入口函数地址、任务ID或名称等。</li></ul><p>当创建一个新任务时，FreeRTOS会为该任务分配并初始化一个TCB，并返回这个TCB的指针作为任务句柄。这样，在后续操作中，通过任务句柄就能间接访问和修改对应任务的所有信息。</p><h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><p>a.动态分配</p><p><img src="/2024/01/29/FreeRTOS/image-20240120162524684.png" alt="image-20240120162524684"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">( TaskFunction_t pxTaskCode, <span class="comment">// 函数指针, 任务函数</span></span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, <span class="comment">// 任务的名字</span></span></span><br><span class="line"><span class="params">                        <span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="comment">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class="line"><span class="params">                        <span class="type">void</span> * <span class="type">const</span> pvParameters, <span class="comment">// 调用任务函数时传入的参数</span></span></span><br><span class="line"><span class="params">                        UBaseType_t uxPriority,    <span class="comment">// 优先级</span></span></span><br><span class="line"><span class="params">                        TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span>; <span class="comment">// 任务句柄, 以后使用它来操作这个任务</span></span><br></pre></td></tr></table></figure><p>pxTaskCode: 函数指针，指向我们的任务函数，在这里写我们自己写的任务函数的函数名。</p><p>pcName：任务名，没啥用，自己随便取，eg:  “LightTask”</p><p>usStackDepth: 栈大小，单位为字(word),一个字的大小取决于计算机处理器的位数。在大多数现代计算机中，一个字的大小通常是32位或64位，也就是说，一个字的大小通常是4个字节或8个字节。</p><p>pvParameters: 调用任务函数时传入的参数，即pxTaskCode的参数，如果它没有参数，直接写NULL就行</p><p>uxPriority：优先级范围：0~(configMAX_PRIORITIES – 1) 数值越小优先级越低， 如果传入过大的值，xTaskCreate会把它调整为(configMAX_PRIORITIES – 1)</p><p>pxCreatedTask：用于保存 xTaskCreate 的输出结果，即任务的句柄（task handle）。如果以后需要对该任务进行操作，如修改优先级，则需要使用此句柄。如果不需要使用该句柄，可以传入 NULL。</p><p>返回值：成功时返回 pdPASS，失败时返回 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY ，<strong>BaseType_t</strong>通常用作简单的返回值的类型、</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t xSoundTaskHandle;<span class="comment">//任务句柄</span></span><br><span class="line">BaseType_t ret;<span class="comment">//分辨任务的返回值,判断任务是否创建成功</span></span><br><span class="line"></span><br><span class="line">ret=xTaskCreate(PlayMusic,<span class="string">&quot;SoundTask&quot;</span>,<span class="number">128</span>,<span class="literal">NULL</span>,osPriorityNormal,xSoundTaskHandle);</span><br></pre></td></tr></table></figure><p>b.静态分配</p><p><img src="/2024/01/29/FreeRTOS/image-20240120162811825.png" alt="image-20240120162811825"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t <span class="title function_">xTaskCreateStatic</span> <span class="params">( </span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,   <span class="comment">// 函数指针, 任务函数</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,   <span class="comment">// 任务的名字</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth, <span class="comment">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * <span class="type">const</span> pvParameters,   <span class="comment">// 调用任务函数时传入的参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,      <span class="comment">// 优先级</span></span></span><br><span class="line"><span class="params">    StackType_t * <span class="type">const</span> puxStackBuffer, <span class="comment">// 静态分配的栈，就是一个buffer</span></span></span><br><span class="line"><span class="params">    StaticTask_t * <span class="type">const</span> pxTaskBuffer <span class="comment">// 静态分配的任务结构体的指针，用它来操作这个任务</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>pxTaskCode: 函数指针，指向我们的任务函数，在这里写我们自己写的任务函数的函数名。</p><p>pcName：任务名，没啥用，自己随便取，eg:  “LightTask”</p><p>ulStackDepth: 栈大小，值是你提前分配的栈（puxStackBuffer）所对应的大小,单位为字；<code>ulStackDepth</code>  在FreeRTOS中的单位通常根据具体平台和编译器的字长来确定。在32位架构下，一个“字”通常是32位，在16位架构下，则是16位。因此，当提到任务堆栈深度时，如果没有特别说明，可以根据目标处理器架构默认为该架构下的“字”长度。例如，在32位架构中，如果 <code>ulStackDepth</code> 设置为100，则意味着为任务分配了400字节（100 * 4）的堆栈空间。</p><p>pvParameters: 调用任务函数时传入的参数，即pxTaskCode的参数，如果它没有参数，直接写NULL就行</p><p>uxPriority：优先级范围：0~(configMAX_PRIORITIES – 1) 数值越小优先级越低， 如果传入过大的值，xTaskCreate会把它调整为(configMAX_PRIORITIES – 1)</p><p>puxStackBuffer:一个指向预分配的静态任务堆栈缓冲区的指针。这意味着开发者需要自己管理内存，而不是由系统动态分配。比如可以传入一个数组， 它的大小是usStackDepth*4。</p><p>pxTaskBuffer: 指向一个静态任务控制块（TCB）结构体的指针（StaticTask_t 是一个<strong>结构体</strong>类型，它就是TCB））。同样，这里要求开发者预先分配好存储TCB的空间。</p><p>返回值：成功时返回 pdPASS，失败时返回 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY ，<strong>BaseType_t</strong>通常用作简单的返回值的类型</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> StackType_t g_pucStackOfLightTask[<span class="number">128</span>*<span class="number">4</span>?];</span><br><span class="line"><span class="type">static</span> StaticTask_t g_TCBofLightTask;</span><br><span class="line"><span class="type">static</span> TaskHandle_t xLightTaskHandle;<span class="comment">//任务句柄</span></span><br><span class="line"></span><br><span class="line">xLightTaskHandle=xTaskCreateStatic(Led_Test,<span class="string">&quot;LightTask&quot;</span>,<span class="number">128</span>,<span class="literal">NULL</span>,osPriorityNormal,g_pucStackOfLightTask,&amp;g_TCBofLightTask);</span><br></pre></td></tr></table></figure><p><em><strong>疑惑：ulStackDepth和puxStackBuffer值的关系？</strong></em></p><h3 id="估算栈的大小"><a href="#估算栈的大小" class="headerlink" title="估算栈的大小"></a>估算栈的大小</h3><p>确定栈的大小并不容易，通常是根据估计来设定。精确的办法是查看反汇编代码。</p><p><strong>栈里面保存的东西：</strong></p><p><em><strong>1.返回地址LR寄存器，其它寄存器</strong></em>：取决于<strong>函数调用深度</strong>，一般选取最复杂的调用关系来计算</p><p><strong>理论上最多要保存的寄存器（9个）：</strong></p><p><img src="/2024/01/29/FreeRTOS/image-20240130114439040.png" alt="image-20240130114439040"></p><p>可以通过汇编代码查看函数保存的寄存器：</p><p><img src="/2024/01/29/FreeRTOS/image-20240130114341787.png" alt="image-20240130114341787"></p><p>eg: A-&gt;B-&gt;C-&gt;D-&gt;E       5级调用*（被调用者寄存器R4~R11 共8个，LR寄存器，总计9个）</p><p>5x9x4&#x3D;180</p><p>我们可以得出：调用深度越深，需要的栈越大。</p><p>但是用到栈最大的情况不一定是在最深的调用关系这里出现，可能一个函数里定义了一个巨大的局部变量，你得去看你的代码，找到使用局部变量最多的函数</p><p><em><strong>2.局部变量：</strong></em>取决于你的代码，比如你用了一个char buf[1000]</p><p><em><strong>3.现场：</strong></em>16x4 &#x3D;64 (16个寄存器)</p><p>通过1，2，3 你就可以大概估计出你这个程序用到的栈最大有多少，当然最精确的就是去看反汇编。</p><p>实例估计：</p><p><img src="/2024/01/29/FreeRTOS/image-20240130115953696.png" alt="image-20240130115953696"></p><p>4层调用:4x9x4&#x3D;144</p><p>局部变量： MUSI_Analysis()函数里有两个局部变量，4个字节，PassiveBuzzer_Set_Freq_Duty函数里有一个结构体，28字节。共计32字节</p><img src="/2024/01/29/FreeRTOS/image-20240130120203126.png" alt="image-20240130120203126" style="zoom:50%;"><p>现场：64字节</p><p>用到的栈约等于：144+32+64&#x3D;250字节</p><p>我们提供的栈是128字，即128*4字节&gt;250，所以粗略估算是够用的。</p><p><img src="/2024/01/29/FreeRTOS/image-20240130120504361.png" alt="image-20240130120504361"></p><p>精确计算栈的大小以后再说。</p><h3 id="创建任务-使用任务参数"><a href="#创建任务-使用任务参数" class="headerlink" title="创建任务_使用任务参数"></a>创建任务_使用任务参数</h3><p>创建两个任务，使用同一个函数，在LCD上打印不一样的信息</p><p><img src="/2024/01/29/FreeRTOS/image-20240131094453190.png" alt="image-20240131094453190"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  <span class="type">uint8_t</span> x;</span><br><span class="line">  <span class="type">uint8_t</span> y;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task1Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;Task1&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task2Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;Task2&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task3Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="string">&quot;Task3&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_LCDCanUse = <span class="number">1</span>;<span class="comment">/*定义一个全局变量来互斥访问LCD*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdPrintTask</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> *<span class="title">pInfo</span> =</span> params;</span><br><span class="line">  <span class="type">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*打印信息*/</span></span><br><span class="line">    <span class="keyword">if</span> (g_LCDCanUse)</span><br><span class="line">    &#123;</span><br><span class="line">      g_LCDCanUse = <span class="number">0</span>;</span><br><span class="line">      len = LCD_PrintString(pInfo-&gt;x, pInfo-&gt;y, pInfo-&gt;name);</span><br><span class="line">      len += LCD_PrintString(len, pInfo-&gt;y, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">      LCD_PrintSignedVal(len, pInfo-&gt;y, cnt++);</span><br><span class="line">      g_LCDCanUse = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mdelay(<span class="number">500</span>);<span class="comment">//没有添加这句时，其他任务没办法在屏幕上打印信息，比如任务3执行到中间被切换出去，此时g_LCDCanUse是0，其他任务进来也无法执行打印，当任务3执行完g_LCDCanUse=1,由于没有延时，瞬间g_LCDCanUse再次被赋值为0.这样当切换到其他任务时，还是不能运行，就导致只有一个task3执行了打印任务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xTaskCreate(LcdPrintTask, <span class="string">&quot;task1&quot;</span>, <span class="number">128</span>, &amp;g_Task1Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">xTaskCreate(LcdPrintTask, <span class="string">&quot;task2&quot;</span>, <span class="number">128</span>, &amp;g_Task2Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">xTaskCreate(LcdPrintTask, <span class="string">&quot;task3&quot;</span>, <span class="number">128</span>, &amp;g_Task3Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>提问：如何互斥地访问LCD?使用全局变量，大概率可以，但不是万无一失</p><p>提问：为何是后面创建的task3先运行？</p><h3 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h3><p>用遥控器删除任务</p><p>功能为：</p><p>当监测到遥控器的播放按键按下时，创建音乐播放任务</p><p>当监测到遥控器的Power案件按下后，删除音乐播放任务</p><p>删除任务时使用的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t xTaskToDelete )</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>pvTaskCode</td><td>任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。 也可传入NULL，这表示删除自己。</td></tr></tbody></table><p>怎么删除任务？举个不好的例子：</p><ul><li>自杀：vTaskDelete(NULL)</li><li>被杀：别的任务执行vTaskDelete(pvTaskCode)，pvTaskCode是自己的句柄</li><li>杀人：执行vTaskDelete(pvTaskCode)，pvTaskCode是别的任务的句柄</li></ul><p>一句话就是你要删除哪个任务，就传入这个任务的句柄到该函数s</p><p>提问：频繁的创建，删除任务，好吗？有什么坏处？</p><p>频繁的动态分配内存，释放内存，容易产生内存碎片，多次执行之后可能就分配不到内存了</p><p>不能简单的删除一个任务，然后就不管一些后续的清理工作了，要初始化到原来的状态。实际上一般删除任务用的较少，可以直接让任务读取这遥控器，让它自己去停止，做一些清除工作。</p><h3 id="优先级与阻塞"><a href="#优先级与阻塞" class="headerlink" title="优先级与阻塞"></a>优先级与阻塞</h3><p>前言：</p><p>在之前的程序里，播放音乐的时候效果都比较差，会慢半拍，比较卡顿，只要我们把其它任务注释掉就比较顺畅。</p><p>提高音乐播放器的优先级，使用<strong>vTaskDelay</strong>进行延时，就可以改善播放器效果，同时让其它任务不受影响s。</p><p>首先，我们让音乐播放的优先级+1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = xTaskCreate(PlayMusic, <span class="string">&quot;SoundTask&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, osPriorityNormal+<span class="number">1</span>, &amp;xSoundTaskHandle);</span><br></pre></td></tr></table></figure><p>现象：其他任务都不动了，而且按power键删除不了播放音乐任务</p><p>这是因为我们创建了一个高优先级的任务，它一直在运行，独占CPU</p><p>我们要修改这个高优先级的任务，让它在运行过程中主动放弃CPU资源，不再参与调度</p><p>将mdelay替换为vTaskDelay,在延时的过程中它不会参与调度。</p><p>内部机制：</p><h2 id="（重要）任务状态与调度理论"><a href="#（重要）任务状态与调度理论" class="headerlink" title="（重要）任务状态与调度理论"></a>（重要）任务状态与调度理论</h2><p>eg:实现音乐的暂停与继续播放</p><h3 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h3><p><strong>Running</strong>运行状态</p><p><strong>Ready</strong>就绪状态：当创建一个任务后，它就处于就绪状态</p><p><strong>Blocked</strong>阻塞状态(等待某些event) : 一个处于running状态的函数，当用vTaskDelay时，变成Blocked阻塞状态</p><p><strong>Suspend</strong>暂停状态：可以自己调用（必处于running状态）vTaskSuspend()函数，把自己放入暂停状态，或者由别的任务来调用该函数，把你放入暂停状态，别人处于running状态，你处于ready或blocked状态</p><p><img src="/2024/01/29/FreeRTOS/image13.png" alt="image13"></p><h3 id="任务管理与调度机制"><a href="#任务管理与调度机制" class="headerlink" title="任务管理与调度机制"></a>任务管理与调度机制</h3><p>P22 这节是很重要的<strong>理论</strong>介绍，好好体会</p><p><strong>调度：</strong></p><p>1.相同优先级的任务轮流运行。</p><p>2.最高优先级的任务先运行。</p><p><strong>高优先级的任务未执行完，低优先级的任务则无法运行</strong></p><p><strong>一旦高优先级的任务就绪，会马上运行，低优先级任务立刻停止</strong></p><p><strong>最高优先级的任务有多个，则它们轮流运行</strong></p><p><strong>记住RTOS的调度机制</strong>：就绪态的高优先级任务，一定会抢占低优先级的任务。高优先级的任务，不能总是运行。那么高优先级的任务，就应该“使用事件驱动”，比如发生了中断后，才唤醒高优先级的任务，它处理完数据后马上再次阻塞。现在就可以划分优先级了：第1种方法：按任务运行时间划分。比如能使用“事件驱动”的任务，可以设置它的优先级高一点，毕竟它平时大部分时间不运行，只有发生“某些事件（比如中断）”时才执行一会；需要长时间运行的任务，可以设置它的优先级低一点。第2种方法：按任务的紧急程度划分，比如不想丢失按键，那么按键的任务优先级就高；想GUI及时显示，GUI任务的优先级就高；但是要记住：高优先级的任务，一定不能长时间运行，否则其他低优先级的任务就无法运行了。</p><p>核心：<em><strong>链表</strong></em></p><img src="/2024/01/29/FreeRTOS/image-20240131203358178.png" alt="image-20240131203358178" style="zoom:67%;"><img src="/2024/01/29/FreeRTOS/image-20240131203658884.png" alt="image-20240131203658884" style="zoom:67%;"><p>pxReadyTasksLists[N],存放优先级为N的处于Ready&#x2F;Running状态的任务的TCB结构体</p><p><img src="/2024/01/29/FreeRTOS/image-20240131211122969.png" alt="image-20240131211122969"></p><p>阅读代码会发现有一个全局指针pxCurrentTCB,每创建一个任务时该指针都指向它，启动调度器后，由于全局指针指向的是最后创建的这个任务，所以先从它这里执行（这就是06节后面创建的task3反而先运行的原因）</p><p><strong>TICK中断</strong>：FREERTOS定义了一个时钟，TICK_RATE_HZ，cubemx中可以看到频率为1000，即1ms产生一次中断（Tick中断）</p><p>中断里会发生：</p><p>   1.cnt++ </p><p>   2.判断DelayedTaskList里任务是否可以恢复，如果时间到了，就把它移到就绪链表，发起调度</p><p>   3.发起调度</p><p><strong>发起调度</strong>：从高优先级到低来开始遍历链表数组，直到找到一个非空链表，找到下一个要运行的任务（当前指针所指向任务的下一个），然后运行该任务，直到1ms后再次发生TICK中断。</p><p>当StartfaultTask检测到播放按键被按下，创建了一个优先级更高的任务，则该任务会立即运行，当执行到<strong>vTaskDelay</strong>(2)，则进入<strong>阻塞</strong>状态，阻塞2个TICK，它被从ReadyTaskList链表数组中删除，放到xDelayedTaskList链表数组中，主动放弃运行了，则触发调度，又去遍历链表数组，链表里有一个记录项index，会记录上一次运行的任务，则会从下一个任务来运行。当两个TICK到了，会判断DelayTaskList里任务是否可恢复，把他移出去，重新放入ReadList[25],然后开始发起调度。当被<strong>suspend挂起</strong>时，它会把你从ReadyTaskList链表里移出来,放到xSuspendedTaskList,当Resume时，则移出xSuspendTaskList，重新放到ReadyList</p><p><img src="/2024/01/29/FreeRTOS/image-20240131214952447.png" alt="image-20240131214952447"></p><p><img src="/2024/01/29/FreeRTOS/image-20240131215227772.png" alt="image-20240131215227772"></p><h3 id="空闲任务"><a href="#空闲任务" class="headerlink" title="空闲任务"></a>空闲任务</h3><p>优先级最低，为0，要么处于就绪或者运行状态，永远不会阻塞。</p><p>空闲任务(Idle任务)的作用之一：释放被删除的任务的内存。</p><p>除了上述目的之外，为什么必须要有空闲任务？一个良好的程序，它的任务都是事件驱动的：平时大部分时间处于阻塞状态。有可能我们自己创建的所有任务都无法执行，但是调度器必须能找到一个可以运行的任务：所以，我们要提供空闲任务。在使用vTaskStartScheduler()函数来创建、启动调度器时，这个函数内部会创建空闲任务：</p><ul><li>空闲任务优先级为0：它不能阻碍用户任务运行</li><li>空闲任务要么处于就绪态，要么处于运行态，永远不会阻塞</li></ul><img src="/2024/01/29/FreeRTOS/image-20240131232312235.png" alt="image-20240131232312235" style="zoom:67%;"><p>若Led_Test不是死循环，结束后不做处理直接退出的话，会直接进入到右侧错误函数，会关闭所有中断，进入死循环，所有任务都没办法继续执行。任务能够发生调度是依赖于TICK中断，现在中断都关了，则无法切换</p><p><em><strong>任务结束后，要用vTaskDelete(NULL)删除任务</strong></em></p><p>A杀B，由A给B收尸（清除工作，释放TCB结构体，释放栈） ；B自杀，空闲任务给它收尸</p><p>由于空闲任务优先级最低，若其他优先级的任务不主动放弃CPU，空闲任务无法执行，同时又有很多任务自杀，没人收尸，内存得不到释放，就会慢慢导致内存不足。</p><p>为了让空闲任务有机会运行，或者说是一种良好的编程习惯：</p><p>1.我们编写的任务函数，一般建议使用事件驱动，比如按下某个按键之后，它才会做某些事情，没有的话就阻塞。</p><p>2.延时函数，不要用死循环：mdelay替换为vTaskDelay,每个任务执行完用vTaskDelay（让当前任务不参与调度）进入阻塞状态（移出ReadyTaskList链表数组到xDelayTaskList），空闲任务才有机会运行。</p><p><strong>钩子函数</strong></p><p>我们可以添加一个空闲任务的钩子函数(Idle Task Hook Functions)，空闲任务的循环每执行一次，就会调用一次钩子函数。钩子函数的作用有这些：</p><ul><li>执行一些低优先级的、后台的、需要连续执行的函数</li><li>测量系统的空闲时间：空闲任务能被执行就意味着所有的高优先级任务都停止了，所以测量空闲任务占据的时间，就可以算出处理器占用率。</li><li>让系统进入省电模式：空闲任务能被执行就意味着没有重要的事情要做，当然可以进入省电模式了。</li><li>空闲任务的钩子函数的限制：</li><li>不能导致空闲任务进入阻塞状态、暂停状态</li><li>如果你会使用vTaskDelete()来删除任务，那么钩子函数要非常高效地执行。如果空闲任务移植卡在钩子函数里的话，它就无法释放内存。</li></ul><h3 id="两个Delay函数"><a href="#两个Delay函数" class="headerlink" title="两个Delay函数"></a>两个Delay函数</h3><p>将<strong>mdelay</strong>替换为vTaskDelay,在延时的过程中任务不会参与调度，它不会阻塞让低优先级的任务有机会运行。</p><p>mdelay一直查询时间，不会使任务进入阻塞状态</p><p>vTaskDelay是把任务阻塞，这样低优先级的任务在它阻塞时也能运行。</p><p>有两个Delay函数：</p><ul><li><strong>vTaskDelay</strong>：至少等待指定个数的Tick Interrupt才能变为就绪状态</li><li><strong>vTaskDelayUntil</strong>：等待到指定的绝对时刻，才能变为就绪态。</li><li>它们阻塞的单位都是TICK</li></ul><p>这2个函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">( <span class="type">const</span> TickType_t xTicksToDelay )</span>; <span class="comment">/* xTicksToDelay: 等待多少给Tick */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pxPreviousWakeTime: 上一次被唤醒的时间</span></span><br><span class="line"><span class="comment"> * xTimeIncrement: 要阻塞到(pxPreviousWakeTime + xTimeIncrement)</span></span><br><span class="line"><span class="comment"> * 单位都是Tick Count</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskDelayUntil</span><span class="params">( TickType_t * <span class="type">const</span> pxPreviousWakeTime,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> TickType_t xTimeIncrement )</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pxPreviousWakeTime=xTaskGetTickCount();<span class="comment">//获得启示时间</span></span><br></pre></td></tr></table></figure><p>让每个任务启动时间的间隔是一个定值，周期性的启动运行，就要用vTaskDelayUntil</p><p>下面画图说明：</p><ul><li>使用vTaskDelay(n)时，进入、退出vTaskDelay的时间间隔至少是n个Tick中断</li><li>使用xTaskDelayUntil(&amp;Pre, n)时，前后两次退出xTaskDelayUntil的时间至少是n个Tick中断<ul><li>退出xTaskDelayUntil时任务就进入的就绪状态，一般都能得到执行机会</li><li>所以可以使用xTaskDelayUntil来让任务周期性地运行</li></ul></li></ul><p><img src="/2024/01/29/FreeRTOS/image14.png" alt="image14"></p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><strong>创建任务：</strong></p><p>xTaskCreate()</p><p>xTaskCreateStatic()</p><p><strong>挂起任务：</strong></p><p>vTaskSuspend()     </p><p>vTaskSuspendAll()</p><p><strong>恢复任务：</strong></p><p>vTaskResume()  让挂起的任务重新进入就绪状态</p><p> xTaskResumeFromISR() 专门用在中断服务程序中</p><p>xTaskResumeAll()</p><p><strong>删除任务：</strong></p><p>vTaskDelete() </p><p><strong>延时任务：</strong></p><p>vTaskDelay()   相对延时函数 </p><p>vTaskDelayUntil()  绝对延时函数(适用于周期性任务)</p><p><img src="/2024/01/29/FreeRTOS/image-20240201102602597.png" alt="image-20240201102602597"></p><h1 id="同步互斥与通信"><a href="#同步互斥与通信" class="headerlink" title="同步互斥与通信"></a>同步互斥与通信</h1><h2 id="同步与互斥的概念"><a href="#同步与互斥的概念" class="headerlink" title="同步与互斥的概念"></a>同步与互斥的概念</h2><p>在团队活动里，同事A先写完报表，经理B才能拿去向领导汇报。经理B必须等同事A完成报表，AB之间有依赖，B必须放慢脚步，被称为同步。在团队活动中，同事A已经使用会议室了，经理B也想使用，即使经理B是领导，他也得等着，这就叫互斥。经理B跟同事A说：你用完会议室就提醒我。这就是使用”同步”来实现”互斥”。</p><p>同一时间只能有一个人使用的资源，被称为临界资源。比如任务A、B都要使用串口来打印，串口就是临界资源。如果A、B同时使用串口，那么打印出来的信息就是A、B混杂，无法分辨。所以使用串口时，应该是这样：A用完，B再用；B用完，A再用。</p><h3 id="同步的例子"><a href="#同步的例子" class="headerlink" title="同步的例子"></a>同步的例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task1Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;Task1&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task2Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;Task2&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task3Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="string">&quot;Task3&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_LCDCanUse = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> g_calc_end = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> g_time = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> g_sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务1 计算加法，并计算加法运算的时间，然后删除任务</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CalcTask</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">  g_time = system_get_ns();</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    g_sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  g_calc_end = <span class="number">1</span>;</span><br><span class="line">  g_time = system_get_ns() - g_time;</span><br><span class="line">  vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务2 当计算任务没有结束时，一直执行while循环，直到计算任务结束,g_cal_end变为1，则可进行后面的打印信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdPrintTask</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LCD_PrintString(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;waiting&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (g_calc_end == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印信息 */</span></span><br><span class="line">    <span class="keyword">if</span> (g_LCDCanUse)</span><br><span class="line">    &#123;</span><br><span class="line">      g_LCDCanUse = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      LCD_ClearLine(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      len = LCD_PrintString(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;Sum:&quot;</span>);</span><br><span class="line">      LCD_PrintHex(len, <span class="number">0</span>, g_sum,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      LCD_ClearLine(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">      len = LCD_PrintString(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;Time(ms):&quot;</span>);</span><br><span class="line">      LCD_PrintSignedVal(len, <span class="number">2</span>, g_time/<span class="number">1000000</span>);</span><br><span class="line">      g_LCDCanUse = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  xTaskCreate(CalcTask, <span class="string">&quot;task1&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">  xTaskCreate(LcdPrintTask, <span class="string">&quot;task2&quot;</span>, <span class="number">128</span>, &amp;g_Task2Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>对于static volatile int g_calc_end &#x3D; 0;</p><p>​没有加volatile时，经过<strong>debug</strong>，发现程序一直会卡LcdPrintTask的while (g_calc_end &#x3D;&#x3D; 0);处，<strong>尽管在debug时显示g_calc_end为1还是一直卡在那里</strong>。这是因为在编译器做了一些优化，第一次使用这个变量时，它会去读内存，把这个变量的值读进CPU的某个寄存器，以后在任务2的那个while循环里，它一直都是去判断那个<strong>寄存器</strong>，但是那个寄存器得到的是这个变量原始的，老的值，它并<strong>没有每次都去内存里面读这个变量</strong>，更新那个寄存器，这是不对的，因为这个变量，是在其他任务里面被修改了，你去使用这个变量时，每次都应该去读内存，怎么办呢，<strong>在变量前加一个volatile就好了，告诉编译器，不要去优化它。</strong></p><p>​“在多任务环境下，编译器通常会对变量进行优化以提高代码执行效率。当一个变量被标记为 volatile 时，它告诉编译器这个变量的值可能在程序控制范围之外发生变化（例如由中断服务程序、硬件操作或者其他并发任务修改），因此每次访问该变量时都会从内存中重新读取。<em>编译器对变量的优化通常基于以下几种情况</em>：</p><ol><li><p><strong>局部性原理</strong>：编译器假设在一段连续执行的代码中，如果一个变量没有被显示地修改（比如通过赋值、函数调用或指针间接访问），其值就不会改变。因此，在循环内多次读取同一变量时，编译器可能会将该变量从内存加载到寄存器中，并在整个循环期间使用寄存器中的值，以减少对内存的访问。</p></li><li><p><strong>数据流分析</strong>：编译器会进行数据依赖性分析，如果它能确定某个变量在当前作用域内不会受外部因素影响而改变，即使这个变量是全局的，也可能对其进行优化。</p></li><li><p><strong>跨函数优化</strong>：编译器还可能进行跨函数优化，例如当函数没有明确的副作用或者编译器能够推断出函数内部对全局变量的修改不会影响到当前上下文时，也会选择不重新加载变量。”</p><p>应当在以下情况下考虑使用 <code>volatile</code> 关键字来修饰变量：</p><ul><li>变量可能被<strong>中断服务程序修改</strong>。</li><li>变量位于<strong>多线程环境且不同线程间共享并修改该变量</strong>。</li><li>变量与硬件寄存器映射相关，硬件可能会在软件不可见的情况下更改它们的值。</li><li>变量用于信号量、事件标志或其他同步机制。</li></ul></li></ol><p>上例LcdPrintTask任务的while函数，尽管没有后面的内容没有执行，但是它会执行while一直循环，也会占用CPU资源，实际打印出来的时间也不是计算任务实际的时间，而是实际时间的两倍，因为任务一二是每过一个TICK就交替执行的，这也是我们说的用静态变量来解决互斥问题的缺陷)。</p><p>所以使用同步的时候，我们需要考虑怎样提高处理器的性能，让那些等待的任务阻塞，不要参与CPU的调度。</p><p>PS:<br>debug过程</p><p><a href="https://www.bilibili.com/video/BV1Jw411i7Fz?p=25&vd_source=a9d487fcf1a579639c6348eb5a9321db">https://www.bilibili.com/video/BV1Jw411i7Fz?p=25&amp;vd_source=a9d487fcf1a579639c6348eb5a9321db</a></p><p>9:25~11:05</p><h3 id="互斥的例子"><a href="#互斥的例子" class="headerlink" title="互斥的例子"></a>互斥的例子</h3><p>示例1</p><p><img src="/2024/01/29/FreeRTOS/image-20240202100718491.png" alt="image-20240202100718491"></p><p>这三个任务都使用同一个函数，这个函数里面会在屏幕显示信息，屏幕就是临界资源，同一时间只能够有一个任务来访问，通过IIC访问硬件，如果不提供互斥保护措施的话 ，IIC时序会被打乱。</p><p><img src="/2024/01/29/FreeRTOS/image-20240202101126626.png" alt="image-20240202101126626"></p><p>因此，使用红框内的代码操作LCD时，必须互斥访问，A没有用完,B不能够使用<img src="/2024/01/29/FreeRTOS/image-20240202101238904.png" alt="image-20240202101238904"></p><p>目前是用的全局变量g_LCDCanUse来互斥保护，大部分情况是可以的，但理论上它是有缺陷的：</p><p>当A运行到108行被切换了，此时g_LCDCanUse&#x3D;1，B运行也可以进去，这样A和B都可以使用LCD，使IIC时序混乱。当程序运行成千上万次时，很有可能出现这样的问题。</p><p>示例2</p><img src="/2024/01/29/FreeRTOS/image-20240202101618191.png" alt="image-20240202101618191" style="zoom:80%;"><p>如果改成这样，看上去貌似没什么问题，但再往细看，执行bCanUse–这一条指令时，汇编发生了三个过程。先把bCanUse存入一个寄存器，把这个寄存器的值减一，然后再赋值给bCanUse,如果A在把bCanUse存到寄存器后被切换为B，此时bCanUse还是1，减1后为0，B可以运行，再切换为A时，因为保存的有现场，所以当时的R0&#x3D;1被保存下来，减1后为0，也可以运行LCD。这三个过程，它们是可以被切换的，虽然概率很小，但你不可能杜绝它。</p><p><img src="/2024/01/29/FreeRTOS/image-20240202103314866.png" alt="image-20240202103314866"></p><p><img src="/2024/01/29/FreeRTOS/image-20240202102710295.png" alt="image-20240202102710295"></p><p>从上面的例子可以看出，如果简单的使用这种全局变量来保护临界资源，虽然大概率没问题，但当程序运行很长时间后可能出问题。</p><p>解决方法可以是<strong>关中断</strong>：</p><p>示例1的代码改进如下：在第5~7行前关闭中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LCD_PrintString</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> *str)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> bCanUse = <span class="number">1</span>;</span><br><span class="line">  disable_irq();</span><br><span class="line">  <span class="keyword">if</span> (bCanUse)</span><br><span class="line">  &#123; </span><br><span class="line">       bCanUse = <span class="number">0</span>;</span><br><span class="line">       enable_irq();</span><br><span class="line">      <span class="comment">/* 使用LCD */</span></span><br><span class="line">       bCanUse = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  enable_irq();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例2的代码改进如下：在第5行前关闭中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LCD_PrintString</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> *str)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> bCanUse = <span class="number">1</span>;</span><br><span class="line">  disable_irq();</span><br><span class="line">  bCanUse--;</span><br><span class="line">  enable_irq();</span><br><span class="line">  <span class="keyword">if</span> (bCanUse == <span class="number">0</span>)</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="comment">/* 使用LCD */</span></span><br><span class="line">    bCanUse++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    disable_irq();</span><br><span class="line">    bCanUse++;</span><br><span class="line">    enable_irq();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样的话 确实能行 但其实B任务也会占用CPU资源，最好的是我们应该让它<strong>阻塞</strong>，A用完了之后再把B唤醒。</p><h3 id="通信的例子"><a href="#通信的例子" class="headerlink" title="通信的例子"></a>通信的例子</h3><p>通过一个全局变量设置状态,在AB里通信，也可能在这个全局变量还没改完就切换了，这样就通信失败了，要用互斥的方法来解决，同时要保持高效，要用阻塞。</p><h3 id="FreeRTOS的解决方案（概述）"><a href="#FreeRTOS的解决方案（概述）" class="headerlink" title="FreeRTOS的解决方案（概述）"></a>FreeRTOS的解决方案（概述）</h3><ul><li>用<strong>互斥</strong>的方法保证正确性</li><li>效率：等待者要进入<strong>阻塞</strong>状态（阻塞和唤醒机制来提高效率）</li><li>多种解决方案</li></ul><p><strong>队列</strong></p><p>可以认为队列是一个传送带，流水线，先进先出</p><p><img src="/2024/01/29/FreeRTOS/image-20240202112706799.png" alt="image-20240202112706799"></p><p><strong>事件组</strong></p><p><img src="/2024/01/29/FreeRTOS/image-20240202112808004.png" alt="image-20240202112808004"></p><p><strong>信号量</strong></p><p><img src="/2024/01/29/FreeRTOS/image-20240202112855635.png" alt="image-20240202112855635"> </p><p><strong>互斥量</strong></p><p><img src="/2024/01/29/FreeRTOS/image-20240202113014790.png" alt="image-20240202113014790"></p><p><strong>任务通知</strong></p><p><img src="/2024/01/29/FreeRTOS/image-20240202112947029.png" alt="image-20240202112947029"></p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>数据传输的方法</p><p><img src="/2024/01/29/FreeRTOS/image-20240202183047523.png" alt="image-20240202183047523"></p><h2 id="环形缓冲区"><a href="#环形缓冲区" class="headerlink" title="环形缓冲区"></a><strong>环形缓冲区</strong></h2><p>解释的很清楚： <a href="http://t.csdnimg.cn/DY7gy">http://t.csdnimg.cn/DY7gy</a></p><p>环形缓冲区是<a href="https://so.csdn.net/so/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F&spm=1001.2101.3001.7020">嵌入式</a>系统中十分重要的一种数据结构，比如在<strong>串口</strong>处理中，串口中断接收数据直接往环形缓冲区丢数据，而应用可以从环形缓冲区取数据进行处理，这样数据在读取和写入的时候都可以在这个缓冲区里循环进行，程序员可以根据自己需要的数据大小来决定自己使用的缓冲区大小，<strong>不用担心数组越界</strong>。</p><p><strong>队列</strong>的基本概念：队列 (Queue)：是一种先进先出(First In First Out ,简称 FIFO)的线性表，只允许在一端插入（入队），在另一端进行删除（出队）。</p><p>队列头就是指向已经存储的数据，并且这个数据是待处理的。下一个CPU处理的数据就是1；而队列尾则指向可以进行写数据的地址。</p><p>队列的最大长度queueMaxsize&#x3D;数组容量arrayMaxSize-1 （<strong>由于置空位要占一位,置空位是为了让空载和满载的判断条件区别开来，否则它们都是头&#x3D;尾，就不能因此来判断队列是空还是满</strong>），所以也引出了代码里的next_w。</p><p><strong>置空位</strong>虽然是人为引入的，但这不意味这置空位的位置是随意的，实际上，只有队列满后才会将剩下的位置作为置空位，一旦置空位出现，rear和front永远不可能指向同一个索引位，因为你会惊奇的发现置空位恰号将rear和front隔开了。</p><img src="/2024/01/29/FreeRTOS/image-20240202183437083.png" alt="image-20240202183437083" style="zoom:67%;"><p><strong>示例代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> buf[<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> head=<span class="number">0</span>,tail=<span class="number">0</span>;<span class="comment">//head对应索引位待出列，tail对应索引位待入列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断条件</span></span><br><span class="line"><span class="comment">//buf空</span></span><br><span class="line">head==tail</span><br><span class="line"><span class="comment">//buf满 </span></span><br><span class="line">head=(tail+<span class="number">1</span>)%maxSize<span class="comment">//引入了置空位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写的方法</span></span><br><span class="line"><span class="keyword">if</span>(next_w!=r)<span class="comment">//未满</span></span><br><span class="line">&#123;</span><br><span class="line">    buf(w)=val;</span><br><span class="line">    w++;</span><br><span class="line">    <span class="keyword">if</span>(w==<span class="number">8</span>)</span><br><span class="line">    w=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读</span></span><br><span class="line"><span class="keyword">if</span>(r!=w)<span class="comment">//有数据</span></span><br><span class="line">&#123;</span><br><span class="line">    val=buf[r];</span><br><span class="line">    r++;</span><br><span class="line">    <span class="keyword">if</span>(r==<span class="number">8</span>)</span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应用代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RINGBUFF_LEN 256;</span></span><br><span class="line"><span class="comment">//定义一个缓冲区结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 Head;           </span><br><span class="line">    u16 Tail;</span><br><span class="line">    u8 Ring_Buff[RINGBUFF_LEN];</span><br><span class="line">&#125;RingBuff_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*若想更灵活，可以用动态内存分配方式（如使用指针）来实现可变长度的缓冲区</span></span><br><span class="line"><span class="comment">typedef struct</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">u16 Head;</span></span><br><span class="line"><span class="comment">u16 Tail;</span></span><br><span class="line"><span class="comment">u8* Ring_Buff;</span></span><br><span class="line"><span class="comment">&#125;RingBuff_t;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 初始化函数，传入所需长度</span></span><br><span class="line"><span class="comment">void RingBuff_Init(RingBuff_t rbuff, size_t len)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Head = 0;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Tail = 0;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Ring_Buff = (u8)malloc(len * sizeof(u8));</span></span><br><span class="line"><span class="comment">    if (!rbuff-&gt;Ring_Buff) &#123;</span></span><br><span class="line"><span class="comment">    // 处理内存分配失败的情况...</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">在C语言中，u8* Ring_Buff; 是一个指向无符号8位整型（通常代表字节）的指针。它本身并不是一个数组，但可以用来指向一块内存区域，这块内存可以被当作数组来处理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当你通过 malloc 函数为 Ring_Buff 分配了足够长度的内存后，你就可以像操作数组那样对这块内存进行读写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个ringBuff的缓冲区</span></span><br><span class="line">RingBuff_t ringBuff;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化环形缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RingBuff_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//初始化相关信息</span></span><br><span class="line">   ringBuff.Head = <span class="number">0</span>;</span><br><span class="line">   ringBuff.Tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">u8 <span class="title function_">Write_RingBuff</span><span class="params">(u8 data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ringBuff.Head=(ringBuff.Tail+<span class="number">1</span>)%maxSize) <span class="comment">//缓冲区满</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> FLASE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ringBuff.Ring_Buff[ringBuff.Tail]=data;<span class="comment">//在Tail对应索引位写入数据</span></span><br><span class="line">    ringBuff.Tail=(ringBuff.Tail+<span class="number">1</span>)%RINGBUFF_LEN; <span class="comment">//ringBuff.Tail++; 防止越界非法访问</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读数据</span></span><br><span class="line"><span class="number">10u</span>8 Read_RingBuff(u8 *rData)</span><br><span class="line"><span class="number">11</span>&#123;</span><br><span class="line"><span class="number">12</span>   <span class="keyword">if</span>(ringBuff.Head==ringBuff.Tail)<span class="comment">//判断非空</span></span><br><span class="line"><span class="number">13</span>    &#123;</span><br><span class="line"><span class="number">14</span>       <span class="keyword">return</span> FLASE;</span><br><span class="line"><span class="number">15</span>    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">16</span>   *rData = ringBuff.Ring_Buff[ringBuff.Head];<span class="comment">//先进先出FIFO，从缓冲区头出</span></span><br><span class="line"></span><br><span class="line"><span class="number">18</span>   ringBuff.Head = (ringBuff.Head+<span class="number">1</span>)%RINGBUFF_LEN;<span class="comment">// ringBuff.Head++;防止越界非法访问</span></span><br><span class="line">    </span><br><span class="line"><span class="number">20</span>   <span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure><p>如果在使用场景里面只有两个任务，且不考虑阻塞-唤醒（效率），就可以使用环形缓冲区，注意不要添加一个全局变量计数值，两个任务都来修改它的话可能会出问题。</p><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>队列的本质是加了互斥措施，阻塞-唤醒机制的环形缓冲区 .</p><p>1.有环形buffer</p><p>2.两个链表: 阻塞时放到对应的链表里，Sender List, Receiver List</p><p>一个任务想去读队列，如果队列里没有数据读不到数据且愿意等待的话，它将会从就绪链表ReadyTaskList里移除，放到队列的接收链表Receiver List和一个Delay链表（超时时间）里，若有其他任务写队列，会把这个任务唤醒，从接收链表和Delay链表中删去，重新放到ReadyList中，若是超时的话则中断会唤醒它，放到就绪列表ReadyTaskList中，有机会运行时，它的返回值就是一个错误的，我们就知道没有数据，是超时唤醒它。</p><p>当阻塞时有两种唤醒的情况，一种是其他任务唤醒它，另一种是超时中断唤醒。</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p><img src="/2024/01/29/FreeRTOS/image-20240203165500251.png" alt="image-20240203165500251"></p><img src="/2024/01/29/FreeRTOS/image-20240204113223528.png" alt="image-20240204113223528" style="zoom:50%;"><p>挡球板任务一直执行while循环，尝试去读，无阻塞低效率。要将其改进为读队列A，红外中断解析出数据后写队列A</p><p>1.创建一个队列A</p><p>2.在红外ISR（中断）中写队列A</p><p>3.挡球板任务中读队列A</p><h2 id="队列集"><a href="#队列集" class="headerlink" title="队列集"></a>队列集</h2><p>队列集其实也是一个队列，只不过里面放的是队列的句柄。</p><p>如果对于每一个硬件都单独创建一个任务，任务需要栈空间，对于系统资源很浪费。</p><p>不管有多少个设备，只有一个任务，就不会很浪费系统资源，那么任务要怎么及时读到各个硬件的数据呢，一种是用轮询的方式（不断的运行，一直都没有阻塞，浪费CPU资源），另一种是用队列集。</p><p><img src="/2024/01/29/FreeRTOS/image-20240204173837321.png" alt="image-20240204173837321"></p><h3 id="内部机制"><a href="#内部机制" class="headerlink" title="内部机制"></a>内部机制</h3><p><img src="/2024/01/29/FreeRTOS/image-20240204173241805.png" alt="image-20240204173241805"></p><p>队列写了数据，必定会顺带把自己的句柄写入队列级（不用我们操作，freertos来做这些事）</p><h3 id="队列集实验"><a href="#队列集实验" class="headerlink" title="队列集实验"></a>队列集实验</h3><p>改进程序框架</p><p><img src="/2024/01/29/FreeRTOS/image-20240206093625049.png" alt="image-20240206093625049"></p><p>IRReceiver_IRQTimes_Parse是红外遥控器的中断函数，他解析出按键值后，会转换成游戏控制的键值，然后写入Platform队列,这就涉及到了业务上的东西，它把键值转换成游戏控制的值，这样就不纯粹了，硬件相关的程序，不应该跟业务密切相关</p><img src="/2024/01/29/FreeRTOS/image-20240206094359196.png" alt="image-20240206094359196" style="zoom:50%;"><p>若对每个硬件都单独创建一个任务，对于系统的资源有极大的浪费</p><img src="/2024/01/29/FreeRTOS/image-20240206094847424.png" alt="image-20240206094847424" style="zoom:50%;"><p>正确的做法：</p><img src="/2024/01/29/FreeRTOS/image-20240206093654826.png" alt="image-20240206093654826" style="zoom:50%;"><p>硬件相关的代码与游戏没有关系</p><h3 id="配置队列集文件"><a href="#配置队列集文件" class="headerlink" title="配置队列集文件"></a>配置队列集文件</h3><p>要使用队列集，得配置freeRTOS,发现CUBEMX没有相关设置</p><p><img src="/2024/01/29/FreeRTOS/image-20240206115409463.png" alt="image-20240206115409463"></p><p>在freeRTOS.h中找到</p><p><img src="/2024/01/29/FreeRTOS/image-20240206115628455.png" alt="image-20240206115628455"></p><p>可以直接修改，但是如果CUBEMX重新生成工程，它又被恢复，直接把它加到FreeRTOSConfig.h中</p><p>如果运行工程，发现程序正常运行，但少了一些东西，可能是内存不够，堆不够，把3072改大一点比如8000</p><p><img src="/2024/01/29/FreeRTOS/image-20240206120715546.png" alt="image-20240206120715546"></p><p>程序15与14现象是一样的，但是框架更漂亮了。</p><h4 id="增加姿态控制"><a href="#增加姿态控制" class="headerlink" title="增加姿态控制"></a>增加姿态控制</h4><p>这次不是从中断获取数据，而是要创建一个任务，在while循环里面读I2C获取数据，然后写队列，然后在game任务将队列加入队列集</p><p>注意创建MPU6050任务时的顺序</p><p>刚开始是在freertos.c，在game1_task创建后马上就创建了6050的任务，如果6050的任务运行了，队列写满了，然后才把这个队列放入队列集，由于写满了，无法再向队列写数据，队列集得不到队列的句柄。（读取队列需要在队列集力先有该队列的句柄，但是这里把队列加入队列集之前队列就满了，队列写不了数据队列集也有没有句柄可读了）</p><p><img src="/2024/01/29/FreeRTOS/image-20240207115825852.png" alt="image-20240207115825852"></p><p>所以应该要在将6050加入队列集的代码之后再创建6050的任务</p><p><img src="/2024/01/29/FreeRTOS/image-20240207120435680.png" alt="image-20240207120435680"></p><h4 id="（实验）分发数据给多个任务"><a href="#（实验）分发数据给多个任务" class="headerlink" title="（实验）分发数据给多个任务"></a>（实验）分发数据给多个任务</h4><p>赛车游戏</p><p>引入了一个有意思的东西，比如想使用同一个输入数据来控制多个任务，可以在驱动程序里面，去写多个队列，去写哪些队列，其决定权可以交给应用程序，应用程序调用一个所谓的<strong>注册函数</strong>把它的句柄告诉驱动程序，驱动程序会把它记录下来。</p><p>如果只是一个队列，三个任务从这个队列读数据，则一个任务把数据读走了之后，另外两个任务就读不到数据了，所以要给每个任务创建一个队列，在红外中断解析函数得到数据后直接使用DispatchKey函数分配，把数据给各个队列都写一份，各个队列依据数据里的control_key判断是否是自己的。</p><p>可以这么写，但是写的比较丑陋，以后增加一个队列的话，又得来修改这些代码，且代码跟car密切相关，那这套代码就只能用在car上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DispatchKey</span><span class="params">(<span class="keyword">struct</span> ir_data *pidata)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> QueueHandle_t g_xQueueCar1;</span><br><span class="line"><span class="keyword">extern</span> QueueHandle_t g_xQueueCar2;</span><br><span class="line"><span class="keyword">extern</span> QueueHandle_t g_xQueueCar3;</span><br><span class="line"></span><br><span class="line">xQueueSendFromISR(g_xQueueCar1, pidata, <span class="literal">NULL</span>);</span><br><span class="line">xQueueSendFromISR(g_xQueueCar2, pidata, <span class="literal">NULL</span>);</span><br><span class="line">xQueueSendFromISR(g_xQueueCar3, pidata, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//driver_ir_receiver.c</span></span><br><span class="line"><span class="type">static</span> QueueHandle_t g_xQueues[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterQueueHandle</span><span class="params">(QueueHandle_t queueHandle)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (g_queue_cnt &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">g_xQueues[g_queue_cnt] = queueHandle;</span><br><span class="line">g_queue_cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DispatchKey</span><span class="params">(<span class="keyword">struct</span> ir_data *pidata)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_queue_cnt; i++)</span><br><span class="line">&#123;</span><br><span class="line">xQueueSendFromISR(g_xQueues[i], pidata, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//game2.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> &#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="type">int</span> control_key;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> <span class="title">g_cars</span>[3] =</span> &#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, IR_KEY_1&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">17</span>, IR_KEY_2&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">34</span>, IR_KEY_3&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">car_game</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">g_framebuffer = LCD_GetFrameBuffer(&amp;g_xres, &amp;g_yres, &amp;g_bpp);</span><br><span class="line">draw_init();</span><br><span class="line">draw_end();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 画出路标 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">draw_bitmap(<span class="number">16</span>*j, <span class="number">16</span>+<span class="number">17</span>*i, roadMarking, <span class="number">8</span>, <span class="number">1</span>, NOINVERT, <span class="number">0</span>);</span><br><span class="line">draw_flushArea(<span class="number">16</span>*j, <span class="number">16</span>+<span class="number">17</span>*i, <span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建3个汽车任务 */</span></span><br><span class="line">    xTaskCreate(CarTask, <span class="string">&quot;car1&quot;</span>, <span class="number">128</span>, &amp;g_cars[<span class="number">0</span>], osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">    xTaskCreate(CarTask, <span class="string">&quot;car2&quot;</span>, <span class="number">128</span>, &amp;g_cars[<span class="number">1</span>], osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">    xTaskCreate(CarTask, <span class="string">&quot;car3&quot;</span>, <span class="number">128</span>, &amp;g_cars[<span class="number">2</span>], osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">CarTask</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> *<span class="title">pcar</span> =</span> params;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ir_data</span> <span class="title">idata</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建自己的队列 */</span></span><br><span class="line">QueueHandle_t xQueueIR = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ir_data));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册队列 */</span></span><br><span class="line">RegisterQueueHandle(xQueueIR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 显示汽车 */</span></span><br><span class="line">ShowCar(pcar);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 读取按键值:读队列 */</span></span><br><span class="line">xQueueReceive(xQueueIR, &amp;idata, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制汽车往右移动 */</span></span><br><span class="line"><span class="keyword">if</span> (idata.val == pcar-&gt;control_key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x &lt; g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 隐藏汽车 */</span></span><br><span class="line">HideCar(pcar);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调整位置 */</span></span><br><span class="line">pcar-&gt;x += <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x &gt; g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line">pcar-&gt;x = g_xres - CAR_LENGTH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重新显示汽车 */</span></span><br><span class="line">ShowCar(pcar);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先car_game()创建三个任务，对应三辆汽车，传入的&amp;g_cars[0]，&amp;g_cars[1]，&amp;g_cars[2]，其中存放着它们各自的参数。这三个任务使用同一个CarTask函数，只是参数不同。</p><p>在CarTask函数中，会创建一个队列，属于当前任务，然后把这个队列注册（加到g_xQueues[10]中）。</p><p>然后再中断解析函数中调用dispatch函数，使用for循环，把解析出的数据给每一个队列都写一份数据，对应任务识别到自己相应control_key后才会继续响应。</p><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><h2 id="本质-1"><a href="#本质-1" class="headerlink" title="本质"></a>本质</h2><p>信号量本质上也是一个队列，但是它不涉及数据的传输，只涉及到里面数据个数的统计</p><p>例子</p><p>把信号量看成门票</p><p>取票为take，放票为give</p><p><img src="/2024/01/29/FreeRTOS/image-20240215091923497.png" alt="image-20240215091923497"></p><p><strong>信号量与队列对比</strong></p><p><img src="/2024/01/29/FreeRTOS/image-20240215092142252.png" alt="image-20240215092142252"></p><p><img src="/2024/01/29/FreeRTOS/image-20240215092450514.png" alt="image-20240215092450514"></p><p>对于阻塞的任务，高优先级排在前面，当信号量增加时会先唤醒高优先级的任务，同等优先级任务按先来后到的顺序执行。</p><p><img src="/2024/01/29/FreeRTOS/image-20240215094215394.png" alt="image-20240215094215394"></p><p> <strong>例子</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> SemaphoreHandle_t g_xSemTicks;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">car_game</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">g_framebuffer = LCD_GetFrameBuffer(&amp;g_xres, &amp;g_yres, &amp;g_bpp);</span><br><span class="line">draw_init();</span><br><span class="line">draw_end();</span><br><span class="line">g_xSemTicks=xSemaphoreCreateCounting(<span class="number">3</span>, <span class="number">1</span>);<span class="comment">//创建信号量，最大值为3，初始值为1</span></span><br><span class="line"><span class="comment">/* 画出路标 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">draw_bitmap(<span class="number">16</span>*j, <span class="number">16</span>+<span class="number">17</span>*i, roadMarking, <span class="number">8</span>, <span class="number">1</span>, NOINVERT, <span class="number">0</span>);</span><br><span class="line">draw_flushArea(<span class="number">16</span>*j, <span class="number">16</span>+<span class="number">17</span>*i, <span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建3个汽车任务 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">draw_bitmap(g_cars[i].x, g_cars[i].y, carImg, <span class="number">15</span>, <span class="number">16</span>, NOINVERT, <span class="number">0</span>);</span><br><span class="line">draw_flushArea(g_cars[i].x, g_cars[i].y, <span class="number">15</span>, <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    xTaskCreate(CarTask, <span class="string">&quot;car1&quot;</span>, <span class="number">128</span>, &amp;g_cars[<span class="number">0</span>], osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">    xTaskCreate(CarTask, <span class="string">&quot;car2&quot;</span>, <span class="number">128</span>, &amp;g_cars[<span class="number">1</span>], osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">    xTaskCreate(CarTask, <span class="string">&quot;car3&quot;</span>, <span class="number">128</span>, &amp;g_cars[<span class="number">2</span>], osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">CarTask</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> *<span class="title">pcar</span> =</span> params;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ir_data</span> <span class="title">idata</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建自己的队列 */</span></span><br><span class="line">QueueHandle_t xQueueIR = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ir_data));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册队列 */</span></span><br><span class="line">RegisterQueueHandle(xQueueIR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 显示汽车 */</span></span><br><span class="line">ShowCar(pcar);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取信号量</span></span><br><span class="line">xSemaphoreTake(g_xSemTicks,portMAX_DELAY);<span class="comment">//获取信号量，也就是票，如果没获得就一直等待</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 控制汽车往右移动 */</span></span><br><span class="line">        <span class="keyword">if</span> (pcar-&gt;x &lt; g_xres - CAR_LENGTH)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 隐藏汽车 */</span></span><br><span class="line">            HideCar(pcar);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 调整位置 */</span></span><br><span class="line">            pcar-&gt;x += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (pcar-&gt;x &gt; g_xres - CAR_LENGTH)</span><br><span class="line">            &#123;</span><br><span class="line">                pcar-&gt;x = g_xres - CAR_LENGTH;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 重新显示汽车 */</span></span><br><span class="line">            ShowCar(pcar);</span><br><span class="line">            vTaskDelay(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pcar-&gt;x == g_xres - CAR_LENGTH)</span><br><span class="line">            &#123;</span><br><span class="line">                xSemaphoreGive(g_xSemTicks);<span class="comment">//汽车跑到终点后，释放信号量，同时唤醒正在等待的任务</span></span><br><span class="line">                vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h2><p>低优先级的任务先运行<img src="/2024/01/29/FreeRTOS/image-20240215103515812.png" alt="image-20240215103515812"></p><p>上面这个例子，低优先级的任务先创建，并取走了信号量，然后中优先级的任务创建，执行一些东西，阻塞第一个任务且它不去获得信号量，然后高优先级的任务创建，阻塞中优先级任务并调用take函数，由于信号量被低优先级的任务取走了，所以它会阻塞，中优先级的任务继续执行，汽车到终点后自杀结束任务，然后低优先级的任务继续执行，汽车执行到终点后释放信号量，高优先级的任务才开始运行，从而实现了优先级反转。</p><h2 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h2><p>使用信号量时，先创建、然后去添加资源、获得资源。使用句柄来表示一个信号量。</p><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>使用信号量之前，要先创建，得到一个句柄；使用信号量时，要使用句柄来表明使用哪个信号量。 对于二进制信号量、计数型信号量，它们的创建函数不一样：</p><table><thead><tr><th></th><th>二进制信号量</th><th>计数型信号量</th></tr></thead><tbody><tr><td>动态创建</td><td>xSemaphoreCreateBinary 计数值初始值为0</td><td>xSemaphoreCreateCounting</td></tr><tr><td></td><td>vSemaphoreCreateBinary(过时了) 计数值初始值为1</td><td></td></tr><tr><td>静态创建</td><td>xSemaphoreCreateBinaryStatic</td><td>xSemaphoreCreateCountingStatic</td></tr></tbody></table><p>创建二进制信号量的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配信号量结构体 </span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinary</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinaryStatic</span><span class="params">( StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure><p>创建计数型信号量的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配信号量结构体 </span></span><br><span class="line"><span class="comment"> * uxMaxCount: 最大计数值</span></span><br><span class="line"><span class="comment"> * uxInitialCount: 初始计数值</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * uxMaxCount: 最大计数值</span></span><br><span class="line"><span class="comment"> * uxInitialCount: 初始计数值</span></span><br><span class="line"><span class="comment"> * pxSemaphoreBuffer: StaticSemaphore_t结构体指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCountingStatic</span><span class="params">( UBaseType_t uxMaxCount, </span></span><br><span class="line"><span class="params">                                                 UBaseType_t uxInitialCount, </span></span><br><span class="line"><span class="params">                                                 StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>对于动态创建的信号量，不再需要它们时，可以删除它们以回收内存。</p><p>vSemaphoreDelete可以用来删除二进制信号量、计数型信号量，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * xSemaphore: 信号量句柄，你要删除哪个信号量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure><h3 id="give-take"><a href="#give-take" class="headerlink" title="give&#x2F;take"></a>give&#x2F;take</h3><p>二进制信号量、计数型信号量的give、take操作函数是一样的。这些函数也分为2个版本：给任务使用，给ISR使用。列表如下：</p><table><thead><tr><th></th><th>在任务中使用</th><th>在ISR中使用</th></tr></thead><tbody><tr><td>give</td><td>xSemaphoreGive</td><td>xSemaphoreGiveFromISR</td></tr><tr><td>take</td><td>xSemaphoreTake</td><td>xSemaphoreTakeFromISR</td></tr></tbody></table><p>xSemaphoreGive的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure><p>xSemaphoreGive函数的参数与返回值列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>信号量句柄，释放哪个信号量</td></tr><tr><td>返回值</td><td>pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td></tr></tbody></table><p>pxHigherPriorityTaskWoken的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreGiveFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                        SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                        BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                    )</span>;</span><br></pre></td></tr></table></figure><p>xSemaphoreGiveFromISR函数的参数与返回值列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>信号量句柄，释放哪个信号量</td></tr><tr><td>pxHigherPriorityTaskWoken</td><td>如果释放信号量导致更高优先级的任务变为了就绪态， 则*pxHigherPriorityTaskWoken &#x3D; pdTRUE</td></tr><tr><td>返回值</td><td>pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td></tr></tbody></table><p>xSemaphoreTake的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">(</span></span><br><span class="line"><span class="params">                   SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                   TickType_t xTicksToWait</span></span><br><span class="line"><span class="params">               )</span>;</span><br></pre></td></tr></table></figure><p>xSemaphoreTake函数的参数与返回值列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>信号量句柄，获取哪个信号量</td></tr><tr><td>xTicksToWait</td><td>如果无法马上获得信号量，阻塞一会： 0：不阻塞，马上返回 portMAX_DELAY: 一直阻塞直到成功 其他值: 阻塞的Tick个数，可以使用*pdMS_TO_TICKS()*来指定阻塞时间为若干ms</td></tr><tr><td>返回值</td><td>pdTRUE表示成功</td></tr></tbody></table><p>xSemaphoreTakeFromISR的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreTakeFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                        SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                        BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                    )</span>;</span><br></pre></td></tr></table></figure><p>xSemaphoreTakeFromISR函数的参数与返回值列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>信号量句柄，获取哪个信号量</td></tr><tr><td>pxHigherPriorityTaskWoken</td><td>如果获取信号量导致更高优先级的任务变为了就绪态， 则*pxHigherPriorityTaskWoken &#x3D; pdTRUE</td></tr><tr><td>返回值</td><td>pdTRUE表示成功</td></tr></tbody></table><h1 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h1>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog Building</title>
      <link href="/2024/01/28/blog-building/"/>
      <url>/2024/01/28/blog-building/</url>
      
        <content type="html"><![CDATA[<p>前言：之前一直想搭个博客，但是本身自己专业也不是学计算机的，从0开始搭建网站对于我的学习成本较高，就不了了之了，偶然发现了基于hexo框架+github的方式来搭建博客，参考了很多教程及视频，不是一帆风顺，也有好几次要放弃了，最后还是遇到问题就解决问题，到网上查资料，经过几天的努力,最后搭建了这个博客，目前差不多是个雏形，后面还会继续优化，在此写下这篇文档，记录下当时参考的一些资料文档。</p><h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><p>参考教程</p><p><a href="http://t.csdnimg.cn/ocJp5">http://t.csdnimg.cn/ocJp5</a></p><p><a href="http://t.csdnimg.cn/8707P">http://t.csdnimg.cn/8707P</a></p><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  <span class="comment">//清除缓存文件（包括生成的静态文件和草稿）。</span></span><br><span class="line"></span><br><span class="line">hexo g     <span class="comment">//生成静态文件，即将你的文章、页面等转换为 HTML 等静态文件。</span></span><br><span class="line">    </span><br><span class="line">hexo s<span class="comment">//启动服务器，用于预览博客效果。</span></span><br><span class="line"></span><br><span class="line">hexo d<span class="comment">//部署博客到指定的服务器，比如 GitHub Pages 或者 CSDN 等。</span></span><br></pre></td></tr></table></figure><h2 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h2><p>参考教程：</p><p><a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><p><a href="https://blog.csdn.net/mjh1667002013/article/details/129290903">https://blog.csdn.net/mjh1667002013/article/details/129290903</a></p><p>【使用Hexo搭建个人博客手摸手教学(8)|butterfly主题页面配置】 <a href="https://www.bilibili.com/video/BV1Fb4y1r7ja/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1Fb4y1r7ja/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></p><p>【【Hexo】2023年零基础玩转Hexo全网最全系列】 <a href="https://www.bilibili.com/video/BV1QD4y1F7pc/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1QD4y1F7pc/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></p><h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><h4 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;我的第一篇博客&quot;</span> <span class="comment">//新建一篇文章。</span></span><br></pre></td></tr></table></figure><p>​然后打开D:\Hexo\source\ _posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。<br>​你可以会直接在vscode里面编写这个markdown文件，可以实时预览，也可以用用其他编辑md文件的软件的工具编写。<br>​编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p><h4 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h4><p>修改<strong>主题</strong>配置文件 <code>_config.butterfly.yml</code>（在你用的那个主题的文件夹里的config文件修改）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">menu:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">list||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">    <span class="attr">link:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">    <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br><span class="line">  <span class="attr">Picture:</span> <span class="string">/gallery</span> <span class="string">||</span> <span class="string">fa-solid</span> <span class="string">fa-image</span></span><br></pre></td></tr></table></figure><p>最左侧的即是展示在网站右上侧的导航栏的各栏的名称,右边是对应的md文件,可以在其中修改该界面的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: zhixiong<span class="number">&#x27;</span>s page<span class="comment">//网页标题</span></span><br><span class="line">date: <span class="number">2024</span><span class="number">-01</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">30</span>:<span class="number">52</span></span><br><span class="line">type: <span class="string">&quot;tags&quot;</span></span><br><span class="line">top_img: <span class="string">&quot;./images/3.jpg&quot;</span> <span class="comment">//该网页最上方的图片</span></span><br></pre></td></tr></table></figure><p>然后后面的fa fa-link这种，是导航栏各个栏目的图标, 以及侧方个人信息栏社交图标，可在<a href="https://fontawesome.com/">https://fontawesome.com/</a> 查找使用。</p><h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><p><strong>上传图像</strong></p><p><em>网页图像</em></p><p>例 archive_img: <a href="http://www.xf5z.com/uploads/2013010764676533.jpg">http://www.xf5z.com/uploads/2013010764676533.jpg</a>   (右键图片，点击复制图片地址)</p><p><em>本地图像</em></p><p>index_img: “.&#x2F;images&#x2F;1.jpg”   (在source里建了个images文件夹，里面存放图片)</p><p><strong>Typora与hexo图片上传问题</strong></p><p><a href="https://www.cnblogs.com/yinyoupoet/p/13287385.html">https://www.cnblogs.com/yinyoupoet/p/13287385.html</a></p><p><strong>相册</strong></p><p><a href="https://www.bilibili.com/video/BV1Fw411Q7pS/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=a9d487fcf1a579639c6348eb5a9321db">https://www.bilibili.com/video/BV1Fw411Q7pS/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&amp;vd_source=a9d487fcf1a579639c6348eb5a9321db</a></p><p><a href="https://butterfly.js.org/posts/4aa8abbe/#Gallery%E7%9B%B8%E5%86%8A%E5%9C%96%E5%BA%AB">https://butterfly.js.org/posts/4aa8abbe/#Gallery%E7%9B%B8%E5%86%8A%E5%9C%96%E5%BA%AB</a></p><h4 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h4><p><a href="https://blog.csdn.net/qq_45173404/article/details/122877378">https://blog.csdn.net/qq_45173404/article/details/122877378</a></p><p>取消当前页面评论:</p><p>在md文件中加上comments: false</p><h4 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a>音乐播放器</h4><p><a href="https://butterfly.js.org/posts/507c070f/?highlight=apla">https://butterfly.js.org/posts/507c070f/?highlight=apla</a></p><h4 id="自定义侧边栏"><a href="#自定义侧边栏" class="headerlink" title="自定义侧边栏"></a>自定义侧边栏</h4><p><a href="https://butterfly.js.org/posts/ea33ab97/#widget-%E6%8E%92%E5%BA%8F">https://butterfly.js.org/posts/ea33ab97/#widget-%E6%8E%92%E5%BA%8F</a></p><h4 id="动态彩带"><a href="#动态彩带" class="headerlink" title="动态彩带"></a>动态彩带</h4><p>好看的彩带背景，会飘动。<br> 修改主题配置文件<code>_config.butterfly.yml</code>。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">canvas_fluttering_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># false 手机端不显示 true 手机端显示</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="文章分类"><a href="#文章分类" class="headerlink" title="文章分类"></a>文章分类</h4><p><a href="http://t.csdnimg.cn/Uc0Uy">http://t.csdnimg.cn/Uc0Uy</a></p><p>把文章归入分类只需在文章的顶部标题下方添加<code>categories</code>字段，即可自动创建分类名并加入对应的分类中。</p><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>把文章添加标签只需在文章的顶部标题下方添加<code>tags</code>字段，即可自动创建标签名并归入对应的标签中 。</p><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">title: Embedded C language</span><br><span class="line">date: <span class="number">2024</span><span class="number">-01</span><span class="number">-26</span> <span class="number">19</span>:<span class="number">04</span>:<span class="number">36</span></span><br><span class="line">description: C语言在单片机编程的一些重要应用</span><br><span class="line">comments: <span class="literal">true</span></span><br><span class="line">categories:</span><br><span class="line">- embedded</span><br><span class="line">tags:</span><br><span class="line">- C language programming</span><br></pre></td></tr></table></figure><h4 id="文章加密"><a href="#文章加密" class="headerlink" title="文章加密"></a>文章加密</h4><p>首先安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install –save hexo-blog-encrypt</span><br></pre></td></tr></table></figure><p>然后在hexo全局配置文件_config.yml 中启用该插件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Security</span><br><span class="line">encrypt:</span><br><span class="line">    enable: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后在需要加密的文章头部添加所要求的字段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章加密</span><br><span class="line">date: 2020-06-04 9:46:03</span><br><span class="line">password: 123</span><br><span class="line">abstract: 这是一篇加密博文，请输入密码后查看</span><br><span class="line">message: 这里需要密码才能访问。</span><br><span class="line">wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Embedded C language</title>
      <link href="/2024/01/26/Embedded-C-language/"/>
      <url>/2024/01/26/Embedded-C-language/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式C语言与算法"><a href="#嵌入式C语言与算法" class="headerlink" title="嵌入式C语言与算法"></a>嵌入式C语言与算法</h1><p><img src="/2024/01/26/Embedded-C-language/image-20240115231828910.png" alt="image-20240115231828910"></p><p><img src="/2024/01/26/Embedded-C-language/image-20240115232323794.png" alt="image-20240115232323794"></p><p>简述C语言中的基础知识<br>    1).数据类型(常用char, short, int , long, signed, unsigned, float, double, sizeof)<br>    2).运算和控制( &#x3D;, +, -, *, while, do-while, if, else, switch, case, continue, break)<br>    3).数据存储(static, extern, const, volatile)<br>    4).结构(struct, enum, union, typedef)<br>    5).位操作和逻辑运算(&lt;&lt;, &gt;&gt;, &amp;, |, ~, ^)<br>    6).预处理(#define, #include, #if…#elif…#else…#endif等)</p><img src="/2024/01/26/Embedded-C-language/image-20240119170447733.png" alt="image-20240119170447733" style="zoom:67%;"><h2 id="1-char-short-int数据类型"><a href="#1-char-short-int数据类型" class="headerlink" title="1.char short int数据类型"></a>1.char short int数据类型</h2><p>对于单片机开发来说，是至关重要的。因为单片机有8位、16位、32位。如果不注意数据类型，不注意数据长度，那么在编写代码的时候，很容易就会造成数据溢出，导致程序出现bug，而且还很难发现原因。</p><p>如果熟悉stm32单片机开发的同学，看官方的例程时，使用的数据类型往往都是重新定义过的类型，很少有直接使用原始数据类型的，比如GPIOIO口设置。</p><p>为什么要这样做吗？不嫌麻烦吗？自己平时写程序的时候，往往都是直接使用数据类型的默认名，也依然可以正常使用，没什么问题。但是官方为什么一定要重新定义一次数据类型呢？</p><p>个说白了就是大局观的问题，因为官方比我们个人更具有大局观。个人面对的可能也只有几个平台和几款单片机。而官方面对的是多个平台和多种单片机的，这就不得不考虑数据兼容问题了。比如在32位单片机上的算法移植到8位单片机上，代码运行起来后，到处都是数据溢出。要挨个去修改变量的数据类型，那么这时候，作为开发者来说，奔溃不奔溃？抓狂不抓狂？</p><p>所以为了解决这个问题，官方就会在每个平台下，给数据类型，重新命名一次，如果需要更换平台，那么只需要替换这个数据重命名的头文件即可。</p><p>在32位单片机中int是32位，而在8位单片机中long 才是32位。那么在32位单片机上的int型变量，如果直接移植到8位单片机上的话，那么肯定就会出现数据溢出的问题。</p><p>那么如果使用了重命名后的新变量类型 uint32_t ，不论在8位和32位的单片机上，这个数据都会是32位，这样通过数据类型的重定义，就避免了，同样的数据类型，在不同平台上长度不一致的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br></pre></td></tr></table></figure><p>不同平台数据类型所占字节对比：</p><p>（1个字节有8位）</p><p><img src="/2024/01/26/Embedded-C-language/image-20240113193817299.png" alt="image-20240113193817299"></p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>见”union共同体”章节</p><h4 id="实例应用"><a href="#实例应用" class="headerlink" title="实例应用"></a>实例应用</h4><p>1.<em>智能家居：网关协议，mac地址上报？</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *mac=<span class="string">&quot;192.168.31.84&quot;</span></span><br><span class="line"><span class="type">char</span> mac_array[<span class="number">4</span>]=&#123;<span class="number">192</span>,<span class="number">168</span>,<span class="number">31</span>,<span class="number">84</span>&#125;</span><br></pre></td></tr></table></figure><p>mac地址如上所示为”192.168.31.84”，为了将其上传到服务器，在定通讯协议时，会和服务器的同事沟通好，收到下面这样一个mac_array数组时，就在每两个数之间加一个小数点来表示mac地址。</p><p>即我们将mac地址转化为一个char类型的数组上传到服务器。</p><p>提问：<strong>为什么mac_array数组的类型用char,而不用int等数据类型？</strong></p><p>答：你可以把数据类型当成一个容器来存放数字，只是它们的容量不同，比如</p><p>char占用1个字节的内存空间，一个字节有8位，能存放0~255之间的数字，因此char类型很适合表示0-255之间的整数，这个范围完全满足IP地址中每个字段的需求。</p><p>如果使用int类型，它通常占用4个字节的内存空间，0-65535，对于用来储存仅需0-255之间的数值而言过于庞大，将浪费大量存储空间，因此在这种情况下，使用char类型更为合适</p><p>2.<em>奶茶机器人：温度采集，小数点如何上报云端？</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> temp = <span class="number">37.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> temp_array[<span class="number">2</span>] = &#123;<span class="number">37</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>服务器发过来unix时间戳 :1607143247，一般是发的hex，即发的是5FCB0F4F，我们接受这串数据，并将其重新解析为时间</p><p>5FCB0F4F  {0x5F,0xCB,0x0F,0x4F} </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> time_buffer[<span class="number">4</span>]=&#123;<span class="number">0x5F</span>,<span class="number">0xCB</span>,<span class="number">0x0F</span>,<span class="number">0x4F</span>&#125;;<span class="comment">//十六进制的一位等于四位二进制</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> time;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">u8Tou32B</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (((((((<span class="type">unsigned</span> <span class="type">int</span>)buffer[<span class="number">0</span>])&lt;&lt;<span class="number">8</span>)|buffer[<span class="number">1</span>])&lt;&lt;<span class="number">8</span>)|buffer[<span class="number">2</span>])&lt;&lt;<span class="number">8</span>)|buffer[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    time=u8Tou32B(time_buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time =%ld s\n&quot;</span>,time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5FCB0F4F  {0x5F,0xCB,0x0F,0x4F} </p><p>u8Tou32B函数的作用是将一个包含四个字节的unsigned char数组转换成一个unsigned int类型的32位无符号整数，就是把5F,CB,0F,4F拼起来。</p><p>继续对上面的u8Tou32B函数进行优化得</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">u8Tou32B_optimized</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;result, buffer, <span class="keyword">sizeof</span>(result));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    time = u8Tou32B_optimized(time_buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time = %u s\n&quot;</span>, time); <span class="comment">// 使用%u正确打印无符号整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-位操作"><a href="#2-位操作" class="headerlink" title="2.位操作"></a>2.位操作</h2><h3 id="位，字节，进制"><a href="#位，字节，进制" class="headerlink" title="位，字节，进制"></a>位，字节，进制</h3><p>1个字节&#x3D;8个二进制位</p><h4 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h4><p>0b开头，只有0，1，一个字节有8位，该字节能表示的最大数字是把所有位都设置为1：(11111111)&#x3D;256,因此1字节可储存0~255范围内的数字。</p><p>通常unsignedchar 用1字节表示的范围是0<del>255，而signed char 用1字节表示的范围是-128</del>+127.</p><h4 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h4><p>0x开头，用0~15表示数字（0-9，10-15为A-F）</p><p><em><strong>每个十六进制位都对应一个4位的二进制数（即4个二进制位）</strong></em>（2^4&#x3D;16,即一个四位的二进制数可以表示从0到15的所有整数值），那么两个十六进制位恰好对应一个8位字节。第一个十六进制表示前4位，第2个十六进制位表示后4位</p><p>不同类型数据的转换可见union共同体章节</p><h3 id="位逻辑运算符"><a href="#位逻辑运算符" class="headerlink" title="位逻辑运算符"></a>位逻辑运算符</h3><p><img src="/2024/01/26/Embedded-C-language/image-20240113211004993.png" alt="image-20240113211004993"> </p><p>位与&amp;:对于每个位，只有两个对象中相应的位都为1时，结果才为1        &amp;&#x3D;</p><p>（10010011）&amp;（00111101）&#x3D;（00010001）</p><p>常见用法: ch&amp;&#x3D;0xff(0xff二进制形式是11111111，这个掩码保持ch中最后8位不变，其它位都设置为0)   </p><p>位或|:只要有一个1就为1       |&#x3D;</p><p>（10010011）|（00111101）&#x3D;（10111111）</p><p>0x20|0x0C&#x3D;0x2C</p><p>位异或^:</p><p>取反~:把0变为1，1变为0</p><p>在c语言中，<code>!</code>和<code>~</code>均表示取反。</p><p>这两个符号的区别在于：</p><ul><li><strong><code>!</code></strong> : 代表<strong>逻辑取反</strong>，即：把非0的数值变为0，0变为1;</li><li><em><strong>*<code>~</code>*</strong></em> : 表示<strong>按位取反</strong>，即在数值的二进制表示方式上,将0变为1，将1变为0。</li></ul><h3 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h3><p>按位与运算符常用于掩码（mask）。所谓掩码指的是一些设置为开（1）或关（0）的位组合</p><p>常见用法: ch&amp;&#x3D;0xff(0xff二进制形式是11111111，这个掩码保持ch中最后8位不变，其它位都设置为0)</p><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>左移&lt;&lt;:  将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）</p><p>（10001010）&lt;&lt;2&#x3D;(001010000)</p><p>右移&gt;&gt;:  (10001010)&gt;&gt;2&#x3D;(00100010)</p><h4 id="从较大单元中提取一些位"><a href="#从较大单元中提取一些位" class="headerlink" title="从较大单元中提取一些位"></a>从较大单元中提取一些位</h4><p>此处可链接到“十六进制”章节中</p><p>（<em><strong>每个十六进制位都对应一个4位的二进制数（即4个二进制位）</strong></em>（2^4&#x3D;16,即一个四位的二进制数可以表示从0到15的所有整数值），那么两个十六进制位恰好对应一个8位字节。第一个十六进制表示前4位，第2个十六进制位表示后4位）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE_MASK 0xff</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> color =<span class="number">0x002a162f</span>;<span class="comment">//一个十六进制位对应四个二进制位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> blue,green,red;</span><br><span class="line"></span><br><span class="line">red=color&amp;BYTE_MASK;<span class="comment">//取color低8位</span></span><br><span class="line">green=(color&gt;&gt;<span class="number">8</span>)&amp;BYTE_MASK;<span class="comment">//将color右移8位（8个二进制位），再用掩码取低8位，则可使green取color中间8位</span></span><br><span class="line">blue=(color&gt;&gt;<span class="number">16</span>)&amp;BYTE_MASK;<span class="comment">//将color右移16位（16个二进制位)，再用掩码取低8位，则可使blue取color高8位</span></span><br></pre></td></tr></table></figure><p><img src="/2024/01/26/Embedded-C-language/image-20240114140043073.png" alt="image-20240114140043073"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_SET_INPUT_POS:</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(data, &amp;(odrive_set-&gt;input_pos), <span class="number">4</span>);<span class="comment">//4个字节 32位 ，input_pos也是32位，复制到data数组中  uint8_t data[8]  ，yi会将数组前四位补齐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//odrive_set-&gt;vel_ff  vel_ff有16位 两个字节 ,data的一个元素的类型是uint8_t,有8位</span></span><br><span class="line">       data[<span class="number">4</span>] = odrive_set-&gt;vel_ff &amp; <span class="number">0x00FF</span>;<span class="comment">//保留低8位</span></span><br><span class="line"><span class="comment">//packetlength &amp; 0x00FF中的&amp;是先把&amp;两边的值转换成二进制形式，然后在进行按位运算</span></span><br><span class="line">       data[<span class="number">5</span>] = odrive_set-&gt;vel_ff &gt;&gt; <span class="number">8</span>;<span class="comment">//取高8位</span></span><br><span class="line"></span><br><span class="line">       data[<span class="number">6</span>] = odrive_set-&gt;current_ff &amp; <span class="number">0x00FF</span>;</span><br><span class="line">       data[<span class="number">7</span>] = odrive_set-&gt;current_ff &gt;&gt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       header.RTR = CAN_RTR_DATA;</span><br><span class="line">       header.DLC = <span class="number">8</span>;</span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h2><p>float candy[365];&#x2F;<em>内含365个float类型元素的数组</em>&#x2F;</p><h2 id="4-结构体struct"><a href="#4-结构体struct" class="headerlink" title="4.结构体struct"></a>4.结构体struct</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><strong>结构</strong>体是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p><p>结构体中的数据成员可以是基本数据类型（如 int、float、char 等），也可以是其他结构体类型、指针类型等。</p><p>关键字–struct, union, typedef</p><p>运算符: . ,-&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title function_">xxx</span><span class="params">(标签，这个结构体的名字)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​xxx(变量定义);</span><br><span class="line"></span><br><span class="line">&#125;xxx(结构变量);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明结构类型</span></span><br><span class="line"><span class="comment">/*1*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> daty;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span>;</span><span class="comment">/*定义某种结构类型的变量*/</span></span><br><span class="line"><span class="comment">/*2*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;p1,p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*3*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;p1,p2;</span><br><span class="line"><span class="comment">/*4*/</span></span><br><span class="line"><span class="keyword">typedef</span> &#123;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> daty;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;today;</span><br><span class="line"></span><br><span class="line">today Today1;</span><br></pre></td></tr></table></figure><p>在一般情况下，标签、变量定义，结构变量这 3 部分至少要出现 2 个</p><h4 id="tyepedef-struct"><a href="#tyepedef-struct" class="headerlink" title="tyepedef struct"></a>tyepedef struct</h4><p>typedef是类型定义的意思。typedef <a href="https://so.csdn.net/so/search?q=struct&spm=1001.2101.3001.7020">struct</a> 是为了使用这个结构体方便。</p><p>具体区别在于:<br> 若struct <a href="https://so.csdn.net/so/search?q=node&spm=1001.2101.3001.7020">node</a> {}这样来定义结构体的话。在申请node 的变量时，需要这样写，struct node n;<br> 若用typedef，可以这样写，typedef struct node{}NODE; 。在申请变量时就可以这样写，NODE n;<br> 区别就在于使用时，是否可以省去struct这个关键字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;Stu;</span><br><span class="line">于是在声明变量的时候就可：Stu stu1;</span><br><span class="line">如果没有<span class="keyword">typedef</span>就必须用<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>;</span>来声明</span><br><span class="line">这里的Stu实际上就是<span class="class"><span class="keyword">struct</span> <span class="title">Student</span>的别名。</span></span><br></pre></td></tr></table></figure><h4 id="例-odrive-stm32驱动代码（可作为使用结构体时的模板）"><a href="#例-odrive-stm32驱动代码（可作为使用结构体时的模板）" class="headerlink" title="例 odrive&amp;stm32驱动代码（可作为使用结构体时的模板）"></a>例 odrive&amp;stm32驱动代码（可作为使用结构体时的模板）</h4><p>建立结构声明（模板），定义结构变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*odrive.h*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> axis_error;</span><br><span class="line">  <span class="type">uint32_t</span> axis_current_state;</span><br><span class="line">  <span class="type">uint32_t</span> motor_error;</span><br><span class="line">  <span class="type">uint32_t</span> encoder_error;</span><br><span class="line">  <span class="type">uint32_t</span> sensorless_error;</span><br><span class="line">  <span class="type">float</span> encoder_pos_estimate;</span><br><span class="line">  <span class="type">float</span> encoder_vel_estimate;</span><br><span class="line">  <span class="type">int32_t</span> encoder_shadow_count;</span><br><span class="line">  <span class="type">int32_t</span> encoder_cpr_count;</span><br><span class="line">  <span class="type">float</span> iq_setpoint;</span><br><span class="line">  <span class="type">float</span> iq_measured;</span><br><span class="line">  <span class="type">float</span> sensorless_pos_estimate;</span><br><span class="line">  <span class="type">float</span> sensorless_vel_estimate;</span><br><span class="line">  <span class="type">float</span> vbus_voltage;</span><br><span class="line">&#125; OdriveAxisGetState_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把odrive_set_axis0()声明为一个OdriveAxisSetState_t（在odrive.h定义的结构体）类型的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*odrive.c*/</span></span><br><span class="line">OdriveAxisSetState_t odrive_set_axis0;</span><br><span class="line">OdriveAxisSetState_t odrive_set_axis1;</span><br></pre></td></tr></table></figure><h4 id="结构的初始化"><a href="#结构的初始化" class="headerlink" title="结构的初始化"></a>结构的初始化</h4><p>struct date today&#x3D;{07,31,2014};</p><h4 id="结构成员"><a href="#结构成员" class="headerlink" title="结构成员"></a>结构成员</h4><p>在C语言中，访问结构体成员时选择使用.或-&gt;主要取决于你当前操作的对象是<strong>结构体实例本身</strong>还是<strong>指向该结构体的指针</strong>：</p><p>•使用.（点号）的情况：当直接操作一个已知的结构体变量时，通过.来访问其内部成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>;</span></span><br><span class="line">stu1.name=<span class="string">&#x27;&#x27;John Doe&#x27;</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string">stu1.age = 20;</span></span><br></pre></td></tr></table></figure><p>•使用-&gt;（箭头）的情况：当操作的是指向结构体的指针时，用-&gt;来访问该指针所指向的结构体的成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">stuP</span>;</span></span><br><span class="line">stuP = &amp;stu1; <span class="comment">// 或者 stuP = malloc(sizeof(struct Student));</span></span><br><span class="line"></span><br><span class="line">stuP-&gt;name = <span class="string">&quot;Jane Smith&quot;</span>; <span class="comment">// 使用 -&amp;gt; 访问结构体指针 stuP 所指向的结构体的成员</span></span><br><span class="line">stuP-&gt;age = <span class="number">22</span>;</span><br></pre></td></tr></table></figure><p>简而言之，如果你有一个结构体变量名，就用.；如果你有一个指向结构体的指针，就用-&gt;。</p><h4 id="结构指针"><a href="#结构指针" class="headerlink" title="结构指针"></a>结构指针</h4><p>和数组不同，结构变量的名字不是结构变量的地址，必须使用&amp;运算符</p><h4 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h4><p>向函数传递结构体的信息：1.传递结构体成员  2.传递结构体地址  3.传递结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  GPIO_PIN_RESET = <span class="number">0</span>,</span><br><span class="line">  GPIO_PIN_SET</span><br><span class="line">&#125;GPIO_PinState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> MODER;    <span class="comment">/*!&lt; GPIO port mode register,               Address offset: 0x00      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> OTYPER;   <span class="comment">/*!&lt; GPIO port output type register,        Address offset: 0x04      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> OSPEEDR;  <span class="comment">/*!&lt; GPIO port output speed register,       Address offset: 0x08      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> PUPDR;    <span class="comment">/*!&lt; GPIO port pull-up/pull-down register,  Address offset: 0x0C      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> IDR;      <span class="comment">/*!&lt; GPIO port input data register,         Address offset: 0x10      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ODR;      <span class="comment">/*!&lt; GPIO port output data register,        Address offset: 0x14      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> BSRR;     <span class="comment">/*!&lt; GPIO port bit set/reset register,      Address offset: 0x18      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> LCKR;     <span class="comment">/*!&lt; GPIO port configuration lock register, Address offset: 0x1C      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AFR[<span class="number">2</span>];   <span class="comment">/*!&lt; GPIO alternate function registers,     Address offset: 0x20-0x24 */</span></span><br><span class="line">&#125; GPIO_TypeDef;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*传递结构体地址*/</span></span><br><span class="line">GPIO_PinState <span class="title function_">HAL_GPIO_ReadPin</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span><span class="comment">//第一位GPIO_TypeDef* GPIOx是传入结构体的地址，以便在这个函数中使用这个结构体</span></span><br><span class="line">&#123;</span><br><span class="line">  GPIO_PinState bitstatus;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GPIO_PIN(GPIO_Pin));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((GPIOx-&gt;IDR &amp; GPIO_Pin) != (<span class="type">uint32_t</span>)GPIO_PIN_RESET)<span class="comment">//操作对象是指向结构体的指针，访问该结构体成员时用-&gt;</span></span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = GPIO_PIN_SET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = GPIO_PIN_RESET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bitstatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p><em><strong>typedef 在 MDK 用得最多的就是定义结构体的类型别名和枚举类型了。</strong></em>(typedef struct, typedef enum)</p><p>利用typedef可以为某一类型自定义名称(为现有类型创建一个名称)，它没有创建任何新类型，只是为某个已存在的类型增加了一个方便使用的标签。</p><p>1.为经常出现的类型创建一个方便，易识别的类型名。</p><p>2.常用于给复杂的类型命名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用BYTE表示1字节的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> BYTE</span><br><span class="line"><span class="comment">//随后可以用BYTE来定义变量</span></span><br><span class="line">BYTE x,y[<span class="number">10</span>],*z;</span><br><span class="line"><span class="comment">//#define也可发挥上面同样的功能</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE unsigned char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以把typedef用于结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span></span><br><span class="line">    <span class="type">float</span> real;</span><br><span class="line">    <span class="type">float</span> imag;</span><br><span class="line">&#125;COMPLEX;</span><br><span class="line"><span class="comment">//然后可用COMPLEX类型代替complex结构</span></span><br><span class="line">用<span class="keyword">typedef</span>来命名一个结构类型时，可以省略该结构的标签。（见例odrive&amp;stm32驱动代码）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以为结体定义一个别名 GPIO_TypeDef，这样我们就可以在其他地方通过别名 GPIO_TypeDef 来定义结构体变量了。</p><p>方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> __IO <span class="type">uint32_t</span> CRL;</span><br><span class="line"> __IO <span class="type">uint32_t</span> CRH;</span><br><span class="line">…</span><br><span class="line">&#125; GPIO_TypeDef;</span><br></pre></td></tr></table></figure><p>Typedef 为结构体定义一个别名 GPIO_TypeDef。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_TypeDef _GPIOA,_GPIOB;</span><br></pre></td></tr></table></figure><p>GPIO_TypeDef 就跟 struct _GPIO 是等同的作用了</p><h3 id="enum枚举"><a href="#enum枚举" class="headerlink" title="enum枚举"></a>enum枚举</h3><p>enum枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。（一个被命名的整形常数的集合 ）</p><p>枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure><p>我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MON  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TUE  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WED  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THU  4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRI  5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAT  6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUN  7</span></span><br></pre></td></tr></table></figure><h4 id="声明枚举类型"><a href="#声明枚举类型" class="headerlink" title="声明枚举类型"></a>声明枚举类型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="枚举变量的定义"><a href="#枚举变量的定义" class="headerlink" title="枚举变量的定义"></a>枚举变量的定义</h4><p>我们可以通过以下三种方式来定义枚举变量</p><p><strong>1、先定义枚举类型，再定义枚举变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">day</span>;</span></span><br></pre></td></tr></table></figure><p><strong>2、定义枚举类型的同时定义枚举变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure><p><strong>3、省略枚举名称，直接定义枚举变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure><h4 id="typedef-enum"><a href="#typedef-enum" class="headerlink" title="typedef enum"></a>typedef enum</h4><p>是不是感觉和enum没什么区别，确实在一般的使用中两个的结果是差不多的。</p><p>但是如果你想定义一个和DAY类型一样的集合的情况下，使用typedef enum更方便</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">举例子：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> &#123;</span> MON, TUE=<span class="number">2</span>, WED, THU, FRI, SAT, SUN  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">workday</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">restday</span>;</span></span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> &#123;</span> MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN  &#125;DAY_TYPE; </span><br><span class="line"></span><br><span class="line">DAY_TYPE workday,restday;</span><br></pre></td></tr></table></figure><p>（此处用法与typedef struct一样）</p><p>枚举（enum）成员的值默认是整型，并且从0开始递增。虽然枚举类型本身不直接支持十六进制的声明方式，但你可以手动为枚举成员赋值，这个值可以是任何整数常量，当然包括十六进制表示的整数</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  MSG_CO_NMT_CTRL = <span class="number">0x000</span>,      <span class="comment">// CANOpen NMT Message REC</span></span><br><span class="line">  MSG_SET_INPUT_POS = <span class="number">0x00C</span>,    <span class="comment">// 输入的电机目标位置</span></span><br><span class="line">  MSG_SET_INPUT_VEL = <span class="number">0x00D</span>,    <span class="comment">// 输入的电机目标转速-------###</span></span><br><span class="line">  MSG_CLEAR_ERRORS = <span class="number">0x018</span>,     <span class="comment">// 清除错误</span></span><br><span class="line">  MSG_CO_HEARTBEAT_CMD = <span class="number">0x700</span>, <span class="comment">// CANOpen NMT Heartbeat SEND</span></span><br><span class="line">&#125; Odrive_Commond;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用于switch case中：</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">odrv_write_msg</span><span class="params">(Axis_t axis, Odrive_Commond cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">switch</span>(cmd)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> MSG_GET_ENCODER_COUNT:</span><br><span class="line">        header.RTR = CAN_RTR_REMOTE;  <span class="comment">//数据帧的优先级大于远程帧，当有多个设备向一个ID同时发送数据时，用远程帧可以有效地避免总线冲突，即ID收到消息后会先回发数据帧，再处理远程帧</span></span><br><span class="line">        header.DLC = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MSG_SET_CONTROLLER_MODES:</span><br><span class="line">        data[<span class="number">0</span>] = odrive_set-&gt;control_mode;</span><br><span class="line">        data[<span class="number">4</span>] = odrive_set-&gt;input_mode;</span><br><span class="line">        header.RTR = CAN_RTR_DATA;</span><br><span class="line">        header.DLC = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MSG_SET_TRAJ_ACCEL_LIMITS:</span><br><span class="line">        <span class="built_in">memcpy</span>(data, &amp;(odrive_set-&gt;traj_accel_limit), <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp_word, &amp;(odrive_set-&gt;traj_decel_limit), <span class="number">4</span>);</span><br><span class="line">        data[<span class="number">4</span>] = tmp_word[<span class="number">0</span>];</span><br><span class="line">        data[<span class="number">5</span>] = tmp_word[<span class="number">1</span>];</span><br><span class="line">        data[<span class="number">6</span>] = tmp_word[<span class="number">2</span>];</span><br><span class="line">        data[<span class="number">7</span>] = tmp_word[<span class="number">3</span>];</span><br><span class="line">        header.RTR = CAN_RTR_DATA;</span><br><span class="line">        header.DLC = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//enum枚举常用于状态表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NORMAL,</span><br><span class="line">    CHANGE,</span><br><span class="line">&#125; FSMMode_e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PASSIVE = <span class="number">1</span>,    <span class="comment">// 阻尼</span></span><br><span class="line">    FALL = <span class="number">2</span>,       <span class="comment">// 卧倒</span></span><br><span class="line">    FIXEDSTAND = <span class="number">3</span>, <span class="comment">// 固定站立</span></span><br><span class="line">    FREESTAND = <span class="number">4</span>,  <span class="comment">// 自由站立</span></span><br><span class="line">    TROTING = <span class="number">5</span>,    <span class="comment">// 对角步态</span></span><br><span class="line">    WALKING = <span class="number">6</span>,    <span class="comment">// 行走步态</span></span><br><span class="line">    JUMP = <span class="number">7</span>,       <span class="comment">// 跳跃</span></span><br><span class="line">    JUMP2 = <span class="number">8</span>,      <span class="comment">// 跳跃2</span></span><br><span class="line">    JUMPL = <span class="number">9</span>,</span><br><span class="line">    JUMPL2 = <span class="number">10</span>,</span><br><span class="line">    JUMPR = <span class="number">11</span>,</span><br><span class="line">    JUMPR2 = <span class="number">12</span>,</span><br><span class="line">    catJUMP = <span class="number">13</span>,</span><br><span class="line">    catJUMP2 = <span class="number">14</span>,</span><br><span class="line">&#125; FSMState_e;</span><br></pre></td></tr></table></figure><h2 id="5-指针"><a href="#5-指针" class="headerlink" title="5.指针"></a>5.指针</h2><h3 id="指针偏移"><a href="#指针偏移" class="headerlink" title="指针偏移"></a>指针偏移</h3><p>指针可以作为数组用，数组号表示指针基地址偏移，很多代码都这么用的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span>  <span class="title function_">test</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">buffer[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第16行，memcpy函数从packet[1]的地址开始复制，数据依次复制到packet[1],packet[2],packet[3],packet[4]中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> floatVal;</span><br><span class="line">    <span class="type">uint8_t</span> byteVal[<span class="keyword">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">  &#125; data;</span><br><span class="line"></span><br><span class="line">  data.floatVal = val;<span class="comment">//共同体 val给共同体的data.floatVal后 如果用data.byteVal 共同体内data.floatVal中的数据会转变为byteVal[sizeof(float)]类型</span></span><br><span class="line">  <span class="built_in">memcpy</span>(bytes, data.byteVal, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//共同体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendPacket</span><span class="params">(<span class="type">float</span> angle, <span class="type">float</span> x, <span class="type">float</span> y)</span> &#123;<span class="comment">//float有4个字节，32位</span></span><br><span class="line">  <span class="type">uint8_t</span> packet[<span class="number">14</span>];   <span class="comment">// 数据包共14个字节</span></span><br><span class="line">  <span class="comment">// 填充帧头</span></span><br><span class="line">  packet[<span class="number">0</span>] = FRAME_HEADER;</span><br><span class="line">  <span class="comment">// 填充数据</span></span><br><span class="line">  floatToBytes(angle, &amp;packet[<span class="number">1</span>]);</span><br><span class="line">  floatToBytes(x, &amp;packet[<span class="number">5</span>]);</span><br><span class="line">  floatToBytes(y, &amp;packet[<span class="number">9</span>]);</span><br><span class="line">  <span class="comment">// 填充帧尾</span></span><br><span class="line">  packet[<span class="number">13</span>] = FRAME_TAIL;</span><br><span class="line">  <span class="comment">// 使用串口发送数据包</span></span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, packet, <span class="keyword">sizeof</span>(packet), HAL_MAX_DELAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>所谓函数指针即定义一个<em><strong>指向函数的指针变量</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span> x, <span class="type">int</span>  y);  <span class="comment">//注意：这里的括号不能掉，因为括号()的运算优先级比解引用运算符*高</span></span><br></pre></td></tr></table></figure><p>这个函数的类型是有两个整型参数，返回值是个整型。对应的函数指针类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*) (<span class="type">int</span> a, <span class="type">int</span> b);  </span><br></pre></td></tr></table></figure><p>对应的函数指针<strong>定义</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span> x, <span class="type">int</span>  y);  <span class="comment">//参数名可以去掉，并且通常都是去掉的。这样指针p就可以保存函数类型为两个整型参数，返回值是整型的函数地址了。</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>我们一般可以这么使用，通过函数指针调用函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxValue</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;    </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = <span class="literal">NULL</span>;  <span class="comment">//定义一个与maxValue兼容的指针</span></span><br><span class="line">p = maxValue;<span class="comment">//将这个指针指向maxValue函数</span></span><br><span class="line">p(<span class="number">20</span>, <span class="number">45</span>);  <span class="comment">//通过指针调用</span></span><br></pre></td></tr></table></figure><p><strong>应用案例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FSMMode_e mode;</span><br><span class="line">    FSMState_e currentState;</span><br><span class="line">    FSMState_e nextState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回调函数</span></span><br><span class="line">    <span class="type">void</span> (*enter)(<span class="type">void</span>);<span class="comment">/*函数指针*/</span>  </span><br><span class="line">    <span class="type">void</span> (*run)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">exit</span>)(<span class="type">void</span>);</span><br><span class="line">&#125; FSM_t;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FSM_t FSM ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (FSM.nextState)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FIXEDSTAND:</span><br><span class="line">        FSM.enter = FixedStand_Enter;<span class="comment">//将FSM.enter这个指针指向FixedStand_Enter函数</span></span><br><span class="line">        FSM.run = FixedStand_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = FixedStand_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">case</span> TROTING:</span><br><span class="line">        FSM.enter = Troting_Enter;</span><br><span class="line">        FSM.run = Troting_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Troting_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> WALKING:</span><br><span class="line">        FSM.enter = Walking_Enter;</span><br><span class="line">        FSM.run = Walking_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Walking_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> JUMP:</span><br><span class="line">        FSM.enter = Jump_Enter;</span><br><span class="line">        FSM.run = Jump_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Jump_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在C语言中，void (*enter)(void);、void (*run)(void); 和 void (*exit)(void); 这三个成员是函数指针类型。</p><p>具体解释如下：</p><ol><li><pre><code class="c">void (*enter)(void);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这是一个指向无参数且返回值为 void 的函数的指针。在结构体 FSM_t 中，它表示一个函数指针，当 FSM（有限状态机）进入某个状态时，可以通过调用这个函数指针指向的函数来执行相应的“进入”动作。</span><br><span class="line"></span><br><span class="line"> 2. ```c</span><br><span class="line">    void (*run)(void);</span><br></pre></td></tr></table></figure></code></pre></li></ol><p>同样是一个指向无参数且返回值为 void 的函数的指针。在状态机中，当处于某个状态并需要运行该状态的行为或处理逻辑时，可以调用这个“run”函数指针指向的函数。</p><ol start="3"><li><pre><code class="c">void (*exit)(void);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">依然是一个函数指针，指向无参数且返回值为 void 的函数。当 FSM 状态机从当前状态退出时，会调用这个“exit”函数指针指向的函数，用于执行离开状态时所需的动作或清理工作。</span><br><span class="line"></span><br><span class="line">因此，在实现一个基于此结构体的状态机时，你需要为每个状态分别定义对应的 enter、run 和 exit 函数，并将它们的地址赋给相应状态的 FSM_t 结构体实例中的这三个函数指针成员。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在C语言中，结构体（struct）可以包含各种数据类型，包括**基本数据类型、指针类型**等。在这个特定的FSM_t（有限状态机）结构体定义中，使用函数指针的主要原因是为了实现灵活且可扩展的设计。</span><br><span class="line"></span><br><span class="line">​1.灵活性：***通过将函数作为成员变量（以指针形式存在），可以在不同的实例中为这些函数赋予不同的具体实现，使得状态机的行为可以根据需求动态改变。***</span><br><span class="line"></span><br><span class="line">​2.扩展性：在设计模式上，这种方式符合面向对象编程中的“多态”思想。***每个状态可以有自己的enter、run和exit行为，只需要提供相应的函数实现即可。***</span><br><span class="line"></span><br><span class="line">​3.解耦合：函数指针将函数的具体实现与结构体（状态机）的定义解耦合，使得状态机的定义更简洁，逻辑更清晰，也方便后期维护和扩展。</span><br><span class="line"></span><br><span class="line">​4.高效性：虽然使用函数指针调用会引入一次间接寻址，但在很多情况下，这并不会对性能造成显著影响，而带来的设计优势远大于此微小的性能损耗。总结一下，这里使用函数指针而非直接定义函数，主要是为了构建一个更加灵活、可扩展、高内聚低耦合的状态机模型。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在C语言中，结构体（struct）不能直接包含函数。函数在C语言中不是一种数据类型，因此无法像变量那样存储在结构体中。但是，可以通过存储函数的指针来达到类似的效果，就像上述FSM_t结构体中的enter、run和exit成员那样。</span><br><span class="line"></span><br><span class="line">所以，准确地说，结构体内不能直接定义函数，但可以存储函数的地址，即函数指针，间接实现调用关联函数的功能。</span><br><span class="line"></span><br><span class="line">#### 回调函数</span><br><span class="line"></span><br><span class="line">应用：</span><br><span class="line">1.*送餐机器人：底盘移动到目标位置后，通知应用程序*</span><br><span class="line"></span><br><span class="line">2.*智能音箱：网络状态改变后，通知应用程序*</span><br><span class="line"></span><br><span class="line">3.*四足机器人项目FSM状态机也有用到回调函数的思想*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">//工具代码</span><br><span class="line">typedef struct&#123;</span><br><span class="line">int status;</span><br><span class="line">void (*statusChange)(); //存储后续要调用的回调函数地址</span><br><span class="line">&#125;T_Device;</span><br><span class="line"></span><br><span class="line">T_Device g_ Device;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">名称：回调函数</span><br><span class="line">作用：将传入的用户函数的地址赋给g_Device.statusChange,当满足条件时，执行该用户函数</span><br><span class="line">*/</span><br><span class="line">//void (*pstatusChange)(int status) 定义了一个指向函数的指针变量 pstatusChange，该函数没有返回值，并且接受一个整型参数 status。</span><br><span class="line">void addCallbackFunc(void (*pstatusChange)(int status))&#123;//将函数的地址传入并赋给g_Device.statusChange，这样g_Device.statusChange指向函数的入口地址</span><br><span class="line">g_Device.statusChange = pstatusChange ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void run()&#123;</span><br><span class="line">g_Device.status = 10;</span><br><span class="line">    if(g_Device.status == 10)&#123;</span><br><span class="line">        if(g_Device . statusChange != NULL)&#123;</span><br><span class="line">        g_Device.statusChange(g_Device.status);//callBack(10);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//用户代码</span><br><span class="line">void callBack(int status )&#123;&#125;</span><br><span class="line">    printf(&quot;callBack\n&quot;);</span><br><span class="line">    printf(&quot;status = %d\n&quot; ,status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    addCallbackFunc(callBack);//将 `callBack` 函数的地址作为参数传递给了 `addCallbackFunc` 函数，</span><br><span class="line">    run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><p>在 <code>main</code> 函数中调用 <code>addCallbackFunc(callBack);</code> 时，发生了以下事件：</p><ol><li><code>callBack</code> 是用户定义的一个函数，其原型为 <code>void callBack(int status)</code>。</li><li>当调用 <code>addCallbackFunc(callBack)</code> 时，将 <code>callBack</code> 函数的地址作为参数传递给了 <code>addCallbackFunc</code> 函数。</li><li>在 <code>addCallbackFunc</code> 函数内部，这个传入的参数 <code>pstatusChange</code> 被赋值给全局变量 <code>g_Device</code> 的成员 <code>statusChange</code>，即 <code>g_Device.statusChange = pstatusChange;</code>。因此，现在 <code>g_Device.statusChange</code> 指向了 <code>callBack</code> 函数的入口地址。</li><li>这样一来，就实现了回调函数的注册。当设备状态改变且满足触发条件时（如在 <code>run</code> 函数中），可以通过调用 <code>g_Device.statusChange(g_Device.status);</code> 来执行 <code>callBack</code> 函数，<strong>并将设备状态作为参数传递进去，从而实现对状态变化的响应和处理。</strong></li></ol><p>提问：为什么不能直接用if(g_Device.status&#x3D;&#x3D;10)，而非要用回调函数，这是多此一举吗</p><p>使用回调函数并不一定是在做无用功，它在某些情况下具有以下优点：</p><ol><li><strong>解耦合</strong>：通过回调函数，我们可以将处理状态变化的逻辑从设备状态管理代码中分离出来。这样可以使代码结构更加清晰，也<strong>更容易维护和扩展</strong>。例如，在本例中，具体的设备状态改变后的处理行为（即<code>callBack</code>函数中的内容）可以由用户自定义，而不是硬编码在<code>run</code>函数里。</li><li><strong>灵活性</strong>：当设备状态改变时，不同的应用程序可能需要执行不同的操作。使用回调函数允许我们在运行时动态地根据需要来指定要执行的操作，增加了程序的灵活性。</li><li><strong>事件驱动编程</strong>：回调函数是事件驱动编程模型的重要组成部分。在这种模式下，当某个特定事件（如设备状态改变）发生时，系统调用预先注册好的回调函数，<strong>而非直接在触发事件的地方编写处理逻辑。</strong></li></ol><p>所以，并不是多此一举，而是为了实现更灵活、解耦的软件设计和开发。当然，在简单场景下，如果状态改变后的处理逻辑固定且无需复用，直接写在<code>if(g_Device.status==10)</code>判断后也是可行的，但在复杂项目或者需要扩展性的情况下，回调函数就显得尤为重要了。</p><h3 id="void-修饰指针使用规则"><a href="#void-修饰指针使用规则" class="headerlink" title="void 修饰指针使用规则"></a>void 修饰指针使用规则</h3><p>void *</p><p>void 指针可以指向任意类型的数据，就是说可以用任意类型的指针对 void 指针对 void <a href="https://so.csdn.net/so/search?q=%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC&spm=1001.2101.3001.7020">指针赋值</a>。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a；</span><br><span class="line"><span class="type">void</span> *p；</span><br><span class="line">p=a；</span><br></pre></td></tr></table></figure><p>void 指针可以任意类型的数据，可以在程序中给我们带来一些好处，函数中形为指针类型时，我们可以将其定义为 void 指针，这样函数就可以接受任意类型的指针。如：</p><pre><code>void * memcpy(void *dest, const void *src, size_t len);void * memset ( void * buffer, int c, size_t num );</code></pre><p>这样，任何类型的指针都可以传入 memcpy 和 memset 中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型。</p><h2 id="6-常见关键词"><a href="#6-常见关键词" class="headerlink" title="6.常见关键词"></a>6.常见关键词</h2><h3 id="define宏定义关键词"><a href="#define宏定义关键词" class="headerlink" title="define宏定义关键词"></a>define宏定义关键词</h3><p>语法：<code>#define 标识符 字符串</code></p><ul><li><p>“标识符”为所定义的<strong>宏名</strong></p></li><li><p>“字符串”可以是<strong>常数</strong>、<strong>表达式</strong>、<strong>格式串</strong>等</p><p>#define SYSCLK_FREQ_72MHz 72000000</p></li></ul><h3 id="ifdef-条件编译"><a href="#ifdef-条件编译" class="headerlink" title="ifdef 条件编译"></a>ifdef 条件编译</h3><p>当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 标识符</span></span><br><span class="line">程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>作用是：当标识符已经被定义过(一般是用#define 命令定义)，则对程序段 1 进行编译，否则编译程序段 2。 其中#else 部分也可以没有，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span></span></span><br><span class="line">程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="extern变量声明"><a href="#extern变量声明" class="headerlink" title="extern变量声明"></a>extern变量声明</h3><p>在一个文件中定义的全局变量，如果在其它文件里想使用，需要在前面加上extern</p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>有时候，我们希望函数中局部变量的值在<strong>函数调用结束之后不会消失，而仍然保留其原值</strong>。即它所占用的存储单元不释放，在<strong>下一次调用该函数时，其局部变量的值仍然存在，也就是上一次函数调用结束时的值</strong>。这时候，我们就应该将该局部变量用关键字 static 声明为“<strong>静态局部变量</strong>”。</p><p>静态变量的作用：<strong>保持变量内容的持久性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt;= <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">            count();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">count</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*声明一个静态局部变量*/</span></span><br><span class="line">    <span class="type">static</span> num = <span class="number">0</span>;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该代码中，我们通过在 count() 函数里声明一个静态局部变量 num 来作为计数器。因为静态局部变量是在编译时赋初值的，且只赋初值一次，在程序运行时它已有初值。以后在每次调用函数时就<em><strong>不再重新赋初值，而是保留上次函数调用结束时的值</strong></em>。这样，count() 函数每次被调用的时候，静态局部变量 num 就会保持上一次调用的值，然后再执行自增运算，这样就实现了计数功能。同时，它又避免了使用全局变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_ChangeState</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C语言中，当一个函数前加上 static 关键字时，意味着该函数具有内部链接性（internal linkage），即该函数的作用范围被限制在当前编译单元内。对于这个函数而言，这意味着只有定义它的源文件以及包含它所在的头文件的其他源文件可以访问此函数，不会成为外部全局符号，从而避免不同编译单元之间产生符号冲突。</p><h3 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h3><p>程序开发人员可以在变量定义后，在程序的其他位置引用和修改变量。但程序中定义的一些变量，如圆周率PI&#x3D;3.14，黄金分割比例 g&#x3D;0.618，<em><strong>这些变量只需要被引用，不应该被修改</strong></em>。C语言中可以使用 const关键字修饰变量。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> pi = <span class="number">3.141592612</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,pi);</span><br></pre></td></tr></table></figure><h3 id="IO-volatile"><a href="#IO-volatile" class="headerlink" title="__IO(volatile)"></a>__IO(<strong>volatile</strong>)</h3><p><strong>volatile</strong>的含义为 <code>允许硬件改变变量的数值</code> 。告诉编译器不要优化这些代码</p><p><a href="https://blog.csdn.net/QWQ_DIODA/article/details/116712401">volatile 形变量可以被硬件改变</a>，在需要<strong>硬件</strong>改变变量的场合中不可或缺！！</p><p><img src="/2024/01/26/Embedded-C-language/image-20240114110255039.png" alt="image-20240114110255039"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__IO <span class="type">uint16_t</span> ADC_ConvertedValue;  <span class="comment">// 用于保存转换后的ADC值 </span></span><br><span class="line"><span class="comment">// 中断服务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (ADC_GetITStatus(ADCx,ADC_IT_EOC)==SET) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 读取ADC的转换值</span></span><br><span class="line">ADC_ConvertedValue = ADC_GetConversionValue(ADCx);</span><br><span class="line">&#125;</span><br><span class="line">ADC_ClearITPendingBit(ADCx,ADC_IT_EOC);<span class="comment">//清除ADCx的中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task1Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;Task1&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task2Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;Task2&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task3Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="string">&quot;Task3&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_LCDCanUse = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> g_calc_end = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> g_time = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> g_sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务1 计算加法，并计算加法运算的时间，然后删除任务</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CalcTask</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">  g_time = system_get_ns();</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    g_sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  g_calc_end = <span class="number">1</span>;</span><br><span class="line">  g_time = system_get_ns() - g_time;</span><br><span class="line">  vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务2 当计算任务没有结束时，一直执行while循环，直到计算任务结束,g_cal_end变为1，则可进行后面的打印信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdPrintTask</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LCD_PrintString(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;waiting&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (g_calc_end == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印信息 */</span></span><br><span class="line">    <span class="keyword">if</span> (g_LCDCanUse)</span><br><span class="line">    &#123;</span><br><span class="line">      g_LCDCanUse = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      LCD_ClearLine(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      len = LCD_PrintString(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;Sum:&quot;</span>);</span><br><span class="line">      LCD_PrintHex(len, <span class="number">0</span>, g_sum,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      LCD_ClearLine(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">      len = LCD_PrintString(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;Time(ms):&quot;</span>);</span><br><span class="line">      LCD_PrintSignedVal(len, <span class="number">2</span>, g_time/<span class="number">1000000</span>);</span><br><span class="line">      g_LCDCanUse = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  xTaskCreate(CalcTask, <span class="string">&quot;task1&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">  xTaskCreate(LcdPrintTask, <span class="string">&quot;task2&quot;</span>, <span class="number">128</span>, &amp;g_Task2Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>没有加volatile时，经过<strong>debug</strong>，发现程序一直会卡LcdPrintTask的while (g_calc_end &#x3D;&#x3D; 0);处，<strong>尽管在debug时显示g_calc_end为1还是一直卡在那里</strong>。这是因为在编译器做了一些优化，第一次使用这个变量时，它会去读内存，把这个变量的值读进CPU的某个寄存器，以后在任务2的那个while循环里，它一直都是去判断那个<strong>寄存器</strong>，但是那个寄存器得到的是这个变量原始的，老的值，它并<strong>没有每次都去内存里面读这个变量，更新那个寄存器</strong>，这是不对的，因为这个变量，是在其他任务里面被修改了，你去使用这个变量时，每次都应该去读内存，怎么办呢，<strong>在变量前加一个volatile就好了，告诉编译器，不要去优化它</strong>。</p><p>​“在多任务环境下，编译器通常会对变量进行优化以提高代码执行效率。当一个变量被标记为 volatile 时，它告诉编译器这个变量的值可能在程序控制范围之外发生变化（例如由中断服务程序、硬件操作或者其他并发任务修改），因此每次访问该变量时都会从内存中重新读取。<em>编译器对变量的优化通常基于以下几种情况</em>：</p><ol><li><p><strong>局部性原理</strong>：编译器假设在一段连续执行的代码中，如果一个变量没有被显示地修改（比如通过赋值、函数调用或指针间接访问），其值就不会改变。因此，在循环内多次读取同一变量时，编译器可能会将该变量从内存加载到寄存器中，并在整个循环期间使用寄存器中的值，以减少对内存的访问。</p></li><li><p><strong>数据流分析</strong>：编译器会进行数据依赖性分析，如果它能确定某个变量在当前作用域内不会受外部因素影响而改变，即使这个变量是全局的，也可能对其进行优化。</p></li><li><p><strong>跨函数优化</strong>：编译器还可能进行跨函数优化，例如当函数没有明确的副作用或者编译器能够推断出函数内部对全局变量的修改不会影响到当前上下文时，也会选择不重新加载变量。”</p><p>应当在以下情况下考虑使用 <code>volatile</code> 关键字来修饰变量：</p><ul><li>变量可能被<strong>中断服务程序修改</strong>。</li><li>变量位于<strong>多线程环境且不同线程间共享并修改该变量</strong>。</li><li>变量与硬件寄存器映射相关，硬件可能会在软件不可见的情况下更改它们的值。</li><li>变量用于信号量、事件标志或其他同步机制。</li></ul></li></ol><h3 id="union共同体（联合体）"><a href="#union共同体（联合体）" class="headerlink" title="union共同体（联合体）"></a>union共同体（联合体）</h3><h4 id="实现不同类型数据的转换"><a href="#实现不同类型数据的转换" class="headerlink" title="实现不同类型数据的转换"></a>实现不同类型数据的转换</h4><p><strong>C语言的union联合体，可实现不同类型数据的转换</strong></p><p>结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。联合体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</p><p><em>简单说就是你给联合体的一个变量赋值，然后表示联合体其中的另一个变量，之前那个赋值了的变量会自动赋给你要表示的这个量，从而实现不同类型数据的转换。</em></p><p><img src="/2024/01/26/Embedded-C-language/image-20240114200704804.png" alt="image-20240114200704804"></p><p><img src="/2024/01/26/Embedded-C-language/image-20240114192714039.png" alt="image-20240114192714039"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memcpy函数有三个参数，第一个是目标地址（通常是数组的某一位的地址，即将数据从数组的这一位开始复制），第二个是源地址，第三个是数据长度。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> floatVal;</span><br><span class="line">    <span class="type">uint8_t</span> byteVal[<span class="keyword">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">  &#125; data;</span><br><span class="line"></span><br><span class="line">  data.floatVal = val;<span class="comment">//共同体 val给共同体的data.floatVal后 如果用data.byteVal 共同体内data.floatVal中的数据会转变为byteVal[sizeof(float)]类型</span></span><br><span class="line">  <span class="built_in">memcpy</span>(bytes, data.byteVal, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//共同体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *destin, <span class="type">void</span> *source, <span class="type">unsigned</span> n)</span>;</span><br></pre></td></tr></table></figure><p><strong>以source指向的地址为起点，将连续的n个字节数据，复制到以destin指向的地址为起点的内存中。</strong><br>函数有三个参数，第一个是目标地址（通常是数组的某一位的地址，即将数据从数组的这一位开始复制），第二个是源地址，第三个是数据长度。<br>数据长度（第三个参数）的单位是字节（1byte &#x3D; 8bit）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> floatVal;</span><br><span class="line">    <span class="type">uint8_t</span> byteVal[<span class="keyword">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">  &#125; data;</span><br><span class="line"></span><br><span class="line">  data.floatVal = val;<span class="comment">//共同体 val给共同体的data.floatVal后 如果用data.byteVal 共同体内data.floatVal中的数据会转变为byteVal[sizeof(float)]类型</span></span><br><span class="line">  <span class="built_in">memcpy</span>(bytes, data.byteVal, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//共同体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendPacket</span><span class="params">(<span class="type">float</span> angle, <span class="type">float</span> x, <span class="type">float</span> y)</span> &#123;<span class="comment">//float有4个字节，32位</span></span><br><span class="line">  <span class="type">uint8_t</span> packet[<span class="number">14</span>];   <span class="comment">// 数据包共14个字节</span></span><br><span class="line">  <span class="comment">// 填充帧头</span></span><br><span class="line">  packet[<span class="number">0</span>] = FRAME_HEADER;</span><br><span class="line">  <span class="comment">// 填充数据</span></span><br><span class="line">  floatToBytes(angle, &amp;packet[<span class="number">1</span>]);<span class="comment">//从packet[1]的地址开始复制，数据依次复制到packet[1],packet[2],packet[3],packet[4]中</span></span><br><span class="line">  floatToBytes(x, &amp;packet[<span class="number">5</span>]);</span><br><span class="line">  floatToBytes(y, &amp;packet[<span class="number">9</span>]);</span><br><span class="line">  <span class="comment">// 填充帧尾</span></span><br><span class="line">  packet[<span class="number">13</span>] = FRAME_TAIL;</span><br><span class="line">  <span class="comment">// 使用串口发送数据包</span></span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, packet, <span class="keyword">sizeof</span>(packet), HAL_MAX_DELAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_ChangeState</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​1.static：</p><p>​在C语言中，当一个函数前加上 static 关键字时，意味着该函数具有内部链接性（internal linkage），即该函数的作用范围被限制在当前编译单元内。对于这个函数而言，这意味着只有定义它的源文件以及包含它所在的头文件的其他源文件可以访问此函数，不会成为外部全局符号，从而避免不同编译单元之间产生符号冲突。</p><p>​2.inline：</p><p>​inline 关键字提示编译器尝试将函数体直接插入到每个调用该函数的地方（即“内联”），而不是通过正常的函数调用机制（如压栈、跳转等）。这样做的目的是减少函数调用的开销，尤其是当<em><strong>函数体较小且频繁调用时，能够提高程序运行效率。</strong></em><br>​注意，尽管有 inline 关键字，但是否真正进行内联处理由编译器决定，编译器会根据实际情况判断是否采纳程序员的建议。</p><p>综合上述解释，在状态机的上下文中，static inline void FSM_ChangeState() 函数可能用于快速切换状态，由于其内联特性，编译器可能会将状态切换的相关操作直接嵌入到调用处，以提升代码执行速度，并且由于是静态函数，其使用和实现细节被隐藏在当前编译单元内，不对外部模块可见，有助于封装和管理复杂度。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p><img src="/2024/01/26/Embedded-C-language/image-20240114192455610.png" alt="image-20240114192455610"></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="串口数据包通讯协议"><a href="#串口数据包通讯协议" class="headerlink" title="串口数据包通讯协议"></a>串口数据包通讯协议</h2><p>uint8_t packet[14];  &#x2F;&#x2F;packet数组的一位是一个字节,此packet含14个字节</p><p>串口接收鲁棒性高，采用校验帧头、帧尾以及数据长度的方式，确保接收数据的稳定性。</p><p>之前一直没用过帧头帧尾，主要是之前用串口传输的数据量都不大，如果要传输多种数据，就需要用帧头帧尾确保数据传输的准确性</p><p>(STM32通讯系列–串口通讯】使用标准库、HAL库实现任意长度数据的收发（包含帧头、帧尾校验，配套完整开源程序）</p><p><a href="https://blog.csdn.net/qq_44343584/article/details/125654421?ops_request_misc=%7B%22request_id%22:%22166299541816800182785614%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=166299541816800182785614&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-125654421-null-null.142">https://blog.csdn.net/qq_44343584/article/details/125654421?ops_request_misc=%7B%22request%5Fid%22%3A%22166299541816800182785614%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=166299541816800182785614&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-125654421-null-null.142</a> )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//packet.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;packet.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> host 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> host<span class="comment">//发送数据包</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> packet_received = <span class="literal">false</span>;<span class="comment">//是否收到完整的数据包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转换单精度浮点数为字节</span></span><br><span class="line"><span class="comment">//@param1:浮点数</span></span><br><span class="line"><span class="comment">//@param2:字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> floatVal;</span><br><span class="line">    <span class="type">uint8_t</span> byteVal[<span class="keyword">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">  &#125; data;</span><br><span class="line"></span><br><span class="line">  data.floatVal = val;<span class="comment">//共同体 val给共同体的data.floatVal后 如果用data.byteVal 共同体内data.floatVal中的数据会转变为byteVal[sizeof(float)]类型</span></span><br><span class="line">  <span class="built_in">memcpy</span>(bytes, data.byteVal, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//共同体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* memcpy用法:</span></span><br><span class="line"><span class="comment">void *memcpy(void *destin, void *source, unsigned n);</span></span><br><span class="line"><span class="comment">以source指向的地址为起点，将连续的n个字节数据，复制到以destin指向的地址为起点的内存中。</span></span><br><span class="line"><span class="comment">函数有三个参数，第一个是目标地址，第二个是源地址，第三个是数据长度。</span></span><br><span class="line"><span class="comment">数据长度（第三个参数）的单位是字节（1byte = 8bit）。</span></span><br><span class="line"><span class="comment">一个float类型的函数有4个字节</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendPacket</span><span class="params">(<span class="type">float</span> angle, <span class="type">float</span> x, <span class="type">float</span> y)</span> &#123;</span><br><span class="line">  <span class="type">uint8_t</span> packet[<span class="number">14</span>];   <span class="comment">// 数据包共14个字节</span></span><br><span class="line">  <span class="comment">// 填充帧头</span></span><br><span class="line">  packet[<span class="number">0</span>] = FRAME_HEADER;</span><br><span class="line">  <span class="comment">// 填充数据</span></span><br><span class="line">  floatToBytes(angle, &amp;packet[<span class="number">1</span>]);</span><br><span class="line">  floatToBytes(x, &amp;packet[<span class="number">5</span>]);</span><br><span class="line">  floatToBytes(y, &amp;packet[<span class="number">9</span>]);</span><br><span class="line">  <span class="comment">// 填充帧尾</span></span><br><span class="line">  packet[<span class="number">13</span>] = FRAME_TAIL;</span><br><span class="line">  <span class="comment">// 使用串口发送数据包</span></span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, packet, <span class="keyword">sizeof</span>(packet), HAL_MAX_DELAY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析数据包</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// 定义缓冲区大小  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义缓冲区和指针</span></span><br><span class="line"><span class="type">uint8_t</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">uint8_t</span>* p_buffer = buffer;<span class="comment">//指向buffer缓冲区首地址的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义标志位，表示是否接收到完整的数据包</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> packet_received = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析数据包的函数 将数据包中数据赋给 angle x y</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ParseDataPacket</span><span class="params">(DataPacket* packet)</span> &#123;</span><br><span class="line">  <span class="type">uint8_t</span>* p = buffer + <span class="number">1</span>; <span class="comment">// 跳过帧头</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;packet-&gt;angle, p, <span class="keyword">sizeof</span>(<span class="type">float</span>)); <span class="comment">//buffer[1] buffer[2] buffer[3] buffer[4]</span></span><br><span class="line">  p += <span class="keyword">sizeof</span>(<span class="type">float</span>);<span class="comment">//指向buffer[5]</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;packet-&gt;x, p, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//buffer[5] buffer[6] buffer[7] buffer[8]</span></span><br><span class="line">  p += <span class="keyword">sizeof</span>(<span class="type">float</span>);<span class="comment">//指向buffer[9]</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;packet-&gt;y, p, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//buffer[9] buffer[10] buffer[11] buffer[12]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在串口接收中断中调用此函数，将接收到的数据存入缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HandleReceivedData</span><span class="params">(<span class="type">uint8_t</span> data)</span> &#123;</span><br><span class="line">  <span class="comment">// 如果缓冲区已满，清空缓冲区</span></span><br><span class="line">  <span class="keyword">if</span> (p_buffer &gt;= buffer + BUFFER_SIZE) &#123;</span><br><span class="line">    p_buffer = buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将数据存入缓冲区</span></span><br><span class="line">  *p_buffer++ = data;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断是否接收到完整的数据包</span></span><br><span class="line">  <span class="keyword">if</span> (p_buffer - buffer &gt;= <span class="keyword">sizeof</span>(DataPacket) + <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查帧头和帧尾是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (buffer[<span class="number">0</span>] ==FRAME_HEADER &amp;&amp; buffer[<span class="keyword">sizeof</span>(DataPacket) + <span class="number">1</span>] == FRAME_TAIL) &#123;</span><br><span class="line">      <span class="comment">// 接收到完整的数据包</span></span><br><span class="line">      packet_received = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空缓冲区</span></span><br><span class="line">    p_buffer = buffer;<span class="comment">//指针重新指向buffer数组首地址</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主函数中调用此函数，处理接收到的数据包</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ProcessReceivedData</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 如果接收到完整的数据包，则解析数据包</span></span><br><span class="line">  <span class="keyword">if</span> (packet_received) &#123;</span><br><span class="line">    DataPacket packet;</span><br><span class="line">    ParseDataPacket(&amp;packet);<span class="comment">//处理之后定义的packet中angle x y就有数据了 可以直接调用 eg: packet.angle</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理解析后的数据包，例如将数据包的内容显示到LCD屏幕上</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除标志位</span></span><br><span class="line">    packet_received = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**********************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 在主函数中循环调用此函数，以处理接收到的数据</span></span><br><span class="line"><span class="comment">//void Loop() &#123;</span></span><br><span class="line"><span class="comment">//  // 处理接收到的数据包</span></span><br><span class="line"><span class="comment">//  ProcessReceivedData();</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//  // 继续执行其他任务</span></span><br><span class="line"><span class="comment">//  // ...</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在中断中</span></span><br><span class="line"><span class="comment">//void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    // 读取接收数据寄存器</span></span><br><span class="line"><span class="comment">//    uint8_t data = (uint8_t)(huart-&gt;Instance-&gt;RDR &amp; 0xFF);</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    // 处理接收到的数据</span></span><br><span class="line"><span class="comment">//    HandleReceivedData(data);</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    // 继续启动接收中断</span></span><br><span class="line"><span class="comment">//    HAL_UART_Receive_IT(huart, &amp;data, 1);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PACKET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRAME_HEADER 0x7E   <span class="comment">// 帧头</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRAME_TAIL 0x7F     <span class="comment">// 帧尾</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> angle;</span><br><span class="line">  <span class="type">float</span> x;</span><br><span class="line">  <span class="type">float</span> y;</span><br><span class="line">&#125; DataPacket;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span>;<span class="comment">//转换单精度浮点数为字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendPacket</span><span class="params">(<span class="type">float</span> angle, <span class="type">float</span> x, <span class="type">float</span> y)</span>;<span class="comment">//发送数据包</span></span><br><span class="line"><span class="comment">//bool parsePacket(uint8_t* packet, float* angle, float* x, float* y);//解析数据包</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ParseDataPacket</span><span class="params">(DataPacket* packet)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ProcessReceivedData</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*PACKET_H*/</span></span></span><br></pre></td></tr></table></figure><h2 id="环形缓冲区"><a href="#环形缓冲区" class="headerlink" title="环形缓冲区"></a>环形缓冲区</h2><p><strong>环形缓冲区</strong>是<a href="https://so.csdn.net/so/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F&spm=1001.2101.3001.7020">嵌入式</a>系统中十分重要的一种数据结构，比如在<strong>串口</strong>处理中，串口中断接收数据直接往环形缓冲区丢数据，而应用可以从环形缓冲区取数据进行处理，这样数据在读取和写入的时候都可以在这个缓冲区里循环进行，程序员可以根据自己需要的数据大小来决定自己使用的缓冲区大小，<strong>不用担心数组越界</strong>。</p><p><strong>队列</strong>的基本概念：队列 (Queue)：是一种先进先出(First In First Out ,简称 FIFO)的线性表，只允许在一端插入（入队），在另一端进行删除（出队）。</p><p>队列头就是指向已经存储的数据，并且这个数据是待处理的。下一个CPU处理的数据就是1；而队列尾则指向可以进行写数据的地址。</p><p><strong>队列是什么</strong></p><p>队列是一种很常见的数据结构，满足先进先出的方式，如果我们设定队列的最大长度，那就意味着进队列和出队列的元素的数量实则满足一种动态平衡。</p><p>如果我们把首次添加入队列的元素作为一个一维坐标的原点，那么随着队列中元素的添加，坐标原点到队尾元素的长度会无穷无尽的增大，随这之前添入的元素不断出列，对头对应的下标点也在不断增大。这样，进队列和出队列的元素的数量就对应到对头和队尾下标点的移动</p><p>因此我们评判一个队列长度是否溢出原先约定的最大长度，实则就是在评判队尾坐标点与队头坐标点之间的差值，无论是出队列还是入队列，队头和队尾的坐标都在不断增大</p><p><img src="/2024/01/26/Embedded-C-language/84497721b6c4413c8558e4266b886ddc.png" alt="img"></p><p><strong>front指针和rear指针的引入</strong></p><p>虽然队尾和队头的下标在不断增大，但是我们对于队列的研究只需要局限在队头与队尾之间的元素，坐标原点到队头之间的元素已经算作出列元素，并不需要研究。因此我们不妨将队列在逻辑上放入一个事先设定容量的一维数组中，只要这个数组的容量是队列中元素的个数+1就行，为什么要这么设定待会再讲。我们想要达到的目的是，无论出列还是入列，本质上是通过修改数组中元素的值，那些已经出列的元素所在的下标位需要放置新入列的元素，并在逻辑上保证新入列元素位于队尾就行。</p><p>因此，我们不得不得引入头指针front和尾指针rear，对指针指向的数组下标对应空间进行操作，来修改数组中元素的值。</p><p><strong>front指针和rear指针的理解</strong></p><p>front：初始值为0，对应索引位待出列，若当前指向的数组下标的元素要出列，则先执行出列动作(实际上不用操作，出列的索引位可以被新入队的元素覆盖)，随后front指针就要向后一位，即front++</p><p>rear：初始值为0，对应索引位待入列，若当前指向的数组下标有元素要入列，则先执行入列动作（索引位元素赋值），随后front指针就要向后一位，即rear++</p><p><strong>队列最大长度匹配数组容量导致一种错误的解决方案</strong></p><p>这就会有一个问题，随着队列中元素的不断更迭，front和rear很快就会超过数组容量，造成数组索引越界</p><p><img src="/2024/01/26/Embedded-C-language/dd50472cf4ba4aad8fe5e565ccfe39de.png" alt="img"></p><p>比如上图所示，front&#x3D;2，也就是说已经有两个元素出列了，因此rear&#x3D;5与rear&#x3D;6对应的两个元素理应可以入列，但是我们发现数组maxsize&#x3D;5，不存在索引位5和6，强行对这两个下标赋值会造成索引越界异常indexOutException 。但是我们发现此时数组中索引位0和1都空着，完全可以将这两个位置利用起来，因此我们可以想办法让实际的rear值转化为等效的rear值，也就是是让rear&#x3D;5转化为rear&#x3D;0，同理rear6转化为rear&#x3D;1。怎么做到呢？无疑是通过取余！</p><p>每次新元素入队后， 执行rear&#x3D;(rear)%maxSize操作，随后执行rear++操作右移rear指针</p><p>像上图中的rear&#x3D;rear%5乍一看好像没问题，但实际上这种取余方式是有问题的，出现这种取余方式的根源在于我们想让队列最大长度与数组容量保持一致，下文会详细说明这种解决方案的错误之处。</p><p><strong>指针的往复移动：逻辑上的环形</strong></p><p>出队和入队的方向是从右向左，而front与rear指针的移动方向却是从左到右循环往复（指向数组末尾后按照取余算法又重置为数组开头），因此我们可以把单向数组在逻辑上理解成环形数组，指针的循环往复移动理解成按照顺时针或逆时针（只要规定某一方向就好）单向移动</p><p>  环形队列小知识：</p><p>  环形队列是在实际编程极为有用的数据结构,它有如下特点。</p><p>  它是一个首尾相连的FIFO的数据结构，采用数组的线性空间,数据组织简单。能很快知道队列是否满为空。能以很快速度的来存取数据。</p><p>   因为有简单高效的原因，甚至在硬件都实现了环形队列。 </p><p>   环形队列广泛用于网络数据收发，和不同程序间数据交换（比如内核与应用程序大量交换数据,从硬件接收大量数据）均使用了环形队列。</p><p><strong>队列为空的判别</strong></p><p>我们怎么判断队列为空呢？</p><p>如果我们按照指针从左到右的方向移动，当front指针和rear指针重合时，front指针对应的索引位之前的索引位都已经出列完毕，而rear指针对应的索引位以及之后的所有索引位还未有元素入列。</p><p>所以队列是否为空的判别：front&#x3D;&#x3D;rear</p><p><img src="/2024/01/26/Embedded-C-language/a053efb0385e4714b8889ecd98ba2d31.png" alt="img"></p><p><strong>rear&#x3D;rear%maxSize解决方案的问题</strong></p><p> 入队图示<br>下图展示了maxSize&#x3D;5的数组中，front&#x3D;0保持不变，元素依次入列直到满载，rear指针的移动情况：</p><p><img src="/2024/01/26/Embedded-C-language/42a1d7c1976b4e7db62cd01c7b7c2fdc.png" alt="img"></p><p> front&#x3D;rear&#x3D;0的歧义<br> 可以看到，如果我们认为队列容量与数组容量应该持平，那么当第五个元素50入列后，本来rear&#x3D;4执行了rear++的操作后，rear&#x3D;5，随后rear将会通过取余算法rear&#x3D;rear%maxSize重置为0，这是我们解决方案的核心！</p><p>但关键点就在这里，我们发现空载时front&#x3D;rear&#x3D;0，满载时依然有front&#x3D;rear&#x3D;0！这样子我们就无法判断front&#x3D;rear时，队列是空还是满，因此rear&#x3D;rear%maxSize这种解决方案是不被允许的</p><p><strong>新的解决方案：置空位的引入</strong></p><p>新的解决方案<br>       每次新元素入队后， 执行rear&#x3D;(rear+1)%maxSize操作，该操作包含rear++操作</p><p>置空位的引入<br>       并且我们人为规定，数组中必须留有一个索引位不得放置元素，必须置空！！！如何实现我们的人为规定呢？那就要先探索当数组满载后front和rear指针之间有啥关系</p><p> 入队图示<br>下图展示了maxSize&#x3D;5的数组中，front&#x3D;0保持不变，元素依次入列直到满载，rear指针的移动情况：</p><p><img src="/2024/01/26/Embedded-C-language/fc276df1cfb14836b200b9ab1791347a.png" alt="img"></p><pre><code>   人为的让最后一位置空，所以当元素40入列后，数组已经满载   满载后数据之间的关系：</code></pre><p>front&#x3D;0<br>rear&#x3D;(rear+1)%maxSize&#x3D;(3+1)%5&#x3D;4  (注： 执行完arr[rear]&#x3D;40，再执行  rear&#x3D;(rear+1)%maxSize)<br>(rear+1)%maxSize&#x3D;(4+1)%5&#x3D;0&#x3D;front<br>       当我们认为的满载发生后，最后一位置空，发现此时rear和front之间的关系为(rear+1)%maxSize&#x3D;(4+1)%5&#x3D;0&#x3D;front，因此这个关系可以作为满载的条件</p><pre><code>   因为处于满载状态，我们无法再往队列添加元素，只能从队列取出元素，也就是进行出列的操作，而一旦我们执行了出列的操作，比如将索引位i=0上的元素10出列后，则front右移，即执行front=(front+1)%maxSize操作，最终front=1。   若随后又添加元素入列，即在索引位i=4上添加元素50，随后又会执行rear=(rear+1)%maxSize操作，最终rear=0。   rear=0≠front=1，此时就不会出现之前那种错误方案中 rear=front=0导致歧义的情况，而一旦 rear=front=0，必然表示队列为空，因此这种解决方案是行得通的</code></pre><p><strong>队列为满的判别</strong></p><p>​      当我们认为的满载发生后，最后一位置空，发现此时rear和front之间的关系为(rear+1)%maxSize&#x3D;(4+1)%5&#x3D;0&#x3D;front，因此这个关系可以作为满载的条件</p><p><strong>队列中元素的个数</strong></p><p>​      numValid&#x3D;(rear+maxSize-front)%maxSize，大家可以带入数据验证一下</p><pre><code> 实际上：   当rear在front之后(这里指的是数组中索引位的前后，并非逻辑上的前后)，有效数据个数=rear-front=(rear+maxSize-front)%maxSize   当rear在front之前(这里指的是数组中索引位的前后，并非逻辑上的前后)，有效数据个数=(rear+maxSize-front)%maxSize</code></pre><p><strong>值得注意的一些细节</strong></p><p>细节1<br>      置空位虽然是人为引入的，但这不意味这置空位的位置是随意的，实际上，只有队列满后才会将剩下的位置作为置空位，一旦置空位出现，rear和front永远不可能指向同一个索引位，因为你会惊奇的发现置空位恰号将rear和front隔开了.</p><pre><code> 置空位就像一把锁，一旦上锁就只能通过出队列操作解锁</code></pre><p>继续执行获取元素操作出队列（解锁）：</p><p><img src="/2024/01/26/Embedded-C-language/bda71bd117674644bbe8c8c44c782aa3.png" alt="img"></p><p>上图中60入列后满载，可以看到置空位再次出现，但30➡40➡50➡60➡置空位 形成了逻辑上的闭环</p><p>细节2<br>从闭环的角度理解，front永远不可能在循环中超过rear，最多只能和rear相遇。</p><p>因为置空位的出现，rear不可能拉front一圈，也就避免了rear在超过front的情况下主动与front相遇</p><p>下图中的maxSize-1对应的就是置空位，rear是无法越过置空位的。只有front主动顺时针追赶上rear，它俩才会相遇，而此时队列内就没有元素，为空</p><p><img src="/2024/01/26/Embedded-C-language/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Mjk2NDE3,size_16,color_FFFFFF,t_70.png" alt="img"></p><p> 细节3<br>队列的最大长度queueMaxsize&#x3D;数组容量arrayMaxSize-1  （由于置空位要占一位）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RINGBUFF_LEN 256;</span></span><br><span class="line"><span class="comment">//定义一个缓冲区结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 Head;           </span><br><span class="line">    u16 Tail;</span><br><span class="line">    u8 Ring_Buff[RINGBUFF_LEN];</span><br><span class="line">&#125;RingBuff_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*若想更灵活，可以用动态内存分配方式（如使用指针）来实现可变长度的缓冲区</span></span><br><span class="line"><span class="comment">typedef struct</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">u16 Head;</span></span><br><span class="line"><span class="comment">u16 Tail;</span></span><br><span class="line"><span class="comment">u8* Ring_Buff;</span></span><br><span class="line"><span class="comment">&#125;RingBuff_t;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 初始化函数，传入所需长度</span></span><br><span class="line"><span class="comment">void RingBuff_Init(RingBuff_t rbuff, size_t len)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Head = 0;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Tail = 0;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Ring_Buff = (u8)malloc(len * sizeof(u8));</span></span><br><span class="line"><span class="comment">    if (!rbuff-&gt;Ring_Buff) &#123;</span></span><br><span class="line"><span class="comment">    // 处理内存分配失败的情况...</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">在C语言中，u8* Ring_Buff; 是一个指向无符号8位整型（通常代表字节）的指针。它本身并不是一个数组，但可以用来指向一块内存区域，这块内存可以被当作数组来处理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当你通过 malloc 函数为 Ring_Buff 分配了足够长度的内存后，你就可以像操作数组那样对这块内存进行读写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个ringBuff的缓冲区</span></span><br><span class="line">RingBuff_t ringBuff;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化环形缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RingBuff_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//初始化相关信息</span></span><br><span class="line">   ringBuff.Head = <span class="number">0</span>;</span><br><span class="line">   ringBuff.Tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">u8 <span class="title function_">Write_RingBuff</span><span class="params">(u8 data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ringBuff.Head=(ringBuff.Tail+<span class="number">1</span>)%maxSize) <span class="comment">//缓冲区满</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> FLASE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ringBuff.Ring_Buff[ringBuff.Tail]=data;<span class="comment">//在Tail对应索引位写入数据</span></span><br><span class="line">    ringBuff.Tail=(ringBuff.Tail+<span class="number">1</span>)%RINGBUFF_LEN; <span class="comment">//ringBuff.Tail++; 防止越界非法访问</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读数据</span></span><br><span class="line"><span class="number">10u</span>8 Read_RingBuff(u8 *rData)</span><br><span class="line"><span class="number">11</span>&#123;</span><br><span class="line"><span class="number">12</span>   <span class="keyword">if</span>(ringBuff.Head==ringBuff.Tail)<span class="comment">//判断非空</span></span><br><span class="line"><span class="number">13</span>    &#123;</span><br><span class="line"><span class="number">14</span>       <span class="keyword">return</span> FLASE;</span><br><span class="line"><span class="number">15</span>    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">16</span>   *rData = ringBuff.Ring_Buff[ringBuff.Head];<span class="comment">//先进先出FIFO，从缓冲区头出</span></span><br><span class="line"></span><br><span class="line"><span class="number">18</span>   ringBuff.Head = (ringBuff.Head+<span class="number">1</span>)%RINGBUFF_LEN;<span class="comment">// ringBuff.Head++;防止越界非法访问</span></span><br><span class="line">    </span><br><span class="line"><span class="number">20</span>   <span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="基于状态机"><a href="#基于状态机" class="headerlink" title="基于状态机"></a>基于状态机</h2><p>当“喂一口饭”、“回一个信息”都需要花很长的时间，无论使用前面的哪种设计模式，都会退化到轮询模式的缺点：函数相互之间有影响。可以使用状态机来解决这个缺点，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态机</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        喂一口饭();</span><br><span class="line">        回一个信息();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main函数里，还是使用轮询模式依次调用2个函数。</p><p>关键在于这2个函数的内部实现：<strong>使用状态机，每次只执行一个状态的代码，减少每次执行的时间</strong>，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 喂一口饭(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 舀饭 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 喂饭 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 舀菜 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 喂菜 */</span></span><br><span class="line">            <span class="comment">/* 恢复到初始状态 */</span></span><br><span class="line">            state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> 回一个信息(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 查看信息 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 打字 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 发送 */</span></span><br><span class="line">            <span class="comment">/* 恢复到初始状态 */</span></span><br><span class="line">            state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以“喂一口饭”为例，函数内部拆分为4个状态：舀饭、喂饭、舀菜、喂菜。每次执行“喂一口饭”函数时，都只会执行其中的某一状态对应的代码。以前执行一次“喂一口饭”函数可能需要4秒钟，现在可能只需要1秒钟，就<strong>降低了对后面“回一个信息”的影响。</strong></p><p>同样的，“回一个信息”函数内部也被拆分为3个状态：查看信息、打字、发送。每次执行这个函数时，都只是执行其中一小部分代码，降低了对“喂一口饭”的影响。</p><p><strong>使用状态机模式，可以解决裸机程序的难题：假设有A、B两个都很耗时的函数，怎样降低它们相互之间的影响。但是很多场景里，函数A、B并不容易拆分为多个状态，并且这些状态执行的时间并不好控制。所以这并不是最优的解决方法，需要使用多任务系统。</strong></p><h2 id="FSM状态机"><a href="#FSM状态机" class="headerlink" title="FSM状态机"></a>FSM状态机</h2><p>首先初始化FSM状态机，FSM_Init(PASSIVE);</p><p>在一个while(1)中运行FSM_Run();</p><p>在外部触发条件下使用FSM_SetState( )来设置想切换的模式;此过程中FSM模式变为CHANGE模式（FSM.mode &#x3D; CHANGE;）</p><p>FSM的下一个状态变为FSM.nextState &#x3D; state；  </p><p>这样在FSM_Run();中 首先运行FSM.exit();  即当前的状态的exit函数，然后使用FSM_ChangeState();函数将FSM的进入，运行，退出函数改成要切换的状态所对应的  （每一个状态写一个单独的.c.h文件，然后所有.h文件放到FSM.h中，FSM.c文件直接用FSM.h就行）</p><p>​    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FSM.enter = Passive_Enter;</span><br><span class="line"></span><br><span class="line">FSM.run = Passive_Run;</span><br><span class="line"></span><br><span class="line">FSM.<span class="built_in">exit</span> = Passive_Exit;</span><br></pre></td></tr></table></figure><p>然后就是该状态的进入函数，此时切换状态这一过程已经结束了，FSM模式变为NOMARL模式，然后运行该状态的运行函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*FSM.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FSM.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">FSM_t FSM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态切换 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_ChangeState</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 当前状态为下一个状态 */</span></span><br><span class="line">    FSM.currentState = FSM.nextState;</span><br><span class="line">    <span class="comment">/* 设置当前函数指针 */</span></span><br><span class="line">    <span class="keyword">switch</span> (FSM.nextState)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FIXEDSTAND:</span><br><span class="line">        FSM.enter = FixedStand_Enter;</span><br><span class="line">        FSM.run = FixedStand_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = FixedStand_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">case</span> TROTING:</span><br><span class="line">        FSM.enter = Troting_Enter;</span><br><span class="line">        FSM.run = Troting_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Troting_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WALKING:</span><br><span class="line">        FSM.enter = Walking_Enter;</span><br><span class="line">        FSM.run = Walking_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Walking_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> JUMP:</span><br><span class="line">        FSM.enter = Jump_Enter;</span><br><span class="line">        FSM.run = Jump_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Jump_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 有限状态机初始化 */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_Init</span><span class="params">(FSMState_e state)</span></span><br><span class="line">&#123;</span><br><span class="line">    FSM.currentState = state;</span><br><span class="line">    FSM.nextState = state;</span><br><span class="line">    FSM_ChangeState();</span><br><span class="line">    FSM.enter();</span><br><span class="line">    FSM.mode = NORMAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 有限状态机运行 */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_Run</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (FSM.mode == NORMAL)</span><br><span class="line">    &#123;</span><br><span class="line">        FSM.run(); <span class="comment">// In normal mode, run current state.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (FSM.mode == CHANGE)</span><br><span class="line">    &#123;</span><br><span class="line">        FSM.<span class="built_in">exit</span>(); <span class="comment">// In changing mode, run the exit function for previous state,</span></span><br><span class="line">        FSM_ChangeState();</span><br><span class="line">        </span><br><span class="line">        FSM.enter(); <span class="comment">// and run the enter function for next state.</span></span><br><span class="line">        FSM.mode = NORMAL;</span><br><span class="line">        FSM.run(); <span class="comment">// then run the run function for current state.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 有限状态机设置状态 */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_SetState</span><span class="params">(FSMState_e state)</span></span><br><span class="line">&#123;</span><br><span class="line">    FSM.mode = CHANGE;</span><br><span class="line">    FSM.nextState = state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*FSM.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FSM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_FixedStand.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Passive.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Troting.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Fall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Walking.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Jump.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Jump2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_JumpL.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_JumpL2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_JumpR.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_JumpR2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_catJump.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_catJump2.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NORMAL,</span><br><span class="line">    CHANGE,</span><br><span class="line">&#125; FSMMode_e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PASSIVE = <span class="number">1</span>,    <span class="comment">// 阻尼</span></span><br><span class="line">    FALL = <span class="number">2</span>,       <span class="comment">// 卧倒</span></span><br><span class="line">    FIXEDSTAND = <span class="number">3</span>, <span class="comment">// 固定站立</span></span><br><span class="line">    FREESTAND = <span class="number">4</span>,  <span class="comment">// 自由站立</span></span><br><span class="line">    TROTING = <span class="number">5</span>,    <span class="comment">// 对角步态</span></span><br><span class="line">    WALKING = <span class="number">6</span>,    <span class="comment">// 行走步态</span></span><br><span class="line">    JUMP = <span class="number">7</span>,       <span class="comment">// 跳跃</span></span><br><span class="line">    JUMP2 = <span class="number">8</span>,      <span class="comment">// 跳跃2</span></span><br><span class="line">    JUMPL = <span class="number">9</span>,</span><br><span class="line">    JUMPL2 = <span class="number">10</span>,</span><br><span class="line">    JUMPR = <span class="number">11</span>,</span><br><span class="line">    JUMPR2 = <span class="number">12</span>,</span><br><span class="line">    catJUMP = <span class="number">13</span>,</span><br><span class="line">    catJUMP2 = <span class="number">14</span>,</span><br><span class="line">&#125; FSMState_e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FSMMode_e mode;</span><br><span class="line">    FSMState_e currentState;</span><br><span class="line">    FSMState_e nextState;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*enter)(<span class="type">void</span>); <span class="comment">//函数指针，见前面章节</span></span><br><span class="line">    <span class="type">void</span> (*run)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">exit</span>)(<span class="type">void</span>);</span><br><span class="line">&#125; FSM_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> FSM_t FSM;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FSM_Init</span><span class="params">(FSMState_e state)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FSM_Run</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FSM_SetState</span><span class="params">(FSMState_e state)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><img src="/2024/01/26/Embedded-C-language/image-20240116005300807.png" alt="image-20240116005300807"></p><h2 id="PID算法"><a href="#PID算法" class="headerlink" title="PID算法"></a>PID算法</h2><p><em><strong>概念</strong></em></p><p>PID，就是“比例（proportional）、积分（integral）、微分（derivative）</p><p>它可以将需要控制的物理量带到目标附近</p><p>它可以“预见”这个量的变化趋势</p><p>它也可以消除因为散热、阻力等因素造成的静态误差</p><p><strong>kP</strong></p><p>实际写程序时，<strong>就让偏差（目标减去当前）与调节装置的“调节力度”，建立一个一次函数的关系</strong>，就可以实现最基本的“比例”控制了~<br>kP越大，调节作用越激进，kP调小会让调节作用更保守。</p><p>刚才我们有了P的作用。你不难发现，只有P好像不能让平衡车站起来，水温也控制得晃晃悠悠，好像整个系统不是特别稳定，总是在“抖动”。</p><p><strong>kD</strong> </p><p><em><strong>阻尼</strong></em>， kD参数越大，向速度相反方向刹车的力道就越强。</p><p><strong>KI</strong> </p><p>设置一个积分量。只要偏差存在，就不断地对偏差进行积分（累加），并反应在调节力度上。</p><p>I的作用就是，减小静态情况下的误差（消除稳态误差），让受控物理量尽可能接近目标值。</p><p>在使用时还有个问题：需要设定积分限制。防止在刚开始加热时，就把积分量积得太大，难以控制。</p><p><em><strong>使用</strong></em></p><p><em><strong>需要及时更新数据，一般是写个while循环使用pid_calc，延时几毫秒更新1次</strong></em></p><p>1.DJ</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PID.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PID初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PID_Init</span><span class="params">(PID_t *pid, <span class="type">float</span> kp, <span class="type">float</span> ki, <span class="type">float</span> kd, <span class="type">float</span> max_out, <span class="type">float</span> max_iout)</span></span><br><span class="line">&#123;</span><br><span class="line">    pid-&gt;Kp = kp;</span><br><span class="line">    pid-&gt;Ki = ki;</span><br><span class="line">    pid-&gt;Kd = kd;</span><br><span class="line">    pid-&gt;max_out = max_out;</span><br><span class="line">    pid-&gt;max_iout = max_iout;</span><br><span class="line">    pid-&gt;err[<span class="number">0</span>] = pid-&gt;err[<span class="number">1</span>] = <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PID计算, 输入反馈值和预期值</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">PID_Calc</span><span class="params">(PID_t *pid, <span class="type">float</span> fdb, <span class="type">float</span> <span class="built_in">set</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pid-&gt;<span class="built_in">set</span> = <span class="built_in">set</span>;</span><br><span class="line">    pid-&gt;fdb = fdb;</span><br><span class="line">    pid-&gt;err[<span class="number">1</span>] = pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">    pid-&gt;err[<span class="number">0</span>] = pid-&gt;<span class="built_in">set</span> - pid-&gt;fdb;</span><br><span class="line"></span><br><span class="line">    pid-&gt;Pout = pid-&gt;Kp * pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">    pid-&gt;Iout += pid-&gt;Ki * pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">    pid-&gt;Dout = pid-&gt;Kd * pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid-&gt;Iout &gt; pid-&gt;max_iout)</span><br><span class="line">    &#123;</span><br><span class="line">        pid-&gt;Iout = pid-&gt;max_iout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid-&gt;Iout &lt; -pid-&gt;max_iout)</span><br><span class="line">    &#123;</span><br><span class="line">        pid-&gt;Iout = -pid-&gt;max_iout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid-&gt;out = pid-&gt;Pout + pid-&gt;Iout + pid-&gt;Dout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid-&gt;out &gt; pid-&gt;max_out)</span><br><span class="line">    &#123;</span><br><span class="line">        pid-&gt;out = pid-&gt;max_out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid-&gt;out &lt; -pid-&gt;max_out)</span><br><span class="line">    &#123;</span><br><span class="line">        pid-&gt;out = -pid-&gt;max_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pid-&gt;out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PID_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PID_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">float</span> Kp;</span><br><span class="line">    <span class="type">float</span> Ki;</span><br><span class="line">    <span class="type">float</span> Kd;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> max_out;  <span class="comment">// 最大输出</span></span><br><span class="line">    <span class="type">float</span> max_iout; <span class="comment">// 最大积分输出</span></span><br><span class="line">    <span class="type">float</span> err[<span class="number">2</span>];   <span class="comment">// 误差及上一次误差</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="type">float</span> fdb;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> out;</span><br><span class="line">    <span class="type">float</span> Pout;</span><br><span class="line">    <span class="type">float</span> Iout;</span><br><span class="line">    <span class="type">float</span> Dout;</span><br><span class="line">&#125; PID_t;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PID_Init</span><span class="params">(PID_t *pid, <span class="type">float</span> kp, <span class="type">float</span> ki, <span class="type">float</span> kd, <span class="type">float</span> max_out, <span class="type">float</span> max_iout)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">PID_Calc</span><span class="params">(PID_t *pid, <span class="type">float</span> fdb, <span class="type">float</span> <span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.电机位置环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*pid.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_pid.h&quot;</span></span></span><br><span class="line"><span class="comment">//1 0.10 0.1</span></span><br><span class="line"><span class="type">float</span> Position_KP=<span class="number">0.5</span>,Position_KI=<span class="number">0.00</span>,Position_KD=<span class="number">0.09</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Position_PID</span><span class="params">(<span class="type">int</span> reality,<span class="type">int</span> target)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> Bias,Pwm,Last_Bias,Integral_bias;</span><br><span class="line">     </span><br><span class="line">    Bias=target-reality;                            <span class="comment">/* 计算偏差 */</span></span><br><span class="line">    Integral_bias+=Bias;                        <span class="comment">/* 偏差累积 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Integral_bias&gt; <span class="number">3000</span>) Integral_bias = <span class="number">3000</span>;   <span class="comment">/* 积分限幅 */</span></span><br><span class="line">    <span class="keyword">if</span>(Integral_bias&lt;<span class="number">-3000</span>) Integral_bias =<span class="number">-3000</span>;</span><br><span class="line">    </span><br><span class="line">    Pwm = (Position_KP*Bias)                        <span class="comment">/* 比例环节 */</span></span><br><span class="line">         +(Position_KI*Integral_bias)               <span class="comment">/* 积分环节 */</span></span><br><span class="line">         +Position_KD*(Bias-Last_Bias);             <span class="comment">/* 微分环节 */</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(Pwm&gt;<span class="number">4000</span>) Pwm=<span class="number">4000</span>;</span><br><span class="line"><span class="keyword">if</span>(Pwm&lt;<span class="number">-4000</span>) Pwm=<span class="number">-4000</span>;</span><br><span class="line"><span class="comment">/*if(Pwm&gt;0&amp;&amp;Pwm&lt;1000)</span></span><br><span class="line"><span class="comment">Pwm=1000;</span></span><br><span class="line"><span class="comment">if(Pwm&lt;0&amp;&amp;Pwm&gt;-1000)</span></span><br><span class="line"><span class="comment">Pwm=-1000;*/</span></span><br><span class="line"></span><br><span class="line">    Last_Bias=Bias;                                 <span class="comment">/* 保存上次偏差 */</span></span><br><span class="line">    <span class="keyword">return</span> Pwm;                                     <span class="comment">/* 输出结果 */</span>              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>应用案例</strong></em></p><p><strong>循迹</strong>（写的不太好，看看就行）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_linewalking2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">bsp_GetLineWalking1(&amp;SADC1);</span><br><span class="line"><span class="keyword">if</span>(SADC1)</span><br><span class="line">&#123;</span><br><span class="line">Systick_Delay_ms(<span class="number">5</span>);</span><br><span class="line">bsp_GetLineWalking1(&amp;SADC1);</span><br><span class="line"><span class="keyword">if</span>(SADC1)</span><br><span class="line">&#123;</span><br><span class="line">car_STOP();</span><br><span class="line">Systick_Delay_ms(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Car_Run(<span class="number">10</span>,<span class="number">0.5</span>,<span class="number">3000</span>,<span class="number">3000</span>,<span class="number">3000</span>,<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Car_Run</span><span class="params">(<span class="type">float</span> kp,<span class="type">float</span> kd, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">MOTOR1_state(GO);       </span><br><span class="line">MOTOR2_state(GO);</span><br><span class="line">MOTOR4_state(GO);</span><br><span class="line">MOTOR3_state(GO);       </span><br><span class="line"></span><br><span class="line">Speed_1(PWMA(kp,kd,a));Speed_2(PWMB(kp,kd,b));Speed_3(PWMC(kp,kd,c));Speed_4(PWMD(kp,kd,d));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">PWMA</span> <span class="params">(u16 kp,u16 kd, u16 basic)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> error;</span><br><span class="line"><span class="type">double</span> mistake;</span><br><span class="line"><span class="type">double</span> fix1speed;</span><br><span class="line">u16 fix2speed;</span><br><span class="line">u16 olderror;</span><br><span class="line">u16 der;</span><br><span class="line"><span class="type">int</span> PWM;</span><br><span class="line"><span class="type">int</span> P;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  mistake= Get_Adc(ADC_CHANNE_ML) - Get_Adc(ADC_CHANNE_MR);<span class="comment">//左-右 F7-F9</span></span><br><span class="line">mistake=mistake/<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (mistake&gt;<span class="number">200</span>) error=<span class="number">200</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mistake==<span class="number">200</span>) error=<span class="number">200</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mistake&gt;<span class="number">0</span>&amp;&amp;mistake&lt;<span class="number">200</span>)error = mistake;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mistake&lt;<span class="number">0</span>&amp;&amp;mistake&gt;<span class="number">-200</span>) error=-mistake;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mistake==<span class="number">-200</span>) error=<span class="number">200</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mistake&lt;<span class="number">-200</span>) error=<span class="number">200</span>;</span><br><span class="line">  fix1speed = kp*error;</span><br><span class="line">olderror=error;</span><br><span class="line">der=error-olderror;</span><br><span class="line">fix2speed= kd*der;</span><br><span class="line"><span class="keyword">if</span> (Get_Adc(ADC_CHANNE_ML)&gt;Get_Adc(ADC_CHANNE_MR)) PWM = basic + fix1speed+fix2speed;  <span class="comment">//左边大于右边 说明黑线靠右  左轮应加速</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Get_Adc(ADC_CHANNE_ML)&lt;Get_Adc(ADC_CHANNE_MR)) PWM = basic - <span class="number">1</span>* (fix1speed+fix2speed);<span class="comment">//   黑线偏左   左轮应减速    3是电机正转和反转在相同pwm下速度不同</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Get_Adc(ADC_CHANNE_ML)== Get_Adc(ADC_CHANNE_MR)) PWM =basic;</span><br><span class="line"><span class="keyword">if</span> (PWM&lt;<span class="number">0</span>) PWM=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> PWM=PWM;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> PWM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>电机位置环</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Pos_ctrl_ML</span><span class="params">(<span class="type">float</span> rotationNum)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Moto = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Target_Position=Num_Encoder_Cnt(rotationNum,ENCODER_RESOLUTION,MOTOR_REDUCTION_RATIO);</span><br><span class="line">Read_Encoder(<span class="number">5</span>);</span><br><span class="line">Encoder_Cnt+=Encoder_cnt;<span class="comment">//每次读完清空是为了累加从每次起始点开始的脉冲数</span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">if</span>(Encoder_Cnt==Target_Position)</span><br><span class="line">    &#123;</span><br><span class="line">      Set_PWM_ML(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      Moto = Position_PID(Encoder_Cnt,Target_Position); </span><br><span class="line">      Set_PWM_ML(Moto);</span><br><span class="line">      Set_PWM_MR(Moto);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;Encoder_Cnt=%d\tTarget_Position=%d\tccr=%d\t\r\n&quot;,Encoder_Cnt,Target_Position,Moto);</span></span><br><span class="line">HAL_Delay(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*pid.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_pid.h&quot;</span></span></span><br><span class="line"><span class="comment">//1 0.10 0.1</span></span><br><span class="line"><span class="type">float</span> Position_KP=<span class="number">0.5</span>,Position_KI=<span class="number">0.00</span>,Position_KD=<span class="number">0.09</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Position_PID</span><span class="params">(<span class="type">int</span> reality,<span class="type">int</span> target)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> Bias,Pwm,Last_Bias,Integral_bias;</span><br><span class="line">     </span><br><span class="line">    Bias=target-reality;                            <span class="comment">/* 计算偏差 */</span></span><br><span class="line">    Integral_bias+=Bias;                        <span class="comment">/* 偏差累积 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Integral_bias&gt; <span class="number">3000</span>) Integral_bias = <span class="number">3000</span>;   <span class="comment">/* 积分限幅 */</span></span><br><span class="line">    <span class="keyword">if</span>(Integral_bias&lt;<span class="number">-3000</span>) Integral_bias =<span class="number">-3000</span>;</span><br><span class="line">    </span><br><span class="line">    Pwm = (Position_KP*Bias)                        <span class="comment">/* 比例环节 */</span></span><br><span class="line">         +(Position_KI*Integral_bias)               <span class="comment">/* 积分环节 */</span></span><br><span class="line">         +Position_KD*(Bias-Last_Bias);             <span class="comment">/* 微分环节 */</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(Pwm&gt;<span class="number">4000</span>) Pwm=<span class="number">4000</span>;</span><br><span class="line"><span class="keyword">if</span>(Pwm&lt;<span class="number">-4000</span>) Pwm=<span class="number">-4000</span>;</span><br><span class="line"><span class="comment">/*if(Pwm&gt;0&amp;&amp;Pwm&lt;1000)</span></span><br><span class="line"><span class="comment">Pwm=1000;</span></span><br><span class="line"><span class="comment">if(Pwm&lt;0&amp;&amp;Pwm&gt;-1000)</span></span><br><span class="line"><span class="comment">Pwm=-1000;*/</span></span><br><span class="line"></span><br><span class="line">    Last_Bias=Bias;                                 <span class="comment">/* 保存上次偏差 */</span></span><br><span class="line">    <span class="keyword">return</span> Pwm;                                     <span class="comment">/* 输出结果 */</span>              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C language programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/01/22/hello-world/"/>
      <url>/2024/01/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hello World!</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>前路漫漫亦灿灿</title>
      <link href="/gallery/college.html"/>
      <url>/gallery/college.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-container" data-type="data" data-button>      <div class="gallery-data">[{"url":"./college/49-1706344694822-120.jpg","alt":"49"},{"url":"./college/48-1706344708682-122.jpg","alt":"48"},{"url":"./college/47-1706344716685-124.jpg","alt":"47"},{"url":"./college/46-1706344721866-126.jpg","alt":"46"},{"url":"./college/45-1706344637895-118.jpg","alt":"45"},{"url":"./college/39-1706345196130-209.jpg","alt":"39"},{"url":"./college/37-1706345211163-211.jpg","alt":"37"},{"url":"./college/33-1706345229054-213.jpg","alt":"33"},{"url":"./college/29-1706345235414-215.jpg","alt":"29"},{"url":"./college/19-1706345257443-217.jpg","alt":"19"},{"url":"./college/12-1706345274915-219.jpg","alt":"12"},{"url":"./college/13-1706345280346-221.jpg","alt":"13"},{"url":"./college/14-1706345293624-223.jpg","alt":"14"},{"url":"./college/31-1706345317371-225.jpg","alt":"31"},{"url":"./college/43-1706345325834-227.jpg","alt":"43"},{"url":"./college/41-1706345332395-229.jpg","alt":"41"},{"url":"./college/38-1706345344631-231.jpg","alt":"38"},{"url":"./college/30-1706345352332-233.jpg","alt":"30"},{"url":"./college/32-1706345365438-235.jpg","alt":"32"},{"url":"./college/50.jpg","alt":"50"},{"url":"./college/34-1706345374354-237.jpg","alt":"34"},{"url":"./college/51.jpg","alt":"51"},{"url":"./college/52.jpg","alt":"52"},{"url":"./college/35-1706345381156-239.jpg","alt":"35"},{"url":"./college/20-1706345398048-241.jpg","alt":"20"},{"url":"./college/25-1706345411044-243.jpg","alt":"25"},{"url":"./college/24-1706345419521-245.jpg","alt":"24"},{"url":"./college/23-1706345425445-247.jpg","alt":"23"},{"url":"./college/17-1706345438446-249.jpg","alt":"17"},{"url":"./college/9-1706345445647-251.jpg","alt":"9"},{"url":"./college/8-1706345461721-257.jpg","alt":"8"},{"url":"./college/26-1706345477181-259.jpg","alt":"26"},{"url":"./college/16-1706345482816-261.jpg","alt":"16"},{"url":"./college/7-1706345489413-263.jpg","alt":"7"},{"url":"./college/6-1706345496102-265.jpg","alt":"6"},{"url":"./college/4-1706345502454-267.jpg","alt":"4"},{"url":"./college/3-1706345507417-269.jpg","alt":"3"},{"url":"./college/2-1706345515116-271.jpg","alt":"2"},{"url":"./college/1-1706345519911-273.jpg","alt":"1"}]</div>      <div class="gallery-items">      </div>    </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-group-main">    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="/./images/7.jpg" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">我的大学</div>  <p>我的奋斗</p>  <a href="/gallery/college"></a>  </figcaption>  </figure>      <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="/./images/6.jpg" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Robocon</div>  <p>WUST ROBOCON 2023</p>  <a href="/gallery/robocon"></a>  </figcaption>  </figure>      <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="/./images/8.jpg" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">起重机</div>  <p>命运的齿轮开始转动</p>  <a href="/gallery/crane"></a>  </figcaption>  </figure>  </div>    ]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/message/index.html"/>
      <url>/message/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>尽吾志也而不能至者，可以无悔矣</title>
      <link href="/gallery/crane.html"/>
      <url>/gallery/crane.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-container" data-type="data" data-button>      <div class="gallery-data">[{"url":"./crane/19-1706339747403-43.jpg","alt":"19"},{"url":"./crane/18-1706339819893-45.jpg","alt":"18"},{"url":"./crane/17-1706339835479-47.jpg","alt":"17"},{"url":"./crane/16-1706339842391-49.jpg","alt":"16"},{"url":"./crane/4-1706339853690-51.jpg","alt":"4"},{"url":"./crane/6-1706339861221-53.jpg","alt":"6"},{"url":"./crane/12-1706339867143-55.jpg","alt":"12"},{"url":"./crane/7-1706339875488-57.jpg","alt":"7"},{"url":"./crane/13.jpg","alt":"13"},{"url":"./crane/15-1706339890044-60.jpg","alt":"15"},{"url":"./crane/9-1706339896866-62.jpg","alt":"9"},{"url":"./crane/3-1706339904800-64.jpg","alt":"3"},{"url":"./crane/5-1706339910791-66.jpg","alt":"5"}]</div>      <div class="gallery-items">      </div>    </div><div id="music-page"></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>欲买桂花同载酒，终不似，少年游</title>
      <link href="/gallery/robocon.html"/>
      <url>/gallery/robocon.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-container" data-type="data" data-button>      <div class="gallery-data">[{"url":"./robocon/5.jpg","alt":"5"},{"url":"./robocon/4.jpg","alt":"4"},{"url":"./robocon/IMG_20221026_171356.jpg","alt":"IMG_20221026_171356"},{"url":"./robocon/IMG_20230226_160022.jpg","alt":"IMG_20230226_160022"},{"url":"./robocon/IMG_20230226_181211.jpg","alt":"IMG_20230226_181211"},{"url":"./robocon/IMG_20230522_191254.jpg","alt":"IMG_20230522_191254"},{"url":"./robocon/IMG_20230614_211620.jpg","alt":"IMG_20230614_211620"},{"url":"./robocon/IMG_20230707_132558.jpg","alt":"IMG_20230707_132558"},{"url":"./robocon/IMG_20230707_184452.jpg","alt":"IMG_20230707_184452"},{"url":"./robocon/IMG_20230707_205101.jpg","alt":"IMG_20230707_205101"},{"url":"./robocon/mmexport98bdd9d9588b4cdaa855aa0ae3d7dce5_1688707161464.jpeg","alt":"mmexport98bdd9d9588b4cdaa855aa0ae3d7dce5_1688707161464"},{"url":"./robocon/Screenshot_20230413_121149.jpg","alt":"Screenshot_20230413_121149"},{"url":"./robocon/Screenshot_20230708_105442.jpg","alt":"Screenshot_20230708_105442"},{"url":"./robocon/1f808d0f5874cda9.jpg","alt":"1f808d0f5874cda9"},{"url":"./robocon/62ed118391dafe0a.jpg","alt":"62ed118391dafe0a"},{"url":"./robocon/274a1c04a632f15c.jpg","alt":"274a1c04a632f15c"},{"url":"./robocon/-757c3e143b47490f.jpg","alt":"-757c3e143b47490f"}]</div>      <div class="gallery-items">      </div>    </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Vscode&amp;Keil</title>
      <link href="/vscode-keil/index-1.html"/>
      <url>/vscode-keil/index-1.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>路虽远行则将至，事虽难做则必成</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>vscode&amp;keil</title>
      <link href="/vscode-keil/index.html"/>
      <url>/vscode-keil/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>zhixiong&#39;s page</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
