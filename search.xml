<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>具身智能入门</title>
      <link href="/2025/05/02/%E5%85%B7%E8%BA%AB%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8/"/>
      <url>/2025/05/02/%E5%85%B7%E8%BA%AB%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0d783efb3b1f9acf68d489e361bd3c615246ca94d78c8dfec2f5587536c1ed1b">34257ab2b37d2b24b0d1614cb5aa327ab52456e0e06443533594051f07e1436e061a1c331aa27e364a6bbb10a5200cde93f4acecbfa7a78625bc2b83524c08269b1464a1b1e61191eb86a61e91340afe2d1620d41c8ab8952658ff320d594afd7b7472d3bb0810bb5f493abd1ced17a1dfab6f26a87cbb6dc6fa2c813bd83aa019be4fb40b2ab33a3dc12250f666593778d8a3bdcf555f075b882e15517eb0f1b0b581af0718f37376b24a24279b06a58065b6a3e4ddc72cfcb1933ed60313d793996337bebc187c7f5d28dbfad4624a7ed28906842052bf96bb1135c6ec713f78cb935fe3e107227b3a3b42c6ff505c8e080a49918eaae01b6e42ca798fc0aff12607578f3fa9b07b4006aef63aa2cc1e5a9ace15bb3c4fa9fd6f29800f9d4e41fb7b75837c04abb7947cf277c1e2792de2a7916a762c8c17b3612520e1cb0c0c41ab0b168866bfb634297fd4421e441d9f22ded4e1dbe4b6ec4b8f1f850a8cdef97b4fdc820f0c1e8a04e6a268e997818928805078f36207b1ca7f37740cd7ff08650df7a66bea19ef366591b7bbc6de027e85473e73bfd3b66f48ffefbbecef6537895c6dc756f8c20c3a55fdbceb9eaa72ca773f29013259fce4c8f9317f32ca8755d513992a68d8fdead4a7c8c4889365efba26dc70f30e7bce0eed7c0a18989101886436299a638a8a919976e939aea67092084369d8f49b0065a07a8c8ea62b24296a35437c9441e2ebb70662cfbeb385f18442bb130e63340cc03d10176f1c80c4455c9e6b35c52764533587407f2f1683aff6addabce219a796e91b198524acb18461bcfd0800579de32f2c1bebe40476f75c7e367ddd619be4bd45365c8d7ce175216523765bd464a440806d845abc03152ff170d31052ef6bdabd977950df29a9472e474335a9f17b20250586fe600ecb6615cf00dba3f5071d49eecf64f47d7ccd456a41b378c50907703bd9ffa7f07c113718e5bad5214dbf99c35583157e3459c51b038df544f65b71bdad6fb209cc2bcc60f88fd68df5f242f161fb4ab316bcee085faf1832e461c9f6bb7b7469eb4f6423c6a9e7302688c6f1eb5c8cb48aa42d3c80d21e1fd162c5cb656ed25e103ba90cb277eaf209f7b7a161661a30892f1635880a0b42b2798e2c377bd84d23d533d43ecc6ab57be8421648142846a47b506674a015d4bd01f058e055339b3fb232d879d58d271cfd050ad4ee94efd997ead34026ba427b6a63861424f71cc0cb2bc9c26e5a90a13ec4968ac0d58f505afb174c114bd85e6fb0e2249401daa9dc405fcdf089c7ffd17cb0e59eaa659abf2409cd55618bbb1dfcfb55c0b6a936a7a22565d351b9c97e3b3bf7e5c051f51b5ba0ecceeca245f5f1334de276df157f53e8515fc53b59f9ae0b42df5cbf1ce55a64006013aabcf1146435ac833b448e2ce1de1505979b10c8bf56d3eff3df39b82328ca456dc8194ff3fc72dc94da587b5856cc2b3a7cc65e714836c23c3599f6a98c93ca23a0a2707eb715994b3eee86ae9f94fede3734e2ee2f7d7d4bba334a0aeb526f87536041aa8bc8432307d46f42fdb07684f80d4b5875fe011ab57ce8776f065cffef50e1259edd86a65c9c359f701e721f28cdd1abd83d84157dc5f9966c087c96ff1ea99b06e7a4d2e84d995966c951082c3ae508b2dbf5840fb5e5383ecd10972f18b49110ea3b53bb6e644b0282bad96d0ec426d1b23215a7f5dbef46497850d99249682623f9544239ed79a481800d03256d3e0557278f2ea8510a61ae3c847b294264ebfa55779b91d53298baaee4e5ff0da115f145442b6652e490f95e89568038cda475b1bc8ca9ec56ab4af8ece7084aa052c39110024bb9b9a13245917796866093ed128f00f9e75fbd42532f116bc85776711ee9a6e094c1a550306e1c9123baca014556250213aefefc380611f66ddd5f248225ac1840b0623bd2b0cb374233d9f17f2c6c6ac2727f21d194806a301cd249fe4c7fca4571b1b44b35bd6bfa6911a6304b1efb2419bcb88d33789360c4d0756973ad6a7b6cc8e529feea1007d8881e9de81c68a400e66033259a574bfaebeb3877993edf448756d67fd16e6aa1a493df2e5c65969a9cd00e49b77116605266debd84fca28064545a6b829081e5cb3aebb026c9e0cc89594e386cd2d09ea3d68d8bc9258ab0b6802feb86357b5b3b2bc3d518f365089c0e6ca5698c8b828f110e56e4f497bd03b11aff36c7f1bd48ba89d3a08cea3c8b8a3ced01d22ce09ab047404958cef0010866a78a6c21b6718715f5e9d1cffe5717bf15baf5b0e5612692eee7ebca773bfb9c07da3cf293b32823f92ebbc4236f4b87a63acc104bffcd1a4828149bcc855a472f6644f71078ef22f029c73c22551ce435d020e465f991e86f8df43d1d4bc939ac4189887ffb0eeda6e18b1143fddbb9d2e4e3695d8869e31a94f79594668abb175c1bc72bba09098ea815d1396f960a10352fa8b13518dbedb516d1a7db33f547a408c9ace889b82f95a4cf11f00432a35f9b06ffd98a518d355c96963ded7997cc1480bdd79558e1fb7464fff19a441e4d475a7c499f0636978fe6170dcc9f75f86c987cd8b8fe0ccac6e4e6dcd3af73f5b0d65b2407ff21e4afd061ef227eeece36ce0ff978c0d7541606129ecc7bd0302be4ea0d24c23bd513d936778d955e40d7e1cd7e0b8da57e41f9f1f748463c6a1de16a67664842eaacadb3a793ba9d54df92502263fed85f90a78d0da25322424cd1f599b8bb93a3852f0ca7f34d447a683182f1409b4e6d5ea160325c0055795263dabccc73b747b29210e385d8e03c55399a9859801c87db74c96fd6db1cc9825434c0e56481cd374e106fb2db4f68df3ab40a7724b82822ff6da2f66f882f4ef77043c47d575e85579a86756ef84cf1d436de9412ac731b732f0f32f2bd8a2a68f4ea2338fe2a64cc3b6830be78f2de7a83676d6a55fa444adf60160c12f5cb927d025262e650167726b81043467b2744b02ef5630a37bd8cfcfa8058f25384daab87556de726f64451a236af6c4f49a50fe47d3695578d65bace5847a3ba975b62c0f1125ad7cc97e08e36f0a452eb34fd75e5e3928b2f357365d64f009b83c89085b5b1007cbdcccc4e00ebcb30dba5ca5ec31f161630381098166e14653e9862127ebab269bcd315d544b6b3ac8e055f35c7f67595274f76668917e20c3c66c1e7b1161c61aabd3592d9c49033979ac218626b224c610b3a465e74b5d3ac491bdb5937e99e24ad89222134ffeef529049bf62b3d5bb3011e85f85c8868f44eddbe21bc40786c05db5ebdbd9a51d01555829c1db62b4ff8fe695842c56ece3bf6f991b072cc01b6cd4ecf896babee9790eec107bc879940f5060908a7aa4078bce3a8a71d9b368e25719c5161b75702fddefb16550e1bbec7378c227f3f03b61a8108838d65509dbd91d6c308dd215d41091aaf3d5e665e704085e68141ce3a6f3fe7b3189809e4a5cd797132364033bb3d6bed48ee787d70f9c4d6fd829d281087c406b1c3f59dd7885b1495ae3ee1c29429134c6c3205eac3d676b01a3a23a9490d90959953a2b38cb94f450e20ce266165139697f1eb1734336cf59438bfcba3e95ee323b93b10c025af4a233c2f3dc2d983f000cadb49fbc9785c026c97af8e0b0fb3d9a3fd02871e6df36de87488bdc85ba36bfe574f8ac1e695b88cc6410b225626a625c0c6766ef3a300f14034aa5b6545bea6a827ad443f1575f31f18e15c69445d39f555513eecdba9f7140df833cec785b27fe40097876678ea0582cc6de1cbc468d85f3ea0ff367131e68cc903214fbb5b8589926c170b9e68a723a381dd10777f1776449f021e8d1f1db6ed5248f5a0439f895af0f6358f9a28395143a47be620b26669b7bc1630fd063f9d2ffe55400628470ec344dc0e1109503617f83f1ad619da2c1a3c90e7bf661aae99e9dbf36a8dee95dceb0757b55888c47455c0e0f604b12f09d5ca6cf6240171ea4b2465403ba0322981ec839950cee9ee1769d6fd918960419c50f2245d10498b18d61285c89251abe750f8a9ba9518bcd8fd37c0ebdf34e6f45d10c4adce6e34e58d4b13948851ebdc7b1fcebc62f289229868954199a5062e778c221a606fe59b41ed69fded13c785d2fcc0607ce8ced9333849d72ec2aad5ed999f71a48474b8d47e29de1eb79adfaf806d676173608acb925bc3d02a82a23a08415815a5f13b676b008566f55598cb2e0f5b2b4b1c9d7291599a5e825c5b0dd9a42bee8ca10d425837b42334befa14750b4d45dbf54eb58554811195be3b4b9b6a72870b28d127f955cfd83bbb710f3523d4a8eaf280445458b7ba57536ed9e10604db29e6f9f6575654ccd37ce445481f94811ea59209a37d62850c71a456950c213eed08879220aceeb410762b864c15d929450c57d074e439dd99e01bc749ee80395fe698b29f5e719eb5f27b06a9f995923fc2576fbfcdb4225ac19dc4de4bfbfc948e8390e35835b5c341c04d2e5fb21e4a5cb09ef7ff51ecaa35e1278a273a2db0f491a2b72b28b73710bfeb5499538a5b74d6894803ea577bbea0f7b9d024ccb4b1be5b9fa831d866518787a9277fa3defabf9bbe372ac67706e9eaf4ef04a55193847178126c72c8925fe3bc7d5ee13df3401abcc45b6fba6c235ac00c3765356979e6f994ebc67f89695825d6bcf4d463f3208edf8318d42a581afc815b48bfa758a062f37904491fb623024fbfbf8e9e9c96eebc5244f60eb2a90d2b5ff25cc1681121afc1ade6a4da602be55ff2ab6b33eb00cded9add550a7a27f03bebe885fe8648fe44f78ce78715ad119209cb84db1be433341549ff3fb6340beb4fa2b3c0c953be84eaa35ca297a496fe4c97cb06bb9a96cfd9ab3a4a6cb4fce2e94d9809c60cd7b84918bdd7f7c2b41813ff677aa167d2458fa12a0e2c83a7f2f180c2fdd0bb4e28b63ac6de4f084ef4ce6aca9e2b3b192a7748aea448928cc58aceee2df038a91cfe10e8b98114abeff77242bf979adae9a78b25a8471a2a2d37df6c8e47421e0daac167dd07cbc81c57ada351d2cc81038e9f880e16def82ebdde33486f03b9ff0e3004bbf3bd952f5a6c0108f9244c4f4231fe19c5944a021aec732102e77b3090d86b94fd2b6fb2018d2e23c42cb5d20fdeb851432af8f430677988b593fe087a383dbd1cd5bf4e4a11c3839859352ae905f182f834cd39c21ab5b3983e1d1f1bc9c105afc7ba53bad1d85e074daae28b0d15a50ad04a0ba29ffb045bd0162484f58c3d94293e2517ccadeed7ec7962fbe5b2b47b8c0c87113ada7c92c89220156620aecb9e1765f72d0987fafbe075a3ac510a743b861f66dee12f89e52211352d31565cab336103fb3e424d05590305d2581ae36a67c00fe39787978c8fbb8342e243cde879526bfbb0ec024fe38c52c58de4011dfaf51058950473f38f00df67c31664f62097d56198c7f2cbc230060d28c76bacf82f4084244faea1aac660ca1f0a1cc8f5604139d90f2d137956bc064cc2ac4b757c25ba410895375f948fc21704efe17ac05985baccc9bf20120caf30c945d1251ffa121ff69ba9b68f8d0e9491284ec4e5ed88fb426dbe47dd0f5f6d96a28b07ecaff339e21a8ee5c3ce5b1c823c18c3b3719f31802f53b3ca7f61f0c346e65c3b02ad08525e2b892e64d7fa9bd1533db8bcc3116187d4c767490e3a97f164ee4a41e50b6681ac0f5556f0ee560fcb3c8f559f6d1dd770be99d178515014e8d2ba261d18655a6466fb324d044915569f75f62fe1e9a1638f6fdc8b36d2dd6ff8f4d895816e59f5156ddf60a8c82e095de3e947f36a0ba74cea26a43b630fc5a101e16a5fd5761869e3d63e10d53dd10caa8a98908e15e7db3e8b8f7bf33fe85472caa9de523e8395bdf5360a60b445eacddb3fbccaa77e922b34832c16903155e94e4936a4ec4eb044150a47dc98b3695fcee884793ae4ce9f9466475920d8be4731318552f298c6b4a278a23779c9f6202db33c582f8bdbec954699c753555c435c7ab0b3493d643160efc88187af26348b8fb5f4f90263603ff20586635443a0e6c04a46d23223179d403d1980d4a988779a5b5d8a7d68c50b02627a18cdafc9babefb236020b1f3ef35943a07e15cbc2a4d6d85c032cd4187b06c4828e5b92ea29b1006f4ec91802a2a608d43d5b25fac592531a6938968ea37562469cffeff6c09d4a9b8332ea1fc948b64da2965e352d4c1cbfd540567af50e5c478a2cf854ffa777ffec2b0e3f350a97ab55c86425f5d4456764feb15a07cbcb5008252559dce9f6fae4b0063be27c0b0a31f2fdb7e9338083bd9938e6749b8100ec419891a424d9d37a1e1e0f80087c20dc6a85c26e8c90bfee642fd3247da8419cfab28a3012e1d6f4b165c736e0810a9a80cca60f0a733bed48eca0279f09e285039b9317c217f6c9094b5990dff6d9c742cff4ebde865aa042ba9618d3ced37692d631c956f4a63d9001491ff04d4de7b4708736168d72d86bca62f1cf607af55fc9738e99493af2a9627d989f59a17976681f08d30d35b40cc612b4e9a34cd12cad0d0257aa8be21bf1eeab2ebcfac3c714c22b607fc53e5019f4037a1305b47bde6e07ae3fc66f0c8d3d2e364413480f786b56d406f9fce76b77f679cff4bebed608a57ef2a040dfc4f447747a286034fff6118379650f30bbc5bfcb0eae95139669772ec82a092525aa6e89d01724a3f137555e9c8817a4364f164d5c7ceed66b25a2d64c47ce8ebfc55279002c210582c48c44bbb91586354076ee0218062adab8a494f1882aec40f321aeddb8de147eb0558c8e88f87fa93fdee45771990fdcfb88ffba0c9ebe0d1d3d9cb6970bb5f35c38d6bee7f48f5ec47aaa1062c9514e0846bb039b7dcf67b27665b40f6490c26adc4bfce9a91b98633ccb1b2ce9d3f08aeb4c812d07ee88396f7998242359d3ef579f1d3c53ed1ba8b269368c511d74e830dd317ee666dbf3ab4153f59ee4f4381c5992c1152d98103a79598fdaed1ff8a1a80221c6f9cd7b4e100cbbf23f1f8d522bba036ca5d20802fea353a06c92d76cb972691e99a01b4efebd76198c7b2cb910f93aa57f9341cff9d6e3d7b6e00a2e06f4d03503407b523b353d1bfa10e237b3dfe3b11068393278b4c7255c85f6ab9e26190d4df3bcbd5174f9a89ac3973d6bfd8044bfd1079470ea7847f9ef294814bdb7782a99d95cad8d785b73e1ac8a92c69176fec312033e2e735968b17ff475dad061ab4d5a21030f5e85977cb1e66c97390bc1c58dfcb4c507fb627b9f4f475c437d572b67a256bf740118b724409fb80f6a1326cdce961772a1ceb183afe0bb66939314fa1cf95d48505cab6c21934704e1a1bd70141ccf90e262b3472d6a13820cc623c0b9b908fcbb5f4f9e78c90c6b691843840e27a8848ec0f8b0577e0052e41c80733a74183875aa903bed2ae5ea162588d9249fffdb519cd0b080bed6483adda7c0fee07055b5569dba2334a75d3818ad3ab5319ef5ac6ba12a76bbcbec1ccc04e64e5615399e55f306025322fae6bec7f50d0aa82e859a6400d22ef7afde59036a7a6175389e93acbf98587d981b8a4ffd0b1d86fa21e7de56a498e7a490eceb0656b1f5c507d152a3b9064d50269ba10db907b21cace68f213c8465512616aba409b24c19f9503c9fa5642da4be75c8b97e5cdf2938c65735a1a39c88a0ebcf0376123756852c185ef02e5899b75a1a64b0a1d01babf0de5d365f0543429e75c5f317ad445d594ac2c195e0d8518fecedc32e5a1b86e85d75e6f0fa6733bc7e35a74b1dd8708b2f1aef1a54a7b4cacc4d4e42a13e73e38f67918962bafa804e04e54e05c6805e9dce46de2f8ea44b9e5db2c3afa463996cb07aca7e52890a20d7b6a0986b6990a24f1a0ccb7e95cbaceb7c79bf009149e6a3aa5f262e3398d01460c2b13ef6abb8ca9d9a2b9bbf9ab8e106ae6026f5a76599246d2c564ea3f0f4abbe6e756a048bb1f7f418ef0abb3d45faf12a2adf2fa378d23a8d472b79a0547f6c9c695831caa542b2a7b56c53162ab4043ab179652cdb19bf38d89e15d26a1fd918e71a50df50a576001c83edcf6d90d548ee709e501d5d240f715462e34dddcac288658cbb8a23b59f99c9da8ba4ebe6cb9c3f2e243c1aaf95ef2ec79faec87dbde7aaf96ebbe8345e775dac0824072becaf01e9b8dd4e09ca06c37fbb67237adbea68f2be4064d5d956d38d47cd1c34285c9e342677b27b7578ad2c4ac0ee1a5cfc5a324fa0266cd29124f2ed1a39d3b4fc8ddf0d714287907a1a173b3ddd85a54153a9dd8e545c295092ff57c09c8e48f88967e9228652ab8652a7c88fcf20cf5b7b4b6b9cc5edbf021befbd1afd977f807156f9b4daaff0757fcd3547d1a2e1cd0f3b6ac129610fc0658f10ac901cb858c57a7983b3383dc6c95ad131b2df284bbf00d137062f5759fff8601ce2a085018a6e13a40c2c3b881cb529a0f5a586985eb0861d228daeb39896c358ea0963563f103a898d506d5060a00bb26eb87fa5f2e5d2aba46d5578cc1e4bdf2068d380f075dd9fafe6a4cfe944045140de6a60c0afbb81419f9141f002c6276fe5b9fae4c9ec418b104ba888e25ef3fafa7758a485c60c5e25c1c73f59599f0d51f8fb8309e1e2e57f0b89cd1bd329d4c99261b2fb47ce84aed47d7d4368f39548f67ebbfbc9764169cb5bed3827eb96e3741f97d33abc5e85323a93015d5d1476a69d605867368a9aa293066f2bc3b49e4d2b96180907deaa3be60aeacfc2ad8b2f75789b1b7a884ec07b0cdaf3894eea60fcadec4bf07f8f425d7c23c4e68615f63965cd8af18cd2e870328d20311261223beb4325579a6cc8b1184ccc28a76cfe7336a97f82bde1c33a0a1c46b0aed656be2a068d2b37812803f1909fad2ca877c7fb48a19c255aa66c7c5f9713e53a92be92f582fc1460f3ff0bea0440401efc03428cd55373271801edaf4d04b1e3bfd835a9350dcb00fc5e93814ba871d79f5c0795bf7ac7d7e281b1d4545c81ae53be9539a2edc69e59e7478260171e26e47cdd3b5552e06e77473d7b551e947a284ec09024d0cd869566584811019f93df82aa82d478c7e54bd729bb1a4265cf6ad0ec0edd22ccdfb8e799603b9a1677b4a4647daf7c57c13717cea7174ccaf6b5de80486b0ac556aa2b7f47ca8ee4f929d596ecd1f0b1465fd0abbd02c15063e76460137f882f82df62e7ac867f52d0e1a7f7c1a0f6237f65fd77009d2d85c654ad2afa5a5b282b74f6966c88fcdadaf3f783c104dd8d72d56dee5533cac390a9733bab68de286131fa695de5aee1f44654dfbe4f2f33c51fade5073498918f429537a33e2feff507da879705af3cd2258f671a1bef8f3388667ebe72cb696943ae0e555294bbc4577ccad3373a46a3cad959242097a792e9902fd129a9750fb5a07bb3a0c9f9e6811a6f17fce2d3f6eafa7addc1e8780a56f1b72ccf6c9cc06658108a75bd094374ecd80de766cf850923a0226730aae839305dff707e33c1c01abc1fbb92e054835946e00b7794cff74e5ee1b1ef15db312a3b41adc934de91568b9ea077c63de1f7aeff71d08ccbe4e599fb0d6b2e5633de2bd058bb0f6449ae1298395b1025227bb4b59a32d098bd4facd39f0b4b25a045ff5467e2e6c6d6fabe1dce7c2ed6bc293e4f1caa8d264cd977156e6bf975f33d6485733929c33a96c9679a2bed6043ef0e59c3f30f48c032941c5ab41e4460743597b1c6281522ae5cd8b3cba1367d2d92fe05eb179ecefa08f16411b69414d9f23b642ffdcc02beb402a242f3b85730034455776103f6aabe0adb2159806db457ac8ed25f5e5df3c537272240d43c4cf3c44af2f785620f8edb4a00b2f7265638db720723031ebbaf705be1d13a3e101cde0542aba8817b687afeebc8f26d5be154cdd256d5509d630e3f09359ea63ee68c83414789a11a302126256dcb48d3ae15c6577aca5bf72fc8f233165ab37fa08ef1268f569d075d46ab1421562469f78c90e8b6e97a361f739aec5eeea695f9abab2c4360276907eac996b0297c85611031382620d6f2ce80cdeaa3e48adbf1ebab27d0ba36ce53f370f410bb8e9373855190b74a9b3ea82e0303d32175c0861684bc295943e19efbe93a51bcc5493a4c79e895f3bc4fc847bb374643c751fb11166f84dbf129052af4731e4d8e9d2c598afe72251e0a3d0ac420e5b3a34737a6e24610c436bdcc24b7a3c344316a8eec3ca79ef292cee6859296c301e354046242f255447e2ed63bf0d8a794e644f3f9037674e65b0bfec053c858634e6b56b64ef0659b850492bb4ea8908c2d28b65bc1a5f6e6026c9e2ef255675fa1d29d12aec7445d402ee363f59b0a242ddf80cebc1b0e0ea6495f6cdb2f4b1574350c71afcf160664a37db299bebbc61f95889767711a5be24f02193b2f39ca9bcba92e3c0b4c173d61ad600e734c32a5e47021cadb53e102fd98498ad98622397090ebdc9ff9022082611f8ee66cd52c7298ed1934126bbda94d733cfc17e9850ae646a33d124c8be7936595dc9014f6b8fd66c5407195bd9398573ec9fd79ebdef522495dd6c79f5e13bbde29b88fde67320f944bf25e99c96b9e117a69a7a2b258dc6ddb432c7099f271663176ca8272e0b9b1b1f766a19bce683b975d0641d623b28cecbc24cb166c66d76a4988ca1eea80d08d5cf05c91627e6a4137528cf467ca1312ce10fabd81e6f5646c47d51608309f6e0420b247cb356f240a2815bc1c9c9a7a89024f54f8ffd100eb2e487b64d510a5838e500586e97052839e434d726d43f61e10a6047967178628061798b1791b1e9604eb1a98425be8df5d781c1a9fe2cfc2be9fcdfdc72012c5178a05b5be926dcee9cf158c26e31802cf09661b1a49f242acdf3e3166295590663cdbec20974784aa91655b1cfc7dc830d7980027f69b9d235920fb0fca7cdb2a45325acd91dd39994edb5b1d42a7e54570650ab544c1fb9eefcd3e81b9871a1ffeee4520de7d510c4fe699ca6fd8d92f2e4b6a1c83931f9e6631a82107653cce52173ae11a83bf9ebc4c13f13e75e071c58732e7c239e6178e0bb59f4e602eca5c09d7bc2736b28922c9ae26ba509eb2e00f5458ac0d1d27a5b85799d3ab364c07daca367e8f729a75a79cc0e218ad2d2632908f75c5200ce29bf6960fdfccd6ebe9ae1421b8b3f9f448b420b7beb0e37b079c0522255404da18a5bd2b47b92d154bb05b32d7197796ade14a719ba5c06817644cdb583e929d76143eb23690a30a5510d051e98b343a1d321e26d071f15990532e65096cd45b807f387daf726fbca2ff67f445f03b02a4e51be88c144a2f2fbb34d98a36d09b4745ccaed44143041b47affdfbd18e548fcab64210948d45d403986f28205a61b9e082a0f852e9c7a6131180e5744f0d911b03e3e3d4b97ca13e72f820001f0aa7402f3f35534a6cf1e0b64d72f46919b23bc60fcb65b0a2b7241fee6a4af77a6f1197229597d4efd2571455e1e5bdc0706e9a2ad0bae743becfbeca6be780cb13fd86b980794d1f22b8d836b8fec26a484301ccbe112faa403448c115e6c038cd40195478127ec4116651d5f2073c8a9e0f62a82296af59ac50ecdc540f0336f0ec312aa2141292821463dbdb2bf1fbd26a995b88e9c7d8afea63e814ba8eac30d66f045afcc3d0480cf9006b7c9ab21458ded897d43ad8a4a1a64b42194d496135b25a0a994589ad58341ab028b5640632147c8ee0d8b8527f72278cdae30fcaf33852d2293af3a991174884fcaf3b890304dc5f5fd5bf65e7a070e9d892e8de8b882f15e6055d7491a46211a5e1814a4eb8b3f9c481c20e15c713ae7758ac42c9d3251f25001d4d4cdc8da02a3a11e6bb89e0af5e2d58f7345255a2a1c7005b5719a6f20da3af7db6be9990c7834041982e6f84b29e997244465f3e9ea7577fb8212d379e4de3e56fb9f342ce852db772e171e68b7eafffdb1f19435e6c07fa7a155fcaba53c32a6ae7334a911c90633cc312fe52a3b4d8b9fef4bb9698cf80848fa43e8e58defef372d265c1da150719c5a71ba48d7d94301f80a1c70ac351107b0421e0bb231995d5ae06a2b4c9774363d1389bb5ae00ef19f0fb84d895226781c825bc77c0e98d98e6779ae5a02d4188dbf8a8d14487346f93fe06b8bee68b90f63fb7c126c2f0a0902d144a18367b3e448900aedff639a335c776efd996dba7204f829840b3574680b061668c9a907dd1084c35b5fe773f7786ad0abe8113637c332aafc4e11c5c21648315d66cf5cd17e3e46715f8893390b165eb08fd0997e299f2a9ca9824f033768e2a05b9f8730fe0f8ee2cc3051cd944d91cd9c80f54b53398cddd5a25b95484285d239e510447d35351b6c65465e64b0e6a5ef25ab484f3ea03972d0a15c689b51100879cee2f20624c12a3c5eabae9d98a23ea650f0fe1427c2c1902b302307853b3d59b51b1fd8977ff56508ae986239a774c191603666e385654fc4f59c59024ba29cf6eb7d6b612b7ec48df58d4128fb696bb6c188b488d1ab4c6893f40eb31755846c2f222e4c57409cc374cc3413dd774f15d001467c034def84f2e686840d69173bdd5b90206c964075cdea197acae4024477fd194eed8c81f6c8ff57d8103e645ca8e7fb042641624e70cf89cced4e432dd4d734f400a99f25a5d32df8b72437d5c1631dd0a3069f7d32f5cb5be6d63aa08f5bf4b12c0ccf3a99c3067e94daa094d8ae55c72661ffbb444b524f1d41bb5245f3ad4b6a9af1538aeb01b13c95703dc76f8b3260ba69cb656d142d7a4e696ae307092f32b07db7c41ca1495028659cc90a124782a1887ea4303652465cc77420f15f3bc830e352069d10aea80ca8af37ec6f1217a90951a50f70759d0460b1bed9f4a504a2474f109035715e5563ede0f206bb01f4c36db7d537b1c633ba10f8563c744046b215959921b2b934a552ac0f9bb91e70d02661607980780de07b3cf36d2300598c56a675ad58c049de450b0f43fa721381b566a3c5cecd200b415abbcc8a47f1ce3997dd5a352412b518d56593db415bcdb922e40d208079b8ac657209638d922883d6fe0bbd42ca2f8eea64087c644559ea89f9b2d1e993298dde728a16e1ea09afeab9db4f458a40c936d71c882de2130f8092f203d4d5c0b4ab542b8e254d6f076650fddedd1479cc875050d8ad3db82480bb8f1f9fc8b86036407720ad6c9bf8da917605fd5ba3f19dc5eb9c7c116dc8a9fc61046c7e9dcd73469c306d82d3e0f7c78f3a789e1cbfd3c3a2f348f640a5d62d9fb0d295ea8be44b5ec2436c2bd3da16d63fff673a927902354bf7a2e82e9f4fd234b7356e543c7900494d726623ebd4f2c8e167964429cca6732b9c2fb4055e9cafd6128673a5aba6502cf6ac4bacbc915a6582c768c6671f6953ee8cc07c14e288c8f246cd81a5be922b9c0605c7b196ed7004132f5f05a22c47df54daa110182656f9e1b4e1db2f5e65cb7042aa255d4bf52d908216d0b73195abf389842a46e32e66d7be476ab9cefcfe356f79205b2557c28e2f8ea96d65d4e450ecbe32345239539dd4225eb074a316f97b54873fda588768ae9387fde7326aed1d6420960e6127a788a5fe9771eda4521a85086f0f7dc96535d96c3283ef9ce95778815500f79fece4e097da4397bd55dede0414c260fb4d67ea9395ea0a88598586803b93683a38f12d09ad21296903c766b45ccb62566003a9ebc6ef96d9e72c1b4d9a1d3349fc3fb86366da899c0eb417265bed3c60ff68a7cc64abef713c152711ba7c9b1c037752d97e6e6ad01e0a7c560d4b378487b44556f4f8d063a19e54457a177e83de3adcff24dd14d14eaea67da9032762a6d13ba90f92920a6821949c8ea063a30065bc9330cf19013c368b28ce89cd1768fa61ea8a3aa630986d31b5d8b485d8a56895f104e6f6b1b04853f0ae835e4a5e360736cf3fdaba21b33159463b37c1270c5f67c312f2a9be29377f1a3a5d4775ae3a4c0cff583516166e1aabafa7c11706746cd5c8ff2ef6228e8cfb943b67aca399ff874bf8176304e42e3308fabf556c1f0690c1c784bde50f38bd78965d17893ef5f38498a81065688a82f537e2495642bfc80bfea424ec4d0a78af1eee1cfe77638651edfbd68865755a28d16c5d43c94ad3414cbe6430c4aa15cf59e53a54f45deeb6c588dd8e7d68b976a49834e6a53b360c0218d8ec46e4e6d7302aa4c1373396785063ba039024aeb086429f0d76e35fe5cdcc32da642e3b6bb89ea9f82d70a5dd4955c4f9206e93b69186a5ce45cde4796fcc9805d64f9fb1888a091f82cb8060c143759cf4bec01cf24e38408bcd01089ce77b65aa92e74f08781939c7233f42aed2420a818baf6fe6422c403a8438cddd9c8b1cdc5341d65762338bf90c4cb2d87e05eacee8e9d5080e4f3c001bf3ef4dd7593a574254f1d802f998479f4e77f6d50c7e2196b1eeeb53082102a7ccb14719bb95c904e56c9eb94ddbaee06a5070fdd4cf80f39c5c487c39a631f8703adcaf5e5a93d8821af6bd1e0681e33174b7631862116fff7b2e6578e5f037ddf8b8674ce266b82e6775aab18a3d5d6b71a979949776b8d52ff9a194e7577e94636891b7db5d3354d5af969033685f2ef4ec6321779ba58803891717c20d5f4d2b63d2f93ac3be6e90797338d856f0c9ae58dbeba535beee423768d040115f19f2eeaaf70c11e1c8719f625cdf923eaa476c31d2af4743270c4e0a394a03ab2da9c7e36d485eff75deb1589d41d419d329dcb55f82ff5f9fb5700e505f1d51f06be3db35ea077c2efab73fd3933e32b337a01fc6e564d3b1527f54625c8863e427584bdef2530172840bac02eac2e0ae619cc0ffd906f56068be5264bd2a588e8ac7a9478d08e8900a289a7d561f99c3f871895aff4bad13495ad6a2034fa10c620ae21e9dbe085752ea3e3b8f8cb92bba6762e52ede05f3812c05760ab99eb71222d7e99e1deb96834f90267a25e5983d166b59c7c3bc730905817abdd6a1fd6a5f4a9a6e89e5dd8e79d992038aa25f1643e41da4a53e1867b68880cdc3ae999cf420efb74f4c8b26deb762e5d7f683c1d8a97db816aa66f74174b01a2f91a2b954eda0eecb88452bac06352a4fa5d220bf72b254c044bcec3e7abbcc2aa6c21fb1e903522bdc21b99c5b480ed2c65c8aa90b5c49e7250c0aef125bcaabcdd4d3ae2635da50d38b5c6916d22e4db2c8fafcb504d98a73150406c4fcdb02b87aa6c456df84ea8f55490f0ba3ca9aaf807fce7eff078027de07e4ed35c70b9ea9be46554bd18489dbbae864acc5d4885e5c1065177647313477adb0db58f1ea3b035abd797d459c0d60a1b67e35784e24b09f8e1baa599a6d921639dd98e09157799ebc325e1593bff04765b8a8db0f38fdbf27968c599e05dd09c26579a4ba03c4b712648d57647cab8878c87c0d02b6f34acbae752bf4d9bf8ceab397bb3701907328856253c52aa4b57825b14bdd8af81c9f8ebc78bff6070fde538f102f192f2a8dd789f345c7edabde291d7707b357550b63ef954888f19c45478f97947dc755721210ce28477f311109d9ee77ec598fb3a76fc960885f274c617f3c66c9efae38e7d8b41cd7c8d72956a5d1c655c43b24f287ed3cf39945e9ef8ac7e46665f8245f2b9d1175c58f3008e1f723fb313a58dad9603d1df7fcb4f481e8c5fb2f623046986fca0733d6569195f559e55d4f2a0b1daab2e7eaf36d3f278713e918f25bb950d226fe8b48568a858c14af82dcd5c00152423a08321e7502ded3270b4962e10cd75c66818592416b151b648f3e27aada524c2453ce6196fb6894addf5bd74be985b95eb5b798914ff9e24f72ec337e8bc2ff4f9dba7abe87319424a9b100fd9830d127371b8481c08d997447facca4dfbabc2c7b74a4db8e417544d6010235361e7bc80d11b39197365df9cc386ae2f61d9035e1eabd52263245507c7f2ee26b9d05a4dc629332ff4cdfd928cba200d0c8e3d4076455e6340c11c626d1c2a99b0153471995405e1583860de9710e3effca8673d776326a505f1c356b79de508d9b8926498bf312ead005acea98cb053a655de6a0dd8574e5b7e0ba14af27f4b468d168040a2ab3d21ddcd1c7f71e0e56aa4598e39f4469e9def220797c06b88a8a6fac9885d47b520e6ecf21d7d89fa0dae6334b552987c86d2cf5830fbbebb73ccb8cb224a6ce072941e84cae4917cf985a8432e79eb6e573ff283a308eb7a31f821b7ae3e1d6962a27465ef53236ded61c6a1305b98660455b2ff745f3d5ea38fb4cae21268e314ad44675d7fda30da48018b56c0adf61f1ad53eb0de9485b231ac18b326c31649f78e550fe29efae6dfa53d31ac8522ac879c7082e66f3ec98cb00f7299f4407ac7b85b13922e35c12ac150e14810decf5d95086264bce4f02d83ee8056bd0b66cdf88611b23f2f5f433a64310d81e1ce6998a56314865d20e09fc38382845d480962c28da622537303da16f70e980283fc2abf200aa03c185fb60852ae446fdfbaa34fc46214a158a77b3338cb04c06f1dbe2860c042f38e2b92dcc9b1819326ce34a8462b02807f197b2110e27e51386b04e51effa5d855f65dc19e45942a2f234b4b3f335a3c5f498750f8ad4db8bb7ea5b24f6d1e351e7c8b6efe8eb50e880de0532a8e7ac508fe43d8d53eb7a3e0741519e90a5990c81615a297d510f5d2169439ab8b870e2e5948d3ac9d8fcc79e83dc2062b2b25dc78fd0b0c30e9a8ab87e591fde62c33588616df4d41d0a2b0500f65a5bc8fd95acf1e171887b3e08c410ff683dc509babfcaa7beb899d64d23230ad1257921f9f140da28d1f7a6939fcd86fbc7af23044be8af555c20b42d4132c7bbb76bf916a39bc9d451d780f75669e8a18082e331ea90ea93d5037710fc41ad8f3bd2f09a5aae948f6201f65f792f1b666aad89e085d3dce06d6bca6639e59036fe22a8a4ded09832d5e9a27344f26988181d49df426cf880900895aaac4d99c5efc54d2485112999425c63aa641e10d62b6ed6d69c837bde86534dcfd688011741aad84f516e06bf20f344bc70bfb1b9635ef158aed0979e7630c38c1a09e7fca33278a17152ff18655b884f6c83477994932a3b951b88ef1271c603dcf7900ef0de766f448d7de3fdd7c8e3861fefe8cd50c3165d1246da7d92eae3042b73e8bfe083bd7ec5d1e183f4613345760a85a38540bc2bb7e3989c9b5b5f4b5f4ea31225eba13310bbf596dc8218473578b55ec59cb84914e4181fe672b3d9235679ccee3f67454930c672c012048dd0ff5c6789930923f88917e593d3297edc1813643912f31aa11d465f1890b28c269097000f74e341cf722d016073c4a3759a421bab47548aa31a0877883ead27335a3db41faff2026e05620b3df007adf0ec2dfa34d444a4ab592d856621c7be339cfbf72035ec6ebadc1d82c298af8098903a7e660258b5e4f4c29d0acf19a8784dc9c53b2ede1d1216bd41e5878dbc3e64ade2a6ad765e2cc4d318c5a0d124baa3598fd3eb1a450af33d77ecbf67737ec037afc642d085bc38caa7a09b6ad8ccd0c795eba3bfed82d34edbf192c273f450af8077cb165701437985f7d36ca1b12d72b92478e7a2fe3d08747940b5397757b5018a9f399f6fe383b056363b5157f4d813fb0e522381b54ff64807410f26216c5e7dc499f230f42a4c3cb27c51431010839b2b9c9cb8defa7dce91841dfcd0b97f81b1095ce4cacb8e885d8ad46addec628dd32b123b0ae45aa722d02648100b743cc65188690080d15f8ac06ab8a1d4f54ec933fe558db6efacd31fefeeedaf743bf4d26c8e4c2a73e82ffb194ca22f5e57695d1fe5c843527941a41043a2f45496e39b1690f5ecb3e3fcd8fc8102838dc215fbdf76866700cd2c5610e721ae10f809655545b9885ec8c1cfd659c2dc429e6e8b9ee010c936260017a5f5f66ac83e4d3f8cbb727050b6b2d7e866087a42d087a47e3642869f85a96fb8899f17bfc707ef95c70c27a03e1fc27a356e122b4f4b060810fd847296ee48c2b4142a04b78faf7b5bb4a1a702b45cdf5d67d3dec1c55ed9aa69222f18ef6d1f0f788561d0745842e7146351e6936de95ac48127379479c712ad97e9f3d13c4af09cb69676fbb9b4c7df7ec73cc6bc0125bf51d0290ea51dac021d376141749f10048875d02d36351e0b30acbe7b758166fd9d56556471adb66e3144e6f7f38cccc8ff9f980e49831db5aef5f5a08bc8f165c205124cac75179973dbd02a412d5f01dbfbdceb86708fb1b083fb6e91e6d9ed00c8504328d2bbed6b5bccb16ceba7419c0369c034d6fc7f7d7a809b68017ae37ca3f1d8dc1dc03bd14dbc43738c0cf6a03b546832a597d80bb5c03f2770694b6717706735ab9184d235824fe50d4d67edb1469379dac28df33c803f6dc0257efd6afb800ef1aebd16fed4a159b198f38b56085a139ccc991fa0414a7ff624bd9feedf9733a22ae72514462a3e038c26200eac93c2779036a1061e02c3782006f656477152699b2957e161e829916971be1f23e444f99285b849730a226b8ad05eedd1240bf6a8eb487e8d59856f305b7217e078d1dbc51a3b7cf6c7f9e459ccd68607b897f4a17a750ad526cdf67b8ba8993ce9a05b031d63999f35d3fe18ce8860c2dd05f3d8dfbaef58f177c6a353b56c27aa874b1d33ace79b3c646f21cb7ed00d8af27b9fbfda872231c0bad8713e6a7d47ef5419deacdd9ccf2994666a1c9fc1e413a8460498480023721593490d45d2656f3310a433afd8f6b4d4b6f166b0702876b4e8f596980ca889b7ea79ec08c68cd7fbe1c02bd63da310029744e77f8c13650949d5b4f83c6d663ccc37c23935d19d88b4eaab0e26b22c0ff66f2750f3a973c3f261c0220763be9d9e3fb229f95167e2851ae6ccbac7f8ddadaf9788f2ab893315527a3717bb49fe36313ae614064777abc639d583adfbea1427a554dd8aad16e3a8eaf5db8a8d80e299866acc79b54bf5c11610aa66e29ddbf021e16bb0fd8b1455a71bf59a17b68b0649b2a45173b641c890a0ec6689f3094eb80679b593fd8c00005042d000b4467607bf157880724a6ba0b032b9ec2c9c85a799e36dd2f8bc1cd6bea16a203a43cff6b386621ab9d210d460f599acbbe10152f0d0c944c186e1c55894212ef139a01d3a890c876cbbe7c6f4282fda51839cb62646de7732c913e94f12337bfed93935f5131c4ac098e35f815c0570a4aaa3b1f8818c875766547b87eff48c53a41ef3e7ecf046af1561367d596a95b8832a1fdf828dac5da11b4c8536d8b0b3be2f6980192c9b8ef5c03ffdc31b5759538009f50f562be2a0758e97127b5e1cf8aeb8b5b19d8e4cfe09b22a03eb9af7b99f335364b762840d24986c1eb24375e33c4af8231cc8b80216507622f38bc6b3c10e98fb3b7ac4dcf97ec8544943b90392c4eb2b357bd4d2afa3b3d5772146b5c2beb5c40474abe243118d5fa3b7381af0046c4281e7eedd5c41d9b10e54855074009fa15f326df2d7b95556dbceedad3aa4069eba490edf89c766ed718fd76cae12111d7032aa890d4c3ff7c9e332b8b6ceb3c9fe5770a29b6a4dfa854800a48f322cdccdff1830b25e7f536f7eb695794831143be7c110afceff5d4ad2c796cdec7a7b04cd5c7cacd740e5b54d12c42ca8d0054088073269a4c25066eb6e5d57145443423e061cdf55961721f5820391681240db69761327156618be1dee40a474e0f169703407aaaf6543f705f4451fc0a70e304e330f71b3d6172ca5db9b5bde96b9a516adedac1e68912123e38df40e63092ae2cc03048fb1af6bfd32fe160092ffd48eb00c4793b2cc7b673d6ca71cc1dd06f681b5dec053d5e243f3cb3c5702ebf7c9f3b3315df28788352f6426d062b9936cd8d7fa7780303eeb5858044a928361fff941e5f1b742ae15e119feda718b9d4414f1531745cc64213c5c9ae4b37fa5356ba17eb92a67123ce341af692d66e00ffb03959f21ef0368e64db490b90ade800baeb4cfff80a4a4e9da5067de5f05443029e3657697a4653d2a67d4326117d5d58d3b29e2c5f6c0485fd1fdcf0b99fdc1c66f7358747afc5612f5f78d6a44530dfec2a0cda1826d36221edaf37dcf4c1a3530d7a5088c81a0a4f44a422e45b6441e36d676274696d5b90d951bb6f43c375d1bb17068eac3a1dd6fe676cee12a650b5162a9a9e95dde2267bd98fdb6e56a4941f7b17723739ef49c6ae245705fa2f4aa5927daf390f91bd34af1f39399234ea50b525e34991818dac41dded5c3b4f760bfbc032af1f84dd9f8cc04768d506dfad3a3b0886011a2b7e1e462750b8cb9c6feb57e878a901d3414b6c02cb14314b654946b237b3a8c42c9038bb911b576520a8042ee0f82f673b2ce5a544886191987c2118ab3950e7fa4a6dd953675e84e243b968ac61834ad798d9b14ab6cfe053f4002a0b9a5b6d0e2ab7059f97a4a6943de1e51a892069ddb773db47e1a0b282d43864e9a7d6f2ac9fa717e0246adf36cb8320c4dc6eeddd8b4d304692c58797c8294924d7b5b644bb7c9ae7c257a70d24f020526ec930a9dde2534df48c6238724a06c66889ed409e10803dd5176802250631f52541fe1fea0d0a120b953a464ea79e271d40e845096594d9a982fc9109cf946aa0e319d4f03daa9563a580ad2726ced749043e17c05936a750a298057bb10b49d55a039bc580ac8cea87aa7be90a8fa8c49a63627561e1430405b3169131f59d0d355dc3fe1f00379fdebf9501b3567e6adf6100090e66d61108b93078ab26b6dd75054e111d3b37adb09b40054a3f120e781dd8e4fb45ac938b4ff0cfe70190fb39e274a8aa26ed5c882d97b18d018ee39753c827adf13333cd924b63994065977d0d1d7b985a18cd578b85c1c4cd647cb101c33c0edb9605a80ccf42a8e95d084648dd8497c96e0e8ebc5c304a2b0d2779576713f7b6a519877808045a1f0ad08089182bd6a1bd6f181a334ba7c95c137b2198dc4f104a43d4cc4e824b5e6a0b5b3074283d6f4c92ddf7ae18e1d7c1429871a672ba884b84101aee14052eb222e9245a8503a41800e21f128fe8ce1564eb88aef136bc3aea8f7e41a57234ea00d9bbf381b70d56875400f264a6f4a7d0b85742f708b068dd44529776ce1b265fbeb83c05d5f37f0834d3cb6b97ade5dca0bcd201d5049c6e648034fb4ac15b516ac7c3dabf2da826efa239f18809881bc48aa159f01759e4d74649c10308c1939bca7907d3c0678dd0e80506e74d40c9403e9e9248b1ecd3f64c19b1765d2b0acccbd6a04d213d8c746a8519672c8a9e45448e9d13e845066b4138ce48533c342af95b9a4fe0770003fbd10f7ede3f461a8beabece199fa55627710fac3716a4e9f6950c03ada12cf10765551de217aab7595222091bd6726e65af96ca6138aca41bcecd0b905964b5a0bca5e3a6b4c82c95f867e7f0fbaabfc0960be1c1436591d349dd9ca646518861c542d9167ea99eff343ffb8daa451487572f778d1f37a23a5301058936957b882fc010cc6900a6adf90df40063efa49ee674ed0e2ad034075bf0372cedded34ced32c1af4f14163371663ca54e467c5ef7d0f362122eb426eae041e886236f84cf65ca9b2ccc778186f60d7e6dd906afa291879b49b7167d23682ca4195c7c74e90f7f3118aff37c7c237950ebdca1baecf3dfb71bb2b2799549e6eeb68534d992e88ad291ba5e24b88f6cbc7f912afd747fd10e25cfe9ab98b57ca33c2aeda7414cdc5f32d18e241404d1061aa00b9fd39a7bd8e0325675b67fc8a33e69061ac1fbdda85d70cc477d9f77875c4a6744917b1769aedf769c161e79c63b156d4053b61122fc995b690833ba024114da7da207222f832282aa4e4f86c8f7a60a97b66b76c8a0958883253f2e6588bd88835199de8f0c31d7beac6b8262d22b2340384983f4f46cf6d8e803f696ae67328631dcb6d72247bdf30d71c9c3e85daa18717f6d68b07dd87d15384b7f7421395ca29de8b8225cfb5e5ff79c19c1144bb7bf3185e36019ac6ed2d854a7e3c1f260e79d2ad86e409767316e7403e5febe3ec203e966b087dd9e9b28e1fca65832daab528fab9397562f93c5fd7b6d8ea37a6f54bf44f150bc0361b1c27a856afecea48444a3653c75a7408060580fa471500e5f359a81a99bb1c33cef073a47cb45aae18ff2d11d7fb14cc6da1baac423cfc748b5d3ad525e96ace5d59c14275f4e61851e37f2f682f90b6309b0e56334be4a4b30388ddc9756aea76f7254d920ee6add999d1cf14f69cd5d7ea6fcbde514685d1aeff98d5b72d24159aafe7bc3d9b5ca31b2595262db4e364113b467acbc0f6057f1f9e57866400a4faf171618e1594f93b89c3e64353e089ebf902d65e0275a47e0553bd16f07848234c2d272588111a2d170d58efe3384ea9ec3acd47ef7f6e0f746cf14ec271bd95306f84dbce988f5112c954fcb6350ecb996ad26a5b2ccba8ca4b26f7f5c315e660009f631f94c39cc80053cb82a4c53aede6d421c8c16f01183d94203c0686890412e82f77ef744b94d89539a9d755f23efe87c9f2ecbc95bbc0250300f4938eeabb97df2062ff58845daa40161f006580e22e0458adc6a5533289f2dfb46b3200edd6f53291fb61a2fdb8a397dc7b22f0d906ffe0ea9bc64ce907bc6aee5d915e7aacef86a6d56256fea452a4d849e3c41b63fc3591084a311ce408b683e77777e65a82a1ecfd5b6a5290b4bb57cbe4ac53f3972df88c7d6984ede61510cf1f99fa0750b1addff989ebec947e0be09e44265b35cce48501dbd9c8e29db29780b920914cbe79be7d3a10fc91337388d796b694ca58eab842645be779bc95c8f37dd05046d5ca114e90d2941ec956d6463075e3f40ff64cf9a8d175d8e4147438455e8e4a4d5e9ec0d7d59c139d155eda8059b60936e78b0867ce09673ce8cf37a65da753c788de9aa2090e2d2f64601d3d6b095cb1cf81b8943d08a866cf96cc2215ace132b27fcd88eca3c76028aad316872fd87304c5e4e24a1de0dc91d7718f98487955d86beb57ee5febb86004cd5b4e7cec3fbf8f58591004f5b4803673cf5668744d941e184dc3835177378012f649e0a84da7fbac62482a2ef12a80ab82b43dd0cdd21f99e9a6d61e8270e5e17e35f10554c1cacbaa04b104f4a386599774c7b7272bcd8e0be9643569ada840d92943f5e02eb20ad5b0e986eeea388da360259445d77855ac33eeb19c79ec6fc8e3509aec55d1ee8d7938b0384142df33f18781ee9c0ede2459263de017b02316f120f3487c086b368279d792dbf172e2ab4481f37622b3972ea70daf3a93387c6edaa7718bc76f3fcd68c85a7d5ea4659c6cd64a549696f37c719dc24c24ae643ea9a9f2a506f3cf44301090bdb710e879097f0f6202648273c7ca9ca3dcb60e37402ce9bbd0aa73dd8f772c9d73211848b4bf8dc183733ea0ebfeca69dc880b0662451bc93f38f5d267c80d2a5bb44b819e640c90f8825c08e4851de955a6ccfad7c3900042e7e9f112d2075744efdf43dfae9a5e0f9961203da0af24e1cbb5f0fc78117a1fbcf27c294ef1579469748d3fbbdd8661df57c3a3608059ea239b5ca7d28aa8f33c7d9397d8e22b6ea7c6371409342557ae651c7991f6615463d97e907d14c7e4c21af964f7e95af7f95f1651470a873e7a6ff4fe8f2fe662ebd8fecd78479e8c1bea1065724047a54932e089bd4636580820fce97f0b023640388e061a4855b454645bfdae0986634de94706b61a1ac335cd279730ff45aa283ca485c5dd01414ec5f0a2d7eb1a1cdb037242fc73b9aa286bbbdb7fc7028678781abd8136487d23768505cb662a4736fe21fd5157fd04cd40aa7be044b88e132bfe144e2b24c7aa625fb74cd2a9db1243029e0154368601826c7ec512cc1dafbab53e5cff202701aec9e10e9d1c62d94c86812c18b51c24c7b3023ed3490b81b51e6960a9fc5ac7ddbc1de175f88cd94892b8ed30fe303f850fab412d25fcaec958f0a6438b8f1cf56bdb4836751feec4e824251a446d039fb3641f5423a32834fe3610113915c9e29685885a1c8eb01fa8f70b3de0066343bd6a2492e534436b03427360848f2f7d8b7f4234217077ba099013213dbfa29e75462b0d085c20c30ac977035157b28dc1974b6952f74937a06f27e78598b92adba47acec00a1adcaf4e07b69d4f4a84d9dcf32e52c0406d17146e24b1ec1eb712934c138531c555a1fdcbc1aa84a89c523f109f89b6529b6c3b524772ff7167b81966c25043d1874af1ff1dab4d91f1a1e60d3fc8bd6fab842ca74d884a18fc9ad62c07bead104380caae158ddfaf40af18cb4ddfab8a38913ee709b6670a2fe7a7023ad2f6e58e4d0a917637c47fd1f575866964045b27204721b1f31ebed6b43f78c48585fba3e5d784b792cf103939e0dfaca78e107659e23ebacd510414f9c0d60730e2413f202912182b601a720c2ddd9e3b2c83e066f6d8c64025c3007ce496aac05cf4efa0e5639afe28219664c3c77538697bf3c822220c363d55939b09be3558e4887033ce15e48c6197ff6cd0ab933c878520e5dc959678212a6d33fc7b58f149f04403bae8665c24fafc455587863ccbaae18abe1d3ca99b102592f0773dc69d9acf7eeb294a2bd57a861f73bcd70522f065b4951c77f2f92ff4f935360df819a85f2eea53a449df0eed77d28c695d85c3b49793565c7f353bd27e186edce9ce1041f55e89f972758731f6cca6b2ae9a854e7aced6b1d533395be5f2eda66a11a61815263cca8bf7f007c1dc7022c8dcad254bdfe0a0374075ffde8d487eca88cbc5ea326cc699d07ee02684e2733e68e16b01238a172ea914db0f93320969dc3be7cbe4ca08307759957e88c1ad10cb98b1e89f652ec13f076a91126ea053888c0a85031d1c5f7be7a6658e81fc926195cd5fab6bb0538f91a1790638195957e41dfb80c5f12802c17f38a32709d817dcf18fc0a16b777e7c64697a938557c21c1656e06dd5142f6f4e08baf514730f37b672a15a1619673263da3c83a62c7691363430a0d29857c88c32d187ebca1ccb2bc0e9cb467de24ea5d6b3e26b2627f6870058c3841a5d6a41d8d8581a9eca32757f2f2d12d8b691de39ddc0cbdb8a9fdb85dd1b02431c311da12ef3f17f7e53015ef29089ad5010b22f3c2215947988d8e5409ee1cda0ab4368046c02c3d4b23ea4296c721418156cd678a97d7a19e326b81400fcd55e57ddaea5b132d7c6beab5342c959255ad4d9d570150bc2fd23420ef9bad019ab6e38368fbd29693f96baa225c9792e2975c94badbb878953e9e39e142cded8d56e63639f7874ad3117baec48b4a12eed0e0b62d8b562c23f2f746eaa6cfbc4090439a6312d6fe82ca3e791cac883dd6c4cf524252037dad65bdf2d5c656ad25bf336803e31b8fd017d83d80825effd887186b74c20fe9c838d3ff6fe833efddc454164be05488916016bf29ce9f634bb22a466c5f1deace84803e2786a8f1c0c5e4d57af0446c91407b546cf9d57e5caf3b9f1350449cb1d78d77ecf5f72769f44465f0bbd5a4ce9badcfcb43e3859170605ba4bf9abc552dc27d7062b43f4898f15c8825885e327320486055546179ce2f5202a2a5edbb4850cbc04b83d533fad1451e51a6b5e6ef1aea9bb4ab6ca42d6075b4013a2cd8bfb44013f5b0e61f8f725057a87315be76b760f22744844e27110d69f166c818e781f31e878015e510cca5c2fd5242ee09d72d7a6dee8dc3fb71f38d4d2af7aa17ce138538202efc63b905d6d3a1045bb788b462163d26e11a59f7c3f47f5d43d504af75256e5ad9a997ed18af87657fd1569595f7921b829e7914034376877462d73fd4d00d03aa8f1c32a32736e142b4c9505759905a1685f3744d8466d3a3abaa4cb9040791803eb1a2f0a5d717a244c23fae40f0c3ad5204a30de4b6b9e31a288203f8cf021c362f718f5f266e146cae46bf451d218c04713e0f1a8f904e7d1214869184d57ad78b3ac2e6de19ba6c05e505f3ef0fbe64b66964e03a40ca541911ffadbe978e844c9ced4f4ddd56ce039d0aa1173108150b197e14ee2144ddf8c5d9f9f8a66bbeb3ea7831955abd0b8b4686fac176925bb458829111a739a2658e306f81a13b25a8d11135a91866c81e3df286bbe10ca708c480450e05c446e57d8d943563b6ef52a6c1bcc0eb9d633b50e9091c2bb6f46f9c68a79b75255b4f7cf76adf305671a4902b38232ea91315bdf17a64379ced54e28ba7e2cb7a4b09e11b138fa67dddb4a83ea531c69de1b5bd49cff86330097cfd310ffbad5d4e282095f8f72f9e8d7cc6fbe93efd9f2d743f163373d4b0f8549f7d89341dfb5163f08ce58dd9cc1538fbdfaee72ee441c7168a4ab66207fd3b332eb998cffe635196e500d1feb50b78a722b80f5640efcc77c74562bf3f87d1a162979e583bbfe6ed959d725061143599d6f35b7b034f611b12c00f510c1ad7cd38aee16bebdd08e4110b881603dd803d78ced04fa9d6aff0f70fcdd2c08621fcfcbd0590913d43d7aee2440c2eaf88360b126120c36d5aa721e8f7cefa57ce5b45f8c5a4a92a8e850aba51a9d851359269853e1f9e60de93df452e037ec19a4b7c2c5a0573d7711d70d48626db49f56959b18e2d491b098d41ffaa7029b9430de72667db811034ddbf5058e42f1b522b171738d9ce74534b69dffcfdbaa4bb98db65b215f23433b6c4e90233240e3d480e949b881d59245e735e51e0f6992b3572fde6670ad557f80b8a5e76551df365006ec5065abb4f0a000e1f4ba1d7991ae53279c98ab32d0f1d56aa70a5184e5bdff47983e3c69de4d401ead94dd74fa0db8e2e4044ee83f28035fa28e9dc25e4bc03069f2d282f8c116b928fbd9f0095054c551719ec7acb2c5093b8f053ee6b90725d0676efc17f3be6aeb36ce7c01313e0d8bacd9efed938b9dc46c1f36180dbc0537b737f37809253805d39ca920b75b3b3513f84aa22f2ad8e906dd4513cffd81b46f6fa17d66d002ed288e30a54bc224456f20639d4ab381f588538b850083aafd9f0e246a66580335a6b3b5fa4dcdf649f2b94c4287e516331cc21e10b43b9d8cd2804c6653c6a70c7c09e914e0b5fb1790b5cd3ae7520a90cd70262f692afa6611bf9234f470cedc432a2f7a8464b60cbf2e0ba069d0111d7eb9a18dca917e34a97d9822d5a4441de25cfc0d8c1255a2a32c8a6daa0703fcc110a4ef4942edbb81e4569771a476a8803d49c2c80aba5c38e37c8e8d381c12d8a127cd74c6137786a6a248f0e0ed26c5ebdc04738a1784594138b420c07c44681098a6b5a2da90bbf5dcb22b35a3b7e905ae68bfd4d76b4cf3db84c1b659f5dd66085852e3d192d021df2bb398cc8e578bddbe782711e42a9bb461729930a55344ad3995b3883adf55215982f3e1a4bb14ce806a4e1f4b7610b0073ee88b0913f6d89cdc68ed5520e3beedded502835841ed2dcba5f62d43063a1ac5004ad965cd5e34855af6d222cabbdf2e4fb98a3fc583e720c05a9261f5c36726069172b14ba6a6c2a26f9f2ced088ecbbf2629ffdbe75822b71d9266f5c1ca6374a38d5fa7613003de32be4143307a58819c0c2f1ceb13a881001befb4093acd43aae4af9ae1cb862e2dc19dbf9f62e370162803dcfbff4738fcddfd98292499c87589d597151e1c3e9f80b221c81a8315a7b68be7745b646758c6afdc612e38ed13f2dd13092818df967551761605fd11f1e76ac374353fc255cc2f3a5e4a666f79646c2662a1c2d97fa55854d612a3b31a17aded1377cd7c10852349bfb77dfb1f6645ede3962b90391ba8cb030fd51765960c66c1fcd6c79de50f52a29373159573773e5915b8da2d98a7f919842eeb419dd4860cfd90ee0f5d1ebf7e5fc7b7565cdce3439366e80b655fbd2b8ddecce5abca7b40135f2c7e876148a72fc95b7716359982efd4604970a1de28e13b39911f4cc43064d7e32ffe732a404b01d522698b1cb7009f0b3eb0236f147884c58962dce749fc0ed01099e9f79cc4758f3138a39712c0c745134d4ba50ac29f38fd23de7983bdfe653ae4e2f3f1c8fe79d2f3ee2a422fc9f19b55701981172f72a26a8b63a4f26f67f70a378e668943005ab383120116dae59187f39c50a089ddc24c579df1dd8d0b94b2ef378b084c00451221b36ac0107e06967bf35209b62ca5020f451af9fa2f8010e4f498489ef43616090ed482b92e2aaff1fc56daa9942d26e6d8d03a3a63698c7386d0169452dea714cb5f703fba0c83e70102e8a5a9a52288ee0211572997ad8a8f120aec821b2065b3ef09c3663c0f4e65cefba5d3842656425ac3e181cefe2bcc8a5590ded8da792dcc6a9fb3ffa9e8fe1379dcdbb8da3e054d441f4b3d0e4a127fa0ea6ad0aae06513acc06b1f1ffc363d4a8a268efc52ef637c6eaae4502234635f82e02e35d0b9c0cdf4272def0087344b1e9c89ea386e296bf39b018bf3b52152b1da96cc4f472589ed4d955d17e71fc13f6a711bf12bf816887de41206cedaea757af7667a30a85acd3015b2435a59dfad957121794c271929bd765eae081eed3084fd6d9d9b8918b39a6fde982d03189ee7a321c653083e665f703215991e136402cafa168a665019eb769f982bee7ed42a8a450b797e085f7dace64918ccf40aeb86f1ffd97630415d4b7a8e3110af70870229c1a79c4173a1d42fc516f44e0b0a3c664e252f9bff42ebafba4f435467a4dc9006574d811febcf5959f2688098a7655d72c2d44134dfcff25046b861bd62ca171bdddef6486b5fd5a067a0bbd11c9a9a5d5eb2cf1af0b901f26c4385b64b8772cb05b1ba12983315ff59b80f815baaf2c3634c5efa47bd599417d773ee788d90f95bdba5712282607056ecae898013a918b05c59ad0029a0184f914699b5b4d8e0f1d7728b5b45defa51e97656aef9812ed4c48fe8a598430ec88193a6be5977faacb4f64caf1c75a8241eac34549d42b484f4f513d10bd592ff5df4c6cf546a881310a5cff6db64a17d02c85ffbbf6b9c2d3aced138d46dfece756617be0119e31dc858b8d34dbf04132f5ba38e7e74de8acf8c5aab777d85deb1e2ef915ba74bfb86bb71fb67dcebd772cb09eb48037581486103c0d50bb09c51edb3790de9a1265cc03ebb3320adfd5db41ddd0bfbd75d95600fa53c24e9a1fcfd05ee7bf110ee2b49321864014cd2f986ddc935313fe0a77492542ad43aac261db27f224df464ffed8f1c4f142a4f5d0743c14690af0c039272f0dc0a49294149aa30985a1fad9933ee63af34a76227481c10dbb4a42db11887313666e3b358bfa2548e3a3a83f6de143c87f0a1c5613d2f8d7925f0d6cbfafb98a49a0c78638a08826b26f708e4e33fd06c149eaf550471156c75d029f1e11108caaa90fe72a7354d4409116ddc5d5224ca4c80152bd87672db5708c10a98eba1741f26ab03dddf288bca5cd71caea971c64aa87de5a852d802e92935d4914346f24ea53a24cdb8d3735ef6658cef79e0aecc16138b7edacfe6be35970c1d53afbe262433c9c7b65a25be3293d31a54e204cee444b2dbe71008f86559ce26f0e0a2ba151c45c67b24a2046906620b423a866f2a532d1e88369a7b337081c3dc1770dd6fb4ae2ff715bdc6e21a495d9474143d91462b1117fc2793d72f1e2c42efdf9d15b0373ce3e3493e21bbaf944bc49a735c2c8f3bed5b59e9830146c605e68c0cb772b904310a257f6d1f216e9b970450c69ae13dbe2d505c5b76c9a0da0c86171ef597144c55af775f18f28a7023db399273fcd2690ed785aef3b090b522fddff9ef4ed24a430efc2ba75cfc25f24ac5427a0e8c7c183a9b15053b0d0be01d3420c28eb83ffc34488687d6560ae7bbedc2aa16f8b2eeb8d5c051f080a4753f5f2b7a2e67f126feae8346231d694caa379a50fda4fffc46914cba6bd03eef973eebf462d5de92cec36a8e9b0835dcdc900ceb8ccb71112e9fbc91e4328bc356cf07ebd47f5474a227c624e18f1cf2a3a8c2db4d692a9857bb9e3f4936333b939f126f32d38c1198e20a9ea8870ece04aa047813eab4a97db5f766f7b22daff88f6cf4f3df5808f812d567bfc013b1accd71cf8548a6aa3ec2bc27d2aa17e6ce9e73ada0fd2b039d6261d376b21c88288bb0b598611af81384ffa36781aa045cb205900abffa13a3ee1aad8b22c977ebee6167f6303ccd3c55d938ca1410ea7be2d0ce6d04f3b7b53c849486c391b8ce0df4ef311bd3008da798aab9ff487172b899390d5d778638bcf7965cfbc67797a9276fbf4163ef301cd873d74f410f2dad93e7e39584ff392342d08d32904f6abcfe0d976b107a4fd4f7d45df5180b92f29a15e261a75544fed37764f926b2ee2c4830efe2c75bbccf33ffa6de2108042026fa057758c14e5b4c4987a81436d7cf97364d84543ab6938630a1bd52d3d444a2289e0e928c53ec15c5b1aeb71cf9817170c503c0e1b983e9cfab70e215540699b069a38589c3c16dbfda59108b392fd1c759a395c66255a6c01da2e07607a3aa57e99ca4b270704cb6c48ebe3526d25c1b7d4f99cdd2f6d9e46f558fa6e12b06658d77974620ad04045bc4bf654ee56a3a73afc0d22baea05ed26e7c436413be6f390b2c78a28458248f37326c88fecb2f95201b84462efea99d5a44ab9fb60c93ffed9a7e105cd7ec5dad32e8f6baedf2ee8b7e09877fac2f02866b6e4192b1f71365299f047bd44cd1b570c99b313be6aa7578119cc6982c8b0f1386482bb18d4a523f402facfa12f15d69c42d5d83163b0a698f51f6824aaad69e5c584f7287fa733167efdab4ffa44af1de05a284f9bbf49fe9303557529135d4153ce989d405170ccf099f7255b90ce4e9cfeb36975e9928e9b3c81e86f048280b1cc619a6cdec1b7d5c2ff04e5a3ca6a521918bf5b0477de3635cfa9fef3eb947f54d2b0ec95681a0edd552adacee93d1431b866cefd0b3decf904cad7853ec70e8798ef74f8b116e03da7f336cafac24bba5b623945900a227496ec6c24b17f3557db0183bb9e49993a0a88be583aa62d8d747b37282c84407a829163ab91d6d9d4596c92ad503c0f8c68c24daf8e01c26e551ddcf198d37ba8ed42ba866a7a721c506b1ecd33e4d8e3331b54a519c6eb62492255edbf78a713fcb47a74381cd9a26d6bbb4aefae5cafb1a83c65b3e88e1ea8099f262c8c10e7af3efa3cab16f4cc37af38facf1c9261399a86c147f7a8674d0e403cd80c7e07f59314e676c4c16a19ba64303a13f164b75ac24f60a324fddd57c5af17992f57480aa90dc4b8f172d03394961586d3537b92ca697e02c2a27737c8c29b02954bc82846ff2101f0e5c2e418d78983780dbc0210d23d9583a7d827c2e53f18a1d009fdd304cfbc5a4818dbf883939af5c12a85423893bdaa29b1d244777a5187ea12aed4ea6e4d517b210d4f1c903710d399a1641906962b14ce4189d507c70de84873e0594d0d9d141b95ad7fc22f8958061911fd185b34dc6ba2c9471a045b3807167d5a3807e04bee1d957761c32cab761be88a20c050f420cb966562a4461fa6ca2a7a54b9544dcc283ca6a3d367267b3f6b8a1c6e80d64e35bcc65a4eb3b6139d7db141288f1d5223966967cf183db12724cd21d116020cc9200b0ea1a6ce0c553e924679c2c9b43034ea960316b35535494167d243ca1d155da0d110cf042a52afee4ceedd5e839fcef43433e68c8ad4ff79a4b25b8570248fa6c536b18f6387702cbea55220d2474954ff9f27a1b32e95c2d02225fe393acc17cbb9b50a648062ad2d24be4cad5fd9e45e32d77c3a8c961728165e2e647c3569852038b24343c70f1031a639db4839bb1b444cb8d3d4167dc70154b72c35539b740fb7fc2cd99fd0d6454ac8c4786ba261e6c8aaf4de463a30372f6fa0f2e6fc0a7c50e03eddfc883a30e9b3196959159f9aa05291d92c7aa6dcbc21603f7dc4878ca3f182b86ccad6f0a083e465253ca58e4b9477a87b28454d1e71443ab189b4b2b79b85ac83fad8ecdf2ecafe1660034c1f67e6cd86ef5c8a052477e2ee8d6b417463a68fc069aa8b218e7d2ca9f6d7edefc0567ea56c348dadc6350d4121d7247fbd927a406312e8524811dc88899182c73866017c54309d56988d8bb8e8f03fd2d1744e636e047854ecd29533262517c4332afafcf2db870b2efe11372182e6f6f5e5ffc02792b86c9f531530b38bc22a6b671c7b778bb744b61c6a4f19ff619c260b231f9e2adc2ca781333c18d1f1dfcffbf52022fcd05d500427ba9a648ca12a3ff95ef210786875b82e0950c4dc805e4a0a73cc66c16b8c3c4f0066c333dd06b2db8b016db2fb811ab0d60bd9007e92bb20f13f7a3b2a1e1079accb57220f4f5e93895accab17f8f0dcf71efbbec1c4bf02158dd8c58edd377cdff0621c6b45a6dac58deb95543a0143f7cffa6297af92ce81b1a23e0aaf13e9a3f6cde68eeb3d3571812e208383d8f6f505616b86a506183e493db9805cdd3c97a77da7a2d33d1f4d3cae591a4f7188c05087d4426a0bcf178c4246a4115006c95a075fe8ff12adfbaabcc050a5080b1b090fc92ae738a684446dd4173d21677676619242313cea6c90ddb102330cf9191e15b399259f82827b06a943d02ee941d6f46777aacd89a8cdffc25581bca082800d5738017f94c770b5fc19ac4716c0f5a0fd3cbd928b836966330d9af7745ed6dbd0872c5bc4c6a05d54ee5d880243faa7e5917fa06031392a64bdd7bda6d3a7540a0668c3a0575e0f647bdd4631cf3d1a24a6a9c4c5059226c75cbac0e03cc0b203437b37e59159ff0e0d53e7e540698c83ee1835af433e54d377087e7eaef2fcf7da5eae0e510b315be9158c01376089cb9b163c4d3f36ba4edef89a73e6cc8ccbcbd4f1e7685a006edf1f08fc21a349865528173474e928fccdaa56ab0ad2be0e13bd4b147787f1771b7f962b5d32c5ac5e4a88f796abb630200dad9647600b0d284dd16009f013e24075e15117ad83eb781c2cd72a16e527644dffb140b6cb209c3cf28128c7887c3b410abe8e17ef8f5053bcbf699d01b1b94bd837f1b2233fdf410855f950fa358bb516d747a6af9901f3a0cd0d3cc1a0ad7a0ef89135865f53d955a289d429bfaca13b34c968790c3065f5022258f2c85d366ec57e12cb76a1af464aebfa4e034a28d2021b246730aced429d99b6e4da1e2cfc85a7a76fe95aebda95832932d4fbcbe301fdd9e677d533d377279437f1a2402a69eea7ade65c7e0363ec03c40bed9e13e1207350deb0bcd6d885c893b7e51045db7c56174c031ae863aa5beab4f10bf6a3ba1593ac8d313d3c96a2ab3df76a5f985375ddb9c339efe95bddb2529961039af20b981aba0cefef979190b0b5ad2405c0b72dad55aff796c19353c0b9218d3a1e2462ffa17158e407cbe296bf05a89c68d99af1bf143f73f28b42eb69cf0fdf85a18d2d3aee711f12278d505d09d023bcec49fab73a07d19644bae3c2391029e34e36eeb0d7846a8f38d1c05b06912b02c935411a4d6ba470baaba7dd1ce1f1598080d2809d49cbac25c53e7c5447eb46680c79106aad5d8b0ae07358efb75adcdd078d7ccffbffcf595fe986e60cd409623fe12b6e38a0ef39c0e82f06ee3fd7fa452f295787356ca03366108ff8dd23c1692acaf94f3e066496b6eb74557e75a2e2e2456b4156303cf8260aadf3c85a410facf3a16b6c78f143639614656ec170354e864a84da092bc8a2d0386a8b8161c49b222b04eeaf87207694be4b6cd79dc09ec0a79863f1a0a59520e56c8f7d1d07d8cac72596b585d1e75f98552a13cd0d6c21ae7951c7be5806329eae4ef8385b68f6923ce4298f6ed94a8a0efd51e87fe3c3e3fe3f278aad9c802769432dca81dde2112fd535cc76e9a22e960c8e3f1ca91e73299e56bb3ea5b9283294e905cca079b635127a212db6d185932db7500e1bca487f08b6b1ecc5d2622df582ba1a34b712697d639849591e325d2edd8b6765c454e0cc9c91f1ea7b76399f3593a544081e37fb6792e41f92cf282797207f81e86c1645612317bba416c89c6f79bafd32a3555b147daa582610b4c8bfca99e11254b89d7e478109b59d433d8c8903b8063bd42b9b80a95ce79008378a2d110d0ca8df9bfd59c57699d0ee8ad2a4eff402a8e26d8419041ad61c9bf18ea3995e03e3ba4aa6ddac656881d1de6326f52a79a8b03efc09061833bf23041221dc295787bc83f932cc4bfbe616474e99beb843a80837dab339e982390d37c03f0216228e516478de8f9726af868bcb211ace9ca1e140d247237f66a87a4b3c8c6284a01caa619efade8d99ac94bded2069056d99544785303cd39f680c4357c5d754632890f3f0c4f9bc03a5b099ad897b031e6c70ffcb746e3b63f55703cbee484831411891d72ac2df8be56f9d1da108a901d68ad876b385efd741afd67258ba1fee368bb473e86efb570081382819a1bc33a629ff331eb128df763e9e23349d689bb9014edaede20b66c97b90c6b55890e80628c89d7a3e44a854af99cb93cb8edc82b325ede7762e5784e47e7c17f1913ce84c743327b1963645f79ed846006b68bc7ada283dfe047004981becd182d155fd4804c958a8286637b33110c43d65dc30a47cbfb06216be14b88fe632f43f4128057aa5162577830e3498242f6099a133d9ae37db9aa53258bd430f426e2e9a61636440287568c724887c77470e032cf5c5f6855b98a85e726282f3028ea315ee99b89f10bc56308a897421bcd959eba3594727d4a0c1ca6298183eb0fe827e6bc5a286ec363f38df9258b280d54bfee5a0e7d03865eb9008a66349a2afb83461e9b4b35eb38206eb4d7c28598ba48a7b838cd836a06702e0dcf7715506ac5052ca72cce8bca26597049d9c6cffa0677653f4d66a21866626df7b6e77bf59624747f026ab144101f9cccc9c816d117acc1d9d128dd0518f0c41c315e1011377262e1bc470f6e3ea66697488a21dc329feb2097330cb0f1386b2f3e0f8885e44f553826720a5e8424284c49a9dfa62a69f520a358841a1c22b6c1ca32ec1bc100e28833c4185398bedc1c89d09e391cfb127d2bce8011571e531b31d86b3ab676a5159a625473c8490ca72951d4cdfafe6faaddfe3a7c9eddad22dcceb0c88a12e491ae79e1b7793991255491ca615d53c48ab0c2e42e7be9cd36e01b3e3c25a1f12863140eb7da62a657db0b8b585cea934a04a1d2c4a0c3b19230cb651b2401d5bc5e6375e0ed7da47ce383e56289826052fd1cf3b2f45318f7f568ce94486b26b99154493e83a3fdf6c1cbba4cd89d30960a4a90c567a51962e75599de3c280116f5bef5d8f7ffafd137e854bd00c50c94fcf57067faa392057d24c12d12fbc6b26234639f93af6bd9a5dd6f5067b0772cd56cebfec12fc181c7892bcaa58fda93ba234454afcb7d50edb7410866713c28270001503a11d926851a2eb6d7e5802c2bea16bc5f95bdf8a1de9108c5ee56f865e4cc2d41cf37e43382789cced317fbffdb93b84934dc26d885df5fce787865572bc6dd6618b010f4eeb8151ae60471930255f31ad3c80fa5ef728d0d96abf6b3de0ebdfa1e8021b465c29b5def7ed96c2d484b4f181a974da0ec37dda06a09895a936ada74dddbb678a90e2c7cb773d5a624e8ba21bc7306dff57ada5c7fe15204db53d0fa06de02a8315f51a6506b5299de00ebb94eb2ab9b8de9b0cc654c2f72b0cba630038de1381087b5041869966ef17adee09d31b7b764fb83ec0868f87ac8e8b9d6c755df8bbdcb354ff7f721984d4b66dd0bf29ef532ef2552111a1716887558331cc6d1b92984325484f7da5b058842f4a12ed1903e1c7e7ad4db4f6f6d2cd8990854ff67962fae831f6400f3b547ad32c5d057fd3d96fea66e8cf11f5b422441f826e832c396cbeaf725a1f5f0e65a3408e3735d033c7506e53c668f76bef32d163e227377caaeee700cde44de0dfd6142f75c9d380e52277bb4f10b4783ecdb0c4fdc990741ce9af9ce75a1971a512dd4e9dca80b7ca40dbefb2f1d37f49c1c351cc6f83e4c2825b87d7a4962cb3bb64e9a95186b09acfa50b84ca91a24c78b6e437712824ce1f6f99d4e68a926fd8f1bd061930286a234a26cf4068bdacd089fc28569520ee00ff56eb6af110a5f27860d1722d31f36568af9e5690c9c029557825b21047ab5ffe975d71f0f11c5f620d29c816008dee1fb3bf88415dbd45d9c5dacc462b4070dfb68dc70b2db1fc6e9e5d3158f9b3d8609a6a66a29273392572a87ecf4e93329575576eb1c4cc1a93e9d3a70c777d6909cae6908614fb4d4a709e07c03deaa384d3a156cfe663e3e1e75b82cb8e7d6778cdd251a6879a6a886d7469123e0d7a07fe5f040fee30699b8806f502d6a1509e00c0efdcc5cddefdffce9c7abbea1e27e84407f87e9c12f29534e572084d5addb00180c2d2d52275b11226fde0adb7a714af3f91dc3986cb3f2fb16bda45b6e84bd0000147e6603f258ef278861abbdcea70d0c069d17aae4169ae19129486026855968c65e71579f6b0933584278009156730afdd8df14709c23f0773480b608270d2991fed42e00982ca34bbf8481c7415f7355f9d226696e2963a5b63798b63d083ffa8eaa93c0efc8935d5d15e16ce3e27ee75c1707a2b79f7aa7f6d6a94af7f39dd67b41c82ce54dbcb67edc4156326e665daa9392364fe7b3b518defb9d1362513fe04a9f6e175391a08cb49c744646b02afdf0a4d5303b8d974259608de0e6d89e7d1746f536e814a92f2212c0edd7f289c6e6a7a9a242cf77e2c6b63fa697f6c94a84f1c54f4e57cc71fcec9e8a4b670ba02eed3e70eb6479c5b5a8be26c3432e94ef9548a16f412a66c79da2252e322f1eadb2bd2cbec6e1b6a3ced9a7e121bec25d466f403a704a5c7b8c4be02b2062159f78443866534e9f8208ca02297c87f1f9e6344cfd1e0c5f55f696602a704cbc4e154e6a8f06a637acbb2b926c03104a50cefde655b784517a5080dfc4bdd6d4f2c34d6fe1673a95e03181ed20b38db2c22c33df4493e853d042d4c1b76ab13e9f102812cead29d0612b0cb67f1b9c2eb0a3004b5a3a2615461875387ebbbffdbb5881696ff93bf384d2e55a2a5570565795e720b3f5c12f4cd13af6fc5c9f2c1cd4c54155576d9fc95ec9ee88694bdfe5b6db56921563c2528c70ed80cb679d72be568ef6c01d8e70dadd0b4c898b4063684dc8a4051348ab4b63bcf5a7452cfdd644d8ee2657022d2cc233e6df203729ec47f734b53b403b6c7a36d37c1f90e784aadcd32aaefa718503bb40bf150415cc3debd56c1298a940d1dfc05a2ba051f8d2fc4f7d75a70fc9f79e65747c9b07ba27c2e549a93bd7ba9fb842914416a46023e49b0f6460cfa3619bc9ac8e21a6efc389bb675d95ff094e7228ee92e8ee3d8e76b2a0e12cb0a3836a2ec6273ab294e9daa490c4e43ffec1b9cc4feb7809adfc0deaf2c0faeece7410990b3516ae0ce7f5e537cd0e149337cc00756a3793a63af540acc91eea94093f1c32117b7a3f5e82ae5b5203d4c5f480ea827a2fe6e34fe1ef5ee698cadeb43718f1947013dca5637000386ea4c012458b06eb0d7086e3796114a53aeb7c60ec855aa79fa4e5ca92cd64fc3824572d243a15cc225d188bfe8b3ecded36f897bc5fa102da6d9bf5cc53df81f519428835d4484d02d76a8fca066492699acbbc8dad55746f141f65d4b63b0d70c4a40ff23bb2053e6f1839f48189f88e38e301c78bb3f08c4c7c4eaaf09d4f7fde7e54c30eddd9f20020e5a08981b26acb846a8674ea3f87ea647289ec39129a9c74035f6a2f91f28ba005f5ff5d4b8df06d4e810d1db45852e29ff245e853a3e2afda17aa795e36c72d3388ac6c30baebf578dbf5459813e8d64aade2a40015b7b2f13231a7e32a90edccaf814d7c73ace96e899b756c061f59cc85a72e0abfdc673718095f8ed3df88068d2f779ff9487929f06182394d14864eec2a46c6f2213b510ef24b217b815e72c04319e670246cb4f0394376d8aad2a5ace030ecb19f71b1c8e121d9528b53c86ccccbc8616a26a82e6d16057a348c4f7c6035ee9caf273a88d5caf37405c9d49ca48a98127206f3d237ab3f7f27abd6f756263bf54080f89a116710f597b7ea6a9b6ceb8c7af08ecc777bbb31c04ad902c412b3b76b04c1c5bc71eee3156790d7fb6537b55cda05dd82b84da42a688f63847d21cfd7b4cfad5c907bc27055e3e5d994c002d860edc46d11c1c2dcc718f346eb406f4fe882115a9ff85d02f9dec15fb47bd95c1f2f77543f514b8778af4e58008d8501a5215162ed9a74b9e71d24aedf57676d5dc4f9e4380bf66de6dac55868800792cb28fed53c54014a44cd0cd775e00706f972569f292dc30669cd7787f165fc6b44d6b0bd38a2d7ebfeb7f9e536aee4c71586642300ddfd9c9a274f2eab81359abdcf4633b8d82a67ddb0784bda7fafb2b3b22e932517dedc0b2db8b1ee6365b053cebead1eef1adc91f2ddad52e603323f881410fd601aba630dc2d9e8e0bb57cfa4f06cb0c19a478ee9b2d983d78ab0061dac6dbc04f915fcd09a86a152f43dd850bf9826cf1df1d3965b2e363de078cf344e3dc7fd3cd5ed2c409c3073831db59672fb92a780018b0060be335d125b3c3ed1656ff0341b747e6661935d9955c4ceb7eb88040f7571d086bb2ae86e94982ed10137199dce0f16d6101ea47aa691b40fed1c95f668509d1523a8f789672e70230ce6390f03ff52df30548e5a7234f83e68da16dcae98584fe856392beb823331aec2a5dd000bb6b01458d010b0a67f3fa5f3045312a69106ce59f9f392ad8698bced40c97154fe9bb6c3c5e33c798bf4409e293910beaffd27d6692f940ab4d01995c1e1bc3b3135ffbdc0e80de4c924c68dd79e361a790cd02599b0adf9e221bd52accadc274bcb04a6e7c2756c76a9108bb5551a6bf53b02b75e6a7136df53c1fa76c6322fb47cc5c343e75a951db4c08316d4922b5ab42ddcca26c4ea64d9ca654a6503258ae0f1f3b3c61a1e67f0cc0fc522165c2da4d2371d059a745a278fdb08dc4a13dc8b8bace9f1202d110f3c791f5352e9ef138060efd887a35c8b3bf83630149ed29ee4e7d6dd98d056689fd5d7e85a75ac1c8eedc7bfd887b94927251556b266d4ade8951930e6774b2cd4125c1a3a8fdfaa48e46e0775abe8870337519bfb0a665c5f6cab0cb990e091545ffafc7d136fe3f329e1680877e7c613cc155ca19a2afced736d4d384b2d2074674b77de1666f2804de1343e2c2399f15e10f09b3c0f2b889c671bf72f3a886b4fc393a57963fb144591ca7c62e7f4e3513f0de77b869e1d3f31426c19de16dbb02618fe623ec0e90ea80e569afd91f6989c89ec24c4cedd0d4ff89a646f4e3cf9d1c762966623433ec87589bcbd927e2c46024391de426d80154d1441357df50d083fa0f4cc11fc6d31738dcc1f92cbdf399cc74e2c7ee63e5d002c49e69587a9db85d33a010c4ce877821bca14902f0ea77f7b7dee9d2a5f88d09e618284bf2b22316c781c02cd32f414dbca6da4971bb1ff427dc6c14d8f0f12fff4644aa833d3f10cc47db8736adaa60180de3a655aeb439c5c56f391294b3db0e26cf9c82416b4df2e9344556b0f6e359b7a549e6475eae067f32971ea2fa62716c506e25c415362271e1d3351b8d0fe14ee1300bd088890b62aa0f6ba0f598a1d5b10c4bdba49e5cbbbd5928cdd04a921497b18a5aa12c102580b429f5c21c2086bf4bb1ce4ea029f8858044173a16fae4b5bb99e416f0446ba27426089561c02648859f850dbabe7bf87c11e1e02a8c47bfea66f195e1ff4ac7065346571e5e469a968a39659abb5fc8211238d87441a9f58f0c406c66bd4236b478889eeee060ea0dcf98ebf4ad2f820dd447960fc511e2f27f8022cdb45f293db083053fcca6806827fbd3440f2a97177dc7b8f24601037f65f1835ded3917999b9c7f66c8db2e821cefaeb30607c46117e1db92dd5f4ca68a8f7a227dea8da95bee4b7fda60e322062f3d5f3b2abc27235690215a65ad4770f255d5b55e1d2605e879125943069ba59476c0fbcea9f37976ab0e03a8a40662d000a025d529f6083cd016868688a0580216609063bdf59bd33862d99aac4492d67ede9c7919356b3289d4a1136be0744c8aa001cbf6d05595b04f291dbec4c9c1f97d3ec0162df9acd2ae2bea13d88c1f5c5abc0da3c5859c1ceb354794cd1a6ff3de874ea26ff44e9aec87b16985b87e4c779f2c7cbf4bfe32c3ec8dad04bc94190570d8b0c1b2c80e4a620e0431b93e1ace568949e0bcef51e318170d13695334e7d59535a801b8e4d6d5500963c53aeeedcf8343ce66db2982c48cc9cc0bc0b0c3c8bd1b3e5334a3802823ce4e99177f4b2acfdca65668bdb3c4ada096f822963adcc34a6345a6430eeba9c06c79defe4d793cf6924edc91b61230474d8ff48e758c9fcdbc83b85858000777840811dc43c368b37ca3cc8fccb8c4adc0e1045a8ddcbf844d53e4e8c3d466766493334b935a327ac0f626fc72d16d53712c6efb65183e03c6a1c279c158c46bfa5f9b7dc8dd851a6d1298b87f5d6d7a9b10b10ee81fd239c1ac84177ea5cdabc1a99e7c975ed21cb044de6fedc70dc27a572db9b9d918a9193e5951dd278d5d85d7b3cb4d6a7414e95391e8985521938c77a4fd4cfb3bd0368c9039c7478033fba9e59346fb18f9625d4b00fb8d671cb71345e913c7cbb47a248ded39e74a6d55a9b7235a3b10b667956b2819c39124de57800e63873062efa8d57975faab69ac48438f359f8d1c36da5060e6f27b8f2eda126fb3d3b15aad1b2e9bdf81fd33699a7db548d576e6302e983ca015508b30b5300fb32cfe4880bf72fa8586fc69d4b33a7a2e6c6dac3313f6c1ce727c8c138368ebfb66cade1b4f3b7515754428f8db83928af6ef5afac3a22ed37a3fcf03b2d114e3dbadd9caba28e5b870eb071c2b08a8189211ae56346e17ef118fe9212a5953fdd1183873c648cf29146ddfb45edcce851dbe958373008ee84201991971b5caf0b70c104b5d7807fd53d05a907906cc3b1f8676607a42d4b711e9e6cd61720ea1b9e4483f339d618de320845660a5668692743df4d13caf4e744c62467835bca71e8c1ab52413e4238d5b7f95fbcc60cd44118dfbaee9728967378a8948b902f2121c101e3cc2ebacb312832bc19523a76ad55dccf33c9a37bf02906a26d42500534e0aee3f611a7623e414893d88b5ec8c0e31c03d73da9732d87db9fff566e881be20d7be6f2351fcb5d21f3a8f01b23f6e23bc620a4c7dd9d3a7d2997fe8738b5de9bc2e0f554000e274e6dc826e2e82e1e46d851232cfc9b9bb7b098707922705a87ef58742ae7acd0200af1643c2cdf1fcde8e061a183e104bab3ce35856bbe10a9c6d4b31f5f65af019997412c5c86a65e51e5f38989048b5cac770bbed768f50e1459fdc62fadcf897f56377768fd6c328257a3239bd7059e2d8f69e7eb3b74158691ac5e332e84111b03b7196030249559f97d2e52e2192ccedfe733c802a332a3ca450555429b89b1903e1714287c2bfdc661f775936ba4633b6b6571334422d5bc77e8fb72d5d0c2118d824cd9b9c0b97f0549b0259961fadecbb7f670421277a0bb47fb52123d7cf9247fa77a07103a1c01061d742cc4f9c883b4b92819751a3568ad544119cdb28316d21e21b0f2bf08f61ef5c236dfc38960a5918cdc0576f521160039e69cc61b91db618bd402118aa07c5ae47486af3c1702e3ea7000c2096b2ff01c39bdd5a2b6e9987562f4fb1e666c4ca1cd312fcbe5be2c21cbfe892dfef51192a81a7edaf48e750b33b301881bcda219fe5d7f4b3834009595ea36c8f73beff9dadfc81219195bbd4dd7388756817b9dc505203b4dca018a8fdf1fd9d4dfa6fbd5311c951ea0feb9ad82193e5749e406dd4a807083e4dd68f08384a3fd124ecd9ed8f1f56905c841a8bba2e23e7288aa2b86fb5f1393c56850fbcb5b1fd8cf5ac23bc2d6df8c13d63e493b64d3464c42085026669cf71c0be2373238aba71e5b8422aa0648e23d73ed850a8d05efb78b04ef954f9b966b7a2aa87e74eb2aacf21769dee2d917aa8dad17ef0ecf6c1a1937f19c03ac42edb50cff18b743a12d8b6942f61f47961ed5a3fd648824959d494966ae0a0a67911340675c07903858335352bf3f72a3405c962370b2160d3711a46740c9fa8a5af0c7fc6fd457c714c0bbe5728fd710498fc928f792bf0023c0e92e01a54a9212b26aa22d47bbe69a0a0de8c54141d5d0bb5d7fba2e93591daba6131c82fa22d6c0e828a0e89ea7b396a8bbf7cfc19522ff85573c1e5f66c42f3757f32fdd7e6362a6599108c1f362455761e41590b2da7c68471c9f73d1ad3bb74a670ab3547be4caa21d54611fe35752368b955c1ef72b0454496d81e0995296cd556a8fd71e338fb2f99aeb365b71201afcf7c0acc9302e61e96fc303cfea9734262d5da6588dd179e4e1ef98c2b3f98ee119af2cdbf1da1f471ee40154be17f8f10103e23b3002e1181711b1365a8d3441f22dc44a64be5e67e8398b10bcb932fd27ca5df8c792af8e538eecb7890511b306f4de598900ec0b4d7fd9f4b6444852c2870ef6dd18ce55825cf176c465b02784c34cf399d47105276c6292c0fa39d5630bf06e748a6a778b052f24df1a13357b36424927fcb521e84ca667cb9754ae52cf4598a06f68a68a6a202a7d08c19a5ab30619cef3fbf86f87bc0da0e87f7cd646b81c59096daf8069d8a1b5583f513570bb702a3b115fab13527a5d6feef3e9a6a32b4107f93953ee52337c6784db0eea823e857e8be567e1483e79a88ac8ab2060b83fdd34f5a62c60560423e919ce56802ad8c8779844969129b071518a5cb35f4b0c4492807f59c9d2cb3f560510e27183c5286bc79247251ee9a795758cb4c92b58e75c10334352f7a53cd1d6bf0cffb2051b91ea01f196dff8f434fe44b9e15fbb6cfc33257e2c1b3787c6ce741ac58de0cf772c613d9a6eac4ff42bb1a27a612a03a447b19c7d39a9deaebb29bf35c88d29001f14d21411c9623b2b78a4613b24f8cdc13399d268192707565c7c85bc7e4b5f97e90ecaf27bda8c6cfc67d9bdb0fde82f504a6837d9c352532d1c19aec40473ac3b5627eda2a5c55409895fe8ac2a13455b47cc4e831d0b13d2c8ceabe082344421ae2d850b0b9b016e489d957f13f4fae4549c781df8550602fc534dc3abefa62dd16aeec3d1d36ab4e9b5c0c76418dc8cc2e38cef8cf0b19b93e2d85d862b8ad77d3e65c72949e8b507b7b8d47c3b290b45a5f5a2c758031f1d05718b6b56131b1114ca210a9b60d5d7501a480b06b402b92fa83fde7e27cf9cf47754f37318b1b615d609835d99076121c03cfc3996d66617f112673d44946f15139954672ed3dd2bfa4a3897b5718b0c9c2986e2174de24954e9c05909dfdf157783e45b7cf0a16268d062a156858780319948cfb259ad662167a2b23b7182561b2f89fcd9ecb7e21e252ed426298023e5d34b772eff5bd2a9c5364434a4242113e18ea3ec1d29f0f246d9fcc146ac00b7a81f921e03c3e9a31c7636cb34ef6ec55cac707ec22ea5fe63b67987910fdc3455c46570a95cbf1abd27567169090b045e1c772e01dbda90214be582b241cf7ff0b8cba1fc1cf133efbd44d9704bcefadda98d1fabe19625b150bd6b18ca80503e0dc649f881f25b15a3577b3da4982b062591e1de7d77ab59964da142d84990182e88c508c7c8cfe2fed87138ee804690f796d7778e956649a9f9a999baf57d8fdd3bbac4fdd58f876a7de3321c7874e2bab0239e530b6f2e804331180c3c1ffd10b8049e9d5e91d4bbc0ae862317702aa1df130f36d8c376c103c4ea5727b173af27b90c10a3c802af366983f68f600bd376a5767bc012130c55e54899b86c4fef2caa4070702a775dc9edbb30f78159d741cb668d4f95540e6f224ff191f22aec3821a67ec310e55d435985662054a0e95e9d9bbcd3ace25a0036f0eb976157c7bdd1c9d1c4594f88d6a8485c76927b8ff76262aad68cc6052971748623a238944007c8c83d38bc3a919bcd2638e57452eaa90207c603f0db8eeb48736e3ca01a631d46aa83c06de8306b87004204483061788f2950a6f12fe0180672860841316aef7c23abda121424ac272fe7f13f9f3cb02904accd6dc24814ec078b253786240f377dd4a5bfa987134ba2676d2d920d2a5c02d8b617dadadc816271df7f8d6e81d73ed8bfc3dd4dffdbb874d1710836071a679dbd19ac7544d5139def76ddeaf802b138e2da88beea58763568ed0ecf49a7ac7c0f0b18cb30a4d4ef977c0b09704543e0f63294f0334d111d2167e764548f644dd58f24eae58b1c321d48885b90e8826332115eedad0bf23ab42315f72b55a177c4b9aa1848ab42b2e592cdd3732dd5388d86d47289cadd764723b27a7e228f8cb24a5e53d3bc17e9348f4e4be6ea0cb6f125da8e0c00c2ee96cf290891ed08bee4afd9665b9a085f346e817c035479307fa8d33bd82c08594fec6d29ba0dde219c5da68e5533b22d07151b52560ebfd62c45a45d4848f4aa34874f2e7ef37de3dbae60ea29a508bd63f1acafc506ce95e96f4ebdd921df276209e0e543c5f09a2c0bacfb3dc6d90344676fe75ac482dbf69fb54aae78c5097829319e4a8163a90d2cf5a1682c799687af3fd0776a3f087a9acdbfd1db509175f9981dce5545d00fe1483a74553fb6948b6b305b7eff03a6672cf576921269d2d513bf360de9d78d0e3e99f1937d2c46de2f940469c70ae45a2b62e7ecd9a7b24ef6b103c77762b9c900b74af9b174cd3953d232fa7e82dcf447e7d488fd49de093e6d4279c100770b0c30ea0a24187559b82cc61f111821a875db96819d270aec70dcddbc9d493b0a93ba94b9e289b35b94e0f65048d3a2e6ee1af81e8b35ef56f9a189be59dc875227d5c0e0421d931004d0dbd861337e5c61a29d6a0f4b84309323b09242c27676cb9295b2fecef2a8221c42065925a338c7ea4b4e567753689fcaed85ab326853ef4f562c860155c29f6612fbbc5665297f02101f51e0a6baf20f5fa32c4a35f090eb15fb8387591bd76e2126cbbb0bedd562a569a3ede3dfaadff69279c65445ff879a51c0e297e4720e0e2805441119768490dc34fe7a2e0c2fd04496defa2fd44b22817e5cc47bb47f8c41d045b16c1076d4ec5b15da31d12d594ce618b1bf230e1c8153aba27fd50d1cebd25fac3f06e4c1bb1762e574806c8be8c531ba613c23c57ed4b5746bd627d68c0e1bc7ddc9edc602b6b41296c62e95ea44578fd0563cd27d2ce548a40789034030089a56765c3e72135074e8b5fe9ef895bbd83d08147fd7d0ff17c5721118ff672200045de86cab6cdf3680ac0546ba89c20892db275f96e5c02289bb766a198125aae91c516cc0d1c59ac45de1e7f57cf8bf3aa17fdb91b446612d48ad1b7b6b0bb26e117c08046ef778a5c8f536dfa556a292af79bb4382b95b5fa9afe6a425ec1b407eb4c649990bb11bdda44b634e68677a3ead91e3f01f26c7b92f88ac200e86c17ae8f3778e750bde7575238e5a771bf98179fe19c4041430bb5e1b7367b9f19d0d8031883180168c6ddd0734afb2931a4bfae40a491a65ced8b14bafdd0c935c3c92f7b2f44873924855dbcf02e8418947476f6d4db97c2da5bb6b470e613ab015cc57dd08c9ba673e4ce483681b919d0204e7e03bfb0e7523780b9164aa085b848175c2273f9a0fb41f0863f584c8d0a6ebb8362722b46486bd7d90ebb90420464e4b138fee0d8f59cd1944dbca157ce57c9d0e2201133d35f21705e48e29676d310f548e56e292046ff6d48f62c7b518c05d56b23bfc8959f86c3c76b486b9fb287803c667d81f8e95bfd9c21b28bbb57cc201012c62c79dfa3fccd3c740ac6f9410c8b7c8ff86693e4d66bebfdbda478b90d8a9989e3c0edce70231fa94406ee902e7d8bd39f9fc691addf84ed0ef6a0ebbc0be44f27bdc3a06d6f44a95334dddf704b9298d4db414fe2a6a457173f383a5be99e881c3804a3492f104c365f8e066ed2b34bd81a1188f6c84af2af06781aa649ce96ff228343ffd97c0a1b02390140d10a709229884e0df3d50a9bd7abda498954816fea7907e186ca204ae23dccf9045f40390d77d846082df6c82827b4810960419e42ae6a40b9f46594b33102629866cf1ce89e69091326d7870ebddbeef865348ff27299e98ca36962d8b549b11663f6ad87adb4d85171ffddddcbe65ec67acdf4e77665b82b0f72d04163f5dd57f7c45e3e45407cc2bf2ea96a3997a0d41050f7992da62431a1189a1c94f8d619ae4946dadc137eb9ba49f14430c7643f8d520cf6759e5d58cd390996b2871b5a279aebf10d4e92d6fdd241fdfa3003ccc93fe67d5b4ea3c44a43fedaece450e717fd1a437648a4c1fa487c4886b8af153e05c297bfafb347fccea08d26ed35159f28eaff0f57ac1e8339ac665112d0679dee42d3d1da0d2ec5ae6c284c728a90ca3a2b3474ef191f250b4e7be6d5360f3a396af930e0fcd778b9f95d3121cfba348e6955cf6179a63e4de54ed00a2f5167dae2c8a5b98d859c95a878bfcdc1d025523094457c2940f9913dbd77a9f50b0bc5387c791ec857f38e5f3f1e732dc2f6a66920f7ae057489da87e6b7075e0645a4efb05bf0664d7f8be986ac80f9987b77ec2459eabeed63f31921f0ba6271215a239474a809c859165ce67600b0f354869bb940d05384635c92b13190a60d8c1a68d0a484112c1498fd3a0d414db648cd91789667fa654a9d9241ef2ab0a601d40605e03ae26f146f804edc569404116bce72333493a1c0c9da897dd2387ae7e74e96a7ee5aa8cbb32445f54f59641fd50a5ce29ce38b89cd9f97743e3f16d7dbb7c524a5333c87a21225912a2eebbbf025c9935fb321a9e63ce6bba58bef840df2af0fe7f8004c01134af6a795d7ba2f0e2873343f520c85c72094694385ade41b5b90875e32d54c9339be8266479d5232ccf09437ec979a3bde0294fcf47cbc58985c5d060deab297b2be1c8acf356e951bfb5949b06d3d23b5a947aa5af47156142d739fe36668fbdd7d93d894613db527eaa17ffd7866a6dcde97cbb11a11accd709395031c1582d2770503b4a5a1322168adf0cb604718afa3478b55c6c8d5d9be12c657d3f9f647d3d59ed1989623fb9c7109eddf9916a5cb158ba0dd5366c1ae3ccfd8214c9b7ebbf4544500e52531dc396feb3942d0275deeb0298bd102857d0a7c2e2d4c578af1f48756576951edd91073761d60df62e3e1e13ca321a67b2da4379b36352ca978c82acd4dcc3b0e848f3870a2a13a8c0ed1facd48df03fa584c0e7cc920f80f695411446f9c8ef326592e47c7ea08c888ddec2a8b4933869771f6ef668a83c9d68ad3b2e72b33c3a33d6e281d5b48310e6f2a8d26e5ad2e5fa984674598f4e3eab4d5024281122ca4da15c334e0bc0e03c69245016d8e4b074e5089ad94d7727af028d60387c4f4305252ceefa7165d1d9c484301195dba690f6455a33cc04be3c8786f590ece9034734f1e5d3065f5af39ec108040831d1dba835926750a472ff8cf0362d6cd2bd051c4e8141e67db6443c997e8273f11489b3b08465e960adafa88ec1b16c8b78f9e47cffc55d001e2f0d73af3e362e392fa92fcde088c00c959da49492589353cef7834c8590b2daf8128c2b28884553a3d5115f3b55264b6c4cca56d5f5f9627d776aab512a078be8b27ebc262d32bfc9077fce7f6f279fa97870befaba77aaee00075692c268a60e06168166ed1f4229898409b3d146c075db4a4098ba6c4a0d631d9fbce8ac129d3660b283046dfc7893f265ade5d2c61c4b573c721053c3bb0475f2fc66287da5f78ba544f29bcacf12275c3b4b934e2621b4457ac31e305e11ba7a2bcf99e7c2f59ad589c26a52afce1a1385a28f2d45aef943c54aa3579857df9a84d09e7ff8d356fe6412b9aad6521ed2f3b708daee1d7a95d025a9e991f3e784ab5b188020662af6c58f0b408e771c7a8869f6bc3169208a06c6b266549aef5ab1c7fc419d22fa426584295965e84be64cf7192d4e54cc82851f02c43d8a06be6732b0fa7915e00841f2c5d0bf5306f924d394dc7ea5fc39d6e30c5130c4a2443e79cc2e645124a623ab428eee60286d9951a37c8f1bf0fa87df4f8c0a066c70058c6b0bef33e912720ee5f16b00ebf1015fceea0b2d7eb4a1d3be8902a58f5ba8f4f148c94b5698e280e5769a630de262c43db9fdb22fd698a27d63ae339320a5c8eaf40a43c5978df933bcacb4d6319d3c6c369bc72a877e8b34ecaec88c5fe6be97b8139df05ad125a0f8d9494fb6d78aab80dde3d0d1ad897ea7934930fd12443d85d7ba85996c22a9dbf8b711b86b30f1b98c39b74adc3a7087d738e1b5fb6b853e0d05a6c0a76495c6220cce1b3679688732dc319f10de43c8b14e5c4931ccb044ed48bcb9d46be2b4b61dfb8b80fd178d44dd8e74183fed629579d50df4c8784a488b24f9b05145032c667a309596f676bec75ba87b999eb55744c4939275f70b096299a8caa3cb1248a767705d227c5ffd0b6185fbdab147d6bb23dae623415dae9f232079fabc9a9c43bc6f19b4bd7a0fbf31eb0f308c2161ab7a5fc6b8f24a58a7404113c5852b5a31cb8c66ead603d0e65135027b42a33be38bf9ad75f610186f84fc044bda5627f0d9c7eea82c4cc75f0f394166fc8d18a97453554bc0d222837b764920756c6920147aed521680cd852c791ea6062e7e3df6954bc0e5e7e58815526562acc25492183295f42ce645533f22c931c31c70d190ebe7c8ec140c4743c7627979bb0c60924b3631542349cf32f6d7d748b221ca8cb0ff518714af3397f8bcc9a0a21a067205b02ef49c9e2feeb33f437f020d082c88b7ac41c2a8bb7aa97e06db40af89b7f7e0ec745e5d282ec32a6b6036fc90d44f9d12ca14e510d56b651c7e62b4403d44f476c6f8fc413164f92eaf3209284f8160974bdf255525a861ab801ff67f9eb9b20068e644e45c5a9be6ab32a96a9a2523d0c1c9a0e3adf36fe1d26192faec187881c9efbdb40689fc8c3b5dc0a549f5b2c52d476ee3793ebd3c7f09aa1f303b31d4f00d9e42dd09f29ef523b44be3077607eb0e635e774b9c3b40676e162e02f14f4dbfc82d092d639ee35210aab3123da32ca7fc0828f6cd11714f65fd17417fc46238c70f5165adf76a8a9395e02e8acb83ac526167ec259b47b7fbab26dacd75f8ec24c5eeca41ce8799622c416e1ac3a2fa2c278964fd673db8a5959b12b6ca2378994ac3aa078a446d3c8fa4966d43c9a71da5e36807f4c93ec0da2b10229a670cf6fb243a0af65eef2a6221f841ae8a4f9e8459ad287eeffac9b46cf0b4edd79627f2ab140e60b77cbf67f1f5346da4fafa090b514b640c62d76b948a4dd7742410486ea9d5b86f012a241be644195d0448c2217f30803e289b537c95c687b6d2af052a7d44630d922038fca77d48d52e2130c13b118b5011643347e0dc4abd39cb842640cff68864742f5c8bc904c9f0ddf48a86f22a55ac8dcd946a567f57dd3711f27f1e060056892be018eb4e68dc4d73940e96f855e01f1c5e18b7635e6afb172a09889512a5e6c967d8449ed2adcc12a5433deacb2b249fb1311774d46584ca78e4d62769f3fb571db064f8d5c8256518c1ba8b62d38d4c7eed28203820d115b5576fd9f1f6dee36fff29a70ddca173b1b2d0f06e62ec4bb1fe2c55e8f962f6a0b92920bb81ad9a2e6d408a8f4d277a5baa2145b7aa25908f73b927f8bd5fd0075e6a45a936beccc8afba6e81daf47059a2ce2d11c3a9cdee2d428b20a7690cbca921a85b142dc8fb3a72a5280cf2c133cef59253d47d5842a9f34a861c0e89f0ce9b8d48a1a1abfa57ca57ef2c53a8649e44cb80da6b22b63672d413ceffee830dbe2dc068cbaf7dc1c868d9ad3d35f1093a7473cc88d50bdaa25bbc61c7d67e5c66ec5c0ecbfad7156b9486f5c9ac34e06c4ecadd3a521d2ea70cf534679c39baf6a77552b69ff58251616ee946b715ffb9bf5a58aa76f00a5e138a4a3f16d000648c5ee1261b1a8f4cdfe838b608356bccc0ab16442748d00ab3d60e23e9b5809d0b6fd0722814459a8de941c99eb5cc91102a6c2d270ad1d1e27477aadc75964929f41945fc8dc02a82828f2b44c98b485b71f61425c70388c45d5a849458fe11274629edf8eb4a1adbb0c3e628a4edd0dc7dbe34337e29682b53c75ff0bffef0a4cd6af7bb0bfb99068a4d9f0eb26a60275ce4ae4fad8c83fd20a6ab84d3034867bb8a06b4fb7a34321918d542b266c7a388c0a9450ad2124838c968b2e2870030b1e595df52ee7cc1daf87bbb7a3155acf183a0a8616b82081249e2e4ca7eeb1ccb35d4cf5ec59e4740dcedcbabc9fcb8dd778a03e58c9bc7093d6da5dff67c60897bb955c9155fcc8f91609227f255778b8e329225364602048144be048d95e6dde04b6b1e923fc5ce7af652332fc84af63cdd9dfb6d670aa1fa4bc2e9821a81f89cea0a41799bee6c64b7cbc5772fbb1de645b6fd71aee71eab4b7a68c18d44d3379a8b9d9342795fbabcfb05d1b4408e5d4c481eaf8737acf0d3344001f8acd075636b3ef2c9cceaa6aba263e23a8a249540bec91160f0c38a8f8c21301ab544ce8e9260052ddc8f35306c1395270bf91f772fde5e53c75e0a0048a127587a644e48a4d6ce979d1c1a32de7f85a6998e06c4e04fed6463fced73fb8aa2f879e25b296ecee37600675fd726b6a2d16d22a3bc426ac127bc6b0cd89a97c959e424b0c746fdadad797921337f35f064c5bde6dc5dd913dca1034d0e09b02076fbb6aca48fdb5ea45c0acddc272793e0d75f74395443751e05c011e55034ee99cbebf73b468968b5031e935f974066c8e7a101ded2cdfa5707e926694ce299d54e2f7b63aa7c89815e5091418bcc5ab03b6eacc809f19c9548812c5412b85a58edc91f19e16b75414fa487884f09ad61cea3ed51749f9d1f7d87bab45965ce05884dfecbaccf5780fb1c699260e41f2f67f8bee903fbb4048aa5bc550fac3e8f7d41e2b6fcbc9c7eb12bbd1508fb137679bbd84a4ed4d4145bc8a8b1acc6a65838a7b621b6eda08a5dd2225862c519b851f68889f8e13c6b5660808a8d265839cf9bf08f63ada3dd00f05fb3f3b7a0d10871e103832eb6d84a2ce8ad2cb55f1191b1ff03fe731b7ef707824aafef7c96fe64c1f5c470dbacffe5913dbd5c015ddb70eb611e52833569d378fef06dfa9f979d75939e30d59405b19247092abce7b6f4947aa88cde3a459882ffc4d5bd5041c9add56bc2eedbc7b6b24fe33fac65a7aa1ea49d28c7d14ec3da28e9be71c7351b28843dc215a76357ed8ed35e2e9e5d4a42dec4138a446526663f0dd9c428563805c9e5531ffe562186eba8df8292a3a36cf6237905ac1bd49e58e2290d305dabefd3e02de04f576b0cc3b507079b702a5f383bbf382303cf95d3901dceb6660e6d59f314772b0a6af198e3f764088514ee128199549a5d18a79d55b2f238279e3bfd02419d5d1fa947ce447eb6eaf18ff46b34d35d59b755c1003c2d1327a6d49884500cc0619a9fa9ce550071e971e6ac5e11a442ea682130826887cf57e19686520092116b7bad8195cad5ae4a6a98c5408e0874c134769f01ba604a19c4e5fd9ef70bdcd2e7d4024f19f2cd1dae08984616542bb68fdf22cf9bb60a26d3fb74cfac8628becd36f9095b595398b7c15c38b7dafd440d4b69807c236c1b274f9cd79e2edf90ffbabf05f4dab6627d776d2f74005db59ebf0a52b616593925fc704d995093adf715429a7bec53401c8b977eee1ce4d123671d23c70ba936740a379ff9a8494e368a20d0b6acbfc4a109c36735895095cb66a6c258a3062fe325ca841b83f3bf01bb973ace9467c9137458f736654ad0bd15b424688cdf1a71c70ae858d6a1d8cfbf3e106d2252e12475414087810dd320b7dfbd8a70494aa61526d592c1a5b9c720c2ec009146c303f63a1aa7d8baa323f12d1851f0110981cdb850dd9801a9c02f271b813c2177e1a9fd28bfd3570c871797c83311bf5b04976067d1e6c3cbeffc43dcf077ad970590a7cc8c21b2c3c7a1cbca0b0b4ea266008e65d8675d38a0a641702f21afc1c197a2bd37d476e40aaeaac7e61f9e83b2f35920b24129b153b5d802ea3af67b8303e2c43125b5ac30ccf9ec9a1359ca99cfe3b41b5e19e072c615cf3daf009f4b22b600405832cc5005b26982120f9361b9d357058e791de03030d6c0688e71214772e170d73300d15ba67a8c224125d1b141300a1adf2efa44fcf3b36ea9083ecc0f9320a4d02dfb520c9d5c8fabcc9bdeb8a3efcfe507c0c7fbe26f4a0bdb5bcdb7abd09c51b2a594beb2a43890d0ee4e8cdcde016eb1067a3ff12a182e84f8f21f8a7df0eba97732ba0bba6f4ba1ee94b0f2910e99793850ae543d2437f1e1b7c0cd9918646d455b9539ca82e8f02667f97861bcf58317a5f21f354cca8ff3bafffb4a7b78dcad2a2b7d7b9d2f149f5cd6e0ece47246b4bc25d2557e071344b45847b382784067af927b00dd95c833234f1d4644c56fe26b619e0660311b4c0d981e9a6a63b3c2acb824f522712ea33c494f47b0b99bec368e3928070299b59251f56b272f97e6218abc19700ab29c488a7293447fce1ebd09ca843955f5fbd79acc29e086a0de9012fd416976ef17800b764b5089d0a4ded618d4905f5ccfd4e2877c26cb7180693396d18d99268d853966906ed795873f85568783226fa2857a9f24863c4fccd0a3778189febd2c881a9d2c90ae7d3cdef8402d0d3ffb50c4be9b7e1cf4055d93220559f889b3ec2a14393347ab1f91c14bb663de61af383f27dc4f8f9b654591b83c1ec1d3719fe4c3243885e00629f08a79eb21a4cbb3fcc201b9c30d26e1479cd287f553a2e413e3f4f7519db8fb74c49f0b1ea8a9929613e8f1ed3d62da6ed2392fdef7c61b9ca0de13f82dd8c30b6ee7cdef2fd7e047611d0804d64511b79c588bf7d8b996cf31a7763966c3b50bd463fac2fb947db813c80429e6cbd9ed711e0cfaf26deac53c7fbdf8fdad7886ec63ae4fe30005351b0781a9f2f0ab87a13101d9ee76b4c2c787aa2f6ed6cc98ad0d53e510b97aa6a6262891a2b29fd493d30725a37b5815e741d819af239e468b1b0abecfb8557c2608b46a442ad6b716477716cc2180c0c16e29fc1dcd038214478fccec76bdfbf49c27b6069335837fe4f4808e85179590fb4ae95b6367ca4863d6e65de862a112374c2f59dfb34d45601fa48a5f217b1323754dcdc1580d038cf86b66813722105f37e93d880b6ec3b5c4732b73f520be784c0b964ecaf786a336d65939889302c0d52586c2ba00135dd37ea0127b8af3a07dff06235d0d2aa83f80de938dd9f13c4189ef5642e7c01e07c127c8a869803d7fbc9ae18bc3e16cfaac6b2479cf953f8729f6fa58bbfc177cecb87f01331d62ecb5e49a58ba1349841c8026afd765884e814ee4f6f328c796453e850d504a9529019e8fbe2d2b7ae045c81d785b53ccb945b498907404f975867a4ea7670284f4a914af182886c4b6911f423f0d213d610a00b2a7c235f9737ec57b2d38d41301dd7df3581e7b5bd6e82a7e1b408ee7d79307199ff1db674246a9a8e18ab48b394391a44f82a2ba30e523c09a2beba50bb355315613632805b0190a1bde19c49b8db713e4d575a358ee369a6dae0d277cdadbd8e078676001b723a6c20eed46cc3178babd0c2967784990632ef72c8dd2031532a7e9d456eb34f10c6e2e28055c70055e1f30e2553ee642a182247974b38a761f351d8f58748423700b8b7d738aad58c58fbc974dfa522e121e2c83c732830a0fb9ed52085ddc9a69735c217bc7694fd190c68b8413f0961ebfc1ddf5eb1a1f818d0332fb111a27740f7c1306310cfd2b7629bfdb2f0b24da3d0a5a23c12da37083e845e43d218932f83b469f79bcdd4e98453a44142758964aea6e2039a3f0ca6e63ea98216dfb5521f8c768f8a863b0f6112f7a951af12113ac0136e594b362261dde74b07c8e8c30a808c9321720c5bbda091e573c289aea09fbe85d1da3dee2dda78a1daa01c7df717446cb20374ff45b65f051df987a269711f430e2f7b04f3240fe6bd81142a4eef029423afe83c7c5308090b159caec79ab86d91257f4ec74dfc7b19d6c110914bb85e89dae20876f0a8b223113d6f15fe7051c754a40752927247e9be2bd8033f1eafffaba833635c923de94864987fbdcd699593de2074f359af3720c41753d9ed2fc3c831d6eef996deb7f4184934d519bb5f24254ce584da27799cc030c3fa1242b4b0156341e8be6679c56d51cc84133148343133356be9bd5d2bc2f93de22b2f433b78be0ac4635c587baf5eb2fcba5bd74ad391d956eb004849faee7cabd242c6f15853f87c670b2cea494fea8fb99510061da44bedb3d50525369b553610568d0e55dbf9f11a2586a408d109817f4972af9d2aa9e4ace5ae73bea5dae25372a8af16e673839125420fc7d4f9ce28f74410a73daa0aa1eed3445ee1529bc87f966a94cb7ddf816c4abe8b6f18a42c25589a429494c5a8ff68aa16781b88d0746bdfc266c4cec64894b0d6e0bf31f107a4832f0589e026781dc9803f1e20047a25230939ef26bf9000de26b05a1f0730d0b216d9cf381a21f170670c084298ea8d94b5662068ca02445a81207720ad5471a9363eeccfa6147be1814b6988a1ed86ef124f22d7abf9b27d5973219c2b6d4cf4d9644c87e174a3914ed0014d550142b4b3183e5486e1410f088fe96fad9b03dd0742606a5f464a1a654faf941d83baebb599d0888252f0a968e828d845f89b771ed4d23fdb4e63be6586dec88104ef33079ab9f18bf696d8ffa2647d3ad73b66ae66a30f299735140b0cf5c859b19a9af444d417768fd7406d2024cb8472682b731b32ac7d959a9cd9355d5314e5f5543d89353a71253e577950127f8efbcdb407f7945381be31ab7a9b0d3f4209380d4ae01eb8a175f422000e715654f2ad6f39b0fbc9a64c84ba660490a0c9a00affff30b7a6421f486d84514bee12fabbddfba4dfe2fb93bf1d82779f28a46772719b24ff2be41595f1a553f1dff2caf0a7da5275cd6130cb6f6b57821f12c53c31fb2e20b09040eacfd0a02c257006c5ca87729e431bd628ed0d3585346e00bd49e3947b002adfc0b2e45f42b5197b2ff08e21c4857f06101405a89a54a4dd889d6d29f8ef833296c6676e375b2b7ff9d41164f46d6e6497abd858f4b59b3135aee244b60a0b7f6d6ba5874f788f03be8f6cf2af503bf9997183d0ffb103af05ba2045ffcf102fd50da232b6bd5f5fc0a4a31293ad87d016922db91363601894fb542162a3ecb76d49773cc412edacdbf540cd85a23765381d9d58615e9955cac7862ebff5af8aea209f98a4c1abdd09ccae47f2ac1718ea712546ce77fa4eb6169507597390b188d580e2568885da1b9f82242c80c72443ceca053c423ecb79a174c94fe6ffeb62f93f8eb9685bd66cdfc29f82929bad16cb59fdbe6dfefadd6ecaeb53eebf847e7e2721f36ef85e59e2b597ca328e80291adc137287a9a8c1c043ba0b1e891dd5988d0c038b742fc7982be39225b69fd822853f8bb999ac3be738b1bde061c7224dd709425759d672a4e85c76c50a41e6a970b1dea6f5f8d0407f06c21fe7aca03075b2b139cef5fa28e2234a974becb528ce843695a41d029affa13208126345b908f9bdf96bd294ae184b3aab3ad52bc06d530dcac7d786c919fd9c2df62796894ef8c311bcf654a50ea63055073f96d9c0b68dd8c3d01e47abcd81cb37712e5a83f246874664684f5c67120a655056b66424b5472850867b9c701729cbae150fcf4226e0b2c97b38bc5fe0b731773067f98323a76cb6f4319f3c2dafeb700e98597a3865e9cb05daac53da64176f1d440c35d59b2ac94f31dd57c95f8ccf6ef8c14d654e0f6230710964d12940f5d39c1463cfaa14fcec3ab427b7c9031ef4f2ebf8f4143812420990f8893518ce35f6110fe5b2112074fb8878be281bff8969743180dd8fe1b6f1aeef028421722fd266e2bb95cd3c98a273651c7edaf6dd4bbfd51068fc0eecbed04de37ace4d3681ba023e078e57048f578c30bc0031266b2ed0382433cdb30e8c3d3816b8b558fb9054c8108dd031913273a49ecbb8e70ba4fe8809b8f9c7871e75f4a417fab7597d56a3e93c39cd967f6cdc6374f4dc2bbecb4191d0fe754f4edd1e72b380d9488f4f91deb6d4c35035f24abe25c9571dc25fbd476990c643ef96f962e6045f1204d5ce842c60f1f5cc4c5134c04a6ce4cbebf4fb5c074b65e84cb91c7ad16e79ebea4551eec786cb897e74ccc523cf79f582da548e7f1bdcceb194538f5999ed357d78b8af3ab7c69583ad725e6ebc025a7f45f7aa1c3ba3856150b4bed96070dd827481b915dcd38c87e32cd0942e718862b7caf79101383266895d983be4e0731867d34ec3b5ffe5010febfeda491f8cabb0ad8259a0678d6ce87b27912e5d1ba921cbd4760afcca5568a97da9daaaa115164d247bbc42db329f3f0b0fcc0a909cb571668cb7590ca7c25e5effe5164be8b8634ae917d9ed65b03cd6626940c5dff8108950b733fad399d4d49d0bec61fa98cbe6360fa518c550ca6237d9d913a2bb4cc74cf34e485aeb0dca74e6acd3d62e5ab2bc2cc39911c0ede9b70720429824939417076d07d0f1aabda0b2c53fafe9a1b83cf194164912c5ec20f6481dbd048c0ea9d0454d5200d33c438954287868cd9432381e94aea09d16b05886018ebc014b28e8c79e6e71a1f7df7f2d56e27144826c1b91ec2a932a8eb83c7f4c4d86e5f38d7debca4b92c9ce8bd22f9a0378c97c04d5626011720793e095f98b11c806a15b5466e99bc3b0c06550169a6deff801ec21c0d6e0b00e9a709b173e57ec32e56b43185d2173b39b77def2d6f63c6b122293f6a3a35c7cabfac9f32e278c3d299b705c6c660726036a5334d2cdc3a7ced1b2fc0f9919f321526005d6f1c891341420402f715e64575105ffa765ba31411e527069d744f385a6d8d42b886de5915b622bb10598ec7d16e272939fdda2212cf0ad0f35dfc0924758a3b4d113e2f8f5b70ef088d431b56124f34c18b02d0ddf25a3cb5b7ba042ebbe241d5e881410d49d5d7c7899a3db158ebd97100d9182f8a6816797abd28aaa5afc4475dfa0b91ea335ddcd8ae5cd8486a8da1da0b7e2f71d38826d900ac56e90d9244b757eed85abd793042df5442539beb4d06b223442d0857f8a3f7ed4f9b8a19ef30166ce8b151efe20987c22c135874b3503c55e76028c996cf5b5cd8dd3840d03f77ce7e26c78cdae5f1136123d4de9debcc1ebdf0098cf6b5ce93d0528fcac147af04e92cdf6610415417ba37a885ee6c819285257200d45b25366066461cef74e6aaececd06b5fcfb57bdf7d8764c0b96071b7fba3caa5be25b3dc276d42777826bae09b63259dc5fbfafe503165b3b9f56dbb32b59b52e4e30dbe448389d72d98ee6b2be973e7c9beffff1b987317f34886b2cf4dd3a2fc9cebe288669c28fd85b4ed7f4292e1f8baf5143e9d4fa84ad1b4710b40ae7f1731cdb0e08e0cff55d6ad114965c4ff5fc683f1f83c256ce3fd854b7af63966c237ff7d705e55dc045190c5a91d0679d9d560d3196b289915483ae264e13643662d947c2041daff4a5ae08e6b68cdbd3e50f5fd05abee2c48565ec952a8a892b1468436c89b7011e4c3bf3139f37beaeca2c56d511b4d65239ae30afce38aaf2a1089d6c61f8ad49854737862eeb96a47774ccb40046c7336111352cee3bfe8bfc6eb3a0b4e3c03045773090278cf03e877357f46035dbf2c84a25d64c16c9346bc16ddd011e7383627d0e0b9dbcc2eea2ff459fe3d77bc3f6806538a89d1cb97de68c55408aec46f517e170a562e4edef4d2c426e6c13ee6e8359ac15ad5bbcb695e8427f3ac8ea31b0a357cfa30fca581cec3d0337677e4445328499b73a6fec70fc7d049f5b547114fd156a185f5120edd5ed30b7f3f08e06cc2ae32a67ddcdcf7f94bbc9d275795e742148740de0106c781c9c89506d36b6d1a09ca3c03fbbfd19cd97a7e5894c8bef465e23faf5bce58ad06ccf80404e3800cf938c76495a8be917371029d11512cf158676cac334d0c125ac6010edcd9a2bdca76bf22d75dae46ce715dd7345339da73168d2bd212f7ec29f394f64e0f9b63383345950fd77e751ba6845339c59ede8a31c857327a9e6d95a76a9b0a9fd84daf9fe15e454836c1e33d83f443084c7d6a2fb7af61b59defd16f7fdc07ec91fe36554fe315e947a0ebede529a0bb77d024d23b3c87475b3b603e55c1e622c3377457567e8d775d3654ca11f109ec5a0b9bb7f05bc6253c2b8b44dca827e142cacbdffc29645240ebb815af6d100c8841c0acfc2370b82bee09db770652d4a5e145c66a86f36a090e71fa6f5362f5350d856bc034cfd0ca501d4083ae11dba5f656c92cf879d3bc8fcaba66381a5b39fd7461f06a8402b36c652bdc095b75b7c0189add03665491e11f0b750e6be2d38b17238469a60a5e58aba9f78cb2ac1de5fa2b75a1124fdb9e909c1f269612e919daaa2e0218d2ad25bbc38f9da5fa870a092f7325a5919151cf0144c87f1bca2b273683372387d3f0e1514198a4f4b136919e8b5014cb15501d3bfffba84dc509af8e0ecc9a92bc05f9073347cbcbe8d1745a42175f4c7d7bd604fb0dc5cfe15cad1daeb00bf407bb844525cee053a1157ca9485fef5db8a8a92132ed28d2be993a3018cd7b09a9f5b5061c74b06c6f8b945550b093c4097f0a555de63f0fe0dc453a9cdca1e902873283a9dacdc7cc515ccf183475aadfb6927460adfa8f8ea67ee063aa6a6260524f1b7ef815fa354b6c70f62b5e7462f411a5ffddfc912c04b0605ac1041182db786c25845bbb04362901924c273e4b1b26d4212e80608089eb4821276d3b63b5c39764d0f17a089524500b111a75d68b04c9015468205b1da7c29f30e247f75905e747176255d9021209a81ddaca1243bd483a2722df47501642ccddd29926be9adc5ea8a9c4272f8c3a987ce93fcc0eef556c6a265fda4b592686662e44cb4ddc6ce900ae7d5c10c2f9092b6d35ac8f3d6a13a55ce4c4f6509774c58dd294a00f28b4fe8bd5015a03114a01e972e773242bcaf91fbe8566701324676b899821da1f5c6a5a4065f4a1c6f33781d357be21f017bc85cb9c4331fb1334316b11e3872217126f748d53056b94bf476b4787926453fb655d5eaa87a6233867767443b9765a4952fa64c69dfd161bd9aa001f1693df0ed0e21fd2b938eef6a891f37987bdea9d919733505d8ba1a3b77319ead9eaaf0789629800aa914e7303072fc5bbf5d9da2d78334bf31c1dcd52532ff649a29c256fab85898b0c314d0ce451b035154c6e20658feec428488ab8f85d6570fd62de99ab4bdafc99de18bbd8c53ef110691ffce07eafe3c13c2f85635f4487d3544ea5127af1b58eff6bc9db1bd3ff2250d4421bd76308b3707abb36ccfa2628a49510ad91680863eb79281736765105bd536086c28ddbb370338a9651022969e4f4cdebf4a434cad503e943b18022297e764a982bf5d4620606177d56614440cd13c87b3db150c0da906202e1c461643586f49b14faaaece3566731a520970e491824efeef66bebc89c76962331f3cf5aeab60e661d03d12d7b3b27aaae449c0e24b8e5eb5a877b6ec94649ce6dbcac55c46c09525e2049e6f5cc3a99ab616f099769ce53c9c6716adfbf76e308dd505cfc0819650c4c6d4facbfdfe7c937b61f08fe20f371ae1f24347d0c370607a1878695c927505bb5e29c2ff7e0b768b23bc432638efae0b3dcec2d5a0f0a0fec54dae14b9fb8e64a2773152daf8621717532e65a93de9bc7bd847a9ba5e68b5ac07db8b1e9b653442ae4c1ee6367dcd86adbb1ee377225fef6187d1d1bec4077810958766cb247fc2e12b7239b6425eb40f292a4f2a72d89c570903b0220ecfae1a5ab1d36531abea0afd2c16fceaa83d69cb72be9483c891858736db3e22b8576f2c0c74288c9f147c877ef4251932d197f8178f4d8c10ce24491102af6fcbc356088a6ae9b4fc701f22dbc116bb0d0e30834a63258d92471a88dd5ebffbb883e246fc7368bd4983238bdc0c222a6ced84586fd089c67157cbb235de714e6498bf37b10ef4878512578cdc75c0b396877706af69c831f10abdf72d9013b70660adea223ec39fee842147b4070d4a8b0e97f8da0ecb40984713a795b5fe9d1204a99dd58d5450cdf208c9e4ade8ee402fd4f948b00afc288c41724a60213131d0b9c413683b52ebdb524055f16dc16f1b4baf120ba5612188cbab46d022f18d19352568a64c17c7d22b44c911164d86cc743e51ab7eb162042d3ccfd28751f4ab60a08f2a79fb94420ae3c9a8153d293f2cd591e4fba3b81236d40dc358fadf627bf2e9c256b23d00da7dd550dcecaf44090b4616e662d8bd84f1fdb4010da5f139115a83bf8346f6f17266a8c1b92485d5316738c12145c4c1e3db4c535b2cc9cd7963431f7b64ed65b9466f0f5423608eff883ffc941df185f02de9eafd09bfb563f57d2fa0e120f690d7a8b01363bbe6be607383ab0ff60ee9a3a4854452bfb0ae12e50a60a7352f4fa85886fb2e3d6ab7ca323157300547600200ff31ed1b8b155ade0e7847cbcd888cc031d59952dc313a245482a0271ff86c424ea5f2187a530560ef4da68ed221b13e896ca1b84e667d3624965482c7701dcdfe02206c4f671363b89318896b1ee2d0e0f7798e0fb3cc895f00bf8ef608c8c10d48dbdc45f3b1bcffc1be2a0921c0d71ba9a27f3c8e90e24cf34cd30c0690f6eca34699d92b9eccb0c715b79f683bb69c9697d9e68f5a13cb9e194c646c3478aaa73a4f9a3c3c0861908d0ab082aca842595ef67a319dacdaaa65fcdc033e4cdbf8a40d8c7124114ab461ae19f1bf13a7687e36e347400a61e23d300b689e9bea034c68dabf7a2fe3f3732184e79d3c46c0b8c2430bf09a7d735f32f8d04f4d3ef4ed7b6eaa0ae84d52eaaaf33f37df6afdba3fe8848dc2ca9ac7839740909bc39e895e6cce2b4b7fffe00ec175db27d16415bd48b84e0e1500053c65bf099bc2832a634c757288e3822770f60e9c7ed3696241baf8353cdc657e43d643f36d95d3a92d34c6020ba72b88c0ff6b5c53123dd191e80ef57c973dc4a3791b58ba4f38ce43e8dbfd833df4a20ca770edf9d466c74306a44baab12e18127604d0f6978169b4f455f12dad90626e21e67ae8045612ce7f8065a00c09b5fb1b6e2b9d91c47b1c7a4894dc39e4589609a5bf7ad8b43e5f1ac08fac2439c78fcf88db076ab6e57647c4f53a080b3baf2d8dbbd09b9184ebce2b7c80239add7fe3b3ff555c54e1b8b87b1edaeacc478b5af685e1036b60a490dc7a97fed4ff9a54f250344aa042ff4b8d38edbfb9df8fcdf6703395f409086aa7a4e7dadbbdd66ab783a955c526509ca79631995faa753d3a76994f7d1fd40c640833cb859b28850d12ea7556542de6728aa9f19ea5041636c62ed576339b88dc5778a2b9b7a4758eccb96a6ccdcf94658e35f4b776789fca0d8bfb3ff14b9dd9f74b2e1d8aad0b5e0d5559fbe229321c685d849fdf7cb9f78be204efe2b6a18efccf7afdb12f728ad990207e378031489b5a32bc0c692407634a756f63be51b8081feae190bffd7001440309a2dd1ea229aedd5b4352de0f94b532c6a6d7436b59339714664f3a0954c7dcc82478f1c4a2c68af6af75e7e12ce3d05ddeaaeef79253cf55d23df90d08fe638bcf52021f06b8672b809293c3f8f0b401e2a8832437222bb272326823914a871e4546a7626ed3b391e87632474eb7cd000f470bf8500eeed033ccc6314e127c303dc3b62891903e8fb01a8a63a0341ee47e40df246796525661d7832d3b26d4403e25eb38f56ccba41f934f577ac7a70eb5c25696aea2686f0d6af224d2b1d5ad8c139a50d6153f5033b47302933eda1d1690c1a55de55e76aa48489f02a98f1a6f2351d7908e94788f2ca07b14216925c04669c9c8433c7d67d8073ae8d0b6404579347926914aef5295690780b0419624c1b101d37dbf3cc1d4ed6d0f0e8ee6b8d66e721d8a775b59d057754dbcb5cf35cd566146ee2b81baa6c3eadf78fb7b8e735029ea0ca4009a4de6ccd372c218e80fa9a8ecd6a37b90e52cb63261cc103c9efada5aba6120835a1c46a522780c7b4ff568d997f1535a685ce453f40132db9559bde141abdc78c6a040325facde74ebaa949c64c646649392f0432edef9735267b999d995d1a9fabc98e84ec5342ea476e20fe14b337ac823a84c1934d2cf0bef1edf99f6e8727ba28f8be09999cf78abe763b4180bb1146338447f0080012d097374a6b051eaf77ea2535510fbc134adc6560a558938f82fffa1fe2563e2ff7f03ffd8172ce6b01199ceff38600edd91834f5e90f50257bfe5320912d85c2fc4d05a16fb8e166a2b1effb246f7aa277a9edb1e0290e03a871cc27c15327b25e249d1969f9e818444c2e14b31312ccc82bcccc558af157540f4a76bb7d3e35b55e6dfadf8d5f18d6af7b7bcfb5ff135fa1aad331a80652d53a97ac94f22a14f7036941c3f81b549c5521080e254417b9538053f9810ff2cb1dffa4f7e2d5cf6cd72229be94ea7d704f2c5bb0c278255d94cfd689f1844b6591339f3c6abd19b447889441862956ae7a3caf11764ec88b739062064095266a557e8a39e1fcc408a7a6c1c06a65afe148c9f33c275a1ea23612452592ceb97401e95fafbb8386e6ba4f04104975593f2fb6f9dce4b9ffb135e37beff691ad06796cf2dc92395cb6e9e540f50527c88ebd3c8c978cc491d95dab9658126449cfca6a7bcbda209200195ba6e27652839142c226a77e2d5af8472e85f786e1d978e89f3dab3759effbc04d012d2e6b75117e5b8f9b119bd746e555ccf7a353f6fedb0edc8129a00b7f91d0610e98f8a5ceb62981908463d7d8e6fb5afa35cc9089511564de3c97c81dc1bc7ca9d2093c9f17364ff8bf1119762f165b7b5d8f8064d471bce27a78b2b3629cdbdd529ea18d5a768584300c93ddc1ca39d2f0099b4da6613fc3472facf20f571b962d3fad87891ab398e448818d8d4046bf87416876f61142cdbe34f0ae76978a5bfb0b943af73ba749d4a04c95f91314cd767cff1e0fcb9c8175def43330eb3e7b1f6a19b4b7abafd5b73aa434bb51a9c89c5dc69c0ebfc7da7a7e27abc7f9a7a3264538077df531cc73f9faef003d47bd338461392a9cacb53cadd8f54757869af2a0a0be83a0a0b45b111893ccd28da8ec5095da3507899536619cf76f0fc7804f7a324ce62d7649dbceff939eb63184865b0893f15dd630eff591204611f57d30e9ab88d85ad3c27a6895d35d76567c8a7882949915b27a39dba000934efbec4777aac8ec2f08ff4c858071ce792111a36b8a4ab5f497921d4d42e3875a42ae30bb25a7de6156579578b08c3316f95db49e7ff6b0e90e605ec537137551dfc53eaf7444ce743ebaf091ae1d652997d950c132b6866e6f7bdb283a85156f58373c73e1e2c2f8ec3ce506b7fd900f5b1f17f5333f2327f443118678d3536602925db4f23aaf5c17a3f093d71ff9882bf64216132aea9a124d8de1a985c61acc3f514331cd31a9af1d29c2b20abdfeda193d3c711b005fa7aab660f96da4b975e4f055b8ca3cba9fb1f8ec51d14a13cdf5b32e6b464cacef8694399d2cb14df15b5bccf74aa3f7d18d715b4574d191ba6611e8f043f15b9b8298d97f83ac22be3caee4ebefbba0b0496b6fc776c0392489e104c56cc70019ad3bee2d7021569ab49e7ce39e1d47b3d93f0be46ed76143da1096ccd3b7d75a98759fa85109e4d75238bd3d2cfc923ab82ea0ca4977ae1ddf8ae19d96833ab0105b544c41e1953ae2fccd73e11fc869ae2d8751fdaa505588263001fdedacb2220fdb67fcc8d43ee2b53997ed461323eb2ed131611c6ccff7b77273bdb7485e022a35d775dfe90320c99f9c360e8b8f39700ac188cfd2eb94cb79db720a78dbe530d9fb7ccb5d70263b19b7b797372a3cee301964cdc387f763d07ed25dc6e8f91176c338e5210f7e0a14a00ff4baa7478b070f7e59190b6999d73f6674f1142eb61432c93956a945297a94ddcd989991ba8fc7848f7a6999e8344ef71d4a55116de32fcbd4b450d8c4566f66a9860aab51ab317b6f9b5f74dfb55153a79baf608b8a4436410d9879ee74b95be89de8276585a566322da4f20939507d58f712f234cb338e39127447e012a78fe353ef1f9e9b89c410eb6e1cae348256179c14168c9b5eafa2e36e42421fe20f4cff67e7d8c72f069bd16f9ebdc2a0f084464f71bdc0e203099176db41240b37d2a234aeb08cf87469505ff4d4ad50c83a3c4bbe21db3ca9bbd5e959aa8570e4ef4ff00ace614012739e82715c432c2ef6d5a2f5d482b1cf566229235401aeb5883bbc6026e4a1c117fd704d609f44af7562655f1cefa45430a8478141826727b2abbcffb3860059b5ea29efe00bda5f058c684e7473bb7b61bc4b68dbf8055107b926b763fa5011fda44477c14b36c579faaf3efb8dc486884ebaeca782c36b0d454454bf4d515989af4c82b3b3b41829b5e53c38db0003002211369a933cdfdbaa24901375914b12c59e00549c3440ac333d3a4964f3d00924e61806756e1c0d2a66a43bc050fa30222bb0ae649fa85bb790c1d84cd5339a4ce440aaa41e81e9314cd10f94b731b419597d4d4e07f0de7f923579b5632abf74439310093e4fede3ee53e687fb333017b10d8fe58a20c16c2b9b4e70b5968304af935ad2a0ef11ba6d504042d82aed8f152b4f34099c92c94276481f2fb088e0b4b9d07236b52a897c7aeaa1ae84bed9515de6dd9b007d86cf20496fd3eed5d7fe57e6cb14afb71b5346cc54ac6ea0ed5ac991cf9c1c7e751902b8e7a68bb74178f16345db74ad03e2620de51577f1e3098b599485ca0944c1e0af972a0fdb492376219ab1852680c013280d3fbec927a3032f728c5f73508b1186b450c9970f876b85d6a8692c399562253d134c0fe1a53ea328d5afd20ee500caf53423e115d4e21aa8aa4970b051697ceae69e4ad791312f854c54f854bb47d65633e397ed1643bc269d7053043729323a16458e8b5db6e27db2d4d3b1db1913655f21341b249d0e557459b34daf4f8e11d6d79583ebbd4ee8184200220f1bfa6a068b212cd90c230c1a62c64b8781e88d51d69e0101da05b38c411e01cd9df681e4c77e3e05a604dc156fd633832924c54b2aa2b9e9c4253560a17546412aa5fe4d94540fd0e0797afa0f198bf265c1bf558e0569d47c1ff3c16d421dc4a30443ebe20cf2c8c845dd92c9bc5901ce3d99ce91cbf69774d6578b559ed3a9c60a5979723af7d63e18d75ce524a98114afa96c816cdf3f60d7f017cffe2f177f5090bfb2b40da367e984351ea791c8b6bcbb427c7e7400d6f6fbab7a743e56aca3d00a9abdba28d6bd92c9c37d2e16e12ed6b5e5e5ae40d0e2546a81fd37941413ae8842add1247b7ca1eefab03e5a511f196506548235151fa78de7f5d25e5ede5142d140d8470d0fe91adf2a745606687d8f57af24e0ded1e4a74b51974b3899324682c722b6a98fd215fa46a12edd765ba80cd271899702583a2f050a0d2a10ed92678f5bc6ae6b21eeb5407004608850bc3a5919e516e0f891b2a985ef5faada1502d870ea2ff79f26fb4055834caeffd4dc8fcccddba890b26df8f2b965b56f876e3303b4603e316230797edd78955f0a144f216fde93df85dde3b1b505de76349b802a887791025cd71ac022733c16c659c627ac37c1beb18b70db846125ffb4e72283541cfb719a1b3354f80633427b5d2ec17a5bbab30fd96bf0e7548bf2492523447223117567d609344db310e3ed4e4a4d8d9b6fb8214a793c54329ce6db7b7ca9ec57af0b1a8cb79a42680b13e1aed2c8006e91f7472a0e5620241cd3d9d22dc491d82f1e8bbcad83e49fb544c922973f564aa6c28f05f945be1d2fd60072475736cfadf90b6853e4664432849226f58c1615ab2e6f2c4055a7f50fd051e5790cbb5985cfbe94572902d9a9a908535df9d5bcd745ad78f20be7f9f1ba236e3569eadef68e498284e45b77f6c267d55c6e61513bd69ddb8b90170ac5b09bcd703ac95b80179d74d0fb2df66faca92e40732e2928cc374e56304b4d9066d833c320541d925895e1f9325c819418e6a16f0ceb84ddfdb2b54bcd3c348f36c763aa2a7f26320a4af870684d64c8e53aab84bf223e49d1b56ccb520a700ac00f06399dafaa3abdad9f6e5694544e8ea5b2ca92a58b516ebe721840f86c846b51faf684c511578ec4ad85ad2da9c4a6e2e76e9ebfb889c43a8974f5cd9c10bffede6e32360ccb9a074668986553ebc1c35c29e70380017ffcb1c4eead694835f296e7432dd5e6e6c5aef7ac7ddceeaf524912d8f1bb5d9c1a7c7e5e6338ceed89bd7e9372b36f43375abaa0b51a420223924b1d3b916dd8ce9770b666dc45e2d46537731e4f743cb8f2fc3bdb379b0847cab1881defaf1352b288012a0d8989c935e3723fe7463ff9e2460ff7d35faf62bf17f7d79a25bcf74f1f5776f3aae593470086a6e109e95fb28d4808d55e9c3f94582497f9416f6ef4ed0804d077ef3b06f2b97400347615b927cf666cfad71472cea00399ac39016ff810c59bfce8061d8e6d46adfd35b7a5fa7dee5ff6a48646142d61608d0a90e7e42ecfaf8744b9fd3f61156a88a624eb06112df825df1efedb926eee49bbf655f4b2d9b17e491d2ec1594664d9e8dcbf97ee9e135e73f919c35c815c6dc6be0070bb5d327d483c2a97b33bce4a2300e9d46800c7b5ee2fb78ebae36bb8870f970ba2244dfed9e899b007eb9446aa65eb36ca1f08d35a31a06e59ce7b56541884f09926a433a40d1621cb735601a77e9acdf01fd1ecc6cf16bc1fffe3cba6280b1297803e62b269022a0e4ceb6c71fe9c8f3d2f06038b9ca74f5606a6370c433b638d9a6b7c48915ae30164954656f48897ade4abc5e2eb944577d326bf2060cc7c66950ff5fe31252f263e1bfc86a0bf556978795dde93053a63be0d0ea5d168a0c10e8a0204365c4a86f8d904656ad582fab48a6f52e5381bc172911120fe3956d6c2458422b8b2eb164d9742f4b9ecf6fa88a4c7bd3d4a3a2d081099aaaebea9a84152ff33e34f7ac7be2f70f0774042c7b0f4e830e1b9b694dfae9842802cebfd50e13669f7e0055fdaa274f91cd9e2444fb4f97f3e7d1e5d06b1ea096fedfb8b36d754a13c9222f91aef21f97e4aa7e1b0d867fdd6285ac5ddb3f8fed10e9a5f7f1f7167859e6af83eb62eeedf09fc824af8d1c8966491d1ee00de20c91ee59bb4d831ba6b32b10bb55bb2f3ec0b41b40818f6b43367d47f1a9a0a270206baab67debba5021a5a2d3f6555f234f958032e04be5de3d84009440a86f26c7ae4aff4233e4033f1a64c196ea9ebca949ae30e5d1d2a850afdc0c23882de69f2fcbbee454d1472253dc0d100597e87bd19f8efad85d9ef2b6edb34f381f708b161737547e1ebfc5f0639c5fd4400afd66529e2bcd7c87db6b97fe51473c415a0f8f09ec34507f8a6c688386dca92e86ef28fb562a636337344ce295138a113145b07fc5e6c521f8fa0c63646759fa1ad67a7df7dd1eff27fd78a3f573a30dfe70e186bbb634227fea7015961befb575618d81fc6071ad3baafeff51adf3161d05d21e825aa92dc6db3fe33148eda5ad463b4bc9593233b4760190f88908999f1630b7a81c26d2fdd4fd499b0ad658f0f91eadc398c12c41571a217abe324f60186812b8747dd307490782104f171663fdea8bcd65a15a3a60d80a8ccc6772c2b6f416e17f5cad0eb8ee13826a56212b6323c6c1825c2054068cc5bfb4abbe9f82b92b02c7859239c6b6a78045412f2f2d7c18a3cee816a73834b7703cd2ef1e8e5527eeba397dd146d91e70d4afc43d76e3c4278243c6681c2ed7a8d16e22085efc37c84618a14bf80a3eaea93b51c0a0ab4ce78a74a24d9a876d4119227bbcc7460371229574932547c961ad7dc675d22c2a00c54b6f029d14911df55735e8f8c2384be5d657dd1df783a5a75482e0c45fc90c144837010cef4a763d6bec3122bc9c54312aab8bf3c612b5a9bd6b13ded3a2fe7703d78add0b4fb3cffba4f8e10c9120375008edeccaad1675bfd5fdf60dea2fbf5d0fc1c26b1ec0d7f98a7a6a1c2680a2c7534c33c6dfe5dbda814f6f9a1d121e4f5d71f9b5e6f70513458c4b180fa6a93ecfc16988036af2b04aa1a27a921cb3662626cfdcca6cdb84a885ecf7dcffe6995a52ed6b766f393d10663617143f31bc95835b27330f42575a89f97454a896478df58fec0fec8d6fdf7a181e75ac9b936dfc7d940ca60426e9032eae0c2d755fb286250bc456f6d35b84b723dce92a7e84d9be6266680d0652f621475c67d939868906cfe89dbcdbd557c6b0286bf9a443d50c87381e1a831a3248dec651327ef4c2f4c2355dcf6edd621974dfaf9155452406dad966bce0fa858624f2aebbe8d2972ca552e42fdec74d42064d6db4042cb252c70feb45297164135a492f6041d24eecf2994968cb5c92306209294d4db74a6e0a4faff96423d5da8846a236e440963c2465de8b7929c695a084c6b9c8227d387d4ee412a03f6330ebc10290d065702e0ffe69705061648832814cbebd2f5f26cadad94386979b23f2b595b7423807642a1d099da92c91f60e3bc2f0258701b68bf7573ca2ea6ecf4af6a921d5a1f077c484719717af4a211254394a0b6e40aa405088069c37467b52024db9cab8005c59f5d7d4f4d3efe3833614fe5adfea4f003b830fbfd3780a67e2259ea601f7e61f84df87941d2d19693119657e18b2a8d88dd5be702025dda3ee9e762bfbbf8862d34f86f70b0300cb543f17f27b8bb1f2eb713060c2448809cd3c4325c7b8d5ae10b4f565a3f59279913c5a7b8e13f1cb7b52db470a22720b90c65f6b251055cd4c7d40fe31517cb16fa909e2e208013b15ea1f961d8e0e196175ba3b3b4c3cb10e1a7bfda0651648363742a31c48de4d1d4c717eb1cb3b9bd31c48b9f6e8215707ed8388cdf0cbde59c76fa9d40d154b132cd03dd05950c82aba0461b2d9d3dcb36d779788a4e45c964ebe582f9b8a63070fb2bc2820e799851714d06ce68d73794188a401ba2652fb340cd8cf7a8038bb7c13f822f792af529bc082a05ad56fba7123a38f48b01bf9e713e730a6f0be7c4f7fd196e23e83c5a75b508224e4d480da9f5ac25a46fd4a677311f78aafe54265c1c52ccd9d213877a05f376fc07ea40bf5c9c589e1dd1da84c465ed368b7f17bb7d6527fc576af77afc22050fbf0bcd777f4b779a90fd1beb2ad854ea558167356d5c010f8ebe7e00327dad247d16c83d0d8deaaa6e4893595a47002ee0b63477c9a8c1868ab9c661a2bcca8221330835a9f92a7a9b1a5aa77903b1e817e3aa5ba99d56e91212a23193234f1d18a47426037ca79043baf9dcaf7c8def32902c62ad991effbc3214793ffb7e2b67dfaee7fc912aafc71512bd946d9f29f47d01d48ca01595113a6d11e36d04bd4b146ba3592ccccb3d4e7fc98bcd6a4ddf57ef341a750cb2fca4e29fc5396ce28aad07dc9d12071bc744d668c932a1742c612526009e5f94c92cb99197f9e7c1706134e74e5511b674a629f39109ed99e7d8ddc028b6ec076a7840f28e34c0345e2d069f7ccbf79a2e60cf4b87e849ed76292b8c290ae8fc45e9b2ea3ce4c493e163dd5192f1dd755e415c4c4c2c8eb81e7bb14f9d62bedfbf34ebc8290bc82a5fc0136f59c3403e9ce6a6c4d756bba8d08e65373c6c8014d66660fce8c18a2b70cd17617485c5685aae42fd794627a66dc7c4da5d288bc97c0b5c673c127306747d835d34916716b7f3ca6372a709184a5f86a0bab2515da1214e510241fa6e6c309d697909f2b6f38aa0283a205c091749a7eb8017ef8f6f8d7bb948c7f399e6a7bd04f62f8f52de11594678c06930e9c5f6514946b5f2affaed868bed3eb8192a9f6dbeb46003c231d76e79df546665c1d80409559842a93f9413302c29696890f21699ac86c727cc72a62a084fe4bb041d3ee5ae6db162878282ce6d0ddeaf2ccbe359ca5d6bc6309645e74bed2f206561de866d7ecbf151179bf9e6d635bba7b7891a87778a233183822c0a5e908209e0d0b8ad4d92d720cd798d2f29add0e7c6886869b575687ac4276cd8014cc7ed0005c04b2e0a5f51563180ac8f1b34099483760196230a3f3daca1bbecd57127fdfa70fb6e4b3a5615082b91e7c857d3c7007825d6dfe5ef15b33ad5fc2bddf0bccaec8606b8be1bc765c013626f083193f66936fa5d465d36d4ff95315493465320fba3ac12f55bef804425732c2b45673f348699d16e59a03e1b0cc2ad12dfdd2130eb482c97dead5d5afe64aad37e27520498951a63c32be9a7725c5e121336be1492b4e3805f2453a89ff74109f515c3d78d28adcfad967357211c9e6734350f2a43f4d6ae8b12ca078b8de397c7bab0961e933bea8f399f59afda317abb7931ef6cb44d5eccb44353e2d5b4b5356f8c226fffc91febb8cefda3c3c7f597c8751991c542c21adef3785fa3ae8ba2e2b85486c3a616bb9970b93d3d608bdbd96965299d394f3b434bd27ee0b20b0c1b5516388fc9b78b29580e0e498cb101d9defb3e288620abddee3bbccf60822a53372ddbe6f6a5fa08d6f23c30d5defe5ea203cc437f44ce5f01bd15c2387561e6d2a83f24062759d72342538b90221f82199b08c1f66dbe9a181bea3b5b6646a4f953db44398c138c6e776bcf7f38b7eee2fced4b12895fd2ce5d8665013fff9462f3e4c3969b15d7c7df282f62cec20279294b59ba73dfbe205a580680991848b4798bb679d227555639fe71984b18bf6c82f45912a50f8615978adf75a43b2390cb8327920bca81f7f6e54711af50410f4a46e2472ea060c168caeee70e2dea3302ccd0ba5acef38ab13188bfffc651aca0e08b1debdf8d71d436f9b787082c535d7ec0bb3cd4b3983d06a810bc3af0719c37e0e29e29cdf7e8540ad11dfaf317708a1accf8b07882d72485885d7f279b3cffc5a7447ce295c819115a54c1dacd8ce1c1635d275e80acf50773cd076e8d34e35a8800b7eb55dd443355e2a2c9477ac34aa2c8de1785017bf8bc6228ca55c62ec2291577b59f95ba21e4516090f734f5c7f5b1921207f90582179292a6000b43aa277e76458e8efd5894356276c573c4dd7e65ecb4803f7e70b76235b6e6d43dad322de71aaa6ece9c445eceabead703bd2ee4d0656838d0170bd3c799f6d0542a8aa05bed1d3cefcdd70c91195f145254a40d57391551dfde68ed488c60d870c821a0b48febf4f08965dfa60842ea28ef438f29dd72152d996ce53a0aecd7d09059ae6d4f4977f6ab3c1135c12ba03b0c539810d499161c1060491153de3988c15bac4e7481458e1bc421391c2abcbeabafdea33ba776081d13c5ef476a89234d304d075566904d5475e622136224ca05759c3387ea9f88caa68e195e01f44d5f9155ad48ab72eebe5a875b64ad7bd932ebdc59b4f608443d09d83006968a82d3a4640c1b3b5501a9532f61a194840e49765625f44c97af8d1daddf8f2812457f690af8336817de9d314c52d83be1e2a2e80af29710612ac967feea6cd1d6c62a269023609f28872e8fa7344e2165f192e60518416eaa3213657f9141118546e032e0c019eceefc27b661ff2322d1fcff1b0b5be103409e1cdd8f464a19c7f7b607a4bdea6b11c2079cc9d2014ec33676c6698c89a604bd897b0fa5c1ac24b9b407e93906c286942e94aeb90117614cff7409966819348974c718294b05acc3f028c55e6ddaeb0759f1b8c32695d0a6a25cff23dc43e76bf93eb2f4104b0dde0d89037480c0a59bfe23789afaa6a91ea14042d951630bb178c6ad1326349145fb7acfbc0311376bd45a198df2c2dd72d6bf5c5aaa76557e4ebc34a72f75094431510146dd6755ae3646038e8d80802ddc9f5568fceb60594301ec1c72ff05559d9b80b65da94161474be1e03c2561c9bc38808d535276f1fef57e624c701fdaae487c2a056ea66071778fe6b3107f37686aa773d366cd7c3b9db920266a8a4d9ffc7ff3f87522ed142b04f7f84ed7541432fa7640cc5c33ddda237f8409d22274349e7e0cbdea084dad47f34888c5c3912b556e0693c2ce8a6802bff377d9da4f2bc6bdd2ecb6a47325bba5a83013be64e6cb063c9ae17597c738363bc32801d923bca4f935b160a347b38bada3e6281d8f2fa461f3b9b05221290431db672038ba39f5151fca81ab667b5ec9c85744788a08a0e09e043941e46fa87bc8597507a21eb1cb2fd9de7df6064a4d4244cc2db7715f42015e0b4851c340e05cc2b9e87b112c3d72acb67b13ba39f0c80883931696ceb20bf4f26e083ea34d77b6fb42aa5bfe2dd5b505df995ad274253a5167e1f78e1a4089f4f472d282eec3b0b30ce3b0706009fe5bf69d0ddf33e8e27f062381dd8159626fed2cb25b671df60761148d8c94767a73a09d11ccedb162ba53e0da8ff44942ea51f4c32b8e0c4fa7cbe25530f51484bfd955dbbd0ac452d21a2bbe2a27356500a2ec37dfa7832c3c7004010de83a36f0c4fd52810bf6a2af57a2bfd3802703678766cd6857358add9ab37fa12cb4dcad7998810358121134fe9ac380b875f38fa0f483675a778ded46419dcd64e91f10fbf3735f6eb30ba6c2aa741dec2863a4399dc46bc6cbb0586d4315b5477b8da92a6a402a10d5bb7cee5720215a529774c8e6465749d64a14f17fa193a0e0bea8ef2a2255920fe0365a2b127f7a4bb45ef0ff556c643f25c641049025da9060c2d2083a1066489261726c8f495db896b8b1fe77668f0dc6791c63bdfd912d1f175316c070b4274aebf885c4f6a9cfb924beab7889d29e35a9d27a42a9e23a6ba62c3b298ac0ed8d8658c41c1a807103e19045703f3132a8b576dd7b77633c386365f6bc8d40107d1130bcfec1907961dbdc3aac3d8f0aee8f59a459406a68fc5263307754f6d5801744dcbbad527ae6d96e80d96a1fe01df558732b9163bc4a0ac0fa77f452bb9b5eae389359a45783fa9fadba3957a4f4e47585953169daa528702970d55c1b202bcb3a4213a4b69e5c271a9e76221a975715cb779ba198a9ab44afa59b9061384fffe9aeea8f86c1405df7eb0a2df112ac5bbcafb7f0e32c1dbaf225e094a9edc8408e99277a3b11d12eaf40b97934a811ac4945a4a8cfa597c19d92e6b298070505087d1048a68ab588e46f379e431e3dfc544d3ae56ee8414030a5b76c54b592d796ab98a070934513389301573d62a7ca8c103d6065e0be79ad6765a5115f6bb455f74abd58cb0f042c752e5e62d617617dd7741d5f669eeb223615f91065a2020de9b0f67c48088f4c544d263dde870638ab54f9f5f6d91c832ec3f41bfea8bf2593720b15f56114d1b05eca9bc6f7a468a3904ee7daae70e9ecebe21a8ccce5516083454f2bb72297e98fdf179f2a0edd951aa3b205d8e28afae8bd1e8b81c567705e4f751510f205fefb9df0bd48f347c547091999b27472e0678d8137a200e70a2ca3a7d75921ccd7c947af0fb1dd567b2f1546a509d6635ceba80f68ce28a28982ae7c0d77f1dd8f7defd3bb2709932be02391da42ea136bd05891b478c6e56570e727582b7c339ab5783b21c8d7bc2e0862490cf8324c2174ce63bd8f277a033511c08e2700b9ea4b9cdf3f91c8ce283b82463348ee43a1bb392e6c34e15fdbab71fc0b464ed935f77f3585e1ff1a164ff9cab41a8f4f60edbb0fc684d0825a048a72ce4ea469dfba4902c9796886b838960d6728afcaf511c5d2fc72c417fd00cf4e525cc49bb8c3dcd5dba1dba561b3520d88163b3050267f6fa36f2b6e9cd82bf0aa7565ed9881ed084850d3cd392ca550c2f8ffd0ca0efe1b84e8b69981be90e367625ad9bac92783a696ed2af5c011af6df684ab64084dbf164602b32e43e56580a22c6981f8e223430a480230aab72903580b78e0f2744db932c152d82223afcf75f9a6028cbbde846f8af096ae1789ea6a06bccfe640518d4286f03c6f1ef8071e71adfcb697102ec4249b3847dcd92c22afa81457b0f0392bd5204247c1e3c3fb9f6b02429e481c9494f24143f194483bf2f1018e2cb94816cd14060f90b90dbd70287a22e6f2b32d92d4cbcb6f0781d819b4eaf6bc9946871d9466e6fabdaea03644994400905e51944f8764d198ae19eac6152bbd6d52d46833f6bbf7b01aa4cccd47e66591521a000100ffc6dd819678ce92776806926d622e753a59ae8d98d05a6f8fb34c6a431ef6137d29eb20a18a7762afa7529b7bee61540ef2c23a8c8c72719fa6c623302f85144b1dff8ec3a94fa171dd8f2a56b51cfeda2511fb01527e119916683f36af4e92c0e7600d5ca0778821e7aefd0fb4cbb217a7cf64873ae4196104ab215efb2add78c150f2af8db042f785fd7f9bf02c3bf474d549b7431d048ab0617d7cc6ccc5e28486404233aa2bb589e05b0c5460473d5f59d76ecc017640321afc6418e36e16c63c3593f110c4e35c0f4c66de564c5668fec1ba423f91c46f00c4e2e1d7aea2a0f990ed039a6c4b836415dc5c07620fa38a0d92850eb8597691359aa4cc2db18a20b9395791cb210b8995466e53d48aacf33ea3483fa2ab578b1454519a903908627a909bfb046a2b8e548cfbca93982b9d90fbe2d5e7beb3f2d423c14ff2a1c3cccff957872ca7e86aef2746de028b367a40e9a39529a553f4df9151584a7eb1131831c642cebe7e04e53c17dbcfa75d6fccd09d3240d63180af7baf72efb014850b2c66feddef0f0c01fb637fb14119c2de84241c9af2a5f375bc3af8a72231f9c9cf2065921f9ce47ea0e4604dbeeedbff255e4e51df4581f18e87d6601d8b111eda8f231fa83852cb8f41f61b92394a424793f93453a7da3c6e10aa5c99ba49fce0e819da491c6f2be5d1cd65806739fc03eaa1bcf02e9290b3da7ca076c15ca68de215229b62b1b11a15fb4d6765ce49a2c3f94d9202ea4fbae2c21339e32c04427c321af570805cbe4a3c0e68560088b9613b217d51ab8fb818b0cecff8d26a49f856c00bbe168adfd924d196d9f17205fff0ad17cf81343adc145bc01c68fc829f144c28dcdb7ad57596e32abb0450d5b6e3a11612026564e68f23b2149a080d4a7cf99dcfdbdeecd4fdabd1fd1aaf61400bf98f350ffa3d01ab8cef48035917c508925e21fc7e535a4ced87066ce9f8f54dabbb6e9b656c3bd8cafcbf319f8745a1fe8ab5afa4a6eb633908b0cc948c34abb55563fb8e6bb613efe1528bc3585eef430fa5f1fd39ae43ff2d26783bf2f4b1856b8c910311a12021086b2ee6495d52dd40d40215a92fc4eccff992acc1cb7dc7a01b597d5c4064f66eb7598dcf6ccdc9a633e0a025054e48402a6f768e7eff3832b3a077f451069d8e409b7c0783091ec1044f4e21121e08b4856ad544ef85d9ad50371f41163a01201cf3f805af37c589f23cfe367a347b21cbb963a61b03fcdb369ca9409d229ccd5f6b28cce951197e8e6df744f1fc7719d95ae8c08fd8e3c630376697e767c198167803b3768a4fe5620b6976636c5413173cc59cbd36e87900c4c28ec12abf6e3a244ccc7055e5564b213bef1654997394b81f4b785f674552e7bfb2b4b5ad6f839129c9ce027a847f29cc41b0144da53f281a49ae9065fc89ccedde4d65449e614b2a94f2b0d096e472dec9e0e2123a9adcb04ad2f66ce9cc06fa800f2ed8bfd846188279b9fd9ea171684073d3a1268af444cf89ea0cd86c04c727059edeb48a50baf41e3ac68658b9e5669041b6d7a8925039733234b31245a8ac1f36f679674157cd032dc86903176f891fec82e10c03893f4278a9fd3624f819c1682cf4153771ffee6f34852137588f1e4d80f8751bac5fcbea62f1bd4cb07a849e0afb6f6f8a5973a6191b2d70c806a8f146b978d76c50e310f8d4b1b4b33f66679350d5d595a52ce1f30b51472b89ee0169765457e6d6ab940f31ed6bb67125676b30db766ab230d42605b0d84b4ef6297d8d4345f77ed6644f44cd7d0e237f0d7bb2ec81ff6030ea5b86a3f85b9217db5c7a8acf916825c289c657f82debbc97b45e3e3ac37dfc7c8ce7d5df81d84ad045f5e62334a3a18351aa66043bf3154845802ebf68d40b261b675cc52d82e9afb4a76afa6a110dd90c97f8c214f353d712e9dce14f391bb8d445c71a471e16b84178827b172f43c79ee6e55770d73b5fafc6de2b4edbcbd28b705574a6e2020d00b6c1a2f5fc0ae066d025cac2d72ab7117f0d8101199c4bf09d44b5d89493ed2ea13e4f63f49b6316167c735ea9abeebe44105df511181772ed154c138b43422943b7e7541011e462b864036d1b77b7f3204ec2673a7b08d503fa88d845ce0ccb0662c4495d06ef2334dcfce142858edff03909e70ca71ae621fd76143039e014a5c0b9197de32773622b686918aa585bfcbd1fe3808ec746353d5977965f2b065b5faaecd35d68cee64102dad3004efd929f529ed707acf191826331fd9affaf7a3f8734194599e89505e3ac7a3f12bc20626a21400028a42d05bef3c39e7843bc0fb1c30f6ea3c0f81594d3a49d5281fcb25f0ffc6cff0b123e3399cc9259d4fd2f98906d220d8bb315d422f42101a3fd311e1ba7565ef6f12166e0270c91a77497121b9c7e3e097649ddbfb8ca8dcc49e4c90fea6c09f2693ae0cb65bd9f479da3cee5450b2ecdabf571b37952ec8b64ef5dace0e7c3b41d1b498dbde1f5364da3e62e74c60c7455aed6e5771b6fe40fd008f39fd6693863e0420661d28c704bf1e09f896d95ef1084872a514a3eba9426172984ceb10725c4718d6b22c113c02589b25051f1e2421025e33222c44d1b9782a3b702d964ae191e536e87fa65056dc9af79946fddff04e11b6f4bb57d9976c91a594e5e2d26594fef96c7d7ca3ba25e6a7766c35662e5cb9f32855f63299be01233e79423a6249b59368c87890e980b187c2cfcc8decdfb7060683da7ea343039ee0814a26c67318d68586ce9fe218c2458317d5bd1ca9564916e288a96a92216669e164574fac00ab2921d676a89bae742fc20e65fe84e57b3ab8398c76b056a855b5d0e7e86c30529108b8f8220af324a2615521bb300d55d83b03e048e4aae168817a54860bdda3370622384d516341176075a435c53ed54babfa224cc9f862afd181873bb05b0a5594ef7f91711f5f857b8f8a50b529246b08153981500ecfabe57f2435569f008b3a34b852a1ada0bd5f5d01cbe96f257157ebc10d3026e8f3bfe32c82417cd9f60c8d3007eb968c4f77abae4bbe9666cc1bd322c21f4ca08dc3b1e8742893fbe05d663b69ec5ec75420f1a3bdf9a8f2aa58a9b3b1f9294651e14cdaf6e2a797148e2eed5c75c2bf2b56534504dfc6cc5375c8e20ce5245effd4c1b5f9b46fcb0c24f24f4e7d49ce87d272485f8a53d39cca0f1ab03c00c3716e81c9bdec97a0a9c7fa8c32c4343ec4a47c73c6002b85b44da08f51167e4d0c1e073669df89afb10c7cc5e014c31b75b16c9a6ab54619b72a0d626a5cf83249c0fa7919c0040eee33bedea1ab1f2afbb9bd67b580af4448bd47797734a6c41bd91f368f2c624d72d5b68e057c93c4ed0d39d48d781e9bddee5345a2c1c3fc0165de86b4c70b09414a24ef552147815d3ddabe29863c820d2db7fa0aa29bb9838f9c791ddc88e1533f3c2d363dee14d307ad737208541cefa0a139e837e0e817f9c2b4072aa3cb5ca4967361d374f9c0819c3b1d7e072e7648c0d7f7ff7e7d118e8f5ed1bf63b68fd65922b507d7661df986baf597fd44d2d2b035f9c39e07b1fdf1c6cd3e66de860ec4f30fb0d5326e0609c349bf0fb3116387116f516db4e8a30c20a93d53327a17f0740e39b8576468be583c2ed86922ff791489b260b6d56ce0a41d952fdcbe5f16ca94b045ab39626d958541757915a8635c06b779b7e96b36a88a3484444b1f57e8ea23fbe1285e5e14e42aaad7aff5b1a69d199e47b0d687de021eb988aefc90795d11b56b08664188e0ff037b7f58ee4125599aa418a683f24690de540789bd7383dd13a2309b1eff7778cd534ebd68964d8d01eb5885e7562a7639707dbf59d78d7716d201189c8c4e93e20e721c68109178600024a87424647b6e501b1fb52b7ce84d561b803fefdd025aa41c708b1e8ae43823a2461b44969d71366ffeb81cc4d788f7c1dad43c975dd419545aa5ed97af3222858399fffff35b7b3483d914b1785aeffa9f690a6944b9a7494dbec12a90d0de7d828dd06c0175adad62e2cb9998998da17be57cb90740fc222cbeb8e96a2915982491605091e988a893c2c14d8cae705008b092d6a8275c390946e0d5a660663694914ca6e8a44ee3bcc7ec92fe1205f4e43be42cbb5acc597082c5f762ce61539e1145986d0c9756fe60ec489c2394fbff21a70ebc2a78a0e6b39bfec9d75bd8b293d125639bdf995e6ba6ddebbff2fa502a3bb05ac46e0409f1fc2a1f9b65e822b361004506dd599dba8b345ea481cbda25b5baa8aeba1fb8afbaebb7794cf2aa971fba0a52980bab621ae8768e87f5db8b566a8d3ca12838683fac588d3adad733297165fa56ac7dc51ca6bf25b67194e2c243e16442f5e79c3ad8f36c4f61c3c5b771e7bfed9aeb6c705c3be5f684cfcf6289116a29423030a2a4ae1dbd61fa0256e33c7d139399bf42b611eb531ff28ffe5b273049ca20cf79d19f0d4a3e699a6e790fd48a981efc55c9948b84fdfd0087b8462b705f23bf4bbaebcb6d77b26ffa792f02bbb8e1e33f3058756b438aeeecee96af94a41b65b817f9c65ce14534f1b36216d4cfc77e2392cb8126dc7a79db46802314f705a2857656c243a576602ae18c9eb696d2499ab99ec62a9a21d0398cd4a22075010bf4f6e9a01569329b1b02e4f4581fde19a36aae85257c0a09ad86dcb9557f752be5947232eed62b23e9fd4abd0ee822589bf8ba042099eaf1a6a5b3ba407fc91af97ba5e71e65b1a3112ee7c7ec92c111e6de375ccb5f9c1ef0435a21cda2600808e1bee4c9771fa689cb2e3bd8ef7020759a895f3acf1e636f38098a7ec4114a5788b0add12bedb9742d462659cb851ac2d11ffbf5261badfc2d490eac684a34ae70d0e97a0ffbec3e28fa350de3d2b4348069c9e1e0465034836df87005521c79065619c691948bb5e173256b9cbeb79ca8bffb758c3a5d6f7cd1c295b53d63a4c49218fc2801cd882b0eb3699c4da67ae2b87060ab3bf0278dacaac8114a07755029e2926b66a085a715da4d9fd93a93153acceea33929ef475327a2276791c5b31ae6136e0b257ceef3cf721a47820bed68a6421ffa6b6009625298213937447c73ad3dedfcfbe1cb8640c7a96283e309ce5206f6c35b081e9d65795ae77aa5cf49cccd7e4b924fb444e0eb915cce5ec226009ef5169321a2ebabcce71f72fd18a9c2ffdd985248f4154a9f5426bb69364bcfd468a89b800a75d5d53a645c1911e255d327e0087e812c52ba5b6be1f60ca6a4c0a6a4940595b5893c19d32600d1e08ce3ae762d24e05a5bdb8efc2bfc286e8f0fbd91fe062bdda94e64202e71a647e614e31dc5d6fb9d3b3d02f2850f0b657c95e0b443ac0efb2d1d794c2d7f5b3194bd380967694b13de2f00f32df55e7cc83c8bbf3d648d7574ee67f3567cfa4b391d81dbea12bf6181d71f63ec09b1a03a7a5a7bceee5696a47b125a223580c281afc27ac470ae43b188e4c00ec30b7495631d668e05edc40e982be18a0510ec498518021f5095fbfb24e882a5d2f0a86679ca19ae47a356dcaafa129882af1babcb50e2ea18cec81394b2eac342baf8ca14a3abef3198db97693815221833b04129480230230e45b17137a69504775b553be38a2775ba971fbe226bc6e84e33ac7e7615d2160b638c24bc03ba7b98b40136c6d7f9e38fe0192c3444490d152a34444f5df219f01cc6745b3ba76235797492d57d4895f4f11c6a5f559b051ffa75fdeca04193a3eb56666c91e352723d89db17a163315163f667c54c8d24dfc96f67977512ba5e9d56b00372cad69a2c52b32f493053006d890baa3df53a833f1fba4329b43ff152d25ee6f27663ad9ba218a6faa0c946af7e6f6a7a8141703e309b4d30f7396e784f0f2f53590f10fdaa77a55b6bab8b307502fca16a3e13f4eb315bee3a9cf6508b227363e23460cbaf3c1f6706390e4c59a7c6413fea8a2a09e0ea20e42593297ee9edbea98ec8c241d37e7ad046b06d4f8dc4041a7b782a06a8c680f5fef893ac5602a0ed218898c81e391c38fdd8971d65881de749829908b4d8ebba0807b40ebe665e9dfa8711114e72830a1ed9612b52d526bad904fdb618ec73a5952d546c770df07df32cbb98c42b8fc40be8afa1641575841df3f57295d77a55033a1b845703567997456eea86f2a557613906cdcd1d5b97b3fed8f148f4ab41ada04f68b4fed4f43e409d0d9efd9c38da36f15ed12716c2230dd43442d61126aac8b58a8470efc2c72879abe2f0f4389cc9ca5113ba7819927a43bc2fcf5ab8d93fce214bdd92252186540ebc4e15f4b748a41108718c21dc450c30de251766b7d55848975e4efc2593898c70df038b31cbc9fd02d66eb08f818b9a04a1466e1f7be98f870e5e16af100a9b763596605152fe97b3c46425a5c8530500d42098e4ce46d23339f3c3e6dc41eb4b98a033bb402d340e0892cca351d804df8e43b50247528597edf3224a307f78c328815647dfd78ae459899689bf869f2f9311f03fbb9e7c6f54413e485b43ad35998aba194a059fdb9601692c7e89d12d5309e285e472a81313727932c365e40d572e978a7096513cbedaf7b18149e404d138bcbecec27d265190a65422be5a6944947ea38561cb020e7a9c25abc8f4a019cc7a69ca9ff82472fe18ca5346106f1e1e36783f76a502d4b4a970aca3f6e6d6e3fe472890deb8a032eebc494353706f2856bea019e7998f39d2d50e7b18bdd542f6f42c3e127a26bf685b1adada199e8c729380f00af95895a02a8eb4891984d66f06da442894d5cc83bb37b1c82f93fef65879908f7abdd1fecde534be75a011499d3688b2e4e1bcecec586ae3c9c7d54b1ce0fb312693df183f6cd531591e8daa4c7fe67b4d4d7f1c04452ecffcc9c285ca3dc8265217409331464bbd024d512869866aaa485ac21d4e24a12bc4db649095c0f6f80da5ed839b5db4828e069b5f95822387380731677ef144521915ebf0d4274c9e2dc8fada0f7d4ea3713567de101e238d474a055a1c6144615daf1ca4af044a96ddb554214d4ef13b10d4b31e5206f54a26584c3a117d4f9dd660e8bb39aaffbf46a6b697d88b2660e2049bb658a2d593ba3b1fc79a95fbe1a08d54dcb90970dc57a4f0068c6f748a6836239f7723994c3b349662424d9993b8e8705f0b95cbce7a44d6da8a8b43b8d2894cc381a2fb0c9369db252f5cac6c6d9462190aa67b8b649f8722e5af05040285a1e57a52766066b40fa02deba9bb206d0d79c40beb622315a7a508993d65a418ca0828571907c543b6da091c625d1d7d0f6040cd2cc340d7b8c9ceaadb7ac3cf0fc71f7550c47acba09273d72349ccda3274d85bb1493a45522b4fe87875ad9a51e978d0e8500dc1f26418734d0e0cc2dc9a19d14f315a67727bca592d203e291df243b7d18ea4bb63a64d3a8295b5aa862816993794c98f2308c89879faf8ed432a5715975d6dcc701870090558a441c7ffdadd7052e9c76daffc48a9f14b4e1941c5a2696001d109abea36d9e1d42e819d0fb29366ac1690570d7ed00bd565d5de3c2a60b1fd2a5efe797de419ec83495c97b2a9e37a37bbbcf40493ac8b70df1dc3eb41362157c360f54fa08c8e4a6021fb2f7156a60dafba454d9d16b3f800e8a278e91f288aee1fdea46709a45bc33059fb338cad347eaee029c2e8b217ec5f6d19c2bd44d6a7a32e850c36c962f67869d2b29c897e7cf2886e9d1dca03dd1d4e0dc263092764305f829945486da5ecc8f546271918d133da69ff2327f815beab09643268921d98f72602774766602b925c664637777e6a751b8047c42f2727b2541c30bb8bcdc118546af64eefebf760ac5c6cb945ca0391e21d31bc1ef09628e142e6ec015031a007c6cd7575d03b2a7725a62922b6a5b1bec12ba775fe7ab6c64ec323bd0f12bf21a472376d52a9dceea49d7d491988917a827051924ee0b4aeb7a1725998dfe10cb3ba55c166d1130fa89db61f9774d57de72df6fb6c21dc960711a0d10147bf27de4c9e481101f53317fb693e5d4cbf6b1a655907a5a9097ec75cf661cf8039ea29a720d46c3b40f6037f8015d64dce9f90b1a3c1527c5f2ba7e918d923c72b20f27636cdc4416f09353e89194807caed73d6ca6e8509af75f815650c60e0e6e74fc967c9bac3837a04d58086d26c4765dd1fd26b0af8144be8cf70bf2429fb8c7b115c1beeb60bf59be037dc55c60f6359471afb37367594b2007cb593a5de5a7e4a98db8ad87ce383c7a2f74d111a4c8a1180fd02e5cee0a08f8d9b465c197b01d5dfdc7cd8ddebfb140609e792d75f312df54e53eef87a8a16f9579c4280ba17bd1f7a8561661f1766a205f611469dbf6fa5149fc445813a089d30034756cd2205e40663217f3dcf4cf905ebcef3419edf8312ab9182a29e8b196818ae4ce5092615f790a6ae82c604121481646eee7cba31bc52e595070a9045e8ad3fc359877c7ecd4808f72658cb4227485f287bb60ee53a5f37839278711401436ada86457c0d564068f78d8c89c8fd93d574e37f2c8e352f79053957a4bba3e8c3f96f6aa2b4a041af913bb3ff888c68f2a0ac65d8fc4acf92556f5cb91fbb6be97e58bdbe66a2e798ae1bba945ce6ac208ce9592fc397b0a6e0e29e0bc21136f53dfce83b3da2e680f2e9dfd7c0cdde680aa14713f26e1c4409b3093f924e833a0ebd1334269dd924108b31efccc4b84429898d82f475c8bed4520c5496070bfc8f039c9ab49c2d6e58ac79b98efbee84894cb050039e4f60d0c4e8f971c61cd32f7bfe58ae8abdf751103b7f91e6e60d540513e371b6e508365a64f8704091cc3ee4dff7586cf65936b5a1c37c91559303586527e1df8fedc56c1cf28daac810ed788873f5829ecfe609ca137f7b9788db49c0c82b5cabf573bddefabda4c7ba9872044a6ac22426bb28ef62336a2fcd80932e894b3941f71da5ef363676147202bdf09c2a23bab4fac02d5fa52c0bf489436d476aa367ad85acf597ea89125073c89fa8abc863611526f8a10985848c260291ad50e8a54249025d4bf5b0fadbdd8c030eca91843ef9427794c569ace68d510e1ec6cd89807900c8cec1158aa3aa7bcffa445ccbc5d10f6e5197f18391acafba50b2b9e39aa0d05340ab1e9278c2a06c802bb4fb9f6c45e116036fc4ea579ca7574880789c50424fa1cd1fb94fa4ee70fbe8a671c43f5d1e0e621b539f6b222a5018cedc0fb900b8253d73cb5977d5a24f9d84697eba1dfc324b78a41605ea2e235aa560b593198796689e11f1338c6dbd21035a96dd5ba458cae0231f9cf19827dd056bc84d4335e387ba482b071e6d2dde019531f1785aa9956c9e5ab46615eb15833dcb9e43930351de62aa953b51be2f70a53425e3afd2f56404fca594e5025088adf3608878c71ed3f05145ae035b107a0401e82f32bb9f1ccdde723976fd12ff3c937bc8ad40456ef106155a0ca0dde6c40550dd7b7b69d83d1c640da8551b91e3ea5eb7582d672ebebc6fd2bc0265040cae2d8fdd10c1a9692c1f2e6da107a1b20ccaea7044182887ccc5cff2d2791c8dd3188198c42b589767c02004763cbee6a974293db2f286a42034498cdbb9dd94c4f4fe2a88214f35c3d8917af2ad36754de4df986990e94e226d24cd94ac6741fbae87289dafa72efa7971f215d94ccf5b03465bb65c2e5a9c619fe16249b3ca3fb6e4725776a499470a98e4a9ec2cbdb672d732963dfc881f0e03e3f54f109109abaaf3f1081e83d89b2db2ed71c33bc116318f4b89eeacf06dbace14213f809d266959251dd5c5cc5b36fcf8adabf76575d3083cf2f42b499c23f0e24f4e011c415256945ec7905f6cea21294ef02b26770fff2367eda2a95e4a93e8358a765c35ef6c04eb831014816fa46399cd09303866a213cb9906db3a22a6992747acc28688c8d3bddd836a54e4e54d9c86f00bdb32cd17f71555f65dd43eeb4fddefc86842731c5ec4d2f82340615075c46f74dbbf5726670b846e4c328f9a40e74e3c3387c6632b6e342741abf81a48bf0952581b99063370622c64d78464bd2b8a5edbe7abcb4ac6f4c85c179238b372ce9d5c9b28acd70b6a4d3b381fbf5f97026bccecc193e1e68950a823864be2d170cfcffc17926dd280a1c0b0035e8db60344da9a5fd7afc2a34e06747681f170acf0b66cfd92d518c0d91e3c3a9b0ead909869a4b2b515098d7a3fc3cce03017f9bce8cc1b0989e2c9f6c06f97d5b09d2c02d3319f58cb1c8e774f5cb7257d80b3741d8fd625183142c81aa53996b3e6ae83574637a4be35a4544a38d32b3ce3d5d17ad0bd98e23b3ca1a9d2c9823f1ce32bf31d3607b966e1ecb24a73346c1f9bd597568269fd50f622b3eaf0a5447ce938496a3e42ab91d514cf651c99a13173ebec8869cd959db14698656b1744c86874faacb64b98c2bc6de8d4b585cba54b8ecf0148fe97c25008b152400acebdb7e2ac337cd6529499e5620f395f0080e3f1551ce39442e1f896eb9eac01ee987dc68e51a59bdd8908cd5713d5b56cbab01345cdd029fe967ed6dded22271147ff66b6323dca8ecc5d0feb593dc6e8e11ba5d51510e479930f2a95b0823137b1c323471fb26a0c3bd590c9b131d1f1f520cc2b7f701e98971441538db482245e28eaa768159f1c2cabe41777ed5518dbe797709ec1abf774226329fd84eb86545686a60e6385f783dadb665984dd26f8b18b5e20e1c94da7f6a1903497a94f77ab35b5b47583ccd7381188d17fbcf6ce0dcf17a7a89c04689692a0171707485961b850dbeb031312fae57c673584f55e83da69ced4d374fc1327e3614b997f961acd63ffc039653ebed072cc842d04c464055ee385c29ca2347cf1a864a42cd9daa98c7a3ee476a5da89d7ea141175c3fc9e24beb081040912196f5a022a871a4f0baa5c540cdaeb6419e309dfea37978c4546641641d0c965e73737a06d7718331fc181601c5e2edb04f589ec46b3c5405c78ecfc7ffb4e5e4dd3233bff9931bedc65051a4294f8ce9d3a5c937e3b5f07d48d33a3e44533391865668290c3fc36eba6b8ba19084c6b9352e6bc0a7eb4c974e63143ac8f20be8dc82b69dcfe3061fd6813707341a091ed0cddce353a9580103722664711b955616b539421b0291eca7d708c15c4306e0c556743899f59e444d9e396b54f69af8cff35178f8f86ccf867bcc4db84f1b01c0efe43076133c65ed9a746452e04187116f4ffe8d6a48c362b140498513efbb73e2275e31ba09e18f02dc66629f0f2ac56787778179ac4b3eb64e1284c5681666f1769b2eb2aa9b8616c119e0036b2d32a003578b8057c795a40e3e491c2705255a3fb594c3e4c1af710165e12a5bbeef67690be3da75e7d0ab499b6cd132351b1678d4c9cc467addea2b8e0afef31745f707f7947559f644a8340f6b2f973cf73dcf687b5a19736db713fc02b497885b76e4bea96905215d932f59b2afe6b79093314913ce3e7ef1c4a6bd9fb8b15b6a921561680fdeeea2fbedee29fc6f239f77b255f1ac8ff6e577ad2d8ea1b551464e67ee9911f629e9711e28e00bed2a3f003993bb6340ba500c57ee363d6d78a016e60c1b911a97604b64233ff914a2a6f716e9e247e5b61d88a4e87dc80c227e1eac82785325734cb582a1cd46984a4ddc4a0edb96bb3da29d9fd25a09484cc9f4a9537fac67e5e77dd0ec18a3c1cc235b94ad63174bcb6d27a1440a5d4e8f6779cea4cba946c1cf8dc4a5e632bf113df7098d7fc68c9e99b8c20fad2330f40a52902efefae0b59100454422b7911db97db4437d923f92bf9fa1eda329cc8c7f60ec0c674f3dc7ec73f0c5db00c3ef8e03ccf526e4172d9f074b4dd08e92e9ba9b2599f13c33a590c9c3421fe46779ccfadab9a7e063fd3c4afb7a6477cecc21db65975a011804476a19381b8280a10d22dbf24a80c74993f3cec04094937b6f8e7b4f0c631b656d02ee53b7f03ce3117849a5ed443c256451a9082301a23188865b6e103d783cecb06ab060a593da647fc5fc5525a51e272807b9861816e787d0b61f800caa4e7614f19ede353cf26cb7a0bf79d7602a27154f5e3576a6afc2e16cb72a0c7ce8a6e53fb42a858c08861cc47d13684754dfa909ece3c885ce66a5c81e5af6abbc07dd9e32176d0443eb758855997100e8bc5680d957d414115e2e1e5830ff9d01cd9edef2f704ab405b0d3d1b4d33313a306d0915f9973c1ae510112ef28382216fa1fa9c5d714d8ce493855a60d9f9a9e86253bb9416f58a9696b6f54e3ce84e3a4741da052de7ec1dd7601d13cb17da0f7cfc0a046d247232376275d3ef101c49a5fa7cf13e63536978c23bc561e68a4b5ed46b687d4bc6cab48782dc13a75739182ae47740ed0d339967cdb69a4c5d929ee5fdab9bddd3a2dd1892aa65b63f89bf2866fe41d79bd28bf59e5478aea8378358a9656848e340ca3112420e013b244a0960ecdede3b0ef35a5970cf6b6005fcc752bc3392f2cc3b694cb859e8f407cda1ea6daa33adfb0be1d59647e14b2b92498dbbcdbd7db7063089203d96b8c0cacca93828dd1add4f85c2bd4db56d9cae9b8440640170aeb05c2febff2c14c223d4c2fd63f8a966cb60ca9d40d183a9df084d34f6a1bc03b3a5cb2572ac5bb5f851c22899e6c0c49fdefac4d5a22f6507f329224c072450743662e0a7507f141ec4da441097380f88e5ea526caeca19dfbc21d0ca8b25980201a2612c846116ff142f8239a09269d7ff4c7741e340bff9ada2900fc733c8f078d9997f13cf27b51b1ef1d83b10a23d6ffc292933e0a92cd2ea86fb07d8fdfeed70af7196b8b23ad43ea5e3f5a473163797f21b1a709fa91b453afc502c54bb869d8076b2764d8bed66b0270c4d93b503e6d46ce79e42bf50996686aaef0864db9a85c755c1a80f2734283a396c7bd92c034a49be5d37829bfa61450270fa969d16f5ae7e6db6c1f526ee297d0e80947530ce0b406717c5f7a06a4e6ca471b9204807222a6b473a235f9ae901c94cffa5992bd204dd3c1f4cde0288711e04cca7d4a622acb28ab12035d08ad65e7f3aba9e84cbeb05b2f7233cb36922d8cd25fb80361bcf0f105595da777f79bf100cb87ed074b9a37ea0fbd62190d48a6dc6b6b5650755e1b7dd5972bcdca05befb9072823647772c08bfd02b5c692355ba6b87f5e40b86d837c00c39ca067e61c43109ddb61c06d572b0ba31e8bc8a6f68eab9d80ff06dcfb5a7fc66d55fc72b75259e7ec134f3aecff0b6bb7268697d69c700ab8574ad10a92b195e2be6fec23f6334bada7012a7b8e1c4c72a020be379cd3c3c1de82369376dd11313729f7e480df937fef0670f6ce98d7e59713c51cac5a92b04c818550e9c4f071e86cabc5cf0e31a10bba9ffc7bda5a75aab1d482ecdbe6230d5cb53a884ca941ad32bf2f475506738906e4ff2827506e9aaa096f26fffa7c991a2549d395c505556598240fa202cc0728197ff96f48c603015b8f94adda2f04bfdf07b45e7325e4d960e7a16bbf850f5f0644ced81dc6edccc85556fc1f6a4667d1d6c7e633def10497d0ec3791f9c4f1a714075aa0acb9982f89e015e4f8334479e5144003207b455f8ed20346aedab0ca4b823d23eb066b5f25ef9f240bf72592fa560928e11347db75ae437b9f3f92e60ed18cc5c51dc70f5ec1ce9a525390326761aabe04cd20eceede694ae071a599a5b9ae620f8ccc42bae939a676a64fd6688778531009e59344e79d315cb59a1edfbdfaf96607c00bd3ea8cda1d1f8f66ec87b42b912fab66813cf04fc99d71e1371913d79608bc514615274a16698b3c5a650113f359ecd18928c874baa335a19f1c76baa2f7b2b7f4c113fe576dc2b4673cff6bfc95c5388ffb04c831792b2b0e5f5417e87633cde86f5ce31d2e955f09b39a8d947c29ad3473c0cb4bead9843c73336d68015613baacd24d0611de3b631c7017e18fd94947c81fc5f014fe4f57855fa0487cc78f4e7241b9a7938927be64a6d434bac35b466fe6ff31bf63d89556e82128543a7459f64e2cf26485569b317491ab95fd54fe6f2e543d9d10359e0c425bfa61f20ed937913d2bec568cdd69ed79f7d1390c17ec2eb94395fbcd6e9cfc40a58730360195fc66ceb90baa122c1ea7d09b71889fb270978fb5593431c92f394d0779ad2b44da31f979c30f607808c9e32c7ca9d62e3d9e4c9e46783502485b4692c7ae1e4456e49ea03cdfb6cefaae269b47ab74430dc7b85985c3af86bc27b5c71832bdbb7a803ddafbbebebb7a0777ecf0088abf2e29cf4da9ada4cde411e6a51a5c4c448c78daec1e6d42c657ea0f42d27bd21eb8240b79764be82f4bd1a5d00ac15bcfe65e1da343333858c0f98809f8aea96d4d98cb5aceac4d6e2f9db5d371b5f24705d8288dc6c3640688c0c0b4e1c83eb3757259f6eba6aeebf429b60fd5a4697eeb58bb1d6495312c6a0ff04f3cafec4e3dfdb6df0731fda20dd7747839bf68334e4563491e91ff93f5192d7b98a814ac576ff1c81590c0ecd288a954a722bf1225d0e395b7d56dbe4bf089fae63b4f918468ac98409de62b049f579dd966280dda23b4b23b9bdd6c99303ceb4a00430e4df9f6d3b2aed6326faa754d19dfdd2fe5f5e68b8888060aae2804e2e093e79682e558b4c52c8af015bade2a7bb3c1207232a24b8daceedab6da2ff8f7513e9584bbf2bdf6fc6b36a26a2e0f5fcba1187e3cfd650ad68d44328d37ee18d2aa873c3bbdd2264bce53d273cc48dea84d728615eb53ea006b75de542e328e35f714c88d7f68a7dec8f167b7b6c39c35ae932fa3154b6264e9b8821abe53518a609d6848b4555e471b1894ae2e429044f20fc789c82e5ded752f2ef29aabd4dae360d9bae89aa0ed773b67f4a2c37a864b7e4cd480969fa62fe2fda8928338f15d12b04b52e45143cad8fadeeb42c1a74af0fcab36cb9d83040a4abea46f06e1767590518855aa538bf420512a750c54576cf3e00576ab645256ef749ab10e231ef35b944a9020973c5bae8c5fa3924eb211f1b98b54fe857b523c26b687153698af429249df069a03bea97b58c265ef0e090a3e6c4d339ab3a4a3a5decfd8952882771165f575ea9f2b5279227507063625e8810aecaea63ff4dba495707698c0fd44a80c5ceda83114a842b63a2a1d1cb9ca55dd504ef65837076a07365f707a954c52d33f4d2e1aed3ada8425d0a90543fa7db7a4b399e4b1c8398f8702640fbc566d7d88c7979eb562dcd3516c6a4291c758fb3e362e32797ddd3e1e83065d115f8e0e06d02c50d5f54ba5ec78fa732bd49d4fa86ef4fc79b2c9b20bfdf2adb62c8b576b3b167c2b9e935f6fc980188b0d77696a63e6ee132d85172dd619668239b1b1cb050f3b9dc62889cbbc69aa8f85f846a1a82d3f34e96bb95183a80005af0020550900532b6a8e633abe54097455243857af0a6c0fe1119b64d4a64c49de343eae0eb631f343e0b782ea7ccf21a1fc578392d38a06e2899574bb67381545488a08b673e515f5ddbca3893d671e4b660f2000071c95402f9339933d586b2530158fa93152c28443ff85530cc2525c7a256629db3eeb352c11e71e589d372d843fcb3252e88ed6a6604bcdc1d2c5aa3ec5eafc5304825347831106c9cafe3760754031a1c971123e48a226b69ae715b4f28a5130c8871ffb1882ed2c5fb18253ec3fdfa977aa1abb4cac831d6ec59565a258cdb6535b8f48bcec53aa2d1918802e6bba80e12777cff37e13d8ee19e2a3d1cb2ee9d32d7084cca5929632bc9122958883ac298513a34b91604503a46320d09dfdc9a2d841b8d10ce531b2000ab4c4df373c4ac8f40b6c4361102f897006545d3ab7ff02c058f43cbbd80453be93a53f42613f04db4d6c47e106ad0c35f4bf2bacf661708f88547f6fa3cd971a54d9e26bc9be393a6c5a0ee3e987fcbdc9f59379b2dbbc6bbed9bbab398d38bb3595989c6d6f5d4e161e5bba4bf5e4acc13af7b410837135f0a6e9e78f6f03a5eddb60be0e5b009d05c5db7b936b92ef9d57bf10363ead9c213eed45f5fe4ab3e32a843e3cd6a5e3935d2b370dffe6e02c03c914c08d6a0367b7885477f0e69253b84addd3ecdab2b470975683dbd06ea2558348c202fc7bc8c8de396d7ed6e23f36e1459e95f47050288fc6d24a17c3f5c7e84d1387c7ae0471686c7602aa2d7ce40d5c8068f98c768ed6f7fcb4490a48b56e11d69f607587801e6af10d51f6d597a8cfe0c9d0101380b1a73911afe2547c74c58d695ac95b36b6dc32c0187f9fe52c1343e8ecddcacb025f294a5f3459ee77966061c5bec0517c233162c551cf415d8852f93655bf44861581632633e902b8fc9a9c753a2484e568723bd3c4c88822a998b80aaa613b82f459f44c58f1a8e8c8b7bd27b5452628f6953c18684f845bf1136d3746100ab4dce0c37d52426ea8dc3292775b322758f1f04cd90ef4ac579a991e96ce1e2a972c8e33e1627def91bee2778c6e618554cec4da0d87300070157b633aefb7e8a87f320896cf76215a82c0c07c4ebafaf51128212ad84fc3177eab7cd4e9bc0794799c8d136af830f074150d838704a707dd49e0ce319074ecb94022b15c179f9027bbe9c6b4022cfff4e476143cc6d761efdf6ee9034574135decc9474ac36dfb5ed1c64cbea176941ab9689df3cf99706ef50a4de95b332003eec39e751994f6f91cd2ce43b1a2fe65bca6e6bb3020aa61c0fc3218a5aadbf946bf046209d41cd51364f1876c148c5267f23c3685e87cdd9171a17f804ea109cf48082bd54929127dd68e58830d1887b1dff52735af8376878d396ccf3df81c1ebb09a7d4645c8c7fc85ed5929d06c8d9020352ea0bd8f0ed456884ea3c31cd7f5d59d730873fc4b07ded103de24e4f6d6dfd3699a6b39560d7c2f1745df107e92c75a91f4ea644dbc20f8bb281aa2dc3fa01af1eb7cc0c3c5b5f8a87228fddc6044fb735ea03bbd7c57ca91de62e77448312da12d828be2178c6be64820ccfdbebebddcb7c7cb3451316a52eba0e8eb4c74bcedb9bb9b0e0e593f73413ae9ec9f0ac1c7ea0c51e1404e3fd315bad49df8ce205056db6a30b6148d881d9efb17b7ad2d981ebad69af2c195ca5d9cf159d130bd6db113fa95861364e01c4d1d97c2a1135e9c2f8d2a8df7d8178bffd68a10285ec9d1bf17901a352a08b0c5c63513f3f3f7c95f8a7e58eeeb6e2deabf85161e1e5cd3d807e5a3953528305b8fbe92eb00539f48418666f2886a63bced4cdc7bdfbc1491b60869899603d1d71cb5e7ed0217ab73320dee156de37603e14ae514bb95f05a2a4be804429d2b414d19b348c70046ee1f8fede61c6aa8c8219324e294103034131ce17f086ae1be04cb1f57186ab49d423ea4e735780e5a6818f7f464db81c3283554ab5ea33d9a170b4fe3e15dd453ea9c541eab63a9f9de0b3703c0d52191a4f3dd62c92c97ba78e88758081bf949f3e4b4825545d9979f8d801a722408333810a0d5cfb55d7dc7ee3edf42ff443d448053820fde74e121ee61e59d90a3c33c1d385893d03fcc1dc0148102d9afbd880026fcf2dcdabeb7162a130bdf4dcc57bd031bb84e4f4bdbaddceb8357b56d578ccc4bfac2505d7026f69414c5befa027a06c07a59d4b4f621e48dfd5c11019d4997b8e0d2a9f1df9035fd553bc0448ad58be82c321862c9ee244e5182c0f3dd2429858b716db783e8a59725cb33fe3144031dcb1394e245b2f838c84167d5bd2fb1d16df39f25179c6d5dc2c6348ceda4b0e31e2ae93dc80923ddb50af52245b240336e231266c3eb6e1cd72784d68571bd7029625423c0fc35e8bee9c9f3007ebbbc30c666fbeb0d8a3acd0127015a1aaeb207ae1958a040e28332c3c767c6e57b44774e04e5912bb0ea9d6ca8be660ce87c6efed27a0c6daea2b06dc45c9c56dbad8f1245b3c0f80e892e035e372c8593b023200a0d6c2a59ceb74b789d3526eb354109c4468fe0f90ea6a8b6a8a23091e0d6c33186c6faccf314a9c03b6e14fe4aade4971ca925f38a0100caddaab2363192a405eed948f3360190abc1c5f05868c48f23e241a65539411e748ea6b2d11f8db90878f3be775fd23c8aba106af31a36a136628c864bc5965b8b35267ee498a7909de3d7392d3cbe5f25a52731849069936e495c92ccbdbdb5a904a2ce6b1f0926eeb63d8e6c387ab66e3ddd4707ba488d18349934c42bd8e95417fc356acf44e3fae8729b88966ca6a7464a070088a1623e770d0ee505d219e9af8182c4adc67bab3c64c5072bd4c5ef0d09f10c6ddb3f0098a88c8bd2d99188c09befd8de65369b9d645247b5b036d541303bd78b24fe76341a6dd47440554b47309773aec8b3628128bbc627a313f71b2cde2e9bacadff5ce2a17831687516ccbedf778df179f431258aaf1352a85d85be4af2d1dde96f7b7984a7b497611910ec0ea3e5f9487ec1764cf9b839b03eecb856a167250b4e986e209100d7e7598d6a4e2f181ad5d5e40519cd8267458e43d0eb582dc4678e1aaf4c147afb9dafc73c5845020919a0e9e119fa1074b9ba41998cff2f8cf7b16c7e43bd7bede186604633b6dcd683bca803c09463e0a91fa82a5bd8e575a8c319637e35dbf7aead2aa68e7586840133a06a64acc3ce26d8fdaa9f46db74f66e55bb882b6ea44c0d6ce26bb30d91ffb1a0d219645779d0bdb83ea9ef3fac769ebfb165f06a715d901252f93557039f06de9032c2e5dbd977b0cbff2d64a51aaa4582bf2d2add97e2cc337511c978385e37bf1cbd2eb8aa69eb5f4acd6a554c2a705f3698206353b146ed7fa6931d19fd839a598261115796d3d37a3c6b9f372cfe18297b89e060f19c24d990e4aec4a2e7418f0af694c430402eaed3a8dbfc960910fb3932f79e77efb99495cb01b5a926dbd731497093542aed07ef82609e8223b3bbb1a04e42d88d0bea84c643c630a297d23b75e3084f8457bd3150623becf4924e29b692d74ab92ed68695c6ca8378587b6d73050204fb32974fd5d849e70a7618aaa84f47c77ef3b341d7e45c7ba231dccf2c0a3d9b00f06f62475f730e64fd5192d257b228a5fcfe383d4452af92adf3cc8c44bac884d7998aa9f4664ffda9df1afc70c51e0f57d50050bf128839ca7e30da4e9e611bc1f838cfed8fe20886479dca1de7004e50529663ca721e9d1e319401274946e811bc9d43b910ffb06242f7aa1adf7510e4bf9a19c5251471081c49d6190f77857d3982555b7c9179a2561e2f030a477c163b9145b9a910fd680fe4d319ec5135d4ba6489aa176da36038145327a5f334be6509644ca0a372297dd8e5a4fd2d49974a81526543b67e7daaac3337883cef48023d5ef7fcda0c242f952dbf8cb5a364bd5cd368e77b37f30cd9c017ddeff1a1893e6e6c81daa48bb9272d9a306a966545965c822f2fd0f3adf1f4f92071001cbb8bf7b7c67d1bc695f379061f6171d702b9680197fe7d99d862d926dd48910191b1d30a53efd6a08d5fa336d7e39374fc4f78c08b395bd2031a153ff4c6de43b12e8801cc29e4b520ad7dd2e4f575e2415ba5ac75106c851bf2d72ea432335fe0813dd6f731900149d8a7787758b355f736f8d749f3f714af8a6eaafce143747b11426fb58181dfd5b8a558410782b13e5ffd78ed81eeb6356f1c1ce40bd58291071a0fabba5f65a9030a999e0a0619a3c042f0e23a59274257b40662062f2d5a97d309f4276f6e8f6fe12daa33698d7b1fdaf1e837d8fa2362011c8a0e2cce8746dfcd54e993d02bac713b26a63b5e125bac96709fbc5d7564cd7237fbcef9e3094c61e1fb436acea398914e58aff1aa88fc1d25d055bc51e419ca499647b6f1db0850c41b68a249ee61687d0ce094d9a1a5904eeb92fc6a577c3029747cef3220d6dd0023aed58e50062f56f3747de54c235004ae9ad3fdefbac3a513a0e890bd35233c9b4a9102551efc28f7d5d17a834f5ea574cf4251211ac7bbcfdfd8b76bfe5ca1d00f58a63b2d755eb79c0afa5aa475daba21387c2465579e75ed8607e4ef66e7373f481fcc909283df59cd2c716bcaf609caa5d1742507f67660f8290661b1e81ab320f79786933169a413e004b961b4563ba1c541304e88a1d153d557fa741b41b6575f02d72882fce57f6330d88f0d9ad1d7df32615841bd3a1607d54a1f7d17f226c2bd6b517f77999ccef0614a08beb5e675eaf2892072199702c06071c8d0bd4f3312842afe914a665b9a4552909f3b5790867c9bfe745d26c00ce6b27ac9d94a7c7ad9677b66faf7d29c9024ccf0ddb03075649a11d31212be28e51aa82accf947d2053926ced7ccb08b15a4f7bb0a9ac09b17c4e2f63afeae387bcc34b5ef04789524186cd78d8529545411b7b3fe185b1031a6e4fed7a5692f45b5d08e5225e6ed55127de6769fcec1fc60cc257134d26896b3262a0cf639a4abd162e3e99aadb5c0be524a58ddb565652cd12d541718eece8d9fba0d8ae84b9fdeb0ef66c085636e022546805fbd118ba93fc90d21044153b91d71ccf8ea0b3d2d6b389e4db2b4b9ee787a959ff98e614f6dff8daffdcf2f28a8cc04cf1c21de78f58e25cf623ad7864296902fdd1548812b5e0a80f590729d7a824bd1bd3032447f4e7bf33045581fa6f270dc10f2692621bef7c3c4ecfc5e6e030defd31be2e58d9ed40b30a5f4ecdf582877a80a18d23499a31d2328220fbc0b48e59e1ebbff3e7ae4060f6384adc0acbb9cc2c3f59436d04df191e6447bb80901c5e4e02d1ffc9d4ca8404d634de1d7a2d7a0de7a9f90f7d13543e18ce9a665483b18341dc40efdc5d1fac34381650a6bd26f8818e2ca37e50fb4623d07152765ea6bc4c784760bfb47d69534491267da06d5120916748e7f482c685b29e7f4dd0ce2a4ab4ab7d1c08f6af9ea87b068b04cc4d6818df531e9c2d0347da6842af2d2ec46704dd18c83ddd5dc1f999fd027c7c92d0b889f94fbb2147572bcbfddf5f4d7f42ff6bb604f518504c8da791a190101ac2bdec6cb628796de654d759f4f1b84220d3dd038145bf9897526f11069167dc2dd15aa8121a1ea7db3b9b035d34d599c81a1fb0d254d766a20d020be039361afa027930648b0c4d15138d38fbb6e778eecec6835999373ee83b640a88b19928105e808bba024b47655a8e8f356eee11310376facf602c1a3c4e573db842952d35b465c00c85524c95a01ff7ea7dda028ebcc5cf7273931195365a5a42642e6b02a538d9981f85740aa67fbd0d402c99eab8c36b0dee7036c0520027056b0fc937533b470bd01d395c693a8a35a997802307429700ee5bcbad2d7b26ca3c7fe697e0142955cc11c41045d61cb0d228254bf6f07133c2f95dfc58d306772b8487cf6dbe5d92be410b419150041c88eefae4275093c66a98fab061f5b5f15cef17dbba6e09325a22ce1dab5a10a7fac63ade530b1fdca853bb444d756b632ee01a9b01e9718427cc11c4787c93c477cfd240b84633e64d14c8cda5f9bdddb62a1710f41ce5b3b5be17398bdb40b438f5c5075339ecd2fcfb61ea67cd17c5e18d970e3267c07b85f0e3d4d57d1186842b516c9e15494d3de26bfddd363bc5f7792b219a755de33a9030ed587983b49ab43e7c20317e48d811533a755e25613b870c0262de1c6998a0eae87ed01745f121ff818a67a2ced413e6529333196934582cb0d0e337bf82a469122d3206940a80050eb9e85e018a5f4229df56db1638baac24d8eadb10365ac619443c6bc41b68977830244260f0c1e9ec3057915d266cffb35950ca1ccec840b06928bfcfcd30ff8e7d1e7683a0f4f30dac38c9cc07aff10dc90c1c0c429b65e2212d50c0ee019bd69173ce72d97f1442d7ee2f5e446f49e3f6006b0a518849ed7d30fa5d376776028ff8032a71506116dabf7f4c3fc2aa862a40c28b6ea2d202cdd4a9efc6ad360a9e9c7056e53c31d91a468bf9cd6c4ca7a589b96d9aba5680c9d0aee75e9781bf5f39728ebe9b0a7805d45ea11cb8ee75cde81355546769597aefbf179eeb2d13663dc01dcbfb513a8a58a0dcc4d2dd618a60a69ece603efb8f53cb8f050d6e5134e097c8b355f03ed4593b6a09f38d1a443f2e03bc936ed3ce6f7d9d69f90957f834dec9de8eca58590625271d129605b6c3c848625787d653ec36dc7465266f9c99fde400aa45fa90ab464f1f9314087f40bce7c29e69712292cdf46ad98f89b379005ad5f239a6086dd21400d8dfd475a1d0733d45699ef877abb6870462af7e44ba7dd8044e42a61b6c30edf620be41c80222c119e928a71cfd4663fc0f92eecbd0b4b7c0e4fabf3a3d7065ce30d4fbbdfba572b31001d2b8b77b7110ddde9d045c22fd6ca5121ce555bb563493fe882a0194ca9e7f536ab8bd9549aa05ce70af42d09b37cff98e8c8529462658fb07c5fa1a41478b62a2066a00aab010ec91af17c453db940945dd000910d23e3797cd6a457202b9387861d2f27f8e1c01f658d2ae111162e681ed6221fccfafd59df1dc9cc24b409e5d4076c4a1b25558028fa5dce8fd3f8fe755e140148e4d2577e8844a00bb8f4599c8c1ff55cce35c6d9833de00b2f0bccdfb56db1116c4687f15735511aed77c989bdef38c6c1a33e08ed73a5bb773e7b9da390e2966a8cf477a05b8609b292399269768dda8abcdf7ca824550346c7cdf4f9a0c6cf472c293f3e0facd4a3291359e93d8e1320403472a4e366f6ba4bb2789bf83bc8ff81c9f3a2c8cf0da0f199fb0ece9a5ce05e535b2d846a99ca057d3f5252b7c1fa8e23e01222661b789e376b71e01d5ce3b10ee504fe890d8cbcdbcb27de23f93a6f616abbe11669262ef17b584169470a9f8d5813366821cc6ef5b1ee88d5344a62b9ae667572d2c56dc6dbb203b4676e63b28a212932b12f1438e4b114ec5a2f5bb0e0198653fd47ab5e96d047ed8f20cb2b1da399022365c21454684575bbbf65defad6394f8a2483c15680b2a6775c8af67ca70c8c99aa45044d29e4460d24fffed63564ea457ed596535ab96125d02a5ac945fef10891631c45b736a7c84aa4d24b08beb300feacb32d622918265a18ccd17270b2fbc3c0ebe974d930056aa4c9d1690a25c487d6f430691d5cd620200f6e20bafdd646d58132ebdcfcaef16e930b7e74f3e3b0a44b6cfe15dfc9fbafc9a1fda9ce0b81cc6ac36a3567c12bf1fa37cf0fd6c2cf05b6ace458040958195003bb19625ea1584b2f82245c37333be5b7c7c61b922c841845fc5d2c9c38abaa2d212e825159e49ea4a5b05a2966dc76c5e0a8aa55b623dd53beb70d7955e3e939c60de8e33a8cb5fe21bcbd03f09cb58342df25c06b2b5d23ba12e04339c9d74cb589c763df14a9cfbac8cf9aa4989cffb70afa832156c4c439c52683a516e866039e7a429b4bb812a5024a0cf2c990d124c83712873a8215c44c625b1806daae5a09e0dbbb8e57df979749df5bd1b0dafc12b0bd7fa6b41acca533f18ac68288dcd4f725b14fecab20a4d9a09a115302f7b0e9660c853de7f2f846911b66fc7406b35d3a35e947efbbc99da35e095af12f24dab70509847d38abb886ee377f9ea1f2f997a75eb8a219b7f96e1de1658e308a4817be717f1120d14ce1cb5a5f29f35f7581857255d4964e310a56154402b82f5ef349d92cced8cf515110d0af3be709114f212469332d3fe19dbb54e8fdee85d091b11653349e40ec1f61a95e8435c57247e43258b2a4509f7f7a2c4a683b789313139a7aa3f17c1114fe5c297512a0489fdfbd98d0465c65f638d4aa8002f63fc3233da9965cb8588e58f3fd8be9210b74d55e1a4a1af43808d7403536ef50f04ea637adc87c50f6c975a418e55367eba577240b1a5574814295f84965e1b7b8085df8379d3587a78ee27114fb14a98a9ca0b8d852c70bb5a3c3bbb7bbcb5f70a1b20de0a71aeeaf2d054a4562a7a73b3d0d97ac88799bb3988bbb848ba80d65e5f06e83309ca1d6247757e2abc17c98bedc104f043faecd7a87ca5e357684f21e998ce611f33efc2692e8a6f4eca336ee6c958cbe312fa62585010bfd4047607546ec0c5320e2e4fd6e610701e1231d4dbe2881934b552a6b464bddc823be3347c7122d9de00f67992d7a3daf46f0b1c3f4a2b57814254dcdb9719d9ad341beaef1cd3a2de7b572f6212f3f2a89d91bf30047e4ea8d8e514413567ceedce7fc95ed7f12d2c322ba0b1f72ab885b214929794695260fe384631e952e3341553f567e39ee577056fdb0dc51c9ea568d976bb53144f4b09f771f810251a77a426b93d959a38578ffea011c94fb105884f015c03e1206dd323bcb09b683a593794b67ce866a75c5b4bd27270f371f7913ef1968a3aa92367505ff0eb5a74549ad69d7391ebd0b7acc78389844037da2594629a499fe0934bc19785e4d7ff99c65ae7cc48bc4cb5ba91e4044643914e01d13e081003f84f6cb60b203f2d8a1d0f1ae01d9004e139a7ba89593c052743a7478f18721015490b509fb8a3e1d86acaf09c5af9cba834c61bd28efe075260f9b3ca5c184c966d3d198f312cc1e55cd3a1e2f034d46215ccf7d4cdda9b73fb771252884dd8a8e00b378d712ea40990fa5beed3e803cc18299b8194df982a966cbc7bd0c820ea97a18e881b585177b6439943697a6876644748e6a3d1a97c56733a5b5030a534e99798ee1a3689ffc21ed2d10978c99786bb9c92da728f334bc72c3e5c8bc4d6e397fdf1b227ec22d2ff6e2215ec4532339f13470a962eaf48669de658ae9450674991e9ed49c66a518822e46906d005e68ad3d7bc6b495411d99cd94532baa5c420de6d1d616be8c0808ddb9d90326d6cc4ab971233d117f05ef78a586baf42a6939f8fb78f87832d2779d67c78f96afe406dac7d032bf135cb8b23030c419ad3488d27a8d3e2f8c2d20d46e5f0409bcc013d855a790d172518528039decf3418fa1cfb00e7047f70bbbc68756230ce644834f0442d9fb3cd92c18cc2d3d5c98f6885def1f518445343b4c8d4980898773ef9b0c23696ca2fe4010fdc6de1f7ff60509d0c125a35da1e7623ce585e185793a8c8bee4bd11fae24e4f893ff5229d7de3e492f6a53244472229769e3b538f71484fa40f6b1ba32c2a6423de715ab5a24590a4a47e382253ff03268d6a47e942e0b5abf60294109b70f405423d67002799b1310e8571f30df2eb576717050db722a08c53cca09a8349f2f2549de7e0ca08c053034c2680a28cbf8296c4f42743ececb3e6fbef9e7150b8d805f1902100902a2e74241c0f4cd24bf6275898a61996d187d253c98fa20a8ce7134b96f46f36874f92fa5c2724ec19ab01c19553de790bbbd9d77c13fdc6dc626595adabccb8cbb54c6dc84b7f5cb925da6297d6abc9a874cd38b70b2221dd76de60043f67a4b5bb4201feff45ef80aa22729de713300138a5b306d37711cf4ac3d4cdae53315ea3a18c50df95ca048fa7043b556208317dfbbb61340f29761caa314fe0ea0614f17ca5475bbb94a33e755078182643cb09caef79b88fbbd2039e48bc408b3e67c37825738571c2b8b3a115ef1b2ed77e44af86b6751488053b5b38fb10350ee82a42870b0e18d94459fae0d35511228a9b8b4195872d11f8730ec0ee91e5ba0d63874bbdd16f0efa6d56003b0b012908f30f6fb2a31313f7eda91a4738adab69c343e387d30e85ba342c6d1dc0bae5e028b14db7aa37179bf29b6ba079077965765f4928791eae609eef4d027c06723fcb2943858e771b453c539147b05f3f97b06b658aad0d4f3a70200a6591412c9198838a69242897159a02f081ad6d167211fb1a493fd84757a3cf484a6290a678ccbc29755b9a7f42e691ff57b63be5e2b1f835e675b0ac0b69d54cf8fd808626c513bb713636c451f6975a855a815cbaf220e4b3824f2428fa447ea0aade5cf722f8f7349dab6896dc7830949a416e3b65d9ef48a7d13694ee30fc26f3bf0b6dee44785678a911bd3a45e0ef88edb8446214699cbdbed1eda9c0a70f2bea344f1ad35b7168977fae96c12c912343c7cba96a0e7421b2843b8f92530a54c109bc29d181c57be48a677f15915dc7753442c52a23ea534a4f41738bab7aa976e60f01121094a9aa8b117f0ea3d4cf27934be28d215fa932f506b5a396399608d77679ba725b2219b85658eb1d784d97a72037864c5e4a80d4ea6b0f088a9948de161ef9d76d11eddc57aaf886800ad3cf5a3ed09822579abf892741cea3dacad6704a6ecb2a12508b4e70b5cecd388c9c7d4d8f2dc7e8627aea411fe1a340d6564c23bf332428de7e8198de47cc3cdb5d346a36ee756496d1f67f00e8d1f5f20fca3f8facf2b9b8baa8b68085c1f5b283e21ed300b10fb4f9ff33259fb1a62693b91c0367de60869f50dcb9049f9a636cf173ec88cf8be16e2851794ca31c0132562eeb064e3885d245e46aadabee333dc39adc5cad2a194c412b5091d1142f395ab6584b48e53ba17dd9478bfec212671486c07014ec70e2f04c9e676971505117ffe162937cae316c4895b2e98cf246343114a5499a079960043eafa8685cfefa7f6a0325d7a40c498d5f6a041e58a30b49d3195d2ec981510f63e2ada0fce5503d0649d86a85c9567b11384d2b34f0a150e3d314e6cc3934cfbc6f5a511995b3f4a23d9f46050c3b98c4e3897a28420c827f5b46848fc9a15528ab4dafb35154005b8b5a56ef0abe6887ae247483619113872fd4fdee7d848c9e8ef1d336bcad87efe3e931f9e28149be59e5e9b006c32248f990588ae95e2f26e590434a188fb25eaf2d9e4ccddc696f9b895eb723c3c8267143445f1998f2bf6dea57fd11ac2f18e3340a63feca0492d7fc6b0dc5ef8c466e926a1eb1aa2a26da18cfcd5c8fda901f50a444430bb1f7c058d39fc2c972bc1342fd40871f08da200455fe6993470a267ad9f3b52a78b22cc963d52880462d27e6d1eaa0efb7078257fa6471bf13a80c5b6e8b9f3c4d03266d453e55e45e4c138ed3fd2dce27ee0a02002021d2441f2cf6da3241efba3221c6eb8bd8cfab2c9cce3ebd2eed3327ab743cc0732aa94fa1d3bc26b0d990fc26628ff5f0cb41fa6087b45a484ac5c6c73f5f480b21d8fbdd8a37abef2ced5c926b5f8ab58cdc8c2c3e9d15b6ec887fd3b8ed52c30f984f2d8592b45d56765b737335e5636f3a0d71f836263051cd7282368dd3caf87151bf0a45d7b9a048b6e685a22f74454638cc98d05e5d950752d2d3d0bb2a3e5757745da70aca72e521167d6cc4664445bd6d4eee11fe63ef5898f1bd462c59dd2c658286526335e46ca5aa8a185a4d010bfc43142354ef37c4371c8e07bf2be752f48e2a81c4790f55b7e4c12c2b1826dadf2756ab61914b266ea7fd4133903b4b08c9da36f3f9b65d8123bf892adcfae02ffe4499b7703087a4f4f5a258fb18f376fb5b7d6de35b419ec9d8374eed2d1db8b829bfc762474ab937d3500e2a4f4621134727dcb35d55a24abfa3f829cdbc13ad6b910eafb0b3c18f3b948bc2f31effbdf87988a4baac8a032012afdc070bcaffc11caa8cdca17fc56affa8d81341cf1243c70ed67bea117103664301f49edd76f557acde436275ce562b85d2b7be9424a61603bbf95a8da94ceedc47ff95178ab62ae67bdcda0ec37e945de2ce9ef584886c49a2f455c73b9e87edce648b8ac5f5a8ec5ce7fbe5174bf29a06d32420843f6f7070fe6d0beaeb4a985bfd2d8e404791371c4a4b5a6a77399d7b4f73acc77229e2c185234a91b323aecc7f5f2a4e7f776086ca9eba2dfa0b5a8e25b8b27b93d71077665d29100d6871e8a0be9f9f00d9c9177ea00c42c8b1ec4967d3b918e4c20a4c1710bb9e8cdd4b833b2fd92a172e3fd93a41a7d65d9f090653897078008d41ed907d0e53f876e69366e9291ddd9b046ac9e9171b054482002fc26506bffbfd852d69ada7b8f2bad8a0d55b59f0a3dfd15e5e99ea131d4094a57d8fed68c3afd62c18addb5de756b058523b6ed14f5629ff4fa26a56882f524ef97d2b99fec7248b328bcb6b7cf651899c486d6d29fd0c24afb1415bfcd11609a66ebc052ff29adc221e1203fb9195d6d1e36f224f994fd1d9c5223e802fc6d929654bc79a84d8753cca239fe663e9722802dbf26a3944ccc8e00eb378c469fda0f32eb54cc8edd3969625b26d2e88baf5375c25729e4c904002418a33ce3d26c48c4243e88ea9c31f53fa73d255693d7d30d33563585589245d6c3a93b7d018c1f1470b10768a9436e18f890e35c19761d2937ab3085bcf7f09dd976b2132a55304d64dca2d884da9eb6c1d315df54a2456b79dcf3ff91da3714396ac9fafd7ab3049f9731faf1386e116e1c424a1ffecf90d2d92aa14f0cf9af27965fa00de23766250245743c3330746009cc65954143567fe27064d1eb119394a4c2b6360a7a439170b50c70d8278fe7df55b970531bf60e4c762eadc149e8f3194a69770b68c65e7b0a70085cc929a62f0e53d5637c7a7f090efac4f3f64a3c1a31562dda9c6c43b1e527039ebaf79365a6f7f147e49132c4c8e0b91ba3818501d244ea1f52239ac3210cecbc04b73efd559a30ac422883af1739025e1f5d5ee674c28a25380b2a1a03e948d0f8be0f7efa2cbde9c2852b07b2de2cf4ec1ef4194cf3d260bc6e6e1acfb4e220a578df37d58a50a851fb657f42021eccd7aa2802e3d524543384b44c86fe5bc335608a90e56abee0bb5bb7e3ec4c3d490030025039e96901760ea9c6ffa7e0806f1a903c4066d6b64e57fd1129a1fa3bae2ed4f50412dff8fdf51197b0f15e45c3228d7ad47d0d7d4ae0afca3963c6103659f508907fc3e17a7eb4dfec2a92a52a00a1f2bec8aa62eb0eacb8f5e492043bffba4e596ef610b22463c834c5a1e2273e8c2f7a1288abec246376f27727e5fab399a7a7d0361a75a07f37648add9109a0acb51d76350646737d8c2152f4ff984368762a6abd10e122f35929da9a31c9f580b6c41b4e1a5370cad79f843269d575a64cddd0a77f558132909aa94a7bd9272a0c57550604fad312606542d0ad838a73383e6b937161b7562ef6aac913badb8793be2f9d9b24627112c72c4fa5acae7c4e6227a7d2ad23bfbf38721df898c473b870077201f3de8d0f3fe2b5e293db7b5be5779a3003385c61367bd47352b6945adc3bab0b1bfdbf64f5bf2e7a330babd0245a833aae4f46bed5dd78589c08e9854407fdf1c888e126ce582175ebbe6c8bb605f165a4e6ac094d0706b13ee88829c8f3bcf58aad0958b1efa4470dcfa5d757fa69adfe4bb0520a06fa5283979193288fcb4ed0b15123128345d9124ce6bab080917bc70861b985914005c84cc60136275cd9f9de692155f4c765cddd15f8baf7f5a416d64c344069d333e13ac3adfca34ce84ba8d69e815a5b9a20141b30710ccd2c1df70aa14de70dff2d0da7c3543971bedb828007b164ff1cdb936c5713af2c4cba660ad4c093455953311e68e078a2f543cc8260a802583e2ebac7a6a5a402676073351c2d7644dd58b702d417a4240f21595f9ec15029501a78aedfdf5b79b8478d7352305a984b982fe5276a6c44156c693050384b50ff6a903aed279c051d2fb4a710c985ba7a92d0a45f1595e7a83951fbeed96f3418055e56ba967169656f7d6aa7b2742a79063637279a1a900b0dd07105a5d87a41f3d6620a534055c1da934f0edb421d287d2938247eccd43c53a5418b74ef532fc05b9f8feb624ef0c9c641df2257bc4122c12cba2fe5df43060304dc5e0bdb3e1e7df15bee94d1684331eae08add07a117963d531630c66318c398e442a3772cdf3de64cd3f8900be7ffc88bb994cbe5a57f0bdfe23d511a8df0b89ae745aebf0c028c25cdfff30dffa7ea54d6a4911767aa08df46c3824d31659a45ad6557cb6099fe63a2ae67238481d84ae07f4128e46cf342f91e47c30660e81a180755cca96ffe0a66304a5ebcd52f0aac6ca0a20fc2388c31e0f8181884625760c3e7ac9e695952e36386ebc371bde4df1fe8b1daddfedb36764a96ebc12b89ff2a3bfc98912a5e0b988c6350c8f5ff87f17835691fb6ede9cf6049ed7e9327de72cf2ec0e7c1983c6ca5721bb8a826b3e417b4963507bfdd234559e4197dd2f42cad2a55ed3117e900a06f557ee03f2927d54d6eebece2b3df24869de09a1e791266abdfe0a16c6ccec7638c34e261d7482679d60ef55a8eb5f4ab790d91caa46e65fb80bb353e1b4af4cfff616d5737d39d593a692f7096d84973337a1d920db0ad948a286229f5158a1f21165a8bc5f4b54561e645df1fcef293228fbce36ea6f2ac7e63cb62d5eb108535a0efb56093ead77ea33214c1989140ae6f5d26b44cc5001bd13e4c39f881d83d9195fcc553234f335b8efed49239ed4c127e4c1dbc8f84dc82e8ea38922fbb331e836fee72d0643524263877aca2947c157dfc6adcd83beb5bbbb5eba05324ba46d9970e23b254e2d5595730e2497d82bc1b26af15d318fce2a9507c173797303ac860747f15dd3ac9087618d317784675153135e6620b59f643fece710d7e5130ff28949400d6033fbccecc17dad487253b8a70ec17f25e719c983870b05bf18f28d442439f6339d1a50197ccbbc1adfcbb5f01d820bf46a2f4a3face0cf590ceeca7b02e00816b568c9298b1f8c5d22d43c9e0428c33c266feec5863e40d389159754e78db5be007a10cf268102dd5301152209c6b242c941bf92c4e415bc0dcfc8e3038e3885b0a9c85f8bbd39230e69e843b2c48ee33fd05bb22068e1d06b618c31bcd7d93d12a3ced77b00add01fda29bf6d1b6e4f98718fe760ab5ddd5256589422e8b6053bef1047ed792b0bfd1aa8e4a3f4d27ab8a493db85ba623e39c5d525067bf2cbcbaf064d9676f88c1d7fe0e40b979cb4db07d0830299ac7e1a75486a73aaeafb394680e338e2586f8afadfabe56256735849b860e10f3c46c2ff1e451d9d54cab22e75ed21f24daf5ddc2da8bc2922d3874942a8dcdd0c997d69bb5a3c6c515b0254609854691c1e1ac2f9a0607a526566c13f9e36352cb7cf158b7df3abdf6e3721083cfa1c32335cdfc6f62aec98af333cdf51af178ed926a97219ddf3523628798d49af2d8ee07b852b37f30efca366755b1b1fa71752b65c58e9d97573d78124099d6bd5982e058a0d44285e3e14c12663a089ed9b48669887518fae2996e39d5e6be812b14beb4237fda8d3255bf8c5954db30c6586a3cb2010b8abd63b81af424239feb36eaeae21d64110a5a44fd9e965ef0f33a5cfaecfe499f29659c7746d4a9217a6b86d55ed1195bf1855f12faca5d5cc1971253c7aa7cd360656bb51f969d56a8fbe8703bde19c824ff48f2b2c6ab9f3116b2ffbef56dd4a5812a7e26380ce18d814f9cd56eea86a8a016e1fb48061782bd3cb445c47130d916528cb679521b2110646ea63e8b8a4c24194b3de09892280c10d49b09a88775963c2de7db493c8080741069d37460c991dc8f2b4dacdd91bc7d5929309a41fd2de14a5aa5f594e05a8926437ed029eae9e8c1126493205c936fe8813b6fd046259323c51d4fd903e0a39ae19d2ce64077c2f747423e58be4f4846301024b01b81f1a2542f9db9078ec852edce3bc6081d413f32ccfd5dbe85b533c601ba67aa18d19253f1cf4ea12baf1bece35c1e3b7513913f79d61be7b247f60c454a0792cbf55d7b454ada3d1a7bfcc10faa0e489d94605ffa0448daf54c1cd2e76a2d04c10a52e4e0e73d47b124478b682753102247c5e8076e0b1b330b0339ecbb4db0704f27d20745b6e62f6119ad865664b5b24988ab3b45a74a8328e0bad87303ac28e4287437c04841197da6db542cc0cb4a22fb65ea5da42b805094e8c11f887f688da270ea9e063e5b231ef816364d98c79f5ba2780fe296be5561fa3c26f2782d14b47328e123df30fad9546b152ef0ef2243d6f61a4d35e0ae10bd1dd7d640f8fe768bdfa012b85b48c8291f516b3db68a082d852a40d9b8bf72094b5ea961ba94941f35e314ace12489f2377262666b95ee9b5309419afa6a19b78a9b014c46a313d468e61747a79461e6a60139550fafa12cb52b52ce33d45ca6bfd0b520f4cce186e2fd4e18a52682d838143b40755e48808dafcf643e3f88c686216ea7216f5aade5e478e1f7cc182a3a0166a1c3ec2ff61505cd443d7c93bbc82e812d559854f8256e5c0fa798492c1e72c5087334deb59b4b35941e6d4908787fe36dc88904f03866e58307af1525b176b5814ed09ca698029691359e87ab824c367be9d88b0aa6f65d5b69fcf0a37479939612176e450ae10ba6ea5c1598e37c040fe2b1c4515d8527862cd5c9e70274c597767feb48825cb490a7e688218e4a01fe9c0bfcfe887225c31a449bd7a3b73a43767dcf12004c33feb6f402786b8596ab6102876d178beb409d66c712f8d16790bfc416671b9d6f777920e35ba5f04a7d3071fec3294c13c95f27eda628da87269e3e8eca84fadaf049eb6aabfae5648e0c25d072161c7f60e29fccb9f78fa411ea0fe5e204d5b298f80ea0f7f15ed21026b31b0230adc2bb15f519cfda2bc73adafca4119035c2a3ed438ce63f0eb91a4ddd0cc1fe04b2deeda07baa4f60e8b300bfa1e8ebc00c43bcaeee244b03180b8d84ea35df3b130411eea9a329803d24a48cf46f6cb8b5a1314ee9ec4aa0597a755ad4ab47137e6e440a91ba79bf47314d728e28b55af6b463d526e87a4790dc62a8430f9c2c34fb4735ecffc81dc140cdb6b7816d3dbd0fbf2ef4f9e542981b3505c989aa13c7c556b852ff3f64a46e309b4aaad79fa04729a6f2d18e1b18d2a1076ae27c76ec03e4c00863b95747f0fdfdc0213356429a49f8d80319caa906649151b8a0eac9d76d85f535e2acbd0e792aa66a361ecda346cab4b5b6d11ce1de4da062a5cf98e99fa30f2f2d9767ae8761e9c92f2441cbdb66e2c32d99c429dd5baf8fa05760365097ba1ba4519a58b8e8613ef4f11d53c7017dbef511dcd86170f13277d453b47a08ee78434a9ec96c8954b61455b6935f6ea42441db31b202c12a6cd25c6c280bdc9a27f52f409a0ef6d5e1365f285f4853478ebabcc2089d3c1cae1e08cd14d41ce48413d0eb258b7798037e7b461be0849a81d58fca0f1b29cb2c085a13e919043d3f1bb4b3e96c371ffd726bc71008bb1a9261e8e398e014ff696eb0c1042a6abe3c12c5e4a50d61315a6a98c5a9502e96097712b42ae625787c202c5209570176ba92414a89386c0fd13d75f47db97e7ca65889bb9743bfc64ad55b9122db36eb540dcda3d6491b23a79f8e2dc39fc8c59a6a4df4f56091b77c86145168da98f6f04a91f35cd331f250d100457bf45cf9de02aaa98536b355352d6dc4587fa43702907177c74348532047b867724ef5be629bf3f79f4059dad2740b4dd1841b10156d3c73244956979b40d22bcb74e18cbcb53a201018e3502b8630a849178e6fa3a989d73b27a1aa1e02de96f6ea594a380012c403e07d191ea6c24206da35324e4076a7806e5cc585875233e37c684e66999b24e15f9edb7e510ab8b226fa9324b8eae9bb48ddce77257767874e04504cfff4ff026312e7c2e8527706278d633bda202c6595ddfc055d84b0acf0d60961d2bde2be91ee84953d9266757e45be389938b54a1167d2acf7ad38db2b6bfcee65514cf0a3780460f2b57beb46957be9f1e60d82d7608a0000ebd4c57c8a7a7e9b1569dfd322c835c39857cfaea7a12af7b1ec2f49d8f5105564f5939b6228091740448472108326145f121882215bb47bf06200e7f4fc2c6a39637f641815ffd7e15bf295fbc22264db92b11217d334803f62731b34ee8ae424cb2370132e8f316c0223f7e0263d407cf94b7d5cf5e874674b8ee6631f76493426748c09080d268419271e685ffedc3023c3a3b1bc99f94880ed830ea0ffd4117e2d1ebbc25a77a4605812718a20056fa11607a90faaa79f29e2f8ad3e1813f95d65062d5cd51e379fb62417129194db2fb2a23bd57f67a84cdc464dba10a214c6475e346a1598c630f081fa7d32432a210493b260b456083b0035f96844df0044468e71cb9ef6c0d762d5a4605371ede9dbdc8ff6b0963062a0651c76cd5e13e5d239e5b6e112f8421410df3ace61248a43e959005919570d75e59f75c885ff88ddf943a35006e2606d45070a219dd8a1d33f1f23a24da22f2d3f8398ff82791fff02f11a8df6253fc50b27f5b6066773391d13efc91e084d0cf02f0b502fa548aae5f299af4fc6ad75345a5a2bd7fd00f11921b9cf77c7cec6b0dac63ddac01bfea1f315cb1ad9a7ccb5b49e9588942519987c28f5a4cf90c4e4e9b261d17c6422b5b1d3d32c402635d1b4d26d1de741b166a633a20339e00c2b3380b4b1d1000f237cf9ab46d67bd39f8ec6af735c1039950b161072ad046a50031a2bb7374373ac4a2c7bfec8982de6f59bca344659729d48c6f7df744372a4693d43751dafe52a6b4c5febc682d23433db5bf03c946d5a7484adbc77e13f0991262b14e108c91943e7f127fdc662b580e8881cf782306359e957204dbd4a4498f1c1f600c2fc71ccf776228a4285553bd9ecd7a001f7f55e604748ff952eef66c372a1191a1a45a6f34878ba98e36137595968c79e8dea6addf91a70a6daeb84ac1c95f0d496a5b36770185c0675be6f189650aaab46b720622a43a90c48b205e694d3ff04956bb8c2daa3229b0e412eba08559f72b293ce9fb167130054ec4649aa8f407b5dd3c9aa8ac3e09f0f02cdb6e23bee88afa0cb6fd6f0e62749f631da28c34a7ca003e90436de7c491ca4d254f522b090b6d6404929d2118b6f486654b6237b619da1e78f2ebb98134522a939ebcccd99364f58b696b7382ea13868ede04f23d5e4aedc4e9efddc8e6a9b6b6f96f61620e5d6a974f650f52cc81d54fa18457757eec5a83dd474594624f75fcd78c725789230f6c6898f0cc1246521c681a98a35169352267c5e7bee9dc523fff6cb294dc0e211696d2597e67ca9a5edb421bea1da7f9290d2fa0e86849b35b28cef46d04f90af14b495e894fb0abec66217d3ed959b82c0438c8265273806bee5c940b321849845d99d77c68a64c850a1dd8a9a0f140761d3740ceb9f2e054b2864c3ed962c2ced79e69625140b8c49c3a78d7bbf491094bb57c94b4dd74ba9044795b590dba80ec6eef926d7c8f72d35c310bfd20d49620ecfe74f4cbf430dd442d9bbf815b9334094326224e182b1ccfb5303f2578c88655da678ee509e3a44af1c34a8bc1821021116263c3f3af3bc02b3c36ba8455ea35a133bb4b0e209d4a23f0c81c4ecf989cc19f4e7d99e1b1a10453939a239280d4a776a563773d3d110ff8875b2c3755460205560f9842f4c41b4d29eb96ab97febb5219f3084962778c39f88022b3d5d009d8a0722e61ce206150dd72042b67c087a061b4bba93983a5e3963edb7c888752039da0a53729bb438415cf0181e44f81941d92b0e8d639e23c8e48b7af7a17b75517abffc851ff8a1319c2aac3cd037a22f771e2ea3f6be256602d88aab71eb8e2b87c4fe4d420003cbec411276e2c85032b9963ea286c2f83b6d9ffa8cf7f00075b88178f18175e4e0ec7f16e0d256e439d63937f5f5085c3613bacec11613202430257c44132a3d405984b29a2fd4c032115eab01b1b40b9961b7c99945ceb8e28293de6fec0a2b2de80f7ff7754658145c0dc007232379b23da1264bca9c384a9f23ff108ced88670e047c227223475486cb5000107c739e6a4522673de0e3867c5c9ce6ac09672847fadaa528bdf5eaef5dab9aecfa34e93db58cc80181e17926e01d24f0a6f7381f2c864ebe5d3b510a3f6233b75eb41a1ac0243d5d32b64cb029546f3c246d8e314c920eebbfe6d3dedc25b4b5783468948336e062b5492b51cadaaae4e005cbb12466d955039cce43e42753e3168335e3a79997855111b93dabca97478257100294e49593d42f4362734e45506a5fddcd60601ecc0f7db8b91732e5dd9f6ac79f8ea4873160c946e489b0215ac0e59bb202465d1c5f407798a73473bab38f26c115162fbb7f7b0f3c99314b80c79e4a07ce26c675b38039dc89089399206e597a8258c04db2e93eaad27b2e8a872ee7fed5c1555a1b696bf4a42066a8bef47c7bb2f46aff38fc531b8c8387120113a04f27c1489b0824395fe52efac4cfa417ac76fd66c815d199c289752b666df78f320f6896ba849ba810b09790449c1715705a965ac08812ed19751a960dea4009fccf274321d8404be319a5b9d8ed8ac87f7bf634817f67c0f883b960ae6a5135846a7242ecd344815499713d3ded3702c14039f9dff27eaf3c5db049e640e0b3a52812363d4e6eb40a430d5714d6a887c0071281263ffefa5706bbdbcd9193ba03e2cf1ce327264d1130c272436a92f3aca8bbb1ad03f3796155c1f94b11e4d75be6a8497a7eb311cf9f8def7e84f35aede91ff4479e79bdb4634f6f84a57df9f2c46b77e70b5fc77d759968912278e98bdff7fe8eea6407960b42e8bc34704a0631a3259c5c5fd046257f0ca21314ed67f10e08a1fb7b57476413861a51350b465c3b1231421b5139a19638c763a749751ae3387d39ae46f35b0e7f4b1ae184325d4af6e653ca58c955290e74c746168bfe7494571241904f9d74a5fa1af2ad634a8e7a803837d7c5062ddb709d49905de11f252538cbadd898a9bd720b840009de7f88ac9887e23f149f82b51c71e0c9bc4745bbca5d2aa18efe0276516dc23104e484e6b8934e8b4e25f66707d9fb107cb8853b7647363ecc7680b8fb78c50955d48f364e0bcc31fdbc143cc03eb1f7449075fa735dadfd2b45d528f599bc50cba543d1f2b42eec557cfb16cdf96573a97c8b0d5ef6080b88e41ed985780398b05fbe0af702a6a0fb4b2d0f11ba1051a23903603803c7500d12daf21b204e47999db5315cb29b1aba603ef64349351e1e0e09c0c8f23bb81839921544661a0747d8e0524d492892ec3d3a22438107741e29c42929e618bd3524eca997c9842eb41e121f5267f02f648bd66751671355800a8d3c7814fa6760a2e11c2c1f94886fb4360ebc8a650817d4de8e65283e56899edb9c2f3dd3798fc42028e842dcd88a077aa6748b8c6d0f48a8725c05706d19b4df5c977cef7e16203df0047c0556e29df30bbe9693d54666ca9965cfbef05d8ee4435f6e5764263680101df4db3548fa94de6ded35e981210a18bcb5992ccd9615ca5b58ebf06fb6cec9eeb5d88493e10aa62c2942240c52dfc179bc8be5669e4d86d2715e3d4f8d8de6ef65cbbeb1dfd1786a0a77b7e1cdcff2a2437b737bf68922191e145769e9ed533f1853240b05b1966bbe21ff6c510ea6d00899de63655c5dbc1e221fa96ff56ce34adf4939798c2d9079dd9df0a3f0f460c594d6dc41aaa6d7767f6cc4e31fb01fe3f4c4fa618c65245510dc9444e2cbd22c526a362371f393f44da3e1b42b72c16532d39b250d1c7f5f3630628cd9c10b5fd9bdbd38dbb21ec74322e95173f8a31778f0edc820bbf2065f5a8e1fff82c08fb6f30003384d85d52df3434e377f9579b991acacf14a2ea122de3ee8afc1b2a9d4df954c6f73c4cfae37ebf9826e4a9963f917e9299d6d04736159bbadf86ec69725441c8716f72ad09d1af49a40214feabd7cfbc7105b8b38d0cce1e05c688b6d9056ac8f1e486209594889f9ff2c981f8a81bb15597077923beba422c1c2bf6b153330d71e129bdde78c2684d517522936a7817bd77e490b5cd56e6404dfb8fe12f33fddcf3dde1b0978bcc3275931c689064eaa391a42e122c97e26fd1257fd103a02d9e0d22e7a3f8ea3d58bfc4dc1d81e4d6b11b2d0154dd3ba8e2bd6b2c49748cedddd8b5529e20a1839170a7a7879b532c6e8afa30885afb6469b1806efa5fe6775afa31a0e45e162819dbd99a8c4dc4d74f16ac43572d519c33b0e77804c867e3d17ed3960624c814824a2d4df9e39a444089bcc4f98fe9ff7f933f75078538d7a6505573a3397353192bc2d6bb5c9073d88f40a187fe64e36bec45d3430df593aaa37449ba650dc554c74acfb3e2cca8a4f1793c1ef79d52b51d8a85670277fda68091539537b8c0406028729945727c445e3e9228793a497d797aea1706cc19fc2db8a15a29fa737b705d66169017ae55cda24fb0c0d356eb1553163f6354462bab226f6e8a8254c54984a254012c366d1efcae5a781dd1790469f7a4fb1ceaca9a2d2d918cf00ca582b3fee0ca082d8a3fefc06b38446c90ca02c93af0328979b264cabd1d459c06d02d8c91123288a9283ca0e8549a7bffc4c468dffddd9e9d5bd92ea928add9c75c7470fd54b6985a8badbdd6f88993016c278c11cb3d28e8c4a6e95aa3595d38629a3f28026165955220e1ea41aef26928975b22bd5f3357a448c551d07023c609a93e16f5ca2785ae0d8868e161fd38cc2c020e6ac75e5acb136474a22ce5369ba610e48f700d227e5f6ed4c6d86340f59190380fb68e1c01a798ba40db2114ae0d6b5f8012dde26e5df922b4df43a92a87f7325101690ae7902fbb14e48cc5fef8157ca3e43ca7a0eac9e1070b1f5165a682e3e6d8c8afbaee957882afb93bcdf19e39e2160f55ef753b0cafa1f79d760de256406afb506ae18f7752461b6389e3d5d378c99e7c234f14992434d6af1088273bfb020030a2ad16eff872381ee1d5425ae0c570177f47512f5298b70387bf2f1db81d8f226f0827e4d4f1765755f781bc2f59bec983e149fe5e5c3e56d422131113d1797eb95834929c4ed3f4b28ffb1e0f56a37700e05a024e012b3b690bc4799c4ae4b67a0ae826b02fdf8a0b707c743f059fd4deb6ab2985f0156f5ee9ffffd896c785f3d1b70db9f3dec9243019c587ba3ea855684ca9478f0a82a0eb28560c50ebde980ad28c0ffb8de6a7301b138a15c382b18158f68a598bc003994b04b8fceab47e3e9dd58e09f563e30b3fbacfe5d394ce095e1bb3af5ea4824d6e55633575e508585197805a24e1f79a6abbeabdf44947026fcf3e9ba4d527a0bf21dad10d7ed9617342ddab90398a40e48149bf0c7dd4372f23dc9b575ef11f364ed903bd1037c952eadc7408c0ee5fc92f76e6b73b85242b8062087971417d2e033c43b3ec754b7f664288e71171d1030c074ece744ff8a166aff0380a3b4589bad8edd30a4f97b430dc6951c6e2dd324112ea4d71a7d9af10b4d983b2554a39fcb8bc7823224e8470466dca6f8a194029e4877c4254347850cd405d2af9bb34db44db61485a4fd84e835655ad1fd9ebef2a940699e17994df5cbff1d308b5d5264f23e41b09a453b6fc1c2dcc966519609e3351937d734028b7830a79ba1cb7290dfa46017c083015078b0dda913209eec7fab9fef0315ab752bc652e4ef7b0f9cfad33e79258539101b7941ff0d86f67e5994992d8fc95a2d7f582e1f29c6686b90c69a34aacd3d1fd2d2994399e5961c394637c186c6989f3de1519844ffbcf7ce3472a30e266c83b11b59a032f73b767ced156ed2875ce3dcec7903c62f25d06fcfad769274b6711339de3c8641c7f52b178a464ea351d6bfd21fb24b08f310cd63ef1b66205330d830fa23f835d816f7f5816f9eb194daefd42329e47ee5a7e0e4d17bae730c280cb963082479877b751212ed889ed34acb012899d328b9cef1b4c4213e1f5384301a90281c1e88089865f913649885f12667fd3acf4ef7417dba47e8c8e06a4a5e22302acf98ec51767bec3044fc514f07c94f21607d44c3831f6d9de1a3b1932742d3814f24bbe7ce04fa815913d3d38d7f7f281ce1686b3391cc4feb1d005f7fa342a0994d4b758cb2f595341c3d2624e0fac4335854cc49791afb2366869002e44afe54942c6b48f567a647584e6b8d45188803c2749f26503daf2e5f08f2e5d1fb2be7181f92a01bc54cfca613e925078fa612bb344c0ca3675e7caf0e68c44b46e40cb706bb5b1c0cfb42c50412d982356cf3d2fb6ce0c83ac38f4732f2b96943daf7f6b5dce39e9317ef1f2ba4b12ac647f3c3b4fa4ba7385f2f2488fce06854892f0154ecaed6a5b9e2df65bad84d4fc87e686ad9dcb628c3351ae3595309b8e7617697cdeb2610bbb6b6449eb82c247065901a8b8a1c530128d1ac69a4951708f46102b0a9e35bd588896e6d0a0a4205119c05a58f349cfee1a0000a5d977024bdb42758e39641d18d30cded537c388e4e5b89d3dd8395901d6a238967ff866c345ae32e59a5be7834114eeecf54bf9678ed6718f91ed0649275e7543519f90b2bb95ecb1d3beb9d5ada00da02db4aac8e455700fc647416b996bbf14bce5ff1ea7368cd5c9952ab261b7c378fe43a65b122d33d9b261b0f8f345dda6d52b96fccd306a2cc4b0282b738eadefa22ffcd901d55c53febaaa9836bdfd1c4c2f2c6128feecaa9f607e136bbcd8a9e74d399085a8ab853e5fd3081e669cf12a2a6dacf85ed03b268054102d7635a769119dcd48fee30cda368d39793fa49bab421230acf0260d34978fbdd588a2e8ff8a021494c6c51c8a328f1cd4da405d0cea3eaad7bafcc1b452e5f6dbc68eb29e0306b21237549005d31f6830ed2c780ef17d54d4c47f28a2f5a283984fbf2b11dfe3a9c19cf9c517a2bc4d78e98a24c5944f4ab344d649a6b5d542e9b40bd37c6c9f85e0dbf0c4658f979d2ffff058a5cc2cdfaba44ef30d7bbf63478cdf0013d3583554f84c30c9808be0e818cffb88058fd624812b7938768d2b022876820a80f12ebac6524eb4642ac1953ae47eb9f9a1eb6e39f5a38cfded8f97981bd11dd3ca2c9035374f91cc98a3c716e301d4460a49a69a508f73dfd617478ff0a9de56f1146cf95b73fcaf5d614f65c885c5e52d80f204972460ba657a842b8477d96891d1ddea8ac33c6218442c2ec0d62ff43e471e692241dad0ad1b714ea24c86c69c55c212006383d4298086f5241eac6b1947b86f1cdbffd628ca914964000008749138329801b7574b232f333ff03326b2b74e49471f298bdf005258ad64bc6b5630f07f8bed586740bdf2b62a8aaa8e55cf05200550683756a5cc96e44035df2ef278ba6eebfcb3b7c2f78706b7e964f3694afe715722905e84fd97957b517297d7ba90c05a36d0560df4eafd35b7cbbff3b7618c3e09d226081167cbe34907bd70d9b0debdba41117d701e7ed35f07211ab7dc102084dca231254a389d53acca275aca4469410c7bd62daf832bd44bed9b45f3ad0a2264da85a07dbbf9f8ea960c0de5cf843f03527bd31a3c2882512ba0aca470818b96b9b640ea1249f31af6d1e85d3ad0b291a3a0a8b56fc39e41800da615fd50f2139d56b9c0c61a898116d007821b4660bcaf3155382956a14316b7a6c6524be0b0632abbee8e1f8a9b2232570522b620ac16c7f3f3ff9465c1dc1702db53b297e67a4ab86861dedd75efb243743ac36f60c96208e6ed5297ef87cd009d6dcf5b92330ec9317b17510a797793bb502bc183ddb591c55327e360ca8a4763d728e36f6c8277c54f47c90e7a8cffa19dd4e5e48b1d0971dd2eac5e602314b58e195a5d13480b0b193c17ef3ac64a00c9679fdb181cf06f78159348f20b6640eb57bb63b25a6ab150326cf548e440552c0f73f8139172fb3e46ed7d87857685e02091d4efbd5d1e5632ded967159b6131a394edb86d0ec3ee4c8e987bdb9549f7dc3f63dc2b898fbc0e207b87f687f008e6ea5d11cc979d21b53b8557117ec70a335a2e61e7545c0974469237b65f2633aa933f9eb087053491f972d57a70ef86777c95f3488e2f5f846ba9f92667f45e4bcf5ea68f109011047ac4f2ce504590d121f6442ed071dd981fcf3a8686eaedee0d260129b5e9ba6d39effe3cd2c4d6f93ca0325543695bf1c2ae6e8e0dd1ffac8c168c8e272ada2b495a2965aa3bc4acfabcc8081a51a9455fdb45e97270a8fe3a8b10f634656df92d7974f99ed6c9428f7d6c9af36d4906e6b3be094035cddaa70922138a8fd7df690b3fd05ccafbcbdfb8ef096f0e2004278db0f758ab04fbc780062294e7df1c2adb8f547ff971e09aa4972a016d423c23b832f37aa80a31cc30b376cbb3c869d5437f66edc8603a0ef7ca04d6e75cd772418f2fe08522b3332854cb1bc9db99ab7b7a760f73c08e27d2b41f0d70d45b5ee7c4f9eb3911365b5123b5796aec11c1d1f9f1f644a3ffe0cd2b508ba43dece53477c9c056316474d73df6be05f61a3a753955e05d62f2d893f6022f6ea01a91c018c326fd562265002c304ee0b6156fdfc7db5813502ce22e845c55198a3b25ebe8c9d07db23ff698c98c49808c7d1b72b165885392721b636184bc82abaaed17bfda218a73462930a84bb0ac19f80d496da9ab061c97e9de5deb0751cee8f0e229dc0a9bfe7724ff5ff8ccf8851484d0a22373f981e490fe91c02e9b55a333718a02fe82c343f6dfb351b85d44b9e72c1e1386ee59d4667f6196ae7298d2c4158414f1614e222f0e24bd0bf32ef001e9ba36a9f4820fa71ab30d9940e9e0b5390800e1b9e20fb185f7a3d0e339841caf7c45bdd7e9f53967d66186f19415a24ea2c7864d1106b1b351c2793542e82ea46246a7b7f695bb54217d2fc4011268b0aae0bbe6fbb8e962c1738ca0878b18fe6b15ede3e7ec66dc61e3650bdc9459847a884c7b1467236ebb2625ebc8045d715afc934d6b75e057a2632426531b12ea9b9ca5fa426b7bf69c1eb6a1c717db1885926c899ac3e7755cffefdba4882a460c4a8223a92786ed558d9334499f3f453e73fff906687e3a52b24147d0fe940ccb8b6f173ac34c6cdbc12f7b9bb796025bf3773efcf352045363e21f58c9f737c28ff0f9cdc567b341782ff22c6dd73972460478e4235f687c3dcde677a5f3ba8682fe71b57ba36c84c0bde9615e543c5ad4ff92c4f37b24692321f793baf95e63d4d4dcdd9d2d7508c375438e774862391493559c35616aeb8405c7292930ef921411803585c26a563960c3a1adff902a874e0fb193a83f3caa88591447ed32f49b5f258abfdc7846ca97abbe41902a9766d8bbb98f4ca277154b96773c778acaefebfc08d8b9c772831eab4c5092b7d55041ae98626fdc396f33009e99f7ed902c311df9c792c628eac9f8070c552881bf86246765a77deb882aada00dd920c647c387f119292702ecd9aba16012da0184376db0d0430c1541a9ee804dfd312af6c3f530d53aae01cbd995552c40d035f5b7288d027f4823eea8995037c1eaa96af68efc381d7c24262495a98c2e7f4de8579b8fdbf2ef67e408ca842bf0ce8a6a2ed3a23a3cf01b855b105545fa9bd18c20daad3132e81fc0f4fb24eff9ecbe3145399b807792181e83634b36525415c5f3095ccf0090434fd1aa707f1d66124ad4ff31aa89104750017aa5b78039f9fb16e1b6defe0fc2d7e08f683ac1b485eeebf7a047792c222ad287a3a63158223f5c200c82ca937da51e57176f5f483256c35eb79e5a79c2b40a6f0d6d91add270e84b739d2f34904f2979d475c4cca8475eafda0fbb9f5dde0b07150d694d68bdade97d7af2fe236ecf5c18aa791b4eec33d354a425d902cd9f08aebe8103b6dde89716fcc00c86b497f0ebde4498631d2706fded7165f8e3943d5ececcbd5a7ada8ce3e67dc1fe95890f8ccb7b65b2a9910727faad9c81206286186be7a7ef327085bcc205d3623be00a84e91962f5473807a4683036cdd82dc9df24884288ae204ad1a73da484a1fd8996aebc7393faa525a6061d5e716aec8af57b29881adcb6408e98b887df94bfb909f4e01ccb1c5d4de2f4d5e1ef4f0518301fa6795964e38275103aacc81d62077b175050e2b8b6cfad6580fec70817ec2431e56fe7145eca0da0456bd1074b831e219543d87c6a326321e746d3eb70481cf43340ebe9a1716dc75be07f327c0cf2da70cde24ba07bf3bd57d4380c6e8c4ddd490758dff4fdd8be66061299ffe9293cfe046b1fb2fc2e8fa203be01a3507bca62ebbf40a6af66112b030a2c2ec66699cbedd009f3c3134354e64d087136624e79d7ce39ba0fa812987d4b6388459fd7d2713abd9da2cd392639cfa8a4b80949861df723813a816a0b328f011c0f93493b5c5e9a24022f72efffaba60e88dd2780c2115f5ccb17fba38270b566f2aef33045941868abfe8bbb2e149f4ffafc74ad04ba843d226b7e9beea4443df97aa2bace26cd7d9050e92f28385432d3d3b6d279b0e17661e324335a9de59ca7a3ddfc9eba33b7d7ed86e1c5537f2f23b70adc4d7de16694016057cd73937a74ed0642890db0b1cd5728f98838b5ef347a8cfd0f9f67c58ea8f67b6d83138ff01a714fb723e8fb55549b687c41a4761f8bc3bd5d159ecc2a8e302f18d8e611a538c282a51feae7bc4c88fbc21dab969231ee115bf94cbcb888b023da3102a92fa716dfcb5c955705eccfd3f19a51e0a581aa8ec5de08e564e309555f017cb7513b0f1caa4929535720240bdc424f5ede23b3820850d42990f164d5d964adc2f383c38ec2a15952ae6bd3ad9f6bfaf11fe1819c03b1c94bdfc114c1cb5e588643962a2cec95bb8583d8a78e67335a356da669220116427e72a7d471d99388ef9224767593bc725fcef2e025b4780fc94bb35048f9347f212c43ebebec64370ffa441129ed0c593d3ab2dcf47cfdc5422337fec4118a79295e61fd7b591dc9cc14e04d61c79dada7c9b4357ca6c0a449822ac7170a5df581b2010916b86cf487ec06247db46737c957447a5276dd1b020f4116197a970c8ae1124a861be243a34b41fa9b2fa9609c3d4158a825e1867a6713959fc25e8aeda80636bd07d1b335a88ffe0abe61e81dea621d4600e8fa36aa05d76bfdcb5391bdbe6eb72548427c18d8b5e8fec5e799fb204caea5b86909f4c3c7f2b91cbaf09786eb812e1d759b3b2869aade3e027c4c2f3216fd3f39ee7d63437c0bb6b7429d0e0cec75a4726436a75582eace442c7b9b125e6721333f1198ab92381007581df52543c25ad96377f79fff001ed078f3009a5cab68fbef2f5cbb9aaaa686db9ee6a610d71a3a39c8ff407faa9db53fa3d4d3a61c3d0721d64571e949278f2c0fd3d900d18ef06a4ba933cfc91501449b5be3da5e031845c0f6a3e7968b2121c2d7bcb5495c595f45c26ab5c9258593064e6987f79a935d78dbdb17c21a41893d6ec9714c2035e6b6fe15a5138c22d3cb5a24c52560dd999f7bb3c8ab048b4444c89d9479f2859c42aec8601587e29e6d4a4b047077002dc8bd816a697b66788ebb1672d144313ced117cd0125fa14505dacc185d408d32a0c6ffcf611b98b76f2ef39a8a97c3a1e03ca77b43263523280e3380ca6114e3a9f87241f28795599f040bdd0dffb9d9b77930b516ef4b84e2ed8df8985395f0e45d8fe9c72329973566e809471a9e9db7c0f4e3d8399701331f65a1ef7ab80594f9bfebed16736ae92855bf727a1baf8d61419d6868bfebabd8368898723da84670e72d0004b1f84c511bf679a3c236b9e4b5d4dde52bf5922db58c0e5f5504f19dbb142a95cb5a4a4ad11794a9bd214cf824f28d736bb59daee8154aac02a39abbc76268747d09fb06bf1779cd8ad4008a2fa0676d177d12e7914317d1adffdd129510bbb39fabae594502cb3ed7f2b011d172e209959feb9d1666e43024e74d9d3d2aeabf29abafc2701679f8035abad6b3dfff9cad49eeac16bff4b10b322b6ecadfc4139be0b32d889410a5ed069a6d8027bdbd6b8f8281866f9b83d9354d6f60eb3d35cb2b81084ba48b3f42417323fb6f59183edb47a81ca18143d862ddb9fc7be8cbe76ddba2ba00ef001533eaf91906bf5164056a3e6097a04c5f9dd85cf2dae1fb771e1e531d7c69a4bdf282032d03f26b4363cc6de40cc491f533594a7c51c7c55a883191f739e26eba6272e6ae7e5868602a45fe874ec0f7e9d7de42da645a07c91449404510718be359d9f16ff38d18d5538af7970c4097d5ca70f2e5a1990dc00a5064560bc75296a56b1b2028f79ed154388beedcdad7a547bb9364fe9fb8ea1a9ad77fb8728a53c5e1c8d62205b210a9cd4aec77ca70aa4720c3b6718338a113e1604afe5e6d6e91b34dc9b335040f4b82a200eab529082272f2a7ec99cb29db6aab1f441e364c3fbb649dea64b34fac6d9c2c0d2fe042f7ad8e0edead0721d55f56f4fa70a87a933bbb0f064f02a98ddd4053bb4aceef1eed221ea873563408abd65353ed3ac12e301b91a2af2ed8bb60bf8cec2a6ebae67b22088faf65103d7bc3b987c10ccdb60e2b71bf4634f074b92f5b1ea7e58f7c90dfaff6b5ac6bed929d23e6e1a34ab026bb398ffba98dbfc50496c6840a6480a6a182be1990488b21079e835d4a876cc98e219e8cf45d2e5ab25607a3879d4df022ec3efc5c113cc7b0e9dd1a333fe68576924b728c721e8ecacadb5c0ab99579a5d7a053231e08dc87b448610b80a2856c79c1183a4d0391a691e8ac73ea41da6d552b14667e99b134e92a92c66d4ef88b5485b8c225e78eefacb9d6810c89c3890292168b50908f9df2bd8eb31316e663f9ea7d1ed4f22bdfa915645b4aaded58582709acce6dd25b873e1cbd5e248aa9d5ca9f4f2a953cf69521f21d0f03c4d23e165413e59f5b639780b816b023afd78c59fbd979d93eeea05f2e9c3d930740122f07aa39edb7a71a62caad2a96440232ce7333d352ffc900ac2bcacd7f82d8555361e8597b611a26c3eaf24d0817988f28d5ca07c733ca5612ceab72a3b697db9d362ec3ecf6bcb6fbe2ae4f3f1612cc80cd5504bbaff228110365b7dd755595ae8a2332ce9536b443d505a5aef11fecd2affe1e75028249c43b17d98b97876fe57761ad1d15d8840427de20d1f8a2b6c9596300918d77410f9f52237413cf911fe32c9a55c9ed3aa4877dacac53ae0a0c9e0bc1337a0ce74adf7730f323c8027caa781297189f66d78c804dbd0419aaa3cead9a0f646a533cc4400cbc186d63a0b6c3975729cf4f0708f3fda7242a48d2a4b25ea79b0c1e19cc4e44c9921ba87bbef9b62905148148f97c66a8b76707883623f98982774542c2e19f9e48984d6f5b59ad8ba9e5730ebb631ebc5966c7166a905eddd73cdb2a212088281830b77c081abcaf1652ae1517654c08e628eedb4905b0bb6124aeedd6402f1bf1a53d0e8b787058d5360197b86d5df2c75fa4918a6af08be40361657d670b100ac9d9996c74783d9f2210f32a2436db2b06543a06c844029d0bc649060dab586a5ed1681f84f38c1b58747b2fb36e846c926e450382917d171dd74671ba99fbb267f0daaecc955d2ec5d8223f7f2558d489b096f32bbe115f34d9a856b1bccf695016eb58e2422bf193ae579fe2beefa614b70e5b93d6fb507d40e0804c32050847875fa209d329245404dfaf3c826a9af2265059eb811d06d82a1941ae207f2bb69de13e4a4e41038184d8282d79618bf9dc91effb2f5af8ed21b126384585fed20e283b5054dcf0f05e87fdb673ae4327c38a460bb99dbdde933b35ae2c48549ae2b1c5f7fdb3fd5443eee5e8af8708678d05d0e7d35aac7fc8b79ad3bb56db5b849029298d46dc03905c0af71df3f7aa0efff6f75d63ed82cafac36d06e8f912ef7a252bdf1542d73bc6c2a39b9cfa4d8b43e603c77a7660c0a09a36c16d49405a0bce375d5d011d62aaf8ff1ec70d8dec0093fa28a46bdf17fe9fef91eaeab911313b800e04b37267efac00a804041f7b977bd385f51831ec73cb97e8e1e1f52fe2d8ba5989a44a2e68f112cff4a2945fbf275231629f726051bfee49b31dbf70b269ea210419201e2cd1d58ff5076c08c09d45be2cf3708744db64a1fb3a539ec30e6289b1252bd3e9698a83b00c7a9ef59a191d5e5355036bc751e370af915c23a27b944954c1e6a53a373920cb470483885d46389b1d77d3cfade725365e9643706789ba4ea07e187a6beaf387157b42bfd387f677f6d672ad23514ac7c2173a411f0fec17e264ea2cc07ebbf2d544ef1c7f6f00d91a24d19b21993102393b47cbecab524c180bde83b0c581b4a839b484b31b03290d04ebb3f632647e19ec10d75405e7e5ff949cc8078ab1cb37df704e9db21e29b349becd2b1130c6a9037a93acde715116b1f4b14ff32f28f994dea75adaeb990101e3062e821d8c2a076e1a891d50663af0cdc8ab6076af6907276b5ae2ba9ae444adf3610ae97f5a24dcb6ad8cef4c99950a4779645c26387bf30e25ab08fdccb870c924c1baff0096d10ca557c2fe39c675e5fc9dc1d5c5850da63de503e1fbc27b689b4638e1b381ecc58df25d761a71f645cc15b1b2890db2d6f5c889c61e44a50b74ff3c44fd00cc7a1e5a3704582cd92185061a8c9da139f6a57a3700cd2e4fce3d3b5f4858347fe2f86931abcab6491d69af44bd4f21e095339bdad49e1ee3778806a0b9fcb453f6896c87a3d33e6155e0ad1e115c77c77de06caa2a51fc82e2838f148d5b52e939bf8d52e14a794f7df18e2679cf0e0296d69866b0fcad7faffb83630517a06a5234950fb8601004eae8a4b47a1312cd94095a137240d382bb4dbf1448bdd4b784578773db114f79a4a537ac64bc93594023b7c2af8702b7e7d8ff639227bea53c449c2b282cf1608f891391143d5fedfcdfb6b36f0027fa720e2c69d93bffbc30eca7bbbe7bf022b3c84d3ecd2368c2d78ec56138f2bffb84e35160025c3e1f59b5c9e59662b13547b722a5af105bba7e80f74de05edf04765c137793715315562fbee65da64019dc2ba5485edcdc2c827e3524798f86f35856d477be4b9a218f4f9648f752b56f9e05a656563b50e84bdc4b5181cd7a58eb1d51f040a10eb3ee8373a68fec5fd05f4d090c59fa4dbbddbfa027b13b6ea770360edb9c35ea839138624fc27216728e0e5a4910eb385e316154594c39ba989b308e6979ea314fd996f22947593b19801bc98cf9cf506c5e5b2ab4e1305c469a927838639cce00b9cddf10c7768e5c0b92d8029bd568da27ffc8dfe97f80488fc063874ecc27984d92ce40b1bec11d6a59d5e9ccb51d4ad97e0988cf230800349c7e1785fb042b40f3688c5552b2cd5541b76852265a5d70ff91aa5ed4837bf38ac45662af6c9c7488d9a2485f91c6c7d5926bf6e2db59f4399f7f549cedd3888af5c4e192f008deeabc83d7bf4c8afcf7483f163b66882e3a0a3acb3006e21a9701b88c441730f1140d2f7d63f495c99f0e9e1c7a7b8a743b9957c64b2962a19619647ed716a7bdac6d497353a3b833836c55175bd68733020e8ef456e840df2bd41bdb02b70db7c9152ab7704443a476f9708e8b1004ca3e8a39d39b41b9675c69699d8831c1f1171053b0e33c219788014f82b9ff0181370523ed68b848559567cb6880db1be24930485a41ce655d8a9a85a6626f5e14dae471742a684e1cae6d9b0f12ac058da8b1ec35976b63d032e6328920cd3e82960406f2e706d2365efca24ae5e3c4aaa1403b5a6a7ef18c74795bacce394d0ec39272de3a6f08dd15998999c8439d9bf212394b2eb1ecc316b2e743a1c499d2bdafa3dfca8a15c8036c0caeebbe3c4b33ab5926b3f346d004ec8cf681062191cbddfd6a836aee901a73678f2c363df19554dbd5c1a62b56921ca1da7c7b88ebaf5884e706890de2b4d75e36cc776dd97e8a644437e8f187586e8d0020c93b86520157957a6a4cd4b56a84faf6ab1ad446cf9557dd4d98df61340f805d6513a49155b8a03457bcdec2553ec2592a51b31e62357906bfccadb8a3a33c0947d5def0e60cb35cf2bbf3c45ba999fd638582773f28ffeee0cedc9b2aa06d88692dba7f8a557f3aa698fc21afaa27fb2c03267d61a6598a8ee12895b2ee78440d60d552a58d5e0738c22bc2ab6638cdebceb7922e293dadb8a6765c110b78a7bf128b86d03f520d42febc2d67f8e511bdceaba94cfc74068dd91913eae35cc0cbc20d1a3e687f61222a51a9d15568b4fd988084c4bbae9e38f82445d100d60a07d0ea153a570b3457cbd657999d24aa147ae3a456a96aabd1700e2fbab023ea656755d8cc540188a8f673f8cd633dc7d71ac04950f294fbd78bea6e5c1747e11a6b575cc8136b8a8cdc0a1a5d44a34613c46c31787aa2df41474657de3c7770f23ae0d284eac94cef8ebe84b5c278b78878cf6a23592a4bb2db13ad600848887a630167f419aed1e6685f56f47a9eb2a474a26ab31d4429ef78226d45e88fbc7caa8bfaa580bc2a927d1af747361b929a75f5bf703ae827e03a12303416d898c28a26aea542f71ac84ea1f6d8dd40ea76dcf3d0637f15510ad98ddca1113180d74c81140cd531fcc35114182bd39b6ca56c1499df9a3e5f1cfaffff848e4712a39a3fd23aac89ff0c2629ece74f6017f6df61bdc7461d6959af02203368103da73b08f6d48182c8c8aa15d70e4089d756068ec14d9de415a77923173c252a051ab73153d2044d3d9724fc3892805f97c5367d002101f2000399106bef0114259e77c1a2b55ad65221fdb43bca82692594693d50781805357f0a9a8487d3e35ed5d4966ae4bfc3099704431e0be5d04b053fb7642fa44c7d0c8da64aa32a189042cfae4e5ad0418bbffe43d06a1e1d411136efb98d6178d734c46abe12f5c2a1ed2382aa73d6e115ed4d70f4cdaca86d4a385bc4a9b2c28087376e879e44dd6e01b1a88a4889e8ae8caf08179bf27ef9cfcc1b0d7b8da2820bb5efeba26b6f7328a40dc31c4cb006297e15b00696b830ed7cf1420db33927195dfc18e42bc98f09d3acd3936d30e487e0dbc3224192ec9b1512b466251dd9fbf8a40596287dc75f8b5c5bf0b6f281a284d3b3915db776b27bdeb1031479bea224a51aaf52790c9798d4100f30cdedcb0907411e48c9410f924d7be1e22d3e3d1c57f2b2fbf7cf4664c221e7663c361c673f269f3f9ae66d9f78ed65201ca6607d30033336276c4b4bab5b6909cf7b224dacd7a89292e4985bd058d65520ac2809e7e573a7b9a9a12802a24bc8243ee72997f9105c720d68cb07adb769e7c788a3a6ae9a1fe4c4166854a9811f4b37c8d551efeedc91ceb4003062a9b62bf56212bf6b805c0b504bc77d92447fd5d9612130e4a4050fe92ce13251d588d143842b1db0608d7cb6e3f5e39ef90d2f6fe9da498aa06530da6c249e8dd2e1b92bee69facb250beaf651075e425236388c1af4918675729e7d9539a9c03559e9d4796386a29dff5570c5fed974efff399fa419a243a8f4a9281fbd85f2a57eb3706965b81097a571324f72bd420811de3cba4ceaa6754286929c6a3a6a2e56ed24899ef7d176a936139df016e5cb5b49111826f328a111469b10f3ca33e1faee293a45d2e3693de28b13cba2c74a76717b8ffb85ee11ba115e8d65cbe8fc6afba3973271e150fef7c1a8262343f49272accd77fe3ba759b8386899771378c140a953dae2342460aa6be8116f52e0ab6370bb8d628c78466db4ac8709811260fcf6280f0bbdf21b56c993a820e5eb6d34cd31e6d68e8d0ce1cc3695676aaa1e9fb52f3a611f12c595657b87de46b2574ca3dc2c2ec4e84ebdc861f427e9c3874881ffaf1dfe2f15ca89dced5a3e57e8efb9145bdba4c9460da9214720de9641f8fa9ba5502bc11fff164a8eeaab58a60ed9e0fbc615ef209a1cc378643e1232e5b5cf63dcb1473545d0352532108aec0b76fb5966099cfeab01daf862fdd75f289f4fb1efea5850e2bb916c8e6519afa32ebfc4d3fb5fa2887a53b94edc2b3c8ec67df181120ea19d3d4ec0fb9b655d1f419e43df74e27c35ceaec0ffc375fa5564ce8489a967d1f7866c6a246da5346683c9e579afe32d6bc873c4211f35846fd0a343f95d7a0178248ebbbd5d4ea67e48426689626fe763f9839536da5eef6176984f5c467f13ea14e1cf8b94986a842df6c4e3936dae1f77f7380f2d29788cbcbd4792902591941aaf27d2260d411b24aab13b548ac20b72288cc94649a8e16b40aa56c46f6a999e00083b8476b65110b247fa322850b2eb21bfc7e37c1c9a0978b6dde3438c645484fac908dba360a4ac980ae21fae504bc4102bf88cc97a315c117cb073f140258f2899c91f5aab8f461380a1c38e2fae4af12ec26ce1d92b27d66f55f4eb998e4614514a684f106447872f99c7b8add5a9bf9fe2fff73b75f9804b3c0d681faa4e6d8c0d0fa927e9c716ef115b0e28ed36058f11f089bc54935dedde25c78f820d3a94ef1972355988b5ccb5b8720a71ebf8655fec3010772a598247544ce876bb9554386e923fa59d99e89a5262d2883601ce7425a0a18cc0f20830da61b319c0d3b31d4e6314af66245c716555124d30971beed74bad869625b230181bcaf028da5188dafde44ded013c1c6a9e2a891854511ab3e6e820f1cf7c2d75810c779098d9449499b780a7f8f19918db7642586eedc2fcaa5dd8b2fbab31c3dcd803ae22f231d0b661439e2a6a1e34499b7d3e415dbe888111b4b1437f9175cdb19c367c8700d5a083798cfee2ef57390712a8ba75c82200239dac252318763a6e2cee40688e4926cfc6029350eac353e74c830dbaeab00d18667a7a1d527e044352addf0df8f81b23fc38697b14b44e334376457f4f455559c8f36475c5f11bdf84f2cb426081343f60c1cb1acd129a2bc2375e0e880783c71cbf9084916ff2d5d4426e2effe0f3eff08dc9cd755a30380a856f572a42a958124c12838bc821deb10398c9b78ddfbde83895973df8ddf1cbc69592c048781a9a3f0332a44e8cdd8af831ad824dd069cb44d2305019a0254d74c89d086e3c81ecf82be119105aa85ff92185fb63abc674158845ac5ca7e98bfeb5cc1c9f848d914b8b576584bf102e72d5c89ebd082061ce3f74fd7416ecd62582f18749eefe47c505b74666e77e2153fc782807718ac6de2c15a84ce08063a2ecc5ee9f5d954b156cc1c697af3fd3a60d6411475d21ee56895083f1d07a97560492c71223e9172d0411aa0a570ff333db6ee47f18edd145bda0ec07784e1407201d5e2c8fbca2648ee957683d95da1d2c327ced6e43332931cfbd080aabde06698955f3af9893a0b13ad815f63af726bdd30879bf69532a8223df0db1e7db4a5e4ebe09f1fe54406f14db0540e4bc9bd372cea6de331384459df1739ed4a8367fa6a006b7e3a461ba1abe2b02e6b7d36ae8c01f084d369e44d217176ab98964da62c0e759ab2e9ae7fbac6536c312e055246fccc471f8aa5cb46f64e34bde6f15ae71077143feff4e5d95c0c2ab4a2facb75de8834de573a288dee900d9337623b459724b244ab323b9faf489f262296504fa27c174198feb6fe6affb4114cf5b873e43864ca3625ed5ae0b26a504ffe0e1b1ad78513f55b37bb71d5d9f6ec97c14e2c3a8ad2332a4cb00a62cf73dc30ef2974b1bdad1cb148cdedb97900bad40afc25b7da2d07f5cc05199bfa31392c102248927d110c426bb440ad3e2372365c29b3df20d0b09209e86e8d68aa2c3460e6891ab4d277d6d40093cbd0c80fca74ace00786edbb06c904022a040a4d3b0c121ba88eca05bfe5f043083d1332243544ceda46b1e9afa9fa9ad0675e7c717ac6e8d8e679e6b21710ab5da0235130f58271faf129c4f029cc3e1f18e93589f12ea11221519944396a171295cf77d41e7fdac7be142dc573824a57a5c05af220b7aaa30d70de0390ad6435cfee02022ebcc43406e679e6131babe0fddfe0e630818c4ca5cdaed2743447011943209b6d392e99f134a2c180e53aac8afd87520d15bb22d09076713d3f0ef5610980710d67e57a818c23e26b2837f22e01fffa174eeabec1624fab4f098e4d76e3e13c101953e8a25cc540d9409ba07305157143cb7fa27402254044a49dae66ce5d1712f70d6e85c351b655852b91d4ed3df10939e2bc859a3579a7f2420ba7e95f5897e6322f4dc9206b7736d2a0db9d41c7e7e961bd66e3c6a4fe83b14bf6a64d02f4dae55a87d22e93fbdb4848fff8629260bcf033648dd9b01dd4adca4014fea54ed6d61d5a2ef533efc9cb75b944359b9cc09747e6d607fa48852f8d3c447ee08e7d5a03b5c9bad54fb6b3a622196127942e302a7f5f568d77ad8e448be5fe405e00fd2df1c95cc00b49553e396a25cbb5faff53e272f9b29c4fd6f288919ff020b80a35f0ce3f02c4c5b4813ab2ee35e08e6710e30e372525538e4c7c028137b9c29a2245d32e940e3acc24a660926dfeb5f3507da39538cec05437f852a73da6f4c144727bde4d44ab2586e1e887c7791cd6c302ceae1210bcba1d71ff1f84bc435529bcebd8af640cc6162a0d5a8f3f2f2cc95040fe60fc619f5d649a0622362f05547e13eb5c1a64b41fb49c07db313610b543f51ccdb3d852f1e6ad320f4df272568abba765f816a97dddbd5954ad35de23d5cd2bebf16ad7a4f0320238c762436fdd48dfd346ae034cf70b8a209ba01fb3eb3a7fce228ac8fcd8b767f2bfda0b54902072efec1e9b58f23370c8cfe1a4d80d869539ac5075e1095482c6b072f24993e7273b90036aa52fd93cf7dc54a233264e7556b2b1195de652c46cfaca27b4f1b351b969bdf2e5fbedc7202cd13f4199e2dfc7aa8f0b93bc3ddc3be1c534144da72bd22dc8f0d56c27e5f2ef06b748904ae33c22ac47da10865510b896611eaef922f2f274325fd8d18f956430e3cdc887907820b5bc9039368d15c99b47ae4f0e7d12961bab540c600a2710f8b69180edae345a313f1a47426e4bc4729c00981400783f6e10aee3e0853977281faebe2074bd5d8a40e1a2faeb6842e19946e5b4df9aa0f9e8a6394e2faaea7e721248f5036b52c1830cc59984988e2cdc0fde4764e15bb818fb48ae8fdd5e7ec803965051554f93a32fe73073072b7484bdc56ef030f1452e2b3640665b84dff919b5213ea51ef1abffed666be339a9b80e582b08f891f0459937ebd42a16abb9f9e1672fc2925b864a1e1620689c108938da6516e72396866d5a14d5be75fab3ff648ede12aec4bdabc5f741cd0fad7a90a45df6ec4d0331870467d6dfd3e5d1c73a7fc0e2f5ea73adff5272da1dfc5b51b91b399d8eaa3fc505db7f9708c4f7b7698860015c5cfb88665a70daa67e68c8e1e460647dce167c9f77e9e6b50c512393fd0dee274f85147bc87ee06cd83acfac9b2173e5cba0ba01d1bc40a911128ab2a1967a78a1b2f76c77acaf5adeebb4aa636fb9674db3d9c2e8fc8cc0e2e02728dcf8e50a0331d51b8e01338dddd0aedc403969595030418e0719fa239e2770d4bea24e2a4620264502907f44d14093449c922162779bc2b956a1b245479664b0e9e2a9f73e8df19ee86c660cb47a4c235dd2341df06140c5c60e2aa4278c90070147476d9a005e672ec751c7be2da4295c963668cbf139beff05fff0aeda88af59e39d2359f431ba062209584b2bc355ba055ac7c293020fe2b4f6870170f2e5abff825af380387b5ee9fd2c8152b4a67103227ff80ca051cb43b5aeab40f618fb0d5134c602242f91eba4b212ee4010812ae3f54b0b758ac9b5c729865b676f8f9cbd4e0aa36b5a24314223e7a74cb7510a4aa251811ba698ed85a62f896e71afe53da0d2e63f2dbf47d736c35cf0ead110f5a0414575fa3726171160dbf6ef0a4e4a9fa0ac5716570a513ebe9b714b089b203cfbdc2e363f4932b50f9766ba1503893746004fe5d8a27de8f6f5ce1304879754194c35940a561aa0c98e6b93f24cb4737de619c30ebfdc538594e7a4546e6b69670348dd109e9286ff6b9c67539efefa7979dcb253c77bb7ee5fdf3e4abe98572f8f9c80cd2eab90e249e846d766fa57a1cc7dfb8f8f736e59b1ac15c328eadac843856ca613a32724b5dbca36100079efddd76b18161efdf78b14559e41cde642864c0296518fd517ed0f3f8964bf56faf06f15106486a72396b9b76d1dcdfd9ed707236b3865a139b2e2a30ecb79158b40197edce5a85dea4baeef59c5016b5efbcb1fe76c24e958d40bb946d94ac9fb4d7cb8ae3e7eda424d7d6d80002a933c3cf2fcf0b65123c02fcbc3cfba6caef384363b053103bf5e71a7c12cfbad4394240f07683bb7c15da04a82226e5e34ab4a7d67335337f0f67d4d3b72e23c9a135025b155fc8b02e9dc1d3870ff03bf7861ea395c7d051640b20d88436eed8eaa2f6d887d4ed60bc53146cbbe2c2d8139510371f73cbdc0dfc96621bbf7769ec89d1f9174e6dc05c78d93ac12ed508d68b70ffa857e96ea71cd80a772b9b1f33c8ad8d91576ed1d69377c290a2c6330cb52222b262eabb4b0dc6416372091195215505e13f97fd579aa46e650643acae3a55c5cb7b1cc59a2ec6aaffc52da9e68691c3ad7151339f7b2fc78f07d75f3bd34f1599f92b92368a705176065d962a97e958ad393187c84eeb2d5658d0aa7a6b5874558d473ba7a4b4b4806dbeac2ecb8f3dd8018387d8727b51036dd867bd0693fa2111bd7057729856c415901190536ab315348a63901380de462ac454c7aa0578d98b3e7f52ca1bca6da95c1e765ee2f68cbc5bd473ddd00f5b1524a1ba568b4ef6d7e36956c399b8018a3185d51bd209914e82efc79030f1f9f18f3b3514ae9dd7f3d9904430a617c75fb92bad238ee42fcf8c91970f2927948c769145f57400bde53bda3ba30df30caadc0d86a1dc15ecbff6e81bf60d321ae683a9d23f264414bae18adfcdc4d21e22f643b399da4afc292bd182d367efa5d7b3168fd69a349a182477f78ef77574e71b833598976575eb64651a045dd82765ac804af0298b4d708fa1793433c814410af1584d21b95521a8c1e9499850fcd2d1277be98b8de89fa5c79486a8b444a4eb48d8f572882e0b35914d61f08c330699e5dca4cf81ff10823c71fd14150fbbfc026d4c3ab3d2fc4c334103881ba003d4890b95fbca2f88aca8af1b45369c74350efdb494e34ba7baab12047d2191d3f7171f6badd0ba3e9e4b1e847243ed6a9eec97720b491849180cc7d6ba7c5331c35f42e1c35a755847816d14f9374dcb58bc5d1fb6e4efed59f16c220a38bd9f465df2435dd59d38f7dbb906949385692c8e17803116d070ed77eab8fecfcdf6db7121c098e13bc5726d1cd99773a728fff151770b7c9effba9e4f6731b0e2e8ab505e7362fc510793e522f1a08fe2c8551bc98438acf2700ffbe1a2266028c323f4b4720cd120bf60d6bd1b2c66b07ae6fa03832c7c1a9344836731908c8b7268c976d2bc9d074e25deba167b5cdd1547d08fd6cd251e2c5e6600708cdf073fdfe06e6c11c91fdac8293a38397051e16418835e56a39e64f096fb702c659a3be6a0bea8f9fcfb3ecd2db91a0a6033eef6f7cf00cae078c7ee78870027bfc1dee16cc39ee886bf84539f105a6792bdd39f41351ab112913d41e244732f33df626997242a04a3436b39bd5f60f800bc29ea4828f0578db7cea46c6776aa01dfcf23afc004603d81ad2b793b692298a55fc46f61ade98b045f53e0e53b80c7faad592f1837de8ae0617c0724c20ca559cce1ceb01926ac175a017ea7e13a792ad776fc67e8be79ec41235c186cfa186a18c1f268277c3374d36bee9c3a036ff5b2998117176a737f414462b47d2e92737931fd8d25fe791dadb2efb84a5149583485b0505294e0491500e18ec058eae29ef6c5b0d86d0335d40ce717ad09096c5423acc12c4e79b2ff4baa77e85a89d957ac6f32b193545a77147a1d16d40b132d92f5ab4eb371567ed42d708cdbd9160d5c00c64ef4e03935211bfe40416e1955fa573c2bd97f757a05a0d5e1905b8eb7e44734c3c4aabcdeb290278c08c5ecea2d6a1eb8c334be4c473c5a325753ebf11ff449e0e22f65cd1c882bf29b53b4e26dc8977190b0d3f9c2ea5510c53b8476ecea50bb74ffa64d9b7f6fb81e274a1cf18edaa5023bac56bbefd2ed0f729945401e173f6c9449eeda27d1ca404920a5ec16b538745b74ff05536af629836177a6b349b720abeea4a4487c6120f111073999f3d0059f151cdd5a93eb72ea8591d6f5231ddca3067c5f3fd60d417ec59f7e12973ddb71915a364e22adba9571bac702ebf1724377481c8825f6f730d2a2530d4e07eba5fdb5ebe45de294f3d5fb1e67b459e2caa3d5a89b7a1643b9630291a730e1c280bfee2fa7672750d410d43de3df53ab62b9c0ef404088c0cb16d6795f41dca596e0aa48dab556c6567d3e04f362a7baf8d3645d3dd54bfa871f2bda22e5cb61616a3ee855f4fd9ee18043bc80adbb88d68938ab0e9388bcf98f4a9fc7f3faab50e73ac8b70905c2c49f9e5c0835e40191f6f41beb113ee0926510163c91a6f36d5230ae35bd826ab6730fc6eb203f5dc7e751297b9d4239c87044841fd4de09bc3affac105aade0c16b98580bdd4164eac28ba384e859eab244ab0c528bdfec70ada35495d4624d3fa33ce7ac44e95c01cb78be08b8df88ad54bea36a89ab3fb7df3472f38b5ebe2721bcb98cb9a2e5e8bc2c645780a82946bea9985504a3ec291d9622f445480c2341b5a32fd88a6817b6ccb7026abd5054b8d71647327d0f20f276d7e3d59e2320583546cd5b1be40a984e1f5e2424cfad6bcb3a5e18334127b3b329b85b588046920eb95b130837797e9b46f50241fbb70e6ff58cd7c2df11c9c87f85f3d4dc3d6fdd451efe684dbd7ac121b9ebbb6b39bf0e5cf7a470b4c316cd9bfdc37142dbe1831f6c74f7deef43cb95b6c002a17fb088c11b4e5ac6cdc26d87e948a2d0d48b331c7b5bc0550ce26ed71d25b0c36bf1716e156fbb4b5a260abe8aaefd7cd8ab631310e44cb26254de1467db0378d66e4fdde3af3eb72f57c3ecd76cf1c364dc6a6f6aa5e7f05b389742835b38fa6c0b323433b56fd06334de9a7bfcb760a3fb28d078c5e942f210b80be4ad9e20efbf3bffeef361d2c9be886b7f77497d5439ea4a33abb6b5e1afdab8650e23f41436917266fd97813c822b76a3533e3db67d069289528ec699480310572298711f5db449c1bc5deb0fe03caa30430d584a1ece2f3aaa3d29e9f2d09fbf9e8b091d40694bacaf7e8f942cf220d90549e98f55432c027c7937d707f872b041c61106d437b0e13374f5b33de5c2b79c6309d71baad7fdfa80058899b7b20f17fc2cba9d79b9741164a049d4129af42a4adcf47236834cb0c01423e26f97660bc28c2a6f2037d362e5e03377ce731aed658e5509cbcf958096ec8c973cde7eb353be31009fafffb4d163adf0d35f3f2d1575ce5e2031a73e58d79ece532a81009988e2e50b3d9697855133f05a338911cf05d42b10b177f42ed07e77cb539d114c7931e995c289ccacf0fbfdec1bdc679fb5b3df8d20c7dcd589a10a455952e40fb5cb82cab9b61e61face9f67d09a49dc33163eb71ab6e180c810019c0f07102b7ff57545e41b4fa3ed03e273a3e1dd6958d33182b43fc4a8590a5e50d45ad0860d74f8d605867e9a854a9e81a0f090bbc9d77c56f2e60426dae8f798017c62ab36551936cadff6794fd7c56704c67eeb51dd7df6e034e1b7b8ad368940a1dd9e766f83122a4166f85656c1680a1913bc243ecd62ba6480f417c214cf01d535cb73188e30c62fd42e8d10059cbaa54d0edf319f1d4c8c3da726b589289d5ecd50bb0176c042ba9cd197329070f188199c47a3a9987e297dfd33b46d0f521fb5f542e51613603bde021a5c58d191b8b6b59f46ac30e02fa935bd0cc7d7ef84d04b29bfb9c126a358d4c69a1005e40e0c2e1b04055522703a168ad4c52bd8b0ce0e0dc8fbc5f6a9e860ae8c4a37e3fb0f5bc9af67456e93931a0c0eea81c507b845880f604612e46ce6d31ad027db87e07208226c5766b7b566361bf47f02e82864e558c1f4f53cfafd67dac7f471d8371b65c3d7d176b095772c7657f7577a7028ad6bb34141d3c3b0a81411cd74fe31b3c0dc4acb1efad80ca2c54d37971f4d2ff7f341072fd99cf0c18e84f02ad0f45be8fccf79d36c44ba4bef56fe2a765ce6ece9f332f480f18887d6b4ca92f02fc0b19e38f900ec67c0be6414717b420e23ae56a04ba412b78d3bd4c9ae865c465f83597974148bf147aff0040156c92b11e24d6f57e8306997f951084ef789407d78142ba43f4b00d248da3a1b6bb25f55daba629b683c99394378c70e3f620412ad862e7f3c86e8552e8638df6a5b3bda207a8d0474f7a723337717aec6e4b66e40494c3716a441d10e6f1ae53fb6a0a0cf02ad05ebb97eb17c823ec1545b5db5811d21d672a6f8e38e1cb01d3cbf4f47a558bdc1ee0e2c099a51ec2c7468b76d0d7da20603aef220c33531380cf99917bd05819185f0500b1bb66ce4fb5d3e05096b3da99ec75c28fa51ffae3290f34a95c3138304d67b757c6528c638f537653b2410b4485870eb45d57284d06b0f2cfd6884749cdf7a41addb3d0e54d2fbf8440e3ed75b4c82aacbc55212cf3782b69e3bdb5f239d7e0fc6a4333f1a3e4413022d15858a25bf62f953d78263b57dd31ed585ba424574c73ecbc27331998c87fbdf3f7230f48b7fd4c7b7e8e717bbac2b01cb1fb86eee2eddfb94dc37d70aa5a5b308edd382ffa860afd2a4f4dddb0453110bcd30f58123d0f78fc2309d144afd70538cc1e1b72f66236a37cd82eeacb049eeb6152db35d6a9cb3b728c924776c30083c4bfda9fa3e3915ac1a675ba8309ae765a256a7639399c4b6c0f2fa5dba7a661e575376856a3ec2ae26c8ec21c57b124769e04082c17fe2de5dd7a2633845353149df5d1fd705ba020200bfb73d546a19b6982662c8ba0b590f5be1a63c868dfd3da33cf183a940d7b4bb5f4134c9cad627c67d4420f4f0da951a291df79071f61ad78931d0773aa773d391fd4d47da0bd018514982e69b007b09baa7578c7a1897d66192ed61b1b7d7fa2919737fea7603248f01f50534e08768296049359422dc0690f564eea78a16b92513b8f33ff57cff743db9bd8c33f6ac0f87e84d455b10bed400e582ba2687b0154a18db3148ef97be7231a99e18b0e7e63b2d466721bf34a8f916e375c8f7be91b26540bd0ab9be88eadf94d19620278def7cca9da9c9e94586577850b1de45bb31e0c9a7a44423db36f2bec8777ea0dc11062647676c7ea7fc7b257148c08b639a18017f68912887cf65a040d8970b2c7b675ffff47cc8bc14a536e3c0e7997806a4fce9c7f1b125f54fa1df1c3d491f907ac20ad33f665ed94b73641794e0ca058ec6f081225119c8630260599fbf60a94a488c084459aaad206fe249a7be3868380b37d4cc908a593bffdeccf31cf702be55b825c72a214f17ace89b951f786401eb7e852e3c498190d36b5d2d61527e746ee0ed40c96e9d746c4c3a8b20bbf25e97f4b9ba601a8e112d05716d855b08644280b0b6f4e332cbe44e6db70ab53879d364591ff64492e983fe61c064b247b356fefadbe767c16ce52ae051bf21b15305ff07832d84ac06756297b2044628008c2dd912c13c45f4c3ce06620d97e31ae14202c5c61ff67d161d820079731b724b18c2a3a26910645e3840f2715eef38621724449730ae0d6a391eaa7947f96adbbff4fb93b0f202c34084eea59c0619cb261e2fac64c8f67a3ed25a69ab08f7f1c3ab8053aae18bfdbc323e5d93376d496f095f94ed2ab3ab52da46767345d98c8dad05e2dbed499597b57212798857b60e900a925a0a0e0541908865eb279e8e933085a4d241203d462325aaf86f800092676a8f4f5cb9d6d1a8c54d1063c784f66ada77e085e73b6e21d5dd4975b8584ba17b3084f8d088816299882d7531297ba8586af5229a5de9154c40091a7e8548d94ad3f2a46a644b5373df6b55ce13296cb7e021b4b2905ced841ffc4bec32de438762c99de88a3f2fa534af42bebfd0e975a95e23b822ca6e0d3226889a95d8bdb49dbec17f44cdfb05ceaf8ab785402e338c3b40bbaffb33c4fbda2a923c7be58d0aa78c8629580fd5275148cd93fd31d30dc080b1340b8973490feb96dc4d2b495529ea05ce96a8f7159701fcc318e790f673573c22ee94924f80045042ec2e821e0587a3a93578b29f0aefe3e183f0a34e62df322c3a32eab5f7e2bfcb6ff2919dc550fcd5dc5163589b9f2214211920c8617b2d9082386c5f762b97cfeb02103fe9e36e3d9647557929510d8e59c53d659f975aec3802894cf7c56f02e2b4de6e5153d41d43fdb4fa6bca14c90f541c9d1d5a7f9db6275bbe0d18b5a02920458d4fd507374ff4cbabdcb99c6367122ac5f5cdb3c20b992c146d09be8703cbc80d81d10e49cdffac500a093ebba04b2405485df150a3d067001acef59698da8689e9033c4ec33d4e89dfa6a48bfa5ceb51913c93247ddde1511c05a33bd1c4a0d2c3f50a443e4f940f916539d9b1a5ef3665fbdb100ee7011c73ea0610cc28390dd020ef71b3a9103ad3a2b4952c810a4a43e2df3e8984d59348cb49117cff2f1345416c43aea88b9bb6391241a229e1f73ca1629dd451bb9e2b7969022e0e748301746565ff9237e721f820f0c0c0135ee8387e53d2f96362063654d420da2022b027eb5431c78ff7f95811e0a395a436524343535a12743040033c995fc7ee0dea84a7d15c2c870320b750375e36764e53e993cc59c32e8e4be76f153e14b2d0be407dac6cc29f811affa08488498afd6bfee7bd107af3f133abcb478a127aa33f0bcc3c20b2b31fa33a4638b22c77d968c1fbd7c4cc48fbd7b9cd0349761895cc4c5855134209fc915c5b4ca42f75ceb23308e51593067a34e3b52338cbe35938af20376d474aad301e6079358fc86231f292fef12b373a3939991ac8cd789d27810e4d67f28a39973e267dbc4108080a182f06e0ab21b256c9974bca39dc03bfcfc340d6c0acdbab1397363d8d0ed78e47d6027f9a945f904fc2676ff876a81fe6b3c6d1c9d1fd94f676daea3c272f904585946a937faede9d910679d6ed354bf4d212df69a0a7b0f8948cfa102b1965feaa17ab4e265d49c893be3cf3ad681713aa925f615d2eae5f73a7ffea45d4b8d5f053071925b0e44cba0876c1046e837895bfb749a51d2d4118ac61fbde0c0180ff09abadcf9c5049569c40d6813916cc867fc085421e1ae5d49f0d8743711684e225c85eda1003133ce3db65cca50f8e93b4e612230de4d576a2a6995e262da59b3805f54d1c95e02baa0748dfbefbb4f9f62447ab57958afd9ec08c7202cdc85eb39913d518e4fbd8987da0956b27a1578159a4fc790f987e02e7e0487f6aebcac81a7cc162405f4cb466e520b9263ccbf3b07ce6f207c1ae52d261e916309b9e771d920165aed093b78e6a4821719559a6f12b35f5d3231d2dc8ceec4a1c90eb1b1f253526aff480dfb66e8cebb1a0b15b37c4a00affb2db6ec96fae880b32ba5d6fb7f484171655649ac40374f9664369f6157cb6203501075d3a2f1fa8316319b8ee0db09e89fc4975a368f63749c8ad8c283c49da8cf1cb408648712440ddb09254bf41e451b16210b7e447b691479e2165fe8b4fcbbdca8046da49da8ab6c79e110cedae5abd2992c738fca7c49a21bbdf4d5486e30510861b001ab0199d5d35869802563f0586445931c547de80a50dcebaaab6bebdd7ab4e09934e9a3ec1eebf1a459b476d2be955f6c675dd0cdc1dbdbc01151e97fdcb6ad8ddae2bcc3c3d98ebe62cfe8eb75ea058a70b4e8ddc0e3e2f7226f481f5b97d78fb0c8bbaf7ca3980d156246c3def8dc272fa9186e8ef4426802685422e5be36d13455c1bd24b55a01165d060034c7c7086458c0c8801ff3ba19b78ee78be64638ea67d2014cfabd502ecfd25dac27b85e6c69909a738256a17ea31ac869897fd68b3584f3f387d33652821cbea5461066a817b0f8aacb9143a4c79ef275d6fd17efb254cd9a14453e22651a2986bff8440963f5bd4e05d7897b54b5f8c18abcb12b6b526bba0c0349f560aa5d61833da42aa4d3374fb0e7376fbc908835d47fd2757e956cb5176454cadab21513bc07c3b8a7cbf1d257782cf67c80281e00516d70ca8ecc1c5099f3dcbcc63b933dfeaabc7871951c020b751452f7c61480e15da4dab8e92883512bef6f248309ba6685688faa97ba34b97edbf212f68477d5fdaaf0e5ad66e8dbee4b5f2677ed97426a254deb99e9fb32c5574508f9ad4d693d54438083042eaa55f61c0ca8a74772178d3767a5d5f3af7dbab68ba310dafe8780c8f1bdf0e2429c83260c60dc1af670867b1ab4aa09900a520d3ca614204dca3926ecef89d74e27fba0e59692186c7b01a828adaeae9c91ba0f5572569028f4878f2973bd09ec33434eb185908039f86ded6e05bbda8108d94a539a389ed9576a2e4e351e8ac87359e64db88986dc486dfb0059aee23bc2996e8f781d589a86657802d134549e137a448d04df4b96cd4b0305a6e17cdc362cd6a28147f21219f5abc5cfb5170898533bf7689b13e9332cc504c1d3b41327a39e79cd0e8e4f0f7adafa80df3ddd46f5ef4e889c65f5fa8a4be5f081a54d38415cd6331088fa06eca014da562ede62aa74adee6a1f58dfef0c371a28abfb222c414d0a34cbb72cc69728cb4ef166c4a0436cc7e9dd71d3d2988e7b009d1e5c38be24c3c1910e05c8fb7709d518d7f24aff9bcad4938c3524984ef0806ecd39f3ff7e41562e0a170b65842278f02896f888f4af97e0139a81612242e17827a5603a7e9f101d3e2b17516722f733676c507ac2eddc77e727b980123ce08506f8c0c44ab2a60cc568943b14c1407906be4138c007d07699dc1880ce9154d2c700c3aba7b18b6ead6f70b5ddf5313be60479002c1a97444e7ecf63051316d442389c183eb59d1bb806d421cbda45d072764824fe38542e887e062805a7c1afe3c5fb99b31be9933946c58b134b8673f32acdd06ff9c5a6260eb7a4b6faa20a17af557fa6a172331ff3c6fa28d95774c5fae8abaa504b5fa22f741404c8e39a2ce1ffb7c1b67b120e9084bb67f6029848050ff44d8341e226d218e948d4510fc04b116fc501836c4facc83aa7097118a87348859cf394764e2f9c8290ee58d6eb8f2ef4c2b5a5ec876c602ae6dacc67b5f777155fe1bc7e061179ab676866752f39e4f4f67bb1ca9132093d7fa9b29465edcd4731dac67897f02f9e45da055870047e170e2cd5d8e167ba2b51d6ac187a77b99c01586da0e8f1830b03668295c8731c839e75d0be192134feca116d362aa65a7b19ce61aa0cec825f45e7a43f101ef70cc736d834c3f0c0395ec006397d27d06615eb51a73368581aee6c013cfad1eb9357eacb8185cfa0797e52fca1b3fdb83cbecaf6e38c4dfc753d0b0bec0e9aff6156be24744ca4f0b8c3a185727cad8f1cc72811c72493bf20d209634f6e4e38571de9233258d0bd7521a2b9f43cf10531b055a48f6591b5c1c58e3f19a8e156b4ef10cff832edcef2db27011368482bf3aac7fd8e6ecb4c9ddfc17244071f9e592fb3d2bde91222e586585fc0bede4c421bc880e01426eef92992ab81338680c0f1a6f47d244801718e4ba614dd0ba21429100164e60436aa81fc6d30ac605024ec3af5d550348eacf9d257409a35e1919f6b7f2a00747bf8aee04c1ddd5c624ec6d5f491684750f31421d1b6c59de4cd3209dbcfc6fef4722a49ea402249472fee0f2de7ab43f01d054d3b453969ee67507ada282bb7d03da3bf8734f2218c09c0c225a34e755dd759cd7e23f6690c24b270ff0a1eb3165a7430421a2161b7daf839b1cdc7665987bc1ac974ea9853fce07245093741572c46e5aa974e49d5909ac5f174bcf481bce6d599da3de76a297c36175eecc72d7df9f978e4948f430ad89682796267bae434622f326da3a6909d2d3505d07d5d53316c1d4b9009f3c94762fc72ede70a98874a112540651b8edafa46d743558c4ea5cc2dc1f603893298aa51c1346bb028915e40e87bf5dadedde6409d43f3a9ad4f51d3f4a9c1a4ced0accb6fb10904a3273dd6f1d3ddf1d4ef0edaada5b14acb9125856d0b37652dfd8c274d95df879b43e3a106a02958226cf5149dbd34fc34fbe56507477084e251e026ba9872e7ea495c885806566fa004e2cfffb9b10a8957a0a13b939bd854e6b67fdda673af096008c759c7e4ef5fd8546a80db72f6cc162af369eee91599cf2c37e6167438bee6c5b89f7a58851402a2f3419a6b644d658fdabff583a12ea1059c6e956e92f00ceb78e2bec99e214d1f11466290d04ffc974a0b39d90409bd35bb88d2e94cf47486238717b1813652956119a800a1149bbc0fe7db79b798ed180da48306578d8c1b4105983f8105dbde67c1707f6eb58527b95971e0f7b2857702879ae44cfd727d0b6195b070f9136f81dee06ab98ee4981ff95962b3c80c2767994d5c878bbfea94a9bc748d77844386e6466cbb8c8e7ea48348059b74c0975dc7073239f85e143dfef3c17836645870ad110a3aaf4f054923cb8c7edda085ac88f8363804b4fa80848e34d460a978727271967192f4b1f0f990a86594de85054fe0c91f01e3c787e747d915e4c89d5384d46d0b04069a12f0a37363d8c7a4d285fb2d32116572e8d15be82e00d6b5fb7f459a058279246339e91c7f392a1bee94ed17ba63f58fa31a083e1c2964ec75269fee227b3c89d13d527581e4cc67e0973fe8ce60f3d6e92525d4e1daabbac2ec8e1f248a07c2a9fab8cc53eae17f0c86cdca751c436b3d10ff285a1011a4a23a6e26afc8cba681c9639218aaef96feec906d9c6b06689cd96f9f34bfbbf51aa8a5d3d873ccaa9ececf151ae3e70b154fbcaee0e9e28dddea85181fb09cde0588bcdf21610da7ef31e554b3a0f156c7496bf260290982e150504006381b1ec2fcab46681c3536b96b85a9a59b7c3f6540fc824b69daafc87c1e944e29afd5ab02f37233c71ae652813e3e5b1f37fa74eb4341e80cf70e2dce4f95fed1b3d6ecc28a78abd9be19de82a5b14f42787d98dd4e5f7ef1edd99df59cbaabead0b85cecb4e0a8a4dedd0e6a98a0c2c8c1dec523c61f9fd1d56efa35c2f498d470c7dba73a6f1508d9c76d95b6391b02d6e3e2d71a53cf3ea9f09bc30a007f9c54050c7347cdcd6d78c7386e3313225bb33077868af6f3963f1a1ebd7e53ac1dbef9c2a040fb030ca70cb98b59eac7dc187e99250ee64c6c3d5464e1e04fa9fcceef3b328874d051b10b3f35eeef40d04afe17ef9364ce060e8bb43b01ab434eba096313c906afcd68e2a74bf2019ddb73085ef8d95e03ae076595c7c041c803f4ca5b27286f3089f34ade5be51242cab93da94808da9f72598a62c23c8de74d083fcce992ed75e59f914d4abeb6580a1f3b8b33d020355f01c6db2cbbf3c5667f02e7f0489d9509450568106c0ec467b1183044a9842d581ecfd4663e5d371b684271dedfe01da204ea1ee98e62ba802f76f945cbd368bce3dec2173778c207000a37630de2d33ca9c601106bd2a7aebc1395c8a8dff37162c08e51c2442fe579a594dc3df2213eaf94effcd26b1a01890f69cd5b16853db182e8168f2e92dc1e8c763833ee4af5626625eb36ff886d935861e30cb49537a8176e60a3de98bd4e7d0f3768ad9abc4f2783d38dba9afe078dc02f455323f9420849de06b5ac6b0e78dc259b66ac18be810eab90deda7aef896c2d7b9b11226ec1bf3a9c8379ee8f213f6a561eeaade4ac85de706730a7d1f05136cf1bd57267e1a36e5c33c8f76bc6997f2db367c4f25bcbee0e386781e6f61ed7203ae2136d223db224504f0b5868fcb7ccda9251e87b9c2d690c4bb2e41</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 机器人学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具身智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器人学（机械臂）入门</title>
      <link href="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/"/>
      <url>/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><font color="Orange">“在你的专业领域里，你要像一个坚韧的农夫一样，一遍又一遍，向深处耕耘”</font></p><p>已购课程：</p><p>【史上最强机械臂教程】机械臂运动学、轨迹规划和动力学控制仿真-AC今夜有雨 （付费课程）语雀 <a href="https://www.yuque.com/dashboard/books#collab">https://www.yuque.com/dashboard/books#collab</a></p><p>Matlab机器人工具箱入门指南 • 汪迪 <a href="https://class.guyuehome.com/p/t_pc/course_pc_detail/column/p_615fb0e4e4b0dfaf7faa9725">https://class.guyuehome.com/p/t_pc/course_pc_detail/column/p_615fb0e4e4b0dfaf7faa9725</a></p><h1 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h1><p><strong>1.数理基础和编程：</strong></p><p>线性代数：极其重要，是理解和表示向量、空间变换、矩阵运算等的基础。</p><p>Python：具身智能研究和开发中最主流的编程语言，拥有丰富的库和社区支持。</p><p>Matlab机器人工具箱: 主要用于验证机械臂的算法，对于从零开始学习机器人的运动学和动力学小白来说极易上手，里面有基本的机器人运动学和动力学函数，可通过查看底层函数，加强理论知识的学习，还可以在此基础上快速开发自己的算法。</p><p>ROS+Moveit+OMPL:OMPL集成了最先进的运动规划、操作、3D感知、运动学、控制与导航算法。再结合Rviz和Gazebo等工具，就十分完美了。</p><ul><li>Linux:如果完全没有Linux开发经验，可以先安装Ubuntu系统，然后看UNIX Tutorial for Beginners，熟悉基本的Linux使用方法</li><li>C++: 在对性能要求极高的场景（如底层机器人控制、实时系统）时会用到，且ROS的主要代码都是C++实现的 ，学C++的时候就可以在Ubuntu下进行，安装一个vscode。</li><li>对于ROS最好的教程就是官网的教程ROS Tutorials。首先通过Beginner Level和Intermediate Level了解ROS基本的通讯机制，学会使用catkin,roslaunch,Rviz等基本工具。</li><li>理论上在ROS环境下可以从事绝大多数与实时控制无关的研究，如Motion Planning等。若从事的是更加底层的工作，（如控制器设计），目前ROS还无法胜任。</li><li>【机器人操作系统 ROS 快速入门教程】 <a href="https://www.bilibili.com/video/BV1BP4y1o7pw/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1BP4y1o7pw/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></li><li>古月居21讲（归纳性较强），深蓝学院moveit</li><li>赵虚左ROS（强推！）【【Autolabor初级教程】ROS机器人入门】 <a href="https://www.bilibili.com/video/BV1Ci4y1L7ZZ/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1Ci4y1L7ZZ/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></li></ul><p><strong>2.机器人理论：</strong></p><p>目标：扎扎实实打好<u>空间变换、DH建模、正逆运动学、轨迹规划、雅可比矩阵等动力学</u><u>（补理论力学）</u>的基础。</p><p>行动：重新过一遍理论知识，用一个专门的本子做笔记、推导，对于逆运动学要自己手算一遍，不能只会调库。</p><p>1)齐次变换：用一个4x4的齐次变换矩阵来描述两个坐标系之间的关系，</p><ul><li>熟悉坐标表示方式：坐标系{B}在{A}下的位姿如何表示。</li><li>左乘和右乘的区别。</li><li>了解旋转矩阵每一列的含义，学会如何通过目测写出两个坐标系之间的旋转矩阵。</li><li>姿态的表示方式：RPY角，各种欧拉角、轴角表示。</li></ul><p>2)运动学：</p><p>为了方便计算两个连杆之间的相对位姿，需要学习DH建模方法</p><ul><li>建立坐标系</li><li>计算DH参数</li><li>计算变换矩阵</li><li>正解：知道每个连杆两两之间的坐标变换，就可以通过矩阵乘法计算出最后的末端位姿了。</li><li>逆解：闭式解法（解析）、数值解法（如Jacobian迭代）。通过不断调整上面几个矩阵的位置，尝试找到可以单独求解的未知数即可。虽然有些繁琐，但是对于初学者来说一定要亲手推一推六轴机械臂的运动学逆解公式，并编程实现。 重点是解析解（特殊构型的封闭解析解，解析解需要满足Pieper准则，否则只能用数值解）</li></ul><p>3)轨迹规划：</p><p>用MATLAB实现直线，圆弧，梯形，三次五次多项式，SLERP，SQUAD，NURBS。</p><p>任务空间（笛卡尔空间）控制更贴近目标</p><p>4)雅可比计算：</p><ul><li>线速度&#x2F;角速度与关节速度之间的映射关系</li><li>用于控制与奇异性分析</li></ul><p>5)动力学建模：</p><ul><li>Lagrangian（拉格朗日）法：基于能量</li><li>Newton-Euler法：基于力和加速度</li><li>获取运动方程：M(q)q¨+C(q,q˙)q˙+G(q)&#x3D;τM(q)\ddot{q} + C(q,\dot{q})\dot{q} + G(q) &#x3D; \tau</li><li>了解阻抗控制、导纳控制、参数辨识</li></ul><hr><h1 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h1><p>了解一个领域的常见技巧</p><ol><li><p>谷歌学术搜关键词：找到survey，或者引用数比较高的论文，然后用ChatPaper总结，或者学术版GPT免费翻译，快速阅读。</p></li><li><p>如果是最新的论文：Arxiv搜关键词。</p></li><li><p>看paperwithcode的排行榜，比如：<a href="https://link.zhihu.com/?target=https://paperswithcode.com/sota">https://paperswithcode.com/sota</a></p></li><li><p>如果是代码复现，可以Github搜：<strong>awesome+xxx</strong>,一般会有大佬给你整理好相关的资料。</p></li></ol><h2 id="专栏"><a href="#专栏" class="headerlink" title="专栏"></a><strong>专栏</strong></h2><p>Robotics <a href="https://blog.csdn.net/jldemanman/category_7433626.html">https://blog.csdn.net/jldemanman/category_7433626.html</a></p><p>机械臂速成小指南 <a href="https://blog.csdn.net/m0_53966219/category_11761138.html">https://blog.csdn.net/m0_53966219/category_11761138.html</a></p><p>【Matlab 六自由度机器人】系列文章汇总<a href="https://blog.csdn.net/AlbertDS/article/details/123968265?spm=1001.2014.3001.5501**%EF%BC%88%E5%86%99%E7%9A%84%E5%BE%88%E7%BB%86%E8%87%B4%EF%BC%8C%E5%BC%BA%E6%8E%A8%EF%BC%89">https://blog.csdn.net/AlbertDS/article/details/123968265?spm=1001.2014.3001.5501**（写的很细致，强推）</a>**</p><p><a href="https://blog.csdn.net/vittore_li/category_11556951.html?spm=1001.2014.3001.5482">https://blog.csdn.net/vittore_li/category_11556951.html?spm=1001.2014.3001.5482</a></p><p>机器人进阶之路 <a href="https://www.zhihu.com/column/c_1241771327444774912">https://www.zhihu.com/column/c_1241771327444774912</a></p><p>机器人技术基础之运动学 <a href="https://www.zhihu.com/column/c_1693921850789429248?utm_campaign=&utm_medium=social&utm_psn=1896366318900467549&utm_source=qq">https://www.zhihu.com/column/c_1693921850789429248?utm_campaign=&amp;utm_medium=social&amp;utm_psn=1896366318900467549&amp;utm_source=qq</a></p><p>【史上最强机械臂教程】机械臂运动学、轨迹规划和动力学控制仿真-AC今夜有雨 语雀 <a href="https://www.yuque.com/dashboard/books#collab">https://www.yuque.com/dashboard/books#collab</a></p><p>深蓝学院：机器人人抓取与操作 <a href="https://www.shenlanxueyuan.com/course/774">https://www.shenlanxueyuan.com/course/774</a> </p><p>具身智能技术指南 Embodied-AI-Guide <a href="https://github.com/TianxingChen/Embodied-AI-Guide?tab=readme-ov-file#vla">https://github.com/TianxingChen/Embodied-AI-Guide?tab=readme-ov-file#vla</a></p><p>全网最全具身智能知识库 <a href="https://yv6uc1awtjc.feishu.cn/wiki/WPTzw9ON0ivIVrkLjVocNZh8nLf">https://yv6uc1awtjc.feishu.cn/wiki/WPTzw9ON0ivIVrkLjVocNZh8nLf</a></p><p>具身智能入门指南 <a href="https://lcn9rz94g08a.feishu.cn/wiki/LhqzwYwcdiuyWvkdmgdc0OQ2nOc">https://lcn9rz94g08a.feishu.cn/wiki/LhqzwYwcdiuyWvkdmgdc0OQ2nOc</a></p><p>国内首个具身智能算法与实战全栈教程（已购买）<a href="https://gkklv.duanshu.com/#/">https://gkklv.duanshu.com/?#/</a></p><p>具身智能之心知识星球</p><p><strong>关于机械臂操纵（抓取、操纵）方向的论文仓库：<a href="https://github.com/BaiShuanghao/Awesome-Robotics-Manipulation">https://github.com/BaiShuanghao/Awesome-Robotics-Manipulation</a></strong></p><hr><h2 id="MATLAB机器人工具箱"><a href="#MATLAB机器人工具箱" class="headerlink" title="MATLAB机器人工具箱"></a>MATLAB机器人工具箱</h2><p>【MATLAB教程_台大郭彦甫（14课）原视频补档】 <a href="https://www.bilibili.com/video/BV1GJ41137UH/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1GJ41137UH/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></p><p>机器人工具箱笔记<a href="https://www.yuque.com/office/yuque/0/2022/doc/27569122/1667006650805-39b5fcad-561e-4dc6-bd08-305d0d51b78d.doc?from=https://www.yuque.com/jinyeyouyu-v4bnu/wbelr0/cs36y2">https://www.yuque.com/office/yuque/0/2022/doc/27569122/1667006650805-39b5fcad-561e-4dc6-bd08-305d0d51b78d.doc?from=https%3A%2F%2Fwww.yuque.com%2Fjinyeyouyu-v4bnu%2Fwbelr0%2Fcs36y2</a></p><p>Matlab机器人工具箱入门指南 • 汪迪 <a href="https://class.guyuehome.com/p/t_pc/course_pc_detail/column/p_615fb0e4e4b0dfaf7faa9725">https://class.guyuehome.com/p/t_pc/course_pc_detail/column/p_615fb0e4e4b0dfaf7faa9725</a></p><p>【MATLAB机器人工具箱10.4 机械臂仿真教学（未完结）】 <a href="https://www.bilibili.com/video/BV1q44y1x7WC/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1q44y1x7WC/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></p><p>【MATLAB教程_台大郭彦甫（14课）原视频补档】 <a href="https://www.bilibili.com/video/BV1GJ41137UH/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1GJ41137UH/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></p><hr><h2 id="空间描述和变换"><a href="#空间描述和变换" class="headerlink" title="空间描述和变换"></a>空间描述和变换</h2><p>具身智能知识库-坐标系与位姿变换<a href="https://yv6uc1awtjc.feishu.cn/wiki/CIuTwmBOoip1cQk31wgc81Tanvd">https://yv6uc1awtjc.feishu.cn/wiki/CIuTwmBOoip1cQk31wgc81Tanvd</a></p><hr><h2 id="DH建模"><a href="#DH建模" class="headerlink" title="DH建模"></a>DH建模</h2><p>PPT-<a href="https://wenku.baidu.com/view/001c588602d8ce2f0066f5335a8102d277a26148.html?_wkts_=1746360331828">https://wenku.baidu.com/view/001c588602d8ce2f0066f5335a8102d277a26148.html?_wkts_=1746360331828</a></p><p>详细介绍如何使用MATLAB中的机器人工具箱建立机器人模型（DH法建模）（三自由度机械臂）<a href="https://blog.csdn.net/qq_44339029/article/details/109708454?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%9C%BA%E6%A2%B0%E8%87%82dh&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-109708454.142">https://blog.csdn.net/qq_44339029/article/details/109708454?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E6%9C%BA%E6%A2%B0%E8%87%82dh&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-109708454.142</a></p><p>工业六轴机器人常见的MOD(改进)-DH模型建立方法-<a href="https://blog.csdn.net/Vittore_Li/article/details/122219529?spm=1001.2014.3001.5502">https://blog.csdn.net/Vittore_Li/article/details/122219529?spm=1001.2014.3001.5502</a></p><hr><h2 id="正逆运动学"><a href="#正逆运动学" class="headerlink" title="正逆运动学"></a>正逆运动学</h2><p>如果是自己设计机械臂或者机械臂末端，需要自己推导运动学公式，若是购买的机械臂成品，则可直接调用机械臂厂家提供的API。</p><p>想要快速了解什么是IK,FK的同学可以看这个，可以建立一个粗略的认知：<a href="https://www.bilibili.com/video/BV18E411v7F9/?spm_id_from=333.337.search-card.all.click&vd_source=b14220472557bfa1918f3d0faa38bdc1">https://www.bilibili.com/video/BV18E411v7F9/?spm_id_from=333.337.search-card.all.click&amp;vd_source=b14220472557bfa1918f3d0faa38bdc1</a></p><p>较为简单的过一遍IK和FK的原理可以看这个：</p><p><a href="https://blog.csdn.net/Dwzsa/article/details/142386529?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Ctr-3-142386529-blog-109314877.235%5Ev43%5Epc_blog_bottom_relevance_base7&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Ctr-3-142386529-blog-109314877.235%5Ev43%5Epc_blog_bottom_relevance_base7&utm_relevant_index=6">https://blog.csdn.net/Dwzsa/article/details/142386529?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ECtr-3-142386529-blog-109314877.235%5Ev43%5Epc_blog_bottom_relevance_base7&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ECtr-3-142386529-blog-109314877.235%5Ev43%5Epc_blog_bottom_relevance_base7&amp;utm_relevant_index=6</a></p><p>puma560运动学 <a href="https://blog.csdn.net/howard789/category_11645542.html?fromshare=blogcolumn&sharetype=blogcolumn&sharerId=11645542&sharerefer=PC&sharesource=qq_52769953&sharefrom=from_link">https://blog.csdn.net/howard789/category_11645542.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=11645542&amp;sharerefer=PC&amp;sharesource=qq_52769953&amp;sharefrom=from_link</a></p><p>3、4自由度机械臂正逆解推导与代码实现 • 吴健新 <a href="https://class.guyuehome.com/p/t_pc/course_pc_detail/column/p_61839a62e4b0ac1ecd65bf47">https://class.guyuehome.com/p/t_pc/course_pc_detail/column/p_61839a62e4b0ac1ecd65bf47</a></p><p><strong>正运动学</strong></p><p>手推正运动学-<a href="https://blog.csdn.net/AlbertDS/article/details/110631364">https://blog.csdn.net/AlbertDS/article/details/110631364</a></p><p>puma560 手推正运动学<a href="https://blog.csdn.net/howard789/article/details/123142492?fromshare=blogdetail&sharetype=blogdetail&sharerId=123142492&sharerefer=PC&sharesource=qq_52769953&sharefrom=from_link">https://blog.csdn.net/howard789/article/details/123142492?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=123142492&amp;sharerefer=PC&amp;sharesource=qq_52769953&amp;sharefrom=from_link</a></p><p>较为详细的视频课（南科大贾振中）：</p><p>FK1 <a href="https://www.bilibili.com/video/BV1Ve4y127Uf/?spm_id_from=333.788.recommend_more_video.0&vd_source=b14220472557bfa1918f3d0faa38bdc1">https://www.bilibili.com/video/BV1Ve4y127Uf/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=b14220472557bfa1918f3d0faa38bdc1</a></p><p>FK2 <a href="https://www.bilibili.com/video/BV1a14y157uL/?spm_id_from=333.788.videopod.sections&vd_source=b14220472557bfa1918f3d0faa38bdc1">https://www.bilibili.com/video/BV1a14y157uL/?spm_id_from=333.788.videopod.sections&amp;vd_source=b14220472557bfa1918f3d0faa38bdc1</a> </p><p><strong>逆运动学</strong></p><p>求解方法：数值解和解析解</p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250517120239149.png" alt="image-20250517120239149" style="zoom:70%;"><p>手推逆运动学-<a href="https://blog.csdn.net/AlbertDS/article/details/123679114">https://blog.csdn.net/AlbertDS/article/details/123679114</a></p><p>手推puma 560 逆运动学<a href="https://blog.csdn.net/howard789/article/details/123150942?fromshare=blogdetail&sharetype=blogdetail&sharerId=123150942&sharerefer=PC&sharesource=qq_52769953&sharefrom=from_link">https://blog.csdn.net/howard789/article/details/123150942?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=123150942&amp;sharerefer=PC&amp;sharesource=qq_52769953&amp;sharefrom=from_link</a></p><p>MATLAB机器人工具箱中机器人逆解是如何求出来的？<a href="https://www.zhihu.com/question/41673569/answer/129670927?share_code=IhuO3vQR063S&utm_psn=1907032115301823715">https://www.zhihu.com/question/41673569/answer/129670927?share_code=IhuO3vQR063S&amp;utm_psn=1907032115301823715</a></p><p>【一起用Matlab从零手写六轴机械臂正逆解和轨迹规划】 <a href="https://www.bilibili.com/video/BV1UY411N7Xr/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1UY411N7Xr/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a> （不调用机器人工具箱）</p><p>机器人厂商的逆解是怎么做的 <a href="https://www.zhihu.com/question/380943528/answer/1095992504?share_code=10Gaq9dtXhHIi&utm_psn=1907032724964882059">https://www.zhihu.com/question/380943528/answer/1095992504?share_code=10Gaq9dtXhHIi&amp;utm_psn=1907032724964882059</a></p><p>较为详细的视频课（南科大贾振中）：</p><p>IK1 <a href="https://www.bilibili.com/video/BV1PD4y1t7xP/?spm_id_from=333.337.search-card.all.click&vd_source=b14220472557bfa1918f3d0faa38bdc1">https://www.bilibili.com/video/BV1PD4y1t7xP/?spm_id_from=333.337.search-card.all.click&amp;vd_source=b14220472557bfa1918f3d0faa38bdc1</a></p><p>IK2 <a href="https://www.bilibili.com/video/BV1Tt4y1T79Z/?spm_id_from=333.788.recommend_more_video.0&vd_source=b14220472557bfa1918f3d0faa38bdc1">https://www.bilibili.com/video/BV1Tt4y1T79Z/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=b14220472557bfa1918f3d0faa38bdc1</a></p><p>Book：</p><p>较为详细的IK理论 <a href="https://motion.cs.illinois.edu/RoboticSystems/InverseKinematics.html">https://motion.cs.illinois.edu/RoboticSystems/InverseKinematics.html</a></p><hr><h2 id="轨迹规划"><a href="#轨迹规划" class="headerlink" title="轨迹规划"></a>轨迹规划</h2><p>具身智能知识库-机器人轨迹规划<a href="https://yv6uc1awtjc.feishu.cn/wiki/Zmk2we1JQiv9gBkyk0ZcMXgSnMd">https://yv6uc1awtjc.feishu.cn/wiki/Zmk2we1JQiv9gBkyk0ZcMXgSnMd</a></p><p>机械臂速成小指南（十三）：轨迹规划概述<a href="https://blog.csdn.net/m0_53966219/article/details/125828466?fromshare=blogdetail&sharetype=blogdetail&sharerId=125828466&sharerefer=PC&sharesource=qq_52769953&sharefrom=from_link">https://blog.csdn.net/m0_53966219/article/details/125828466?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=125828466&amp;sharerefer=PC&amp;sharesource=qq_52769953&amp;sharefrom=from_link</a></p><p>机器人控制与轨迹规划<a href="https://blog.csdn.net/qq_37469992/article/details/112131666?fromshare=blogdetail&sharetype=blogdetail&sharerId=112131666&sharerefer=PC&sharesource=qq_52769953&sharefrom=from_link">https://blog.csdn.net/qq_37469992/article/details/112131666?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=112131666&amp;sharerefer=PC&amp;sharesource=qq_52769953&amp;sharefrom=from_link</a></p><p>【NUBUS五次非均匀B样条轨迹规划及机械臂仿真】 <a href="https://www.bilibili.com/video/BV1gX4y1u7gY/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1gX4y1u7gY/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></p><p>【一起用Matlab从零手写六轴机械臂正逆解和轨迹规划】 <a href="https://www.bilibili.com/video/BV1UY411N7Xr/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1UY411N7Xr/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a> （不调用机器人工具箱）</p><p>六自由度机器人（机械臂）运动学建模及运动规划系列（四）——轨迹规划<a href="https://blog.csdn.net/weixin_47849087/article/details/126143953?fromshare=blogdetail&sharetype=blogdetail&sharerId=126143953&sharerefer=PC&sharesource=qq_52769953&sharefrom=from_link">https://blog.csdn.net/weixin_47849087/article/details/126143953?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=126143953&amp;sharerefer=PC&amp;sharesource=qq_52769953&amp;sharefrom=from_link</a></p><p>机器人基础-机器人轨迹规划 <a href="https://yv6uc1awtjc.feishu.cn/wiki/Zmk2we1JQiv9gBkyk0ZcMXgSnMd">https://yv6uc1awtjc.feishu.cn/wiki/Zmk2we1JQiv9gBkyk0ZcMXgSnMd</a></p><p>【适用所有机械臂!轨迹跟踪仿真!matlab算法!手把手教程|源码公开】 <a href="https://www.bilibili.com/video/BV12q4y1A7fi/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV12q4y1A7fi/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></p><p>【《路径规划入门教程》——第一个专注于机械臂的路径规划课程】 <a href="https://www.bilibili.com/video/BV1G24y1M7ko/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1G24y1M7ko/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></p><p>再就是买的一些课程里涉及到的轨迹规划的章节</p><p>参考书籍：Principles of Robot Motion Theory,Algorithms,and Implementations.     Planning Algorithms</p><hr><h1 id="项目1：机械臂直线规划-梯形速度规划"><a href="#项目1：机械臂直线规划-梯形速度规划" class="headerlink" title="项目1：机械臂直线规划+梯形速度规划"></a>项目1：机械臂直线规划+梯形速度规划</h1><h2 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h2><p>使用MATLAB软件对珞石XB7进行建模并实现直线规划+梯形速度规划。</p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/%E5%B0%BA%E5%AF%B8%E7%BB%93%E6%9E%84.jpg" alt="尺寸结构" style="zoom:50%;"><h2 id="DH建模-1"><a href="#DH建模-1" class="headerlink" title="DH建模"></a>DH建模</h2><p>D-H约定定义了一个机械臂的正向运动学方程，也就是从关节变量到末端执行器位置和姿态的映射，由上图可以得到DH各参数以及关节角限制。</p><h3 id="建立机器人坐标系"><a href="#建立机器人坐标系" class="headerlink" title="建立机器人坐标系"></a>建立机器人坐标系</h3><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250427101139189.png" alt="image-20250427101139189"></p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/%E5%85%B3%E8%8A%82%E5%9D%90%E6%A0%87%E7%B3%BB-1745718769619-7.png" alt="关节坐标系" style="zoom:50%;"><h3 id="改进DH（MDH）建模"><a href="#改进DH（MDH）建模" class="headerlink" title="改进DH（MDH）建模"></a>改进DH（MDH）建模</h3><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250427095756296.png" alt="image-20250427095756296" style="zoom:70%;"><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250427095206691.png" alt="image-20250427095206691"></p><h3 id="MATLAB对机器人DH建模"><a href="#MATLAB对机器人DH建模" class="headerlink" title="MATLAB对机器人DH建模"></a>MATLAB对机器人DH建模</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% MDH参数</span></span><br><span class="line">theta1 = <span class="number">0</span>;    d1 = <span class="number">380</span>;     a1 = <span class="number">0</span>;    alpha1 = <span class="number">0</span>;    </span><br><span class="line">theta2 = <span class="number">0</span>;    d2 = <span class="number">0</span>;       a2 = <span class="number">30</span>;   alpha2 = <span class="built_in">pi</span>/<span class="number">2</span>;        </span><br><span class="line">theta3 = <span class="number">0</span>;    d3 = <span class="number">0</span>;       a3 = <span class="number">340</span>;  alpha3 = <span class="number">0</span>;    </span><br><span class="line">theta4 = <span class="number">0</span>;    d4 = <span class="number">335</span>;     a4 = <span class="number">35</span>;   alpha4 = <span class="built_in">pi</span>/<span class="number">2</span>;    </span><br><span class="line">theta5 = <span class="number">0</span>;    d5 = <span class="number">0</span>;       a5 = <span class="number">0</span>;    alpha5 = -<span class="built_in">pi</span>/<span class="number">2</span>;     </span><br><span class="line">theta6 = <span class="number">0</span>;    d6 = <span class="number">83</span>;      a6 = <span class="number">0</span>;    alpha6 = <span class="built_in">pi</span>/<span class="number">2</span>;     </span><br><span class="line"></span><br><span class="line">L(<span class="number">1</span>) = Link([theta1, d1, a1, alpha1], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line">L(<span class="number">2</span>) = Link([theta2, d2, a2, alpha2], <span class="string">&#x27;modified&#x27;</span>);L(<span class="number">2</span>).offset=-<span class="built_in">pi</span>/<span class="number">2</span>;</span><br><span class="line">L(<span class="number">3</span>) = Link([theta3, d3, a3, alpha3], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line">L(<span class="number">4</span>) = Link([theta4, d4, a4, alpha4], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line">L(<span class="number">5</span>) = Link([theta5, d5, a5, alpha5], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line">L(<span class="number">6</span>) = Link([theta6, d6, a6, alpha6], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 限制关节角度</span></span><br><span class="line">L(<span class="number">1</span>).qlim = [<span class="number">-170</span>*<span class="built_in">pi</span>/<span class="number">180</span>, <span class="number">170</span>*<span class="built_in">pi</span>/<span class="number">180</span>];</span><br><span class="line">L(<span class="number">2</span>).qlim = [<span class="number">-135</span>*<span class="built_in">pi</span>/<span class="number">180</span>, <span class="number">96</span>*<span class="built_in">pi</span>/<span class="number">180</span>];</span><br><span class="line">L(<span class="number">3</span>).qlim = [<span class="number">-45</span>*<span class="built_in">pi</span>/<span class="number">180</span>, <span class="number">187</span>*<span class="built_in">pi</span>/<span class="number">180</span>];</span><br><span class="line">L(<span class="number">4</span>).qlim = [<span class="number">-180</span>*<span class="built_in">pi</span>/<span class="number">180</span>, <span class="number">180</span>*<span class="built_in">pi</span>/<span class="number">180</span>];</span><br><span class="line">L(<span class="number">5</span>).qlim = [<span class="number">-68</span>*<span class="built_in">pi</span>/<span class="number">180</span>, <span class="number">68</span>*<span class="built_in">pi</span>/<span class="number">180</span>];</span><br><span class="line">L(<span class="number">6</span>).qlim = [<span class="number">-180</span>*<span class="built_in">pi</span>/<span class="number">180</span>, <span class="number">180</span>*<span class="built_in">pi</span>/<span class="number">180</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 构建机器人模型</span></span><br><span class="line">robot = SerialLink(L, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;珞石XB-7&#x27;</span>);</span><br><span class="line">robot.display();  <span class="comment">% 显示DH参数</span></span><br><span class="line">robot.teach();    <span class="comment">% 交互式示教界面</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="直线轨迹规划-梯形速度规划"><a href="#直线轨迹规划-梯形速度规划" class="headerlink" title="直线轨迹规划+梯形速度规划"></a>直线轨迹规划+梯形速度规划</h2><h3 id="直线轨迹规划"><a href="#直线轨迹规划" class="headerlink" title="直线轨迹规划"></a>直线轨迹规划</h3><p>ctraj函数用于生成两点之间的平滑轨迹。</p><p>ctraj的主要返回值是位姿轨迹，通常是一个4x4xN的矩阵，其中每个4x4切片表示一个齐次变换矩阵，描述机器人末端执行器在笛卡尔空间中该点的位姿（速度+方向），N是轨迹点的数量，由输入参数（如时间步长或插值点数）决定。</p><p>TC&#x3D;ctraj(T0,T1,N)，是一个从T0姿态到T1姿态的四维笛卡尔轨迹，其中有N个点沿着路径遵循梯形速度曲线。</p><p>TC&#x3D;ctraj(T0,T1,S),S的各元素指定了沿路径的分段距离，这些值处于[0,1]范围内，第i个点对应于沿路径的距离s(i)。</p><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250428215008192.png" alt="image-20250428215008192"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">T1=transl(<span class="number">-280</span>,<span class="number">-300</span>, <span class="number">450</span>);<span class="comment">%起始点齐次变换矩阵 transl函数用于创建一个表示平移的仿射变换矩阵</span></span><br><span class="line">T2=transl(<span class="number">-280</span>,<span class="number">300</span>, <span class="number">450</span>);<span class="comment">%终止点齐次变换矩阵</span></span><br><span class="line">N = <span class="number">50</span>;                     <span class="comment">%插值点数</span></span><br><span class="line">Tc = ctraj(T1,T2,N);      <span class="comment">%直线规划，得到每一步的T阵</span></span><br><span class="line">q=robot.ikine(Tc);    <span class="comment">%运动学逆解</span></span><br><span class="line"><span class="built_in">plot3</span>(<span class="built_in">squeeze</span>(Tc(<span class="number">1</span>,<span class="number">4</span>,:)),<span class="built_in">squeeze</span>(Tc(<span class="number">2</span>,<span class="number">4</span>,:)),<span class="built_in">squeeze</span>(Tc(<span class="number">3</span>,<span class="number">4</span>,:)));<span class="comment">%输出末端轨迹。</span></span><br><span class="line">title(<span class="string">&#x27;直线轨迹&#x27;</span>);</span><br><span class="line">robot.<span class="built_in">plot</span>(q); <span class="comment">%动画演示</span></span><br><span class="line"><span class="comment">%Tc(1,4,:)：提取所有时间步的 x 坐标（第 1 行第 4 列的所有元素）。</span></span><br><span class="line"><span class="comment">%Tc(2,4,:)：提取所有时间步的 y 坐标（第 2 行第 4 列的所有元素）。</span></span><br><span class="line"><span class="comment">%Tc(3,4,:)：提取所有时间步的 z 坐标（第 3 行第 4 列的所有元素）。</span></span><br><span class="line"><span class="comment">%sqeeze函数用于移除数组中长度为 1 的冗余维度，从而简化数组的维度结构（仅压缩长度为 1 的维度，其他维度不变）。直接提取 Tc(1,4,:) 会得到一个 1×1×N 的三维数组，而 plot3 需要 N×1 的向量。squeeze 移除长度为 1 的维度，将 1×1×N 转换为 N×1 的列向量。  </span></span><br><span class="line"><span class="comment">%向量和矩阵数据  plot3(X,Y,Z) 绘制三维空间中的坐标。要绘制由线段连接的一组坐标，应将 X、Y、Z 指定为相同长度的向量。</span></span><br></pre></td></tr></table></figure><h3 id="梯形速度规划"><a href="#梯形速度规划" class="headerlink" title="梯形速度规划"></a>梯形速度规划</h3><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250428204846497.png" alt="image-20250428204846497"></p><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250428204918285.png" alt="image-20250428204918285"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[t, s]</span> = <span class="title">trapezoid_vel_profile</span><span class="params">(dist, v_max, a_max)</span></span></span><br><span class="line">    <span class="comment">% 输入检查</span></span><br><span class="line">    <span class="keyword">if</span> v_max &lt;= <span class="number">0</span> || a_max &lt;= <span class="number">0</span></span><br><span class="line">        error(<span class="string">&#x27;速度和加速度必须为正数&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> dist &lt;= <span class="number">0</span></span><br><span class="line">        t = <span class="number">0</span>; s = <span class="number">0</span>; <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 计算关键参数</span></span><br><span class="line">    t_acc = v_max / a_max;          <span class="comment">% 加速时间(s)</span></span><br><span class="line">    s_acc = <span class="number">0.5</span> * a_max * t_acc^<span class="number">2</span>;  <span class="comment">% 加速距离(m)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 判断运动类型</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">2</span>*s_acc &gt; dist</span><br><span class="line">        <span class="comment">% 三角形速度曲线</span></span><br><span class="line">        t_acc = <span class="built_in">sqrt</span>(dist / a_max);</span><br><span class="line">        t_total = <span class="number">2</span>*t_acc;</span><br><span class="line">        t_const = <span class="number">0</span>;</span><br><span class="line">        s_const = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">% 梯形速度曲线</span></span><br><span class="line">        s_const = dist - <span class="number">2</span>*s_acc;   <span class="comment">% 匀速距离(m)</span></span><br><span class="line">        t_const = s_const / v_max;  <span class="comment">% 匀速时间(s)</span></span><br><span class="line">        t_total = <span class="number">2</span>*t_acc + t_const;<span class="comment">% 总时间(s)</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 生成时间序列</span></span><br><span class="line">    t = <span class="built_in">linspace</span>(<span class="number">0</span>, t_total, <span class="built_in">round</span>(t_total/<span class="number">0.01</span>))&#x27;;<span class="comment">%将连续的总时间t_total分割为离散的时间点，步长为0,01s,用于后续计算每个时刻对应的位置s。</span></span><br><span class="line">    <span class="comment">%linspace(start,end,n_points)生成从start到end的等间隔n_points个点，返回的是一个行向量</span></span><br><span class="line">    <span class="comment">%round为四舍五入函数</span></span><br><span class="line">    s = <span class="built_in">zeros</span>(<span class="built_in">size</span>(t));<span class="comment">%初始化与时间序列对应的0数组s，避免在循环中动态扩展数组，显著提升代码运行效率</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 计算归一化位置</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(t)</span><br><span class="line">        <span class="keyword">if</span> t(<span class="built_in">i</span>) &lt;= t_acc<span class="comment">%加速阶段</span></span><br><span class="line">            s(<span class="built_in">i</span>) = <span class="number">0.5</span> * a_max * t(<span class="built_in">i</span>)^<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">elseif</span> t(<span class="built_in">i</span>) &lt;= t_acc + t_const<span class="comment">%匀速阶段</span></span><br><span class="line">            s(<span class="built_in">i</span>) = s_acc + v_max*(t(<span class="built_in">i</span>)-t_acc);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t_dec = t(<span class="built_in">i</span>) - t_acc - t_const;<span class="comment">%减速阶段</span></span><br><span class="line">            s(<span class="built_in">i</span>) = (s_acc + s_const) + v_max*t_dec - <span class="number">0.5</span>*a_max*t_dec^<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 确保归一化在[0,1]范围内</span></span><br><span class="line">    s = <span class="built_in">min</span>(<span class="built_in">max</span>(s/dist, <span class="number">0</span>), <span class="number">1</span>);<span class="comment">%s为与时间序列对应的数组，s中每个元素为当前离散时间点对应的距离</span></span><br><span class="line">    <span class="comment">%s/dist即将位置归一化到[0,1],max(a,b)即取a和b之间的最大值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="画矩形案例"><a href="#画矩形案例" class="headerlink" title="画矩形案例"></a>画矩形案例</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 机器人建模（Modified DH参数）(长度mm)</span></span><br><span class="line">theta1 = <span class="number">0</span>;    d1 = <span class="number">380</span>;     a1 = <span class="number">0</span>;    alpha1 = <span class="number">0</span>;    </span><br><span class="line">theta2 = <span class="number">0</span>;    d2 = <span class="number">0</span>;       a2 = <span class="number">30</span>;   alpha2 = <span class="built_in">pi</span>/<span class="number">2</span>;        </span><br><span class="line">theta3 = <span class="number">0</span>;    d3 = <span class="number">0</span>;       a3 = <span class="number">340</span>;  alpha3 = <span class="number">0</span>;    </span><br><span class="line">theta4 = <span class="number">0</span>;    d4 = <span class="number">335</span>;     a4 = <span class="number">35</span>;   alpha4 = <span class="built_in">pi</span>/<span class="number">2</span>;    </span><br><span class="line">theta5 = <span class="number">0</span>;    d5 = <span class="number">0</span>;       a5 = <span class="number">0</span>;    alpha5 = -<span class="built_in">pi</span>/<span class="number">2</span>;     </span><br><span class="line">theta6 = <span class="number">0</span>;    d6 = <span class="number">83</span>;      a6 = <span class="number">0</span>;    alpha6 = <span class="built_in">pi</span>/<span class="number">2</span>;     </span><br><span class="line"></span><br><span class="line">L(<span class="number">1</span>) = Link([theta1, d1, a1, alpha1], <span class="string">&#x27;modified&#x27;</span>);L(<span class="number">1</span>).offset=<span class="built_in">pi</span>;</span><br><span class="line">L(<span class="number">2</span>) = Link([theta2, d2, a2, alpha2], <span class="string">&#x27;modified&#x27;</span>);L(<span class="number">2</span>).offset=<span class="built_in">pi</span>/<span class="number">2</span>;</span><br><span class="line">L(<span class="number">3</span>) = Link([theta3, d3, a3, alpha3], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line">L(<span class="number">4</span>) = Link([theta4, d4, a4, alpha4], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line">L(<span class="number">5</span>) = Link([theta5, d5, a5, alpha5], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line">L(<span class="number">6</span>) = Link([theta6, d6, a6, alpha6], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 构建机器人模型</span></span><br><span class="line">robot = SerialLink(L, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;XB-7&#x27;</span>);</span><br><span class="line">robot.display();  <span class="comment">% 显示DH参数</span></span><br><span class="line">robot.teach();    <span class="comment">% 交互式示教界面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 轨迹规划参数（单位转换为米）</span></span><br><span class="line">scale = <span class="number">0.001</span>;  <span class="comment">% mm转m</span></span><br><span class="line">v_max = <span class="number">0.2</span>;    <span class="comment">% 最大速度(m/s)</span></span><br><span class="line">a_max = <span class="number">0.2</span>;    <span class="comment">% 最大加速度(m/s²)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 直线轨迹规划 </span></span><br><span class="line"><span class="comment">% 各直线起点和终点（单位：mm）</span></span><br><span class="line">T_1 = transl(<span class="number">-280</span>,<span class="number">-300</span>, <span class="number">450</span>);  </span><br><span class="line">T_2 = transl(<span class="number">-280</span>,<span class="number">300</span>, <span class="number">450</span>);      </span><br><span class="line">T_3 = transl(<span class="number">-450</span>,<span class="number">300</span>, <span class="number">880</span>); </span><br><span class="line">T_4 = transl(<span class="number">-450</span>,<span class="number">-300</span>, <span class="number">880</span>); </span><br><span class="line">T_5 = transl(<span class="number">-280</span>,<span class="number">-300</span>, <span class="number">450</span>); </span><br><span class="line"><span class="comment">% 计算直线距离（单位：m）</span></span><br><span class="line">delta_pos1 = norm(T_2(<span class="number">1</span>:<span class="number">3</span>,<span class="number">4</span>) - T_1(<span class="number">1</span>:<span class="number">3</span>,<span class="number">4</span>)) * scale;<span class="comment">%1:3选择矩阵的1到三行 4：选择第四列 T_2(1:3,4)即提取第4列的前3个元素</span></span><br><span class="line">delta_pos2 = norm(T_3(<span class="number">1</span>:<span class="number">3</span>,<span class="number">4</span>) - T_2(<span class="number">1</span>:<span class="number">3</span>,<span class="number">4</span>)) * scale;</span><br><span class="line">delta_pos3 = norm(T_4(<span class="number">1</span>:<span class="number">3</span>,<span class="number">4</span>) - T_3(<span class="number">1</span>:<span class="number">3</span>,<span class="number">4</span>)) * scale;</span><br><span class="line">delta_pos4 = norm(T_5(<span class="number">1</span>:<span class="number">3</span>,<span class="number">4</span>) - T_4(<span class="number">1</span>:<span class="number">3</span>,<span class="number">4</span>)) * scale;</span><br><span class="line"><span class="comment">%% 执行轨迹规划</span></span><br><span class="line">[t_1, s_1] = trapezoid_vel_profile(delta_pos1, v_max, a_max);</span><br><span class="line">[t_2, s_2] = trapezoid_vel_profile(delta_pos2, v_max, a_max);</span><br><span class="line">[t_3, s_3] = trapezoid_vel_profile(delta_pos3, v_max, a_max);</span><br><span class="line">[t_4, s_4] = trapezoid_vel_profile(delta_pos4, v_max, a_max);</span><br><span class="line">Ts1 = ctraj(T_1, T_2, s_1);  <span class="comment">% 笛卡尔空间轨迹</span></span><br><span class="line">Ts2 = ctraj(T_2, T_3, s_2);  <span class="comment">% 笛卡尔空间轨迹</span></span><br><span class="line">Ts3 = ctraj(T_3, T_4, s_3);  <span class="comment">% 笛卡尔空间轨迹</span></span><br><span class="line">Ts4 = ctraj(T_4, T_5, s_4);  <span class="comment">% 笛卡尔空间轨迹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 逆运动学求解</span></span><br><span class="line">q1 = robot.ikine(Ts1,<span class="string">&#x27;mask&#x27;</span>, [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>],<span class="string">&#x27;qlim&#x27;</span>, <span class="built_in">true</span>);  <span class="comment">% 全自由度求解</span></span><br><span class="line">q2 = robot.ikine(Ts2,<span class="string">&#x27;mask&#x27;</span>, [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>],<span class="string">&#x27;qlim&#x27;</span>, <span class="built_in">true</span>);  <span class="comment">% 全自由度求解</span></span><br><span class="line">q3 = robot.ikine(Ts3,<span class="string">&#x27;mask&#x27;</span>, [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>],<span class="string">&#x27;qlim&#x27;</span>, <span class="built_in">true</span>);  <span class="comment">% 全自由度求解</span></span><br><span class="line">q4 = robot.ikine(Ts4,<span class="string">&#x27;mask&#x27;</span>, [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>],<span class="string">&#x27;qlim&#x27;</span>, <span class="built_in">true</span>);  <span class="comment">% 全自由度求解</span></span><br><span class="line">q_total=[q1;q2;q3;q4];<span class="comment">%q_total 是一个包含机器人所有关节角度轨迹的 N×6 矩阵（N 为总时间步数，6 对应 6 个关节）</span></span><br><span class="line"><span class="comment">%每一行表示一个时间步的关节角度值 q_total(i,:) = [θ₁, θ₂, θ₃, θ₄, θ₅, θ₆]   第i个时间点的6个关节角度</span></span><br><span class="line"><span class="comment">%[q1; q2; q3; q4] 是纵向拼接（垂直拼接），而 [q1, q2, q3, q4] 是横向拼接（水平拼接）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 画出矩形轨迹</span></span><br><span class="line">x=<span class="built_in">squeeze</span>(Ts1(<span class="number">1</span>,<span class="number">4</span>,:)); y=<span class="built_in">squeeze</span>(Ts1(<span class="number">2</span>,<span class="number">4</span>,:)); z=<span class="built_in">squeeze</span>(Ts1(<span class="number">3</span>,<span class="number">4</span>,:));</span><br><span class="line">x1=<span class="built_in">squeeze</span>(Ts2(<span class="number">1</span>,<span class="number">4</span>,:)); y1=<span class="built_in">squeeze</span>(Ts2(<span class="number">2</span>,<span class="number">4</span>,:)); z1=<span class="built_in">squeeze</span>(Ts2(<span class="number">3</span>,<span class="number">4</span>,:));</span><br><span class="line">x2=<span class="built_in">squeeze</span>(Ts3(<span class="number">1</span>,<span class="number">4</span>,:)); y2=<span class="built_in">squeeze</span>(Ts3(<span class="number">2</span>,<span class="number">4</span>,:)); z2=<span class="built_in">squeeze</span>(Ts3(<span class="number">3</span>,<span class="number">4</span>,:));</span><br><span class="line">x3=<span class="built_in">squeeze</span>(Ts4(<span class="number">1</span>,<span class="number">4</span>,:)); y3=<span class="built_in">squeeze</span>(Ts4(<span class="number">2</span>,<span class="number">4</span>,:)); z3=<span class="built_in">squeeze</span>(Ts4(<span class="number">3</span>,<span class="number">4</span>,:));</span><br><span class="line">x_all=[x;x1;x2;x3];y_all=[y;y1;y2;y3];z_all=[z;z1;z2;z3];</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot3</span>(x_all,y_all,z_all);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 实时动画（精确时间控制）</span></span><br><span class="line">robot.<span class="built_in">plot</span>(q_total, <span class="string">&#x27;fps&#x27;</span>, <span class="number">100</span>, <span class="string">&#x27;trail&#x27;</span>, &#123;<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>&#125;, <span class="string">&#x27;nobase&#x27;</span>, <span class="string">&#x27;notiles&#x27;</span>);</span><br><span class="line"><span class="comment">%roboy.plot按顺序读取每一行（从第 1 行到第 N 行），每行对应一个时间点的关节角度 [θ₁, θ₂, θ₃, θ₄, θ₅, θ₆]。对每一行数据，调用正运动学计算（fkine）并更新3D模型的位姿。不需要自己写 for 循环，robot.plot 内部已经实现了这一逻辑。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算并绘制末端速度曲线</span></span><br><span class="line"><span class="comment">% 合并各段时间并生成总时间轴</span></span><br><span class="line">current_time = <span class="number">0</span>;</span><br><span class="line"><span class="comment">% 第一段</span></span><br><span class="line">t1 = t_1 + current_time;</span><br><span class="line">current_time = current_time + t_1(<span class="keyword">end</span>);</span><br><span class="line"><span class="comment">% 第二段</span></span><br><span class="line">t2 = t_2 + current_time;</span><br><span class="line">current_time = current_time + t_2(<span class="keyword">end</span>);</span><br><span class="line"><span class="comment">% 第三段</span></span><br><span class="line">t3 = t_3 + current_time;</span><br><span class="line">current_time = current_time + t_3(<span class="keyword">end</span>);</span><br><span class="line"><span class="comment">% 第四段</span></span><br><span class="line">t4 = t_4 + current_time;</span><br><span class="line"><span class="comment">% 总时间轴</span></span><br><span class="line">t_total = [t1; t2; t3; t4];<span class="comment">%t_total 是一个包含所有时间点的向量，表示机械臂运动的每个离散时刻。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算速度分量（注意单位转换）</span></span><br><span class="line">dx = diff(x_all) * scale; <span class="comment">% mm转m</span></span><br><span class="line">dy = diff(y_all) * scale; <span class="comment">%diff用于计算数组中相邻元素之间的差值（即差分）,对于数组 X = [x₁, x₂, x₃, ..., xn]，diff(X) 返回：[x₂ - x₁, x₃ - x₂, ..., xn - xₙ₋₁]</span></span><br><span class="line">dz = diff(z_all) * scale;</span><br><span class="line">dt = diff(t_total);</span><br><span class="line"></span><br><span class="line">vx = dx ./ dt;<span class="comment">%&quot;./&quot;运算符：点除，表示对两个数组的对应元素逐个相除。</span></span><br><span class="line">vy = dy ./ dt;</span><br><span class="line">vz = dz ./ dt;</span><br><span class="line">speed = <span class="built_in">sqrt</span>(vx.^<span class="number">2</span> + vy.^<span class="number">2</span> + vz.^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算每个时间区间的中点时间，用于对齐通过差分计算得到的速度值</span></span><br><span class="line">time_mid = t_total(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>) + dt/<span class="number">2</span>;<span class="comment">%时间轴数据，通常是一个向量（数组），表示每个速度值对应的时间点</span></span><br><span class="line"><span class="comment">%t_total(1:end-1):取时间轴的前 n-1 个点（因为差分会减少一个数据点）。 例如：t_total = [0, 1, 3, 6] → t_total(1:end-1) = [0, 1, 3]。</span></span><br><span class="line"><span class="comment">%dt/2:计算每个时间区间长度的一半。例如：dt = diff([0, 1, 3, 6]) = [1, 2, 3] → dt/2 = [0.5, 1, 1.5]。</span></span><br><span class="line"><span class="comment">%相加操作:将每个区间的起始时间点 t_total(1:end-1) 加上半区间长度 dt/2，得到区间中点：[0, 1, 3] + [0.5, 1, 1.5] = [0.5, 2.0, 4.5]。差分计算的速度是区间内的平均速度，自然应对应区间的中点时刻（而非起点或终点）。这样，速度值 speed 可以正确对齐到区间中点时间 [0.5, 2.0, 4.5] 绘图。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制总速度曲线</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;End-Effector Speed Profile&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(time_mid, speed, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (s)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Speed (m/s)&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;End-Effector Linear Speed&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line">ylim([<span class="number">0</span> v_max*<span class="number">1.1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制各方向速度分量</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Velocity Components&#x27;</span>)</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>);<span class="comment">%subplot(3,1,1) 是 MATLAB 中用于创建子图（subplot）的函数，它的作用是将当前图形窗口分割成多个小区域，并在指定的区域中绘制图形。</span></span><br><span class="line"><span class="comment">%subplot(m, n, p): m：子图的行数（垂直方向分成几块) n：子图的列数（水平方向分成几块) p：当前操作的子图位置（按从左到右、从上到下的顺序编号)</span></span><br><span class="line"><span class="built_in">plot</span>(time_mid, vx, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Vx (m/s)&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>); </span><br><span class="line"><span class="built_in">plot</span>(time_mid, vy, <span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Vy (m/s)&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(time_mid, vz, <span class="string">&#x27;b&#x27;</span>); </span><br><span class="line">ylabel(<span class="string">&#x27;Vz (m/s)&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (s)&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 梯形速度规划（修正版）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[t, s]</span> = <span class="title">trapezoid_vel_profile</span><span class="params">(dist, v_max, a_max)</span></span></span><br><span class="line">    <span class="comment">% 输入检查</span></span><br><span class="line">    <span class="keyword">if</span> v_max &lt;= <span class="number">0</span> || a_max &lt;= <span class="number">0</span></span><br><span class="line">        error(<span class="string">&#x27;速度和加速度必须为正数&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> dist &lt;= <span class="number">0</span></span><br><span class="line">        t = <span class="number">0</span>; s = <span class="number">0</span>; <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 计算关键参数</span></span><br><span class="line">    t_acc = v_max / a_max;          <span class="comment">% 加速时间(s)</span></span><br><span class="line">    s_acc = <span class="number">0.5</span> * a_max * t_acc^<span class="number">2</span>;  <span class="comment">% 加速距离(m)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 判断运动类型</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">2</span>*s_acc &gt; dist</span><br><span class="line">        <span class="comment">% 三角形速度曲线</span></span><br><span class="line">        t_acc = <span class="built_in">sqrt</span>(dist / a_max);</span><br><span class="line">        t_total = <span class="number">2</span>*t_acc;</span><br><span class="line">        t_const = <span class="number">0</span>;</span><br><span class="line">        s_const = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">% 梯形速度曲线</span></span><br><span class="line">        s_const = dist - <span class="number">2</span>*s_acc;<span class="comment">%const为匀速阶段</span></span><br><span class="line">        t_const = s_const / v_max;</span><br><span class="line">        t_total = <span class="number">2</span>*t_acc + t_const;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 生成时间序列</span></span><br><span class="line">    t = <span class="built_in">linspace</span>(<span class="number">0</span>, t_total, <span class="built_in">round</span>(t_total/<span class="number">0.01</span>))&#x27;;<span class="comment">%将连续的总时间t_total分割为练得时间点，用于后续计算每个时刻对应的位置s</span></span><br><span class="line">    <span class="comment">%linspace(start,end,n_points)生成从start到end的等间隔n_points个点，返回的是一个行向量</span></span><br><span class="line">    s = <span class="built_in">zeros</span>(<span class="built_in">size</span>(t));<span class="comment">%初始化与时间序列登场的0数组s，避免在循环中动态扩展数组，显著提升代码运行效率</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 计算归一化位置</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(t)</span><br><span class="line">        <span class="keyword">if</span> t(<span class="built_in">i</span>) &lt;= t_acc</span><br><span class="line">            s(<span class="built_in">i</span>) = <span class="number">0.5</span> * a_max * t(<span class="built_in">i</span>)^<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">elseif</span> t(<span class="built_in">i</span>) &lt;= t_acc + t_const</span><br><span class="line">            s(<span class="built_in">i</span>) = s_acc + v_max*(t(<span class="built_in">i</span>)-t_acc);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t_dec = t(<span class="built_in">i</span>) - t_acc - t_const;</span><br><span class="line">            s(<span class="built_in">i</span>) = (s_acc + s_const) + v_max*t_dec - <span class="number">0.5</span>*a_max*t_dec^<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 确保归一化在[0,1]范围内</span></span><br><span class="line">    s = <span class="built_in">min</span>(<span class="built_in">max</span>(s/dist, <span class="number">0</span>), <span class="number">1</span>);<span class="comment">%s/dist即将位置归一化到[0,1],max(a,b)即取a和b之间的最大值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/trail.gif" alt="trail"></p><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250429161806216.png" alt="image-20250429161806216"></p><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250429161838739.png" alt="image-20250429161838739"></p><h3 id="工作空间可视化"><a href="#工作空间可视化" class="headerlink" title="工作空间可视化"></a>工作空间可视化</h3><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250429162035432.png" alt="image-20250429162035432"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 机器人建模（Modified DH参数）(长度mm)</span></span><br><span class="line">theta1 = <span class="number">0</span>;    d1 = <span class="number">380</span>;     a1 = <span class="number">0</span>;    alpha1 = <span class="number">0</span>;    </span><br><span class="line">theta2 = <span class="number">0</span>;    d2 = <span class="number">0</span>;       a2 = <span class="number">30</span>;   alpha2 = <span class="built_in">pi</span>/<span class="number">2</span>;        </span><br><span class="line">theta3 = <span class="number">0</span>;    d3 = <span class="number">0</span>;       a3 = <span class="number">340</span>;  alpha3 = <span class="number">0</span>;    </span><br><span class="line">theta4 = <span class="number">0</span>;    d4 = <span class="number">335</span>;     a4 = <span class="number">35</span>;   alpha4 = <span class="built_in">pi</span>/<span class="number">2</span>;    </span><br><span class="line">theta5 = <span class="number">0</span>;    d5 = <span class="number">0</span>;       a5 = <span class="number">0</span>;    alpha5 = -<span class="built_in">pi</span>/<span class="number">2</span>;     </span><br><span class="line">theta6 = <span class="number">0</span>;    d6 = <span class="number">83</span>;      a6 = <span class="number">0</span>;    alpha6 = <span class="built_in">pi</span>/<span class="number">2</span>;     </span><br><span class="line"></span><br><span class="line">L(<span class="number">1</span>) = Link([theta1, d1, a1, alpha1], <span class="string">&#x27;modified&#x27;</span>);L(<span class="number">1</span>).offset=<span class="built_in">pi</span>;</span><br><span class="line">L(<span class="number">2</span>) = Link([theta2, d2, a2, alpha2], <span class="string">&#x27;modified&#x27;</span>);L(<span class="number">2</span>).offset=<span class="built_in">pi</span>/<span class="number">2</span>;</span><br><span class="line">L(<span class="number">3</span>) = Link([theta3, d3, a3, alpha3], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line">L(<span class="number">4</span>) = Link([theta4, d4, a4, alpha4], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line">L(<span class="number">5</span>) = Link([theta5, d5, a5, alpha5], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line">L(<span class="number">6</span>) = Link([theta6, d6, a6, alpha6], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line"></span><br><span class="line">L(<span class="number">1</span>).qlim = [<span class="number">-170</span>*<span class="built_in">pi</span>/<span class="number">180</span>, <span class="number">170</span>*<span class="built_in">pi</span>/<span class="number">180</span>];</span><br><span class="line">L(<span class="number">2</span>).qlim = [<span class="number">-135</span>*<span class="built_in">pi</span>/<span class="number">180</span>, <span class="number">96</span>*<span class="built_in">pi</span>/<span class="number">180</span>];</span><br><span class="line">L(<span class="number">3</span>).qlim = [<span class="number">-45</span>*<span class="built_in">pi</span>/<span class="number">180</span>, <span class="number">187</span>*<span class="built_in">pi</span>/<span class="number">180</span>];</span><br><span class="line">L(<span class="number">4</span>).qlim = [<span class="number">-180</span>*<span class="built_in">pi</span>/<span class="number">180</span>, <span class="number">180</span>*<span class="built_in">pi</span>/<span class="number">180</span>];</span><br><span class="line">L(<span class="number">5</span>).qlim = [<span class="number">-68</span>*<span class="built_in">pi</span>/<span class="number">180</span>, <span class="number">68</span>*<span class="built_in">pi</span>/<span class="number">180</span>];</span><br><span class="line">L(<span class="number">6</span>).qlim = [<span class="number">-180</span>*<span class="built_in">pi</span>/<span class="number">180</span>, <span class="number">180</span>*<span class="built_in">pi</span>/<span class="number">180</span>];</span><br><span class="line"></span><br><span class="line">robot = SerialLink(L, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;XB-7&#x27;</span>);</span><br><span class="line">robot.display();  <span class="comment">% 显示DH参数</span></span><br><span class="line"></span><br><span class="line">num=<span class="number">30000</span>;<span class="comment">%循环次数，生成3万个随机位置点</span></span><br><span class="line">P=<span class="built_in">zeros</span>(num,<span class="number">3</span>);<span class="comment">%% 创建一个num行×3列的全零矩阵P,存储随时间或步骤变化的 三维数据（如机械臂末端的位置坐标 [x, y, z]）。</span></span><br><span class="line"><span class="comment">%生成机械臂末端执行器在三维空间中的随机位置</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:num</span><br><span class="line">    q1=L(<span class="number">1</span>).qlim(<span class="number">1</span>)+<span class="built_in">rand</span>*(L(<span class="number">1</span>).qlim(<span class="number">2</span>)-L(<span class="number">1</span>).qlim(<span class="number">1</span>));</span><br><span class="line">    q2=L(<span class="number">2</span>).qlim(<span class="number">1</span>)+<span class="built_in">rand</span>*(L(<span class="number">2</span>).qlim(<span class="number">2</span>)-L(<span class="number">2</span>).qlim(<span class="number">1</span>));</span><br><span class="line">    q3=L(<span class="number">3</span>).qlim(<span class="number">1</span>)+<span class="built_in">rand</span>*(L(<span class="number">3</span>).qlim(<span class="number">2</span>)-L(<span class="number">3</span>).qlim(<span class="number">1</span>));</span><br><span class="line">    q4=L(<span class="number">4</span>).qlim(<span class="number">1</span>)+<span class="built_in">rand</span>*(L(<span class="number">4</span>).qlim(<span class="number">2</span>)-L(<span class="number">4</span>).qlim(<span class="number">1</span>));</span><br><span class="line">    q5=L(<span class="number">5</span>).qlim(<span class="number">1</span>)+<span class="built_in">rand</span>*(L(<span class="number">5</span>).qlim(<span class="number">2</span>)-L(<span class="number">5</span>).qlim(<span class="number">1</span>));</span><br><span class="line">    q6=L(<span class="number">6</span>).qlim(<span class="number">1</span>)+<span class="built_in">rand</span>*(L(<span class="number">6</span>).qlim(<span class="number">2</span>)-L(<span class="number">6</span>).qlim(<span class="number">1</span>));</span><br><span class="line">    q=[q1 q2 q3 q4 q5 q6];</span><br><span class="line">    T=robot.fkine(q);</span><br><span class="line">    P(<span class="built_in">i</span>, :)=transl(T);<span class="comment">%从齐次变换矩阵T中提取平移部分（即末端执行器的 [x, y, z] 坐标）,将当前随机位置的坐标保存到 P 的第 i 行。</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">plot3</span>(P(:,<span class="number">1</span>),P(:,<span class="number">2</span>),P(:,<span class="number">3</span>), <span class="string">&#x27;b.&#x27;</span>, <span class="string">&#x27;markersize&#x27;</span>,<span class="number">1</span>);<span class="comment">%P(:,1)：矩阵 P 的第一列（所有点的 x 坐标）。</span></span><br><span class="line">xlabel(<span class="string">&#x27;X (mm)&#x27;</span>); ylabel(<span class="string">&#x27;Y (mm)&#x27;</span>); zlabel(<span class="string">&#x27;Z (mm)&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;机器人工作空间可视化&#x27;</span>);</span><br><span class="line">axis equal;</span><br><span class="line">grid on</span><br><span class="line"></span><br><span class="line">robot.teach();    <span class="comment">% 交互式示教界面</span></span><br></pre></td></tr></table></figure><h1 id="附录：MATLAB常用函数"><a href="#附录：MATLAB常用函数" class="headerlink" title="附录：MATLAB常用函数"></a>附录：MATLAB常用函数</h1><h2 id="位姿描述"><a href="#位姿描述" class="headerlink" title="位姿描述"></a>位姿描述</h2><p>齐次变换矩阵，是一个包括姿态和位置信息的4x4矩阵。每个T都看成转动+移动，只有移动则转动对应部分为单位向量，只有转动则移动部分对应向量为0。</p><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605121722534.png" alt="image-20250605121722534"></p><h3 id="transl-translation"><a href="#transl-translation" class="headerlink" title="transl(translation)"></a>transl(translation)</h3><p>transl函数用于创建一个表示平移的仿射变换矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">transl( [x, y, z] );<span class="comment">% 平移变换（4x4）,为该坐标系相对于世界坐标系的x,y,z坐标</span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">T1=transl(<span class="number">-100</span>,<span class="number">-100</span>,<span class="number">300</span>);</span><br><span class="line">display(T1);</span><br><span class="line">-&gt;T1 =</span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>  <span class="number">-100</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>  <span class="number">-100</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>   <span class="number">300</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="trotx-troty-trotz"><a href="#trotx-troty-trotz" class="headerlink" title="trotx,troty,trotz"></a>trotx,troty,trotz</h3><p>trotx用于创建一个表示绕 x 轴旋转的仿射变换矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">trotx(theta), troty(theta), trotz(theta);<span class="comment">% 只有旋转的绕xyz轴旋转的齐次变换矩阵（4x4）</span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">T1=trotx(<span class="number">180</span>);</span><br><span class="line">display(T1);</span><br><span class="line">-&gt;T1 =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>    <span class="number">-1</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>    <span class="number">-1</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>移动+转动</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">T1=transl(<span class="number">-100</span>,<span class="number">-100</span>,<span class="number">300</span>)*trotx(<span class="number">180</span>);</span><br><span class="line">display(T1);</span><br><span class="line"></span><br><span class="line">T1 =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>  <span class="number">-100</span></span><br><span class="line">     <span class="number">0</span>    <span class="number">-1</span>     <span class="number">0</span>  <span class="number">-100</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>    <span class="number">-1</span>   <span class="number">300</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="eul2r"><a href="#eul2r" class="headerlink" title="eul2r"></a>eul2r</h3><p>欧拉角，绕自身坐标系旋转，右乘。</p><p>x为横滚，y为俯仰，z为偏航</p><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605121732962.png" alt="image-20250605121732962"></p><h3 id="rpy2r"><a href="#rpy2r" class="headerlink" title="rpy2r"></a>rpy2r</h3><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605121743331.png" alt="image-20250605121743331"></p><h2 id="运动学"><a href="#运动学" class="headerlink" title="运动学"></a>运动学</h2><h3 id="建立机器人模型"><a href="#建立机器人模型" class="headerlink" title="建立机器人模型"></a>建立机器人模型</h3><h4 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h4><p>Link类函数，基于DH法建模，建立其相关关系，DH法建模分改进型和标准型，Link类函数的一种用法是 R &#x3D; Link([theta,d,a, alpha])，其中参数theta代表DH建模的关节角、参数d代表DH建模的连杆偏距、参数a代表DH建模的连杆长度、参数alpha代表DH建模的连杆转角。例如：L(1)&#x3D;Link([1,2,3,4],‘modified’)，其中modified表示用改进型DH法建模</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% MDH参数</span></span><br><span class="line">theta1 = <span class="number">0</span>;    d1 = <span class="number">380</span>;     a1 = <span class="number">0</span>;    alpha1 = <span class="number">0</span>;    </span><br><span class="line">theta2 = <span class="number">0</span>;    d2 = <span class="number">0</span>;       a2 = <span class="number">30</span>;   alpha2 = -<span class="built_in">pi</span>/<span class="number">2</span>;        </span><br><span class="line">theta3 = <span class="number">0</span>;    d3 = <span class="number">0</span>;       a3 = <span class="number">340</span>;  alpha3 = <span class="number">0</span>;    </span><br><span class="line">theta4 = <span class="number">0</span>;    d4 = <span class="number">335</span>;     a4 = <span class="number">35</span>;   alpha4 = -<span class="built_in">pi</span>/<span class="number">2</span>;    </span><br><span class="line">theta5 = <span class="number">0</span>;    d5 = <span class="number">0</span>;       a5 = <span class="number">0</span>;    alpha5 = <span class="built_in">pi</span>/<span class="number">2</span>;     </span><br><span class="line">theta6 = <span class="number">0</span>;    d6 = <span class="number">83</span>;      a6 = <span class="number">0</span>;    alpha6 = -<span class="built_in">pi</span>/<span class="number">2</span>;     </span><br><span class="line"></span><br><span class="line">L(<span class="number">1</span>) = Link([theta1, d1, a1, alpha1], <span class="string">&#x27;modified&#x27;</span>);L(<span class="number">1</span>).offset=<span class="built_in">pi</span>;</span><br><span class="line">L(<span class="number">2</span>) = Link([theta2, d2, a2, alpha2], <span class="string">&#x27;modified&#x27;</span>);L(<span class="number">2</span>).offset=<span class="built_in">pi</span>/<span class="number">2</span>;</span><br><span class="line">L(<span class="number">3</span>) = Link([theta3, d3, a3, alpha3], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line">L(<span class="number">4</span>) = Link([theta4, d4, a4, alpha4], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line">L(<span class="number">5</span>) = Link([theta5, d5, a5, alpha5], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line">L(<span class="number">6</span>) = Link([theta6, d6, a6, alpha6], <span class="string">&#x27;modified&#x27;</span>);</span><br></pre></td></tr></table></figure><p>关节角限制：</p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605121756920.png" alt="image-20250605121756920" style="zoom:67%;"><h4 id="SerialLink"><a href="#SerialLink" class="headerlink" title="SerialLink"></a>SerialLink</h4><p>一个表示串联机械臂机器人的具体类，其中每个连杆和关节都通过使用DH参数的Link类对象进行描述。</p><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605121810867.png" alt="image-20250605121810867"></p><p>通过在MATLAB命令行串口输出’doc SerialLink’可查看其详细内容。</p><p>以下是其常见的一些函数：</p><p><strong>1.teach示教</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Six_link.teach</span><br></pre></td></tr></table></figure><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605122122471.png" alt="image-20250605122122471" style="zoom:67%;"><p><strong>2.plot</strong></p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605122133102.png" alt="image-20250605122133102" style="zoom:67%;"><p><strong>3.plot3d 三维模型展示(需导入STL文件)</strong></p><p>只能用于标准型的DH参数建模。</p><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605122143239.png" alt="image-20250605122143239"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mdl_puma560;</span><br><span class="line">p560.plot3d(qz,<span class="string">&#x27;view&#x27;</span>,[<span class="number">0</span>,<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605122156396.png" alt="image-20250605122156396"></p><p>绝对路径</p><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605122205203.png" alt="image-20250605122205203"></p><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605122211776.png" alt="image-20250605122211776"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">L(<span class="built_in">i</span>) = Link( [theta, d, a, alpha, sigma]，<span class="string">&#x27;modified&#x27;</span> ) <span class="comment">% 定义关节，DH参数：关节角、连杆偏距、连杆长度、连杆转角，sigma=1为移动副, 改进型DH</span></span><br><span class="line"></span><br><span class="line">L(<span class="built_in">i</span>).qlim = [ <span class="built_in">min</span>, <span class="built_in">max</span> ]  <span class="comment">% 关节角度限制</span></span><br><span class="line"></span><br><span class="line">Six_link = SerialLink( L, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Sixlink&#x27;</span> )    <span class="comment">% 将Link连接成一个机械臂</span></span><br><span class="line"></span><br><span class="line">Six_link.<span class="built_in">plot</span>( [theta_1, theta_2, ..., theta_n] ) <span class="comment">% 画出机械臂，theta为关节初始角度</span></span><br><span class="line"></span><br><span class="line">Six_link.display <span class="comment">% 输出机械臂信息</span></span><br><span class="line"></span><br><span class="line">Six_link.teach <span class="comment">% 机械臂操控交互界面(示教)通过执行 robot.teach()，系统会进入示教模式，允许用户通过手动移动机器人的关节或末端执行器来记录示教数据。这些数据可以用于后续的路径规划、运动控制或其他任务。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="运动学-1"><a href="#运动学-1" class="headerlink" title="运动学"></a>运动学</h3><h4 id="fkine正向运动学"><a href="#fkine正向运动学" class="headerlink" title="fkine正向运动学"></a>fkine正向运动学</h4><p>接受关节角度作为输入参数，并返回对应的末端执行器位置和姿态矩阵。</p><h4 id="ikine逆向运动学"><a href="#ikine逆向运动学" class="headerlink" title="ikine逆向运动学"></a>ikine逆向运动学</h4><p>接受末端执行器位置和姿态矩阵作为输入参数，并返回对应的关节角度。</p><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605122227191.png" alt="image-20250605122227191"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q1=Five_dof.ikine(T,<span class="string">&#x27;mask&#x27;</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>]);//当用于欠自由度（小于<span class="number">6</span>）时，需用mask</span><br></pre></td></tr></table></figure><p>ikine用于求数值解，不考虑关节限制</p><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605122234923.png" alt="image-20250605122234923"></p><p>ikine6s用于求6轴机械臂的解析解</p><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605122242364.png" alt="image-20250605122242364"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q2=Five_dof.ikunc(T);//当用于欠自由度（小于<span class="number">6</span>）时，不需用mask</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line"><span class="comment">%% 建立机器人DH参数,初始姿态为竖直。</span></span><br><span class="line">L(<span class="number">1</span>)=Link(<span class="string">&#x27;d&#x27;</span>,<span class="number">105.03</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;alpha&#x27;</span>,<span class="built_in">pi</span>/<span class="number">2</span>,<span class="string">&#x27;standard&#x27;</span>); </span><br><span class="line">L(<span class="number">2</span>)=Link(<span class="string">&#x27;d&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">-174.42</span>,<span class="string">&#x27;alpha&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;offset&#x27;</span>,-<span class="built_in">pi</span>/<span class="number">2</span>,<span class="string">&#x27;standard&#x27;</span>);</span><br><span class="line">L(<span class="number">3</span>)=Link(<span class="string">&#x27;d&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">-174.42</span>,<span class="string">&#x27;alpha&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;standard&#x27;</span>);</span><br><span class="line">L(<span class="number">4</span>)=Link(<span class="string">&#x27;d&#x27;</span>,<span class="number">75.66</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;alpha&#x27;</span>,<span class="built_in">pi</span>/<span class="number">2</span>,<span class="string">&#x27;offset&#x27;</span>,-<span class="built_in">pi</span>/<span class="number">2</span>,<span class="string">&#x27;standard&#x27;</span>);</span><br><span class="line">L(<span class="number">5</span>)=Link(<span class="string">&#x27;d&#x27;</span>,<span class="number">80.09</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;alpha&#x27;</span>,-<span class="built_in">pi</span>/<span class="number">2</span>,<span class="string">&#x27;standard&#x27;</span>);</span><br><span class="line">L(<span class="number">6</span>)=Link(<span class="string">&#x27;d&#x27;</span>,<span class="number">44.36</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;alpha&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;standard&#x27;</span>);  </span><br><span class="line">robot=SerialLink(L(<span class="number">1</span>:<span class="number">6</span>),<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;Gluon_6L3&#x27;</span>, <span class="string">&#x27;manufacturer&#x27;</span>,<span class="string">&#x27;innfos&#x27;</span>)</span><br><span class="line"><span class="comment">%% 正解，给定关节角，求末端位姿</span></span><br><span class="line">Theta=<span class="number">15</span>*<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line"><span class="comment">%% 验证正逆解的结果</span></span><br><span class="line">Theta=Theta/<span class="number">180</span>*<span class="built_in">pi</span>;                         <span class="comment">%换算成弧度</span></span><br><span class="line">T=robot.fkine(Theta)             <span class="comment">%求正解的齐次变换矩阵</span></span><br><span class="line">q1=robot.ikine(T)*<span class="number">180</span>/<span class="built_in">pi</span>      <span class="comment">%求逆解验证关节角</span></span><br></pre></td></tr></table></figure><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605122251128.png" alt="image-20250605122251128"></p><h2 id="轨迹规划-1"><a href="#轨迹规划-1" class="headerlink" title="轨迹规划"></a>轨迹规划</h2><p>一次多项式：首末速度突变，加速度为无穷大； </p><p>三次多项式：首末速度为0，加速度有突变；</p><p>五次多项式：首末速度、加速度为0，无突变。</p><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605122301809.png" alt="image-20250605122301809"></p><h3 id="五次多项式轨迹tpoly"><a href="#五次多项式轨迹tpoly" class="headerlink" title="五次多项式轨迹tpoly"></a>五次多项式轨迹tpoly</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>,<span class="number">51</span>)<span class="comment">%0-2s内插值51次，等效于0:0.04:2</span></span><br><span class="line">[P,dP,ddP]=tpoly(<span class="number">0</span>,<span class="number">3</span>,t);<span class="comment">%对位置0-3进行51次插值</span></span><br><span class="line">指定初末速度：[P,dP,ddP]=tpoly(<span class="number">0</span>,<span class="number">3</span>,t,<span class="number">0.02</span>,<span class="number">0.01</span>)<span class="comment">%t也可以直接写51，一样的</span></span><br></pre></td></tr></table></figure><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605122310263.png" alt="image-20250605122310263"></p><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605122316479.png" alt="image-20250605122316479"></p><h3 id="混合曲线轨迹lspb"><a href="#混合曲线轨迹lspb" class="headerlink" title="混合曲线轨迹lspb"></a>混合曲线轨迹lspb</h3><p>看起来感觉和梯形速度规划差不多。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>,<span class="number">51</span>);</span><br><span class="line">[p,dP,ddP]=lspb(<span class="number">0</span>,<span class="number">3</span>,t);</span><br></pre></td></tr></table></figure><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605122325699.png" alt="image-20250605122325699"></p><h3 id="多维轨迹mtraj"><a href="#多维轨迹mtraj" class="headerlink" title="多维轨迹mtraj"></a>多维轨迹mtraj</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>,<span class="number">51</span>);</span><br><span class="line">[p,dP,ddP]=mtraj(@tpoly,[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">4</span>],t);<span class="comment">%第一个参数为轨迹规划方式，用哪种就@哪种，二三参数为起点和终点</span></span><br></pre></td></tr></table></figure><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605122334325.png" alt="image-20250605122334325"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 机器人建模（Modified DH参数）(长度mm)</span></span><br><span class="line">theta1 = <span class="number">0</span>;    d1 = <span class="number">380</span>;     a1 = <span class="number">0</span>;    alpha1 = <span class="number">0</span>;    </span><br><span class="line">theta2 = <span class="number">0</span>;    d2 = <span class="number">0</span>;       a2 = <span class="number">30</span>;   alpha2 = <span class="built_in">pi</span>/<span class="number">2</span>;        </span><br><span class="line">theta3 = <span class="number">0</span>;    d3 = <span class="number">0</span>;       a3 = <span class="number">340</span>;  alpha3 = <span class="number">0</span>;    </span><br><span class="line">theta4 = <span class="number">0</span>;    d4 = <span class="number">335</span>;     a4 = <span class="number">35</span>;   alpha4 = <span class="built_in">pi</span>/<span class="number">2</span>;    </span><br><span class="line">theta5 = <span class="number">0</span>;    d5 = <span class="number">0</span>;       a5 = <span class="number">0</span>;    alpha5 = -<span class="built_in">pi</span>/<span class="number">2</span>;     </span><br><span class="line">theta6 = <span class="number">0</span>;    d6 = <span class="number">83</span>;      a6 = <span class="number">0</span>;    alpha6 = <span class="built_in">pi</span>/<span class="number">2</span>;     </span><br><span class="line"></span><br><span class="line">L(<span class="number">1</span>) = Link([theta1, d1, a1, alpha1], <span class="string">&#x27;modified&#x27;</span>);L(<span class="number">1</span>).offset=<span class="built_in">pi</span>;</span><br><span class="line">L(<span class="number">2</span>) = Link([theta2, d2, a2, alpha2], <span class="string">&#x27;modified&#x27;</span>);L(<span class="number">2</span>).offset=<span class="built_in">pi</span>/<span class="number">2</span>;</span><br><span class="line">L(<span class="number">3</span>) = Link([theta3, d3, a3, alpha3], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line">L(<span class="number">4</span>) = Link([theta4, d4, a4, alpha4], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line">L(<span class="number">5</span>) = Link([theta5, d5, a5, alpha5], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line">L(<span class="number">6</span>) = Link([theta6, d6, a6, alpha6], <span class="string">&#x27;modified&#x27;</span>);</span><br><span class="line"></span><br><span class="line">L(<span class="number">1</span>).qlim = [<span class="number">-170</span>*<span class="built_in">pi</span>/<span class="number">180</span>, <span class="number">170</span>*<span class="built_in">pi</span>/<span class="number">180</span>];</span><br><span class="line">L(<span class="number">2</span>).qlim = [<span class="number">-135</span>*<span class="built_in">pi</span>/<span class="number">180</span>, <span class="number">96</span>*<span class="built_in">pi</span>/<span class="number">180</span>];</span><br><span class="line">L(<span class="number">3</span>).qlim = [<span class="number">-45</span>*<span class="built_in">pi</span>/<span class="number">180</span>, <span class="number">187</span>*<span class="built_in">pi</span>/<span class="number">180</span>];</span><br><span class="line">L(<span class="number">4</span>).qlim = [<span class="number">-180</span>*<span class="built_in">pi</span>/<span class="number">180</span>, <span class="number">180</span>*<span class="built_in">pi</span>/<span class="number">180</span>];</span><br><span class="line">L(<span class="number">5</span>).qlim = [<span class="number">-68</span>*<span class="built_in">pi</span>/<span class="number">180</span>, <span class="number">68</span>*<span class="built_in">pi</span>/<span class="number">180</span>];</span><br><span class="line">L(<span class="number">6</span>).qlim = [<span class="number">-180</span>*<span class="built_in">pi</span>/<span class="number">180</span>, <span class="number">180</span>*<span class="built_in">pi</span>/<span class="number">180</span>];</span><br><span class="line"></span><br><span class="line">robot = SerialLink(L, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;XB-7&#x27;</span>);</span><br><span class="line">robot.display();  <span class="comment">% 显示DH参数</span></span><br><span class="line"></span><br><span class="line">P1=[<span class="number">-280</span>,<span class="number">-300</span>, <span class="number">450</span>];</span><br><span class="line">P2=[<span class="number">-280</span>,<span class="number">300</span>, <span class="number">450</span>];</span><br><span class="line"></span><br><span class="line">t=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>,<span class="number">51</span>);</span><br><span class="line">Traj=mtraj(@tpoly,P1,P2,t);</span><br><span class="line"></span><br><span class="line">n=<span class="built_in">size</span>(Traj,<span class="number">1</span>);</span><br><span class="line">T=<span class="built_in">zeros</span>(<span class="number">4</span>,<span class="number">4</span>,n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    T(:,:,<span class="built_in">i</span>)=transl(Traj(<span class="built_in">i</span>, :))*trotx(<span class="number">180</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Qtraj=robot.ikunc(T);</span><br><span class="line">robot.<span class="built_in">plot</span>(Qtraj,<span class="string">&#x27;movie&#x27;</span>,<span class="string">&#x27;trail.gif&#x27;</span>,<span class="string">&#x27;trail&#x27;</span>, &#123;<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="多维多段轨迹mstraj"><a href="#多维多段轨迹mstraj" class="headerlink" title="多维多段轨迹mstraj"></a>多维多段轨迹mstraj</h3><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605122344604.png" alt="image-20250605122344604"></p><h3 id="笛卡尔轨迹ctraj"><a href="#笛卡尔轨迹ctraj" class="headerlink" title="笛卡尔轨迹ctraj"></a>笛卡尔轨迹ctraj</h3><p><img src="/2025/04/27/%E6%9C%BA%E6%A2%B0%E8%87%82/image-20250605122355409.png" alt="image-20250605122355409"></p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p>【台大机器人学之运动学——林沛群（含课件+书籍）】 <a href="https://www.bilibili.com/video/BV1v4411H7ez/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1v4411H7ez/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></p><p>MATLAB机器人工具箱10.4 机械臂仿真教学<a href="https://www.bilibili.com/video/BV1q44y1x7WC?spm_id_from=333.788.videopod.episodes&vd_source=a9d487fcf1a579639c6348eb5a9321db&p=4">https://www.bilibili.com/video/BV1q44y1x7WC?spm_id_from=333.788.videopod.episodes&amp;vd_source=a9d487fcf1a579639c6348eb5a9321db&amp;p=4</a></p><p>CSDN:工业六轴机器人常见的STD(标准)-DH模型建立方法<a href="https://blog.csdn.net/Vittore_Li/article/details/121966473?fromshare=blogdetail&sharetype=blogdetail&sharerId=121966473&sharerefer=PC&sharesource=qq_52769953&sharefrom=from_link">https://blog.csdn.net/Vittore_Li/article/details/121966473?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=121966473&amp;sharerefer=PC&amp;sharesource=qq_52769953&amp;sharefrom=from_link</a></p><p>详细介绍如何使用MATLAB中的机器人工具箱建立机器人模型（DH法建模）（机械臂）<a href="https://blog.csdn.net/qq_44339029/article/details/109708454?fromshare=blogdetail&sharetype=blogdetail&sharerId=109708454&sharerefer=PC&sharesource=qq_52769953&sharefrom=from_link">https://blog.csdn.net/qq_44339029/article/details/109708454?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=109708454&amp;sharerefer=PC&amp;sharesource=qq_52769953&amp;sharefrom=from_link</a></p><p>黄磊.工业机器人笛卡尔空间轨迹规划算法研究与应用[D].电子科技大学,2024.DOI:10.27005&#x2F;d.cnki.gdzku.2024.004056.</p><p>CSDN:【Matlab 六自由度机器人】系列文章汇总<a href="https://blog.csdn.net/AlbertDS/article/details/123968265?fromshare=blogdetail&sharetype=blogdetail&sharerId=123968265&sharerefer=PC&sharesource=qq_52769953&sharefrom=from_link">https://blog.csdn.net/AlbertDS/article/details/123968265?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=123968265&amp;sharerefer=PC&amp;sharesource=qq_52769953&amp;sharefrom=from_link</a></p><p>知乎：机器人工程师进阶之路<a href="https://www.zhihu.com/column/c_1241771327444774912">https://www.zhihu.com/column/c_1241771327444774912</a></p><p>知乎：机器人技术基础之运动学<a href="https://www.zhihu.com/column/c_1693921850789429248?utm_campaign=&utm_medium=social&utm_psn=1896366318900467549&utm_source=qq">https://www.zhihu.com/column/c_1693921850789429248?utm_campaign=&amp;utm_medium=social&amp;utm_psn=1896366318900467549&amp;utm_source=qq</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器人学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械臂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并联四足机器人</title>
      <link href="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
      <url>/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="并联四足机器人位置控制"><a href="#并联四足机器人位置控制" class="headerlink" title="并联四足机器人位置控制"></a>并联四足机器人位置控制</h1><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/2.jpg" alt="2" style="zoom:70%;"><h2 id="参考学习资源"><a href="#参考学习资源" class="headerlink" title="参考学习资源"></a>参考学习资源</h2><p>【【教程】成本1K！从0教你DIY无刷四足机器人~灯哥无刷四足一代实验版开源啦！！！】 <a href="https://www.bilibili.com/video/BV1kV411i76z/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1kV411i76z/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></p><p>【灯哥0基础DIY四足机器人指南（8）–用Matlab画出摆线步态曲线】 <a href="https://www.bilibili.com/video/BV1KQ4y1K7aV/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1KQ4y1K7aV/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></p><p>四足机器人并联腿足端轨迹matlab仿真-CSDN   <a href="https://blog.csdn.net/qq_36942736/article/details/106580465?fromshare=blogdetail&sharetype=blogdetail&sharerId=106580465&sharerefer=PC&sharesource=qq_52769953&sharefrom=from_link">https://blog.csdn.net/qq_36942736/article/details/106580465?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=106580465&amp;sharerefer=PC&amp;sharesource=qq_52769953&amp;sharefrom=from_link</a></p><p>华北舵狗王带你一起做四足机器人2（Moco-8四足机器人控制算法简介） - 华北舵狗王的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/69869440">https://zhuanlan.zhihu.com/p/69869440</a></p><p>【灯哥0基础DIY四足机器人指南（9）–手把手教你写出小跑步态程序】                                                                                                                                                   <a href="https://www.bilibili.com/video/BV1YD4y1D7k6/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1YD4y1D7k6/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></p><p>[灯哥开源—四足机器人]程序算法讲解与STM32移植——PA_TROT和PA_WALK讲解和trot步态，walk步态，步态规划-CSDN                                                           <a href="https://blog.csdn.net/weixin_41659552/article/details/113738017?fromshare=blogdetail&sharetype=blogdetail&sharerId=113738017&sharerefer=PC&sharesource=qq_52769953&sharefrom=from_link">https://blog.csdn.net/weixin_41659552/article/details/113738017?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=113738017&amp;sharerefer=PC&amp;sharesource=qq_52769953&amp;sharefrom=from_link</a></p><p>【干货|开源MIT Min cheetah机械狗设计(五)】|机械狗步态规划（重点） - 陈不陈的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/639128926">https://zhuanlan.zhihu.com/p/639128926</a></p><p>【四足机器人项目实战】|四足机器人步态规划与相位控制实现 - RoboticsTechLab的文章 - CSDN<br><a href="https://download.csdn.net/blog/column/11523325/122047921">https://download.csdn.net/blog/column/11523325/122047921</a></p><p>MIT Cheetah 完整开源代码与论文简介 - 廖洽源的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/79391139?utm_psn=1874912895365672960">https://zhuanlan.zhihu.com/p/79391139?utm_psn=1874912895365672960</a></p><p>四足机器人优化方法初探：快速移植MIT Cheetha MPC控制代码 - 华北舵狗王的文章 - 知乎                                                                                                               <a href="https://zhuanlan.zhihu.com/p/450008168?utm_psn=1874923719606009856">https://zhuanlan.zhihu.com/p/450008168?utm_psn=1874923719606009856</a></p><p>看论文：</p><p>yxy, 张国腾</p><p>VMC论文阅读笔记_摆动相位轨迹_公式和代码 - lcccccc的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/687733214">https://zhuanlan.zhihu.com/p/687733214</a></p><p>webots四足机器人建模教程：</p><p>【实例 手把手搭建Webots四足机器人（机器狗）】 <a href="https://www.bilibili.com/video/BV1u44y1f7oU/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1u44y1f7oU/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></p><p>Webots&amp; 四足模型搭建&amp;简单的测试程序Demo - lcccccc的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/686867275">https://zhuanlan.zhihu.com/p/686867275</a></p><h2 id="摆线足端轨迹和运动学逆解"><a href="#摆线足端轨迹和运动学逆解" class="headerlink" title="摆线足端轨迹和运动学逆解"></a>摆线足端轨迹和运动学逆解</h2><p>关于摆动腿足端的轨迹，有以下期望：</p><p>1)在足端刚开始离地和将要触地时，希望足端的速度很小，并且在xy平面没有滑动趋势。</p><p>2)足端在轨迹的中段时运动迅速。</p><p>3)足端轨迹足够平滑，不存在波动。</p><p>​常用的足端估计有多项式曲线，分段直线和摆线。其中多项式曲线可以画出光滑且复杂的轨迹，但其中各个参数的计算比较复杂。分段直线轨迹虽然设计比较简单，但是轨迹不够光顺平滑。摆线轨迹虽然不能灵活的修改轨迹的形状，但是表达式简单且参数具有明显的几何意义，比较容易推导。</p><p>​摆线(Cycloid)，又称旋轮线、圆滚线，在数学中，摆线被定义为，一个圆沿一条直线运动时，圆边界上一定点所形成的轨迹。对于四足机器人，让四条腿以一定的相位差跑出这条曲线，四足机器人就有了前进的能力。</p><h3 id="用Matlab画出摆线步态曲线"><a href="#用Matlab画出摆线步态曲线" class="headerlink" title="用Matlab画出摆线步态曲线"></a>用Matlab画出摆线步态曲线</h3><h4 id="摆线方程"><a href="#摆线方程" class="headerlink" title="摆线方程"></a>摆线方程</h4><p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/85ff4051c97592072b46432c89e1ea28.png" alt="85ff4051c97592072b46432c89e1ea28"></p><p>原始方程</p><p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/7d86ae714c34334350057032c9d9e3de.png" alt="7d86ae714c34334350057032c9d9e3de"></p><p>推导</p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250216095006059.png" alt="image-20250216095006059" style="zoom:67%;"><p>对原始方程处理</p><p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250215233919049.png" alt="image-20250215233919049"></p><p>Xs:水平方向足端当前起点位置 Xf:水平方向足端期望落足点位置   (xf-xs)&#x2F;2pi&#x3D;a </p><p>Zs:竖直方向足端当前起点位置 Zf:水平方向足端期望落足点位置</p><p>Ts:步态周期，λ：支撑相占空比, h:摆线高度 h&#x3D;2a&#x3D;(xf-xs)&#x2F;pi</p><p>t:离散时刻点，每个点对应摆线轨迹上的一个坐标</p><p>θ&#x3D;2pi*(t&#x2F;λTs) </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear;</span><br><span class="line">Ts=<span class="number">1</span>;    <span class="comment">%周期</span></span><br><span class="line">fai=<span class="number">0.5</span>; <span class="comment">%支撑相占空比</span></span><br><span class="line">xs=<span class="number">-20</span>;  <span class="comment">%起点x位置</span></span><br><span class="line">xf=<span class="number">20</span>;   <span class="comment">%终点x位置</span></span><br><span class="line">zs=<span class="number">0</span>;    <span class="comment">%z起点位置</span></span><br><span class="line">h=<span class="number">30</span>;    <span class="comment">%抬腿高度 h=2a=(xf-xs)/pi</span></span><br><span class="line"></span><br><span class="line">x=[];    <span class="comment">%设定数组用于保存x坐标值</span></span><br><span class="line">z=[];    <span class="comment">%设定数组用于保存z坐标值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t=<span class="number">0</span>:<span class="number">0.01</span>:Ts*(<span class="number">1</span>-fai)         <span class="comment">%for循环，从0开始到0.5,间隔0.01循环赋值给t,制造出时刻数值</span></span><br><span class="line">    sigma=<span class="number">2</span>*<span class="built_in">pi</span>*t/((<span class="number">1</span>-fai)*Ts);  <span class="comment">%计算sigma值</span></span><br><span class="line">    xep=(xf-xs)*((sigma-<span class="built_in">sin</span>(sigma))/(<span class="number">2</span>*<span class="built_in">pi</span>))+xs; <span class="comment">%根据时刻计算x轴离散点</span></span><br><span class="line">    zep=h*(<span class="number">1</span>-<span class="built_in">cos</span>(sigma))/<span class="number">2</span>+zs;                  <span class="comment">%根据时刻计算z轴离散点</span></span><br><span class="line">    x=[x,xep];                                  <span class="comment">%放在x数组里，准备画图</span></span><br><span class="line">    z=[z,zep];                                  <span class="comment">%放在z数组里，准备画图</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">plot</span>(x,z)                                       <span class="comment">%指定两个数组，分别画图</span></span><br><span class="line">axis equal                                      <span class="comment">%x,y轴刻度等比例</span></span><br></pre></td></tr></table></figure><p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250216104415504.png" alt="image-20250216104415504"></p><p>在Webots实现<strong>单条腿</strong>按摆线足端轨迹运动，占空比取0.5:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过足端轨迹得到足端离散的x_1,y_1坐标点，然后将它们运动学逆解即可得到关节电机相对应转的角度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trot</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; T_s * fai)<span class="comment">//支撑相</span></span><br><span class="line">    &#123;</span><br><span class="line">        sigma = <span class="number">2</span> * pi * t / (fai * T_s);</span><br><span class="line">        zep = h * (<span class="number">1</span> - <span class="built_in">cos</span>(sigma)) / <span class="number">2</span>;                             <span class="comment">// t时刻足端在摆线坐标系里的高度</span></span><br><span class="line">        xep_b = (xf - xs) * ((sigma - <span class="built_in">sin</span>(sigma)) / (<span class="number">2</span> * pi)) + xs; <span class="comment">// 摆动相x坐标</span></span><br><span class="line">        xep_z = (xs - xf) * ((sigma - <span class="built_in">sin</span>(sigma)) / (<span class="number">2</span> * pi)) + xf; <span class="comment">// 支撑相x坐标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出x</span></span><br><span class="line">        x_1 = xep_z; </span><br><span class="line">        <span class="comment">// 输出y</span></span><br><span class="line">        y_1 =<span class="number">0</span>+height;<span class="comment">//height为支撑相时期望的关节电机的离地高度（关节电机为坐标系原点），+0是因为此时足端在支撑相，触地。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((t &gt; T_s * fai) &amp;&amp; (t &lt;= T_s))<span class="comment">//摆动相</span></span><br><span class="line">    &#123;</span><br><span class="line">        sigma = <span class="number">2</span> * pi * (t-fai*T_s) / (fai * T_s);</span><br><span class="line">        zep = h * (<span class="number">1</span> - <span class="built_in">cos</span>(sigma)) / <span class="number">2</span>; </span><br><span class="line">        xep_b = (xf - xs) * ((sigma - <span class="built_in">sin</span>(sigma)) / (<span class="number">2</span> * pi)) + xs; <span class="comment">// 摆动相x坐标</span></span><br><span class="line">        xep_z = (xs - xf) * ((sigma - <span class="built_in">sin</span>(sigma)) / (<span class="number">2</span> * pi)) + xf; <span class="comment">// 支撑相x坐标</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 输出x</span></span><br><span class="line">        x_1 = xep_b; </span><br><span class="line">        <span class="comment">// 输出y</span></span><br><span class="line">        y_1 = zep+height; <span class="comment">//+zep是在摆动相足端抬起后该时刻足端距离关节电机的距离</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同height的作用效果如下，可见height就是关节的离地高度，height的绝度值越大，关节离地越远</p><p>​                               <img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250217102307359.png" alt="image-20250217102307359" style="zoom:70%;"><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250217102406286.png" alt="image-20250217102406286" style="zoom:66%;"><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250217102532540.png" alt="image-20250217102532540" style="zoom:57%;"></p><h3 id="运动学逆解"><a href="#运动学逆解" class="headerlink" title="运动学逆解"></a>运动学逆解</h3><p>通过足端轨迹生成足端的x,y坐标，然后运动学逆解得到两个关节电机对应旋转的角度即可控制足端实现预定轨迹。</p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250215223609895.png" alt="image-20250215223609895" style="zoom:80%;"><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250215223832155.png" alt="image-20250215223832155" style="zoom:72%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入足端坐标x_1,y_1，输出关节电机角度thet_rad1,thet_rad2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nijie</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//asin acos返回角度为弧度制</span></span><br><span class="line">    l = <span class="built_in">sqrt</span>(x_1 * x_1 + y_1 * y_1);</span><br><span class="line">    psi = <span class="built_in">asin</span>(x_1 / l);</span><br><span class="line">    phi = <span class="built_in">acos</span>((l * l + l_1 * l_1 - l_2 * l_2) / (<span class="number">2</span> * l * l_1));</span><br><span class="line">    thet_rad1 = phi - psi;</span><br><span class="line">    thet_rad2 = phi + psi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单腿摆线足端轨迹代码实现"><a href="#单腿摆线足端轨迹代码实现" class="headerlink" title="单腿摆线足端轨迹代码实现"></a>单腿摆线足端轨迹代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;webots/robot.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;webots/motor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_STEP 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> timestep;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T_s = <span class="number">1</span>;<span class="comment">//周期</span></span><br><span class="line"><span class="type">float</span> fai = <span class="number">0.5</span>;<span class="comment">//支撑相占空比</span></span><br><span class="line"><span class="type">float</span> t=<span class="number">0.0</span>;<span class="comment">//离散时刻 每个t对应一个足端坐标点 通过调节每个循环中加的speed的大小可以改变步频</span></span><br><span class="line"><span class="type">float</span> speed=<span class="number">0.01</span>;<span class="comment">//步频调节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*摆线足端轨迹参数*/</span></span><br><span class="line"><span class="type">float</span> xs=<span class="number">-40</span>;<span class="comment">//摆动相起点坐标</span></span><br><span class="line"><span class="type">float</span> xf=<span class="number">40</span>;<span class="comment">//摆动相终点坐标</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> height=<span class="number">-75</span>;<span class="comment">//支撑相关节电机期望离地高度 关节电机为坐标原点，故为负</span></span><br><span class="line"><span class="type">float</span> h=<span class="number">30</span>;<span class="comment">//摆线顶点高度，需满足h=2a=(xf-xs)/pi，不是任意赋值，否则不是摆线</span></span><br><span class="line"><span class="type">float</span> zep = <span class="number">0.0</span>;   <span class="comment">// 摆线顶部高度h</span></span><br><span class="line"><span class="type">float</span> xep_b = <span class="number">0.0</span>; <span class="comment">// 摆动相x坐标</span></span><br><span class="line"><span class="type">float</span> xep_z = <span class="number">0.0</span>; <span class="comment">// 支撑相x坐标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//足端输出坐标，用于运动学逆解</span></span><br><span class="line"><span class="type">float</span> x_1, x_2, x_3, x_4; </span><br><span class="line"><span class="type">float</span> y_1, y_2, y_3, y_4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运动学逆解参数*/</span></span><br><span class="line"><span class="type">float</span> sigma=<span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> psi = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> phi = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> thet_rad1 = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> thet_rad2 = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> l = <span class="number">0.0</span>;    <span class="comment">// 虚拟腿长</span></span><br><span class="line"><span class="type">float</span> l_1 = <span class="number">40.0</span>; <span class="comment">// 大腿长</span></span><br><span class="line"><span class="type">float</span> l_2 = <span class="number">80.0</span>; <span class="comment">// 小腿长</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trot</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; T_s * fai)<span class="comment">//支撑相</span></span><br><span class="line">    &#123;</span><br><span class="line">        sigma = <span class="number">2</span> * pi * t / (fai * T_s);</span><br><span class="line">        zep = h * (<span class="number">1</span> - <span class="built_in">cos</span>(sigma)) / <span class="number">2</span>;                             <span class="comment">// t时刻足端在摆线坐标系里的高度</span></span><br><span class="line">        xep_b = (xf - xs) * ((sigma - <span class="built_in">sin</span>(sigma)) / (<span class="number">2</span> * pi)) + xs; <span class="comment">// 摆动相x坐标</span></span><br><span class="line">        xep_z = (xs - xf) * ((sigma - <span class="built_in">sin</span>(sigma)) / (<span class="number">2</span> * pi)) + xf; <span class="comment">// 支撑相x坐标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出x</span></span><br><span class="line">        x_1 = xep_z; </span><br><span class="line">        <span class="comment">// 输出y</span></span><br><span class="line">        y_1 =<span class="number">0</span>+height;<span class="comment">//height为支撑相时期望的关节电机的离地高度（关节电机为坐标系原点），+0是因为此时足端在支撑相，触地。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((t &gt; T_s * fai) &amp;&amp; (t &lt;= T_s))<span class="comment">//摆动相</span></span><br><span class="line">    &#123;</span><br><span class="line">        sigma = <span class="number">2</span> * pi * (t-fai*T_s) / (fai * T_s);</span><br><span class="line">        zep = h * (<span class="number">1</span> - <span class="built_in">cos</span>(sigma)) / <span class="number">2</span>; </span><br><span class="line">        xep_b = (xf - xs) * ((sigma - <span class="built_in">sin</span>(sigma)) / (<span class="number">2</span> * pi)) + xs; <span class="comment">// 摆动相x坐标</span></span><br><span class="line">        xep_z = (xs - xf) * ((sigma - <span class="built_in">sin</span>(sigma)) / (<span class="number">2</span> * pi)) + xf; <span class="comment">// 支撑相x坐标</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 输出x</span></span><br><span class="line">        x_1 = xep_b; </span><br><span class="line">        <span class="comment">// 输出y</span></span><br><span class="line">        y_1 = zep+height; <span class="comment">//+zep是在摆动相足端抬起后该时刻足端距离关节电机的距离</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">nijie</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//asin acos返回角度为弧度制</span></span><br><span class="line">    l = <span class="built_in">sqrt</span>(x_1 * x_1 + y_1 * y_1);</span><br><span class="line">    psi = <span class="built_in">asin</span>(x_1 / l);</span><br><span class="line">    phi = <span class="built_in">acos</span>((l * l + l_1 * l_1 - l_2 * l_2) / (<span class="number">2</span> * l * l_1));</span><br><span class="line">    thet_rad1 = phi - psi;</span><br><span class="line">    thet_rad2 = phi + psi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    wb_robot_init();</span><br><span class="line"></span><br><span class="line">    WbDeviceTag Motor1 = wb_robot_get_device(<span class="string">&quot;motor1&quot;</span>);</span><br><span class="line">    WbDeviceTag Motor2 = wb_robot_get_device(<span class="string">&quot;motor2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    timestep=wb_robot_get_basic_time_step();</span><br><span class="line">    <span class="keyword">while</span> (wb_robot_step(timestep) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (t &lt;= <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            trot();<span class="comment">//摆线足端轨迹规划 输出足端坐标</span></span><br><span class="line">            nijie();<span class="comment">//运动学逆解 输入足端坐标 输出电机转动角度</span></span><br><span class="line">            wb_motor_set_position(Motor1, <span class="number">1.57</span>-thet_rad1); <span class="comment">//控制关节电机1旋转 1.57是两大腿平行时motor1的初始位置 90°</span></span><br><span class="line">            wb_motor_set_position(Motor2, <span class="number">-1.57</span>+thet_rad2);<span class="comment">//控制关节电机2旋转 -1.57是两大腿平行时motor2的初始位置 -90°</span></span><br><span class="line">            wb_robot_step(<span class="number">15</span>);</span><br><span class="line">            t += speed;<span class="comment">//控制步频</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    wb_robot_cleanup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webots仿真步长"><a href="#webots仿真步长" class="headerlink" title="webots仿真步长"></a>webots仿真步长</h2><p>在 <strong>Webots</strong> 中，**<code>basicTimeStep</code>** 和 <strong><code>wb_robot_step(time_step)</code></strong> 中的 <strong><code>time_step</code></strong> 是两个密切相关的重要概念。它们共同决定了仿真的时间步长和运行方式。</p><hr><ol><li><strong><code>basicTimeStep</code></strong> 的作用</li></ol><ul><li><strong><code>basicTimeStep</code></strong> 是在 Webots 世界文件（<code>.wbt</code>）中定义的一个全局参数。</li><li>它表示仿真的<strong>基本时间步长</strong>，单位为<strong>毫秒（ms）</strong>。</li><li>这个参数决定了仿真引擎更新物理世界和传感器数据的频率。</li><li>Webots 中的传感器（如摄像头、距离传感器、IMU 等）数据更新频率与 <code>basicTimeStep</code> 直接相关。</li></ul><p>示例：</p><p>在 <code>.wbt</code> 文件中，你可能会看到如下定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WorldInfo &#123;</span><br><span class="line">  basicTimeStep 16</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里的 <code>basicTimeStep</code> 设置为 <strong>16 毫秒</strong>，意味着仿真引擎每 <strong>16 毫秒</strong> 更新一次物理世界和传感器数据。</li></ul><hr><ol start="2"><li><strong><code>wb_robot_step(time_step)</code></strong> 的作用</li></ol><ul><li><strong><code>wb_robot_step(time_step)</code></strong> 是 Webots 控制器程序中的一个函数调用。</li><li>它的作用是<strong>推进仿真时间</strong>，并更新仿真状态（例如传感器数据、物理引擎等）。</li><li>参数 <strong><code>time_step</code></strong> 表示控制器希望仿真推进的时间步长，单位也是<strong>毫秒（ms）</strong>。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb_robot_step(32);</span><br></pre></td></tr></table></figure><ul><li>这行代码会让仿真时间向前推进 <strong>32 毫秒</strong>。</li></ul><hr><ol start="3"><li><strong><code>basicTimeStep</code> 和 <code>time_step</code> 的关系</strong></li></ol><ul><li><strong><code>basicTimeStep</code></strong> 是仿真引擎的最小时间单位，而 <strong><code>time_step</code></strong> 是控制器调用 <code>wb_robot_step</code> 时指定的时间步长。</li><li><strong><code>time_step</code></strong> 必须是 <strong><code>basicTimeStep</code></strong> 的整数倍。也就是说，<code>time_step = n * basicTimeStep</code>，其中 <code>n</code> 是一个正整数。<ul><li>如果 <code>time_step</code> 不是 <code>basicTimeStep</code> 的整数倍，Webots 会自动将其调整为最接近的整数倍值。</li></ul></li><li>每次调用 <code>wb_robot_step(time_step)</code>，仿真引擎会执行 <code>n</code> 次内部更新（每次更新 <code>basicTimeStep</code> 毫秒）。</li></ul><p>示例：</p><ul><li>如果 <code>basicTimeStep = 16</code>，而 <code>time_step = 32</code>：<ul><li>Webots 会执行 <strong>2 次</strong>内部更新（因为 32&#x3D;2×1632&#x3D;2×16）。</li></ul></li><li>如果 <code>basicTimeStep = 16</code>，而 <code>time_step = 50</code>：<ul><li>Webots 会将 <code>time_step</code> 调整为 <strong>48</strong>（因为 48&#x3D;3×1648&#x3D;3×16），并执行 <strong>3 次</strong>内部更新。</li></ul></li></ul><hr><ol start="4"><li><strong>为什么需要 <code>basicTimeStep</code> 和 <code>time_step</code> 的配合？</strong></li></ol><ul><li><strong><code>basicTimeStep</code></strong> 决定了仿真的精度和性能：<ul><li>较小的 <code>basicTimeStep</code> 会提高仿真精度，但会增加计算量，降低仿真速度。</li><li>较大的 <code>basicTimeStep</code> 会加快仿真速度，但可能会降低仿真精度。</li></ul></li><li><strong><code>time_step</code></strong> 决定了控制器的更新频率：<ul><li>较小的 <code>time_step</code> 会让控制器更频繁地更新，适合需要高实时性的场景。</li><li>较大的 <code>time_step</code> 会减少控制器的更新频率，适合计算量较大的控制器。</li></ul></li></ul><hr><ol start="5"><li><strong>实际应用中的建议</strong></li></ol><ul><li>在 Webots 中，通常会将 <code>time_step</code> 设置为与 <code>basicTimeStep</code> 相同的值，以确保仿真和控制器的同步。</li><li>例如：<ul><li>如果 <code>basicTimeStep = 16</code>，则通常设置 <code>time_step = 16</code>。</li><li>这样可以确保每次调用 <code>wb_robot_step</code> 时，仿真引擎只执行一次内部更新。</li></ul></li></ul><hr><p>总结</p><ul><li><strong><code>basicTimeStep</code></strong> 是仿真引擎的最小时间单位，定义在 <code>.wbt</code> 文件中。</li><li><strong><code>time_step</code></strong> 是控制器调用 <code>wb_robot_step</code> 时指定的时间步长，必须是 <code>basicTimeStep</code> 的整数倍。</li><li>两者共同决定了仿真的精度、性能和控制器更新频率。通常建议将 <code>time_step</code> 设置为与 <code>basicTimeStep</code> 相同的值。</li></ul><h2 id="步态规划"><a href="#步态规划" class="headerlink" title="步态规划"></a>步态规划</h2><p>​步态就是描述动物走路特点的一种<strong>周期性</strong>现象。</p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250217193908989.png" alt="image-20250217193908989" style="zoom:50%;"><h3 id="占空比和相位"><a href="#占空比和相位" class="headerlink" title="占空比和相位"></a>占空比和相位</h3><p>​占空比即每条腿在一个周期内支撑相和摆动相所占的比例，进而用来确定每个时刻，应该有几条腿着地，几条腿悬空；相位用来确定这四条腿运动的先后顺序，也就是时序，只有按照这个先后顺序，机械狗才能做出正确的步态，不然就会非常的混乱。</p><h3 id="trot步态"><a href="#trot步态" class="headerlink" title="trot步态"></a>trot步态</h3><p>​摆动相和支撑相各占一半时间，任意时刻下都有两条腿触地，并且这两条腿分布在机身的对角线方向。</p><p>​                                   <img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250217230254398.png" alt="image-20250217230254398" style="zoom:60%;"><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250217230308193.png" alt="image-20250217230308193" style="zoom:45%;"></p><p>第一步 方程转化为代码</p><p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250217195253545.png" alt="image-20250217195253545"></p><p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250217195314021.png" alt="  "></p><p>第二步 做出状态切换</p><p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250217200255318.png" alt="image-20250217200255318"></p><p>第三步 向电机输出对应的两种步态状态</p><p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250217203356862.png" alt="image-20250217203356862"></p><p>第四步 得到完整的TROT步态程序</p><p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250217204739449.png" alt="image-20250217204739449"></p><p>webots仿真：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;webots/robot.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;webots/motor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;webots/keyboard.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;webots/inertial_unit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gaitz.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hardware.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_STEP 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> --</span></span><br><span class="line"><span class="comment"> 21</span></span><br><span class="line"><span class="comment"> 34</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;START&quot;</span>);</span><br><span class="line">    wb_robot_init();</span><br><span class="line">    <span class="comment">//Dog_Init();</span></span><br><span class="line">    hardwareInit();</span><br><span class="line">    pid_Init();</span><br><span class="line">    posInit();</span><br><span class="line">    <span class="keyword">while</span> (wb_robot_step(<span class="number">16</span>) != <span class="number">-1</span>)<span class="comment">//1</span></span><br><span class="line">    &#123;</span><br><span class="line">      t = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (t &lt;= <span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        values=wb_inertial_unit_get_roll_pitch_yaw(imu);</span><br><span class="line">        trot();</span><br><span class="line">        nijie();</span><br><span class="line">        execute();</span><br><span class="line">        wb_robot_step(<span class="number">20</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;angle:%f Yaw:%f\r\n&quot;</span>,angle,values[<span class="number">2</span>]);</span><br><span class="line">        t += <span class="number">0.01</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wb_robot_cleanup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GAITZ_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GAITZ_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;webots/robot.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hardware.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_STEP 32</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag1=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> T_s = <span class="number">1</span>;</span><br><span class="line"><span class="type">float</span> fai = <span class="number">0.5</span>;</span><br><span class="line"><span class="type">int</span> timestep;</span><br><span class="line"><span class="type">float</span> t = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> sigma = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> psi_rf = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> phi_rf = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> psi_lf = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> phi_lf = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> psi_rb = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> phi_rb = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> psi_lb = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> phi_lb = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> thet_rad1_rf = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> thet_rad2_rf = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> thet_rad1_rb = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> thet_rad2_rb = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> thet_rad1_lf = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> thet_rad2_lf = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> thet_rad1_lb = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> thet_rad2_lb = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> x_rf, x_lf, x_rb, x_lb; <span class="comment">// 最终坐标</span></span><br><span class="line"><span class="type">float</span> y_rf, y_lf, y_rb, y_lb;</span><br><span class="line"><span class="comment">//****************************</span></span><br><span class="line"><span class="type">float</span> height = <span class="number">-19</span>;<span class="comment">//22</span></span><br><span class="line"><span class="type">float</span> h =<span class="number">9</span>;<span class="comment">//11</span></span><br><span class="line"><span class="type">float</span> zep = <span class="number">0.0</span>;   <span class="comment">// 摆线顶部高度h</span></span><br><span class="line"><span class="type">float</span> xep_b = <span class="number">0.0</span>; <span class="comment">// 摆动相x坐标</span></span><br><span class="line"><span class="type">float</span> xep_z = <span class="number">0.0</span>; <span class="comment">// 支撑相x坐标</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> l_rf = <span class="number">0.0</span>; <span class="comment">// 虚拟腿长</span></span><br><span class="line"><span class="type">float</span> l_lf = <span class="number">0.0</span>; <span class="comment">// 虚拟腿长</span></span><br><span class="line"><span class="type">float</span> l_rb = <span class="number">0.0</span>; <span class="comment">// 虚拟腿长</span></span><br><span class="line"><span class="type">float</span> l_lb = <span class="number">0.0</span>; <span class="comment">// 虚拟腿长</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> l_1 = <span class="number">10.0</span>; <span class="comment">// 大腿长</span></span><br><span class="line"><span class="type">float</span> l_2 = <span class="number">20.0</span>; <span class="comment">// 小腿长</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> xs = <span class="number">-10</span>;<span class="comment">//-6</span></span><br><span class="line"><span class="type">float</span> xf = <span class="number">10</span>;<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*控制trot状态</span></span><br><span class="line"><span class="comment">前进 r1=1 r2=1 r3=1 r4=1</span></span><br><span class="line"><span class="comment">后退 r1=-1 r2=-1 r3=-1 r4=-1</span></span><br><span class="line"><span class="comment">逆时针转向 r1=1 r2=-1 r3=-1 r4=1</span></span><br><span class="line"><span class="comment">顺时针转向 r1=-1 r2=1 r3=1 r4=-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> r1=<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> r2=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> r3=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> r4=<span class="number">-1</span>;</span><br><span class="line"><span class="comment">//****************************</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trot</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; T_s * fai)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//摆线足端轨迹规划</span></span><br><span class="line">        sigma = <span class="number">2</span> * pi * t / (fai * T_s);</span><br><span class="line">        zep = h * (<span class="number">1</span> - <span class="built_in">cos</span>(sigma)) / <span class="number">2</span>;                             <span class="comment">// y方向坐标</span></span><br><span class="line">        xep_b = (xf - xs) * ((sigma - <span class="built_in">sin</span>(sigma)) / (<span class="number">2</span> * pi)) + xs; <span class="comment">// 摆动相x坐标</span></span><br><span class="line">        xep_z = (xs - xf) * ((sigma - <span class="built_in">sin</span>(sigma)) / (<span class="number">2</span> * pi)) + xf; <span class="comment">// 支撑相x坐标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出x</span></span><br><span class="line">        x_rf = xep_z*r1; </span><br><span class="line">        x_lf = xep_b*r2;</span><br><span class="line">        x_lb = xep_z*r3;</span><br><span class="line">        x_rb = xep_b*r4;</span><br><span class="line">        <span class="comment">// 输出y</span></span><br><span class="line">        y_rf = <span class="number">0</span> + height;</span><br><span class="line">        y_lf = zep + height;</span><br><span class="line">        y_lb = <span class="number">0</span> + height;</span><br><span class="line">        y_rb = zep + height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((t &gt; T_s * fai) &amp;&amp; (t &lt;= T_s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//摆线足端轨迹规划</span></span><br><span class="line">        sigma = <span class="number">2</span> * pi * (t - fai * T_s) / (fai * T_s);</span><br><span class="line">        zep = h * (<span class="number">1</span> - <span class="built_in">cos</span>(sigma)) / <span class="number">2</span>;</span><br><span class="line">        xep_b = (xf - xs) * ((sigma - <span class="built_in">sin</span>(sigma)) / (<span class="number">2</span> * pi)) + xs; <span class="comment">// 摆动相x坐标</span></span><br><span class="line">        xep_z = (xs - xf) * ((sigma - <span class="built_in">sin</span>(sigma)) / (<span class="number">2</span> * pi)) + xf; <span class="comment">// 支撑相x坐标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出x</span></span><br><span class="line">        x_rf = xep_z*r1; </span><br><span class="line">        x_lf = xep_b*r2;</span><br><span class="line">        x_lb = xep_z*r3;</span><br><span class="line">        x_rb = xep_b*r4;</span><br><span class="line">        <span class="comment">// 输出y</span></span><br><span class="line">        y_rf = zep + height; <span class="comment">// 摆动</span></span><br><span class="line">        y_lf = <span class="number">0</span> + height;</span><br><span class="line">        y_lb = zep + height;</span><br><span class="line">        y_rb = <span class="number">0</span> + height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pace步态"><a href="#pace步态" class="headerlink" title="pace步态"></a>pace步态</h3><p>​                                        <img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250217222552574.png" alt="image-20250217222552574" style="zoom:64%;"><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250217222801646.png" alt="image-20250217222801646"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pace</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; T_s * fai)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//摆线足端轨迹规划</span></span><br><span class="line">        sigma = <span class="number">2</span> * pi * t / (fai * T_s);</span><br><span class="line">        zep = h * (<span class="number">1</span> - <span class="built_in">cos</span>(sigma)) / <span class="number">2</span>;                             <span class="comment">// y方向坐标</span></span><br><span class="line">        xep_b = (xf - xs) * ((sigma - <span class="built_in">sin</span>(sigma)) / (<span class="number">2</span> * pi)) + xs; <span class="comment">// 摆动相x坐标</span></span><br><span class="line">        xep_z = (xs - xf) * ((sigma - <span class="built_in">sin</span>(sigma)) / (<span class="number">2</span> * pi)) + xf; <span class="comment">// 支撑相x坐标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出x</span></span><br><span class="line">        x_rf = xep_z; </span><br><span class="line">        x_lf = xep_b;</span><br><span class="line">        x_lb = xep_b;</span><br><span class="line">        x_rb = xep_z;</span><br><span class="line">        <span class="comment">// 输出y</span></span><br><span class="line">        y_rf = <span class="number">0</span> + height;</span><br><span class="line">        y_lf = zep + height;</span><br><span class="line">        y_lb = zep + height;</span><br><span class="line">        y_rb = <span class="number">0</span> + height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((t &gt; T_s * fai) &amp;&amp; (t &lt;= T_s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//摆线足端轨迹规划</span></span><br><span class="line">        sigma = <span class="number">2</span> * pi * (t - fai * T_s) / (fai * T_s);</span><br><span class="line">        zep = h * (<span class="number">1</span> - <span class="built_in">cos</span>(sigma)) / <span class="number">2</span>;</span><br><span class="line">        xep_b = (xf - xs) * ((sigma - <span class="built_in">sin</span>(sigma)) / (<span class="number">2</span> * pi)) + xs; <span class="comment">// 摆动相x坐标</span></span><br><span class="line">        xep_z = (xs - xf) * ((sigma - <span class="built_in">sin</span>(sigma)) / (<span class="number">2</span> * pi)) + xf; <span class="comment">// 支撑相x坐标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出x</span></span><br><span class="line">        x_rf = xep_b;</span><br><span class="line">        x_lf = xep_z;</span><br><span class="line">        x_lb = xep_z;</span><br><span class="line">        x_rb = xep_b;</span><br><span class="line">        <span class="comment">// 输出y</span></span><br><span class="line">        y_rf = zep + height; </span><br><span class="line">        y_lf = <span class="number">0</span> + height;</span><br><span class="line">        y_lb = <span class="number">0</span> + height;</span><br><span class="line">        y_rb = zep + height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="walk步态"><a href="#walk步态" class="headerlink" title="walk步态"></a>walk步态</h3><p>​Walk步态是一种静态步态，即在运动过程中始终有三条腿处于支撑相，至多只有一条腿处于摆动相</p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250218160542915.png" alt="image-20250218160542915" style="zoom:67%;"><p>待开发,涉及到相位偏差,后面等把webots程序改成FSM模式后再补……可以先看程序框架里的部分内容有举例。</p><h3 id="转向步态"><a href="#转向步态" class="headerlink" title="转向步态"></a>转向步态</h3><p>​利用<strong>差速</strong>原理，本质还是trot步态，即一对对角腿在支撑相时另一对对角腿在摆动相，只不过腿运动方向相反。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*控制trot状态</span></span><br><span class="line"><span class="comment">前进 r1=1 r2=1 r3=1 r4=1</span></span><br><span class="line"><span class="comment">后退 r1=-1 r2=-1 r3=-1 r4=-1</span></span><br><span class="line"><span class="comment">逆时针转向 r1=1 r2=-1 r3=-1 r4=1</span></span><br><span class="line"><span class="comment">顺时针转向 r1=-1 r2=1 r3=1 r4=-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">x_rf = xep_z*r1; </span><br><span class="line">x_lf = xep_b*r2;</span><br><span class="line">x_lb = xep_z*r3;</span><br><span class="line">x_rb = xep_b*r4;</span><br></pre></td></tr></table></figure><h2 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h2><p>参考MIT_CHEETAH开源框架，使用FSM状态机。</p><p>首先是main.c文件，while循环只在干一件事情，就是循环执行Dog_Run函数</p><p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250218105920338.png" alt="image-20250218105920338"></p><p>Dog_Run函数如下所示</p><p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250218105942567.png" alt="image-20250218105942567"></p><p>以下所有程序在Dog_Run函数中循环运行</p><p>进入FSM_Run后，切换步态，以trot步态为例，首先进入enter函数，通过Dog_SetPeriod函数设置周期(dog.period)和支撑相摆动相在周期所占的比例(dog.stRatio,dog.swRatio)，设置global.isWalking为1表示机器人正在行走，开始进行步态规划，计算摆线足端轨迹。</p><p>global.bias代表各个腿运动的时序关系</p><p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250218110020203.png" alt="image-20250218110020203"></p><p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250218110234356.png" alt="image-20250218110234356"></p><p>首先进行相位计算，用for循环依次计算每条腿的相位，如果normalT&lt;dog.stRatio,说明在支撑相，global.contact[i]&#x3D;1,反之在摆动相</p><p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250218110059359.png" alt="image-20250218110059359"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确保结果始终在 [0, dog.period) 范围内，即使 global.runTime 很大。</span></span><br><span class="line"><span class="comment">////normalT 是归一化的时间，表示当前时间在步态周期中的位置</span></span><br><span class="line"><span class="type">float</span> normalT = <span class="built_in">fmod</span>(global.runTime + dog.period * global.bias[i], dog.period) / dog.period;</span><br><span class="line">以walk步态为例:</span><br><span class="line">global.runtime=<span class="number">0</span> </span><br><span class="line">第一条腿：normalT=(<span class="number">0</span>+<span class="number">0.0</span>)%<span class="number">1</span>/<span class="number">1</span>=<span class="number">0</span>      下一时刻<span class="number">0.01</span>&lt;dog.stRatio     支撑相 相位 <span class="number">0.01</span>/dog.stRatio</span><br><span class="line">第二条腿：normalT=(<span class="number">0</span>+<span class="number">0.25</span>)%<span class="number">1</span>/<span class="number">1</span>=<span class="number">0.25</span>  下一时刻<span class="number">0.26</span>&lt;dog.stRatio     支撑相 相位 <span class="number">0.26</span>/dog.stRatio</span><br><span class="line">第三条腿：normalT=(<span class="number">0</span>+<span class="number">0.50</span>)%<span class="number">1</span>/<span class="number">1</span>=<span class="number">0.5</span>   下一时刻<span class="number">0.51</span>&lt;dog.stRatio     支撑相 相位 <span class="number">0.51</span>/dog.stRatio</span><br><span class="line">第四条腿：normalT=(<span class="number">0</span>+<span class="number">0.75</span>)%<span class="number">1</span>/<span class="number">1</span>=<span class="number">0.75</span>  下一时刻<span class="number">0.76</span>&gt;dog.stRatio     摆动相 相位 (<span class="number">0.76</span>-dog.stRatio)/dog.swRatio</span><br><span class="line"></span><br><span class="line"><span class="comment">//x和y是要计算模的两个浮点数，函数返回值为x除以y的余数（double）。</span></span><br><span class="line"><span class="type">double</span> <span class="built_in">fmod</span>(<span class="type">double</span> x, <span class="type">double</span> y);</span><br></pre></td></tr></table></figure><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250218194553507.png" alt="image-20250218194553507" style="zoom:50%;"><p>根据当前相位计算摆线轨迹，p即前面我们方程里的sigma</p><p>sigma &#x3D; 2 * pi * t &#x2F; (fai * T_s);</p><p>sigma &#x3D; 2 * pi * (t - fai * T_s) &#x2F; (fai * T_s);</p><p><img src="/2025/02/15/%E5%B9%B6%E8%81%94%E5%9B%9B%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20250218110133037.png" alt="image-20250218110133037"></p>]]></content>
      
      
      <categories>
          
          <category> 机器人学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 四足机器人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电机控制</title>
      <link href="/2025/01/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/"/>
      <url>/2025/01/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="概念扫盲"><a href="#概念扫盲" class="headerlink" title="概念扫盲"></a>概念扫盲</h1><p>BLDC（Brushless DC Motor，无刷直流电机）、PMSM（Permanent Magnet Synchronous Motor，永磁同步电机）和FOC（Field-Oriented Control，磁场定向控制。BLDC和PMSM是两种不同的电机，它们的相同点都是无刷的，不同点在于反电动势电压的形状，BLDC通常用方波电流驱动，PMSM通常采用正弦波电流驱动，FOC作为一种控制方法，可用于驱动BLDC和PMSM。</p><table><thead><tr><th>特性</th><th>BLDC</th><th>PMSM</th><th>FOC（控制策略）</th></tr></thead><tbody><tr><td><strong>电机类型</strong></td><td>无刷直流电机</td><td>永磁同步电机</td><td>控制策略（适用于BLDC和PMSM）</td></tr><tr><td><strong>驱动方式</strong></td><td>方波驱动</td><td>正弦波驱动</td><td>磁场定向控制</td></tr><tr><td><strong>控制精度</strong></td><td>较低</td><td>较高</td><td>高</td></tr><tr><td><strong>转矩波动</strong></td><td>较大</td><td>较小</td><td>极小</td></tr><tr><td><strong>应用场景</strong></td><td>低成本、高速应用</td><td>高性能、高精度应用</td><td>高性能、高精度控制</td></tr></tbody></table><h1 id="BLDC"><a href="#BLDC" class="headerlink" title="BLDC"></a>BLDC</h1><img src="/2025/01/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/image-20250124121336052.png" alt="image-20250124121336052" style="zoom:50%;"><h2 id="有刷VS无刷"><a href="#有刷VS无刷" class="headerlink" title="有刷VS无刷"></a>有刷VS无刷</h2><p>对于有刷电机的驱动方式，通过使直流电通过线圈绕组，得到一个具有磁极的电磁铁，磁极随后与永磁体的磁极相互作用，使转子旋转</p><p><img src="/2025/01/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/image-20250124003923690.png" alt="image-20250124003923690"></p><p>在转子每旋转半圈后</p><p><img src="/2025/01/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/image-20250124004101659.png" alt="image-20250124004101659"></p><p>要使转子一直旋转，我们需要翻转电磁铁的磁极，通过切换线圈绕组中电流的极性实现，这种相位转换成为换向</p><p><img src="/2025/01/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/image-20250124004019961.png" alt="image-20250124004019961"></p><p>在有刷电机中，换向发生在电机旋转时电刷与转子换向器接触的机械位置，由于这种接触，电刷会随着时间的推移而发生磨损，进而影响电机的性能</p><img src="/2025/01/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/image-20250124004757347.png" alt="image-20250124004757347" style="zoom:70%;"><p>BLDC通过用<strong>电子换向代替机械换向</strong>克服有刷电机的缺点</p><p>​                               <img src="/2025/01/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/image-20250124005503307.png" alt="image-20250124005503307"></p><p>可以把BLDC看作是倒装的有刷电机，因为永磁体变为转子，线圈绕组变为了定子</p><p><img src="/2025/01/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/image-20250124094906195.png" alt="image-20250124094906195"></p><p>对于BLDC和PMSM，其不同在于<strong>反电动势</strong>电压的形状，电机被旋转时起到发电机的作用，意味着在定子中感应到反电动势电压，该电压与电机的驱动电压相反，反电动势是电机的一个重要特征，通过观察其形状我们知道电机的类型，决定我们使用什么类型的控制算法来控制电机（可以将一相接到电压表，然后用手旋转转子，相当于发电机，电压表波形即该电机的反电动势）</p><p><img src="/2025/01/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/image-20250124094850055.png" alt="image-20250124094850055"></p><h2 id="内部工作原理"><a href="#内部工作原理" class="headerlink" title="内部工作原理"></a>内部工作原理</h2><p>在A和C相之间施加电压，沿着虚线产生一个组合磁场</p><img src="/2025/01/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/image-20250124101354503.png" alt="image-20250124101354503" style="zoom:50%;"><p>转子的角度是相对水平轴测量的，有六种不同的转子对齐方式，每种方式彼此间隔60°，如果我们能够每隔60°对相位进行正确的换向，就可以使电机旋转起来，这称为<strong>六步换向&#x2F;梯形控制</strong></p><img src="/2025/01/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/image-20250124103000461.png" alt="image-20250124103000461" style="zoom:80%;"><p>随着极对的增加换向会更频繁的发生，为了适时以正确的相位进行正确的换向，我们需要知道转子的位置，通常使用<strong>霍尔传感器</strong>来测量转子位置</p><img src="/2025/01/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/image-20250124103731170.png" alt="image-20250124103731170" style="zoom:50%;"><p>​                                                                       <img src="/2025/01/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/image-20250124104036546.png" alt="image-20250124104036546" style="zoom:31%;"><img src="/2025/01/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/image-20250124104053450.png" alt="image-20250124104053450" style="zoom:30%;"></p><p>完成60°旋转后，就会发生下一步换向</p><p>​                                                                    <img src="/2025/01/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/image-20250124104532717.png" alt="image-20250124104532717" style="zoom:33%;"><img src="/2025/01/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/image-20250124104556021.png" alt="image-20250124104556021" style="zoom:33%;"></p><p>换向的发生方式是：<strong>转子永远不与定子磁场对齐，而是始终追逐它</strong>。 因为当转子和定子磁场完全对准时时，电机产生零扭矩，因此我们永远不会让它们对准，其次当磁场互成90°角时，会产生最大扭矩，在BLDC中，<strong>六步换向从未到达90°</strong>，且角度在一定范围内波动，造成这种情况的原因是梯形控制本身的特性，磁场定向控制等更先进的技术通常用于控制PMSM，可通过在定子磁场和转子磁场之间达到90°来产生更大的扭矩</p><p>为了控制六步换向的相位，使用<strong>三相逆变器</strong>将直流电源转换为三相电流，三相逆变器会转换恒定电压，以使电机保持恒定速度，要以不同的速度控制电机，必须调节施加的电压，一种方法是<strong>PWM</strong></p><p><img src="/2025/01/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/image-20250124105751476.png" alt="image-20250124105751476"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 电机控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCB设计_51</title>
      <link href="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/"/>
      <url>/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/</url>
      
        <content type="html"><![CDATA[<h1 id="电路分析基础"><a href="#电路分析基础" class="headerlink" title="电路分析基础"></a>电路分析基础</h1><h2 id="电阻"><a href="#电阻" class="headerlink" title="电阻"></a>电阻</h2><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119124627693.png" alt="image-20250119124627693"></p><p>插接电阻：</p><p>四条杠：前2条为电阻的大小数值 ，若第三条不为1，还要乘以相应的乘数才是实际的大小 23x1&#x3D;23Ω5%</p><p>五条杠：前3条为电阻的大小数值 470x0.1&#x3D;47Ω%1</p><p>贴片电阻：</p><p>三位：前2位为有效数字 第三位是10的n次幂 104&#x3D;10x10^4&#x3D;100k5%</p><p>四位： 前3位为有效数字，第4位表示10的n次幂 5112&#x3D;511x10^2&#x3D;51.1k1%</p><p>R010: 0.01Ω  R003: 0.003Ω</p><h2 id="电容"><a href="#电容" class="headerlink" title="电容"></a>电容</h2><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119140110670.png" alt="image-20250119140110670"></p><p>不耗电能，主要作用是储能和滤波。通交流，隔直流。</p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119140149174.png" alt="image-20250119140149174"></p><p>MLCC适合中高段滤波，钽电容和铝电解电容适合中低段滤波</p><p>有的电容有极性</p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119140434543.png" alt="image-20250119140434543"></p><p>电容封装上一般标有三条关键信息：容的容值，正负极性，耐压</p><h2 id="电感"><a href="#电感" class="headerlink" title="电感"></a>电感</h2><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119190029851.png" alt="image-20250119190029851"></p><p>不耗电能，而是将电能转化为磁能储存起来。通直流，隔交流。</p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119190343944.png" alt="image-20250119190343944"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119190506110.png" alt="image-20250119190506110"></p><h2 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h2><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119190604087.png" alt="image-20250119190604087"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119191350580.png" alt="image-20250119191350580"></p><p>二极管在导通时电压是有一定损耗的，即存在一个导通压降。当在电源接二极管防反接时要注意使用的二极管的导通压降越小越好，如肖特基二极管。</p><p>若正向电压低于死区电压，二极管处于截止状态，当在反向电压下，二极管有一个比较低的静态反向电流，若超过反向击穿电压，则二极管被击穿，反向电流猛然增大，同时反向击穿电流会遏制反向击穿电压的继续增大，有一个稳压的特性，稳压二极管就是工作在这个反向击穿区。</p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119192643366.png" alt="image-20250119192643366"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119193152441.png" alt="image-20250119193152441"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119193221200.png" alt="image-20250119193221200"></p><p>丝印对应的竖线位置都是二极管负极</p><h2 id="三极管"><a href="#三极管" class="headerlink" title="三极管"></a>三极管</h2><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119193328606.png" alt="image-20250119193328606"></p><p>作用是将微弱信号放大成幅值较大的信号，可放大电流，同时也可作为一种电子开关</p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119193628188.png" alt="image-20250119193628188"></p><p>区分PNP和NPN的小技巧：箭头指向是P指向N</p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119194712130.png" alt="image-20250119194712130"></p><p>集电极c与基极b间构成了一个PN结，叫集电结；发射极e与基极b间构成了一个PN结，叫发射结。</p><p>其余部分看模电书，看郑易慧老师的课</p><h3 id="输出特性曲线"><a href="#输出特性曲线" class="headerlink" title="输出特性曲线"></a>输出特性曲线</h3><p>分为截止区，放大区，饱和区</p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119195147944.png" alt="image-20250119195147944"></p><p>可参考水阀模型，ib越大，阀门开的越大，电流越大</p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119195346685.png" alt="image-20250119195346685"></p><p>当ib&#x3D;0，三极管处于截止状态，发射结和集电结反偏</p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119195826214.png" alt="image-20250119195826214"></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119200737777.png" alt="image-20250119200737777"></p><h2 id="元件数据手册"><a href="#元件数据手册" class="headerlink" title="元件数据手册"></a>元件数据手册</h2><p>找数据手册的方法：</p><p>1.直接上立创商城搜然后下载 2.<a href="https://www.semiee.com/">https://www.semiee.com/</a></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119211814256.png" alt="image-20250119211814256"></p><p>引脚配置和功能这节是非常重要的一部分</p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119205737504.png" alt="image-20250119205737504"></p><p>对于电气特性也要注意，注意我们设计的电路有没有突破电气特性表格的限制，若突破则要考虑换芯片&#x2F;电路设计</p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119210337702.png" alt="image-20250119210337702"></p><p>对于应用和实现这一部分的内容是非常关键的，主要是厂家给的一些示例电路</p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119211451565.png" alt="image-20250119211451565"></p><h2 id="电路原理"><a href="#电路原理" class="headerlink" title="电路原理"></a>电路原理</h2><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119213208974.png" alt="image-20250119213208974"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119213606047.png" alt="image-20250119213606047"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119213817010.png" alt="image-20250119213817010"><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119213919507.png" alt="image-20250119213919507"></p><h3 id="基尔霍夫定律"><a href="#基尔霍夫定律" class="headerlink" title="基尔霍夫定律"></a>基尔霍夫定律</h3><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119214036768.png" alt="image-20250119214036768"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119214215429.png" alt="image-20250119214215429"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119214415024.png" alt="image-20250119214415024"></p><h4 id="基尔霍夫电流定律（KCL）"><a href="#基尔霍夫电流定律（KCL）" class="headerlink" title="基尔霍夫电流定律（KCL）"></a>基尔霍夫电流定律（KCL）</h4><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119214532600.png" alt="image-20250119214532600"></p><p>推广：基尔霍夫定律不仅适用于单一节点，也适用于电路中保卫多个节点的任一闭合面 </p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119220419459.png" alt="image-20250119220419459"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119221227406.png" alt="image-20250119221227406"></p><p>列方程时我们是不知道电流实际方向的，需要自己先设参考反向，解出来是正的则与电流实际方向相同，反之相反。</p><h4 id="基尔霍夫电压定律（KVL）"><a href="#基尔霍夫电压定律（KVL）" class="headerlink" title="基尔霍夫电压定律（KVL）"></a>基尔霍夫电压定律（KVL）</h4><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119222900104.png" alt="image-20250119222900104"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119223101873.png" alt="image-20250119223101873"></p><h1 id><a href="#" class="headerlink" title></a><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119223242602.png" alt="image-20250119223242602"></h1><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119223324917.png" alt="image-20250119223324917"></p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250119223433118.png" alt="image-20250119223433118" style="zoom:50%;"><h2 id="读懂原理图"><a href="#读懂原理图" class="headerlink" title="读懂原理图"></a>读懂原理图</h2><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120095303886.png" alt="image-20250120095303886"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120095333327.png" alt="image-20250120095333327"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120095349490.png" alt="image-20250120095349490"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120095413063.png" alt="image-20250120095413063"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120095427299.png" alt="image-20250120095427299"></p><h1 id="PCB设计基础"><a href="#PCB设计基础" class="headerlink" title="PCB设计基础"></a>PCB设计基础</h1><h2 id="PCB结构与组成"><a href="#PCB结构与组成" class="headerlink" title="PCB结构与组成"></a>PCB结构与组成</h2><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120095629066.png" alt="image-20250120095629066"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120095650871.png" alt="image-20250120095650871"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120095805629.png" alt="image-20250120095805629"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120095845207.png" alt="image-20250120095845207"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120095956691.png" alt="image-20250120095956691"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120100037352.png" alt="image-20250120100037352"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120100134601.png" alt="image-20250120100134601"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120100151328.png" alt="image-20250120100151328"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120100302008.png" alt="image-20250120100302008"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120100353531.png" alt="image-20250120100353531"></p><h2 id="PCB叠层结构"><a href="#PCB叠层结构" class="headerlink" title="PCB叠层结构"></a>PCB叠层结构</h2><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120100851144.png" alt="image-20250120100851144"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120100910420.png" alt="image-20250120100910420"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120101026343.png" alt="image-20250120101026343"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120101115960.png" alt="image-20250120101115960"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120101148747.png" alt="image-20250120101148747"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120101235640.png" alt="image-20250120101235640"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120101627487.png" alt="image-20250120101627487"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120101716738.png" alt="image-20250120101716738"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120101749572.png" alt="image-20250120101749572"></p><h2 id="PCB设计流程"><a href="#PCB设计流程" class="headerlink" title="PCB设计流程"></a>PCB设计流程</h2><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120102935363.png" alt="image-20250120102935363"></p><h1 id="立创EDA软件使用"><a href="#立创EDA软件使用" class="headerlink" title="立创EDA软件使用"></a>立创EDA软件使用</h1><h2 id="元件符号绘制"><a href="#元件符号绘制" class="headerlink" title="元件符号绘制"></a>元件符号绘制</h2><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120122747276.png" alt="image-20250120122747276"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120122920739.png" alt="image-20250120122920739"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120123955664.png" alt="image-20250120123955664"></p><h2 id="元件封装绘制"><a href="#元件封装绘制" class="headerlink" title="元件封装绘制"></a>元件封装绘制</h2><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120124109774.png" alt="image-20250120124109774"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120190422088.png" alt="image-20250120190422088"></p><p>放置的焊盘中间是默认有过孔的，但L2358N是个表贴封装，所以要改一下焊盘属性，把它的图层改为顶层</p><p><a href="https://www.bilibili.com/video/BV1At421h7Ui?spm_id_from=333.788.player.switch&vd_source=a9d487fcf1a579639c6348eb5a9321db&p=17">https://www.bilibili.com/video/BV1At421h7Ui?spm_id_from=333.788.player.switch&amp;vd_source=a9d487fcf1a579639c6348eb5a9321db&amp;p=17</a></p><h1 id="51单片机最小系统板设计"><a href="#51单片机最小系统板设计" class="headerlink" title="51单片机最小系统板设计"></a>51单片机最小系统板设计</h1><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120193921848.png" alt="image-20250120193921848"></p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120195957673.png" alt="image-20250120195957673"></p><p>​                       <img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120200802973.png" alt="image-20250120200802973">   </p><p>​            <img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120201234889.png" alt="image-20250120201234889"></p><p> Typec</p><p><img src="/2025/01/18/PCB%E8%AE%BE%E8%AE%A1-51/image-20250120203722960.png" alt="image-20250120203722960"></p>]]></content>
      
      
      
        <tags>
            
            <tag> PCB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机学习笔记</title>
      <link href="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="51单片机学习笔记"><a href="#51单片机学习笔记" class="headerlink" title="51单片机学习笔记"></a><strong>51单片机学习笔记</strong></h1><h1 id="KEIL使用"><a href="#KEIL使用" class="headerlink" title="KEIL使用"></a>KEIL使用</h1><p>KEIL安装包及相关资源，视频教程见b站江科大视频</p><p><a href="https://pan.baidu.com/s/1Fao9VfrM67TIFeIsusnSIw?pwd=7rx1#list/path=%2F">https://pan.baidu.com/s/1Fao9VfrM67TIFeIsusnSIw?pwd=7rx1#list/path=%2F</a></p><h2 id="烧录代码（生成hex文件）"><a href="#烧录代码（生成hex文件）" class="headerlink" title="烧录代码（生成hex文件）"></a>烧录代码（生成hex文件）</h2><p>魔术棒-&gt;output-&gt;勾选create hex file（每次新建工程都要配置）</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/wps1.jpg" alt="wps1"></p><p>-&gt;编译，在object文件夹找到生成的hex文件(每次新建工程后要换成当前工程的文件夹，不然默认烧的是上个工程的hex文件)</p><p>-&gt;选择单片机型号为STC89C52RC 若选成STC89C52无法下载（用的普中的这个单片机丝印上写的有RC）</p><p>-&gt;单片机关机，点击下载程序，显示正在检测目标单片机后开机即可下载</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/wps2.jpg" alt="wps2"></p><p>当勾选左下角“当目标文件变化……”，我们在keil中编译后STC-ISP软件会自动发送下载指令，我们只需要对单片机断电，再次开机即可。</p><h2 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h2><p>​我们在使用Keil的时候编译器默认是使用ANSI进行编码的，在ANSI中对于英文是使用一个字节来表示，但是对于中文，在GB2312的编码中是利用两个字节来表示的，所以如果我们按一次backspace键在ANSI下只会删掉一个字节，所以出现乱码，因为中文还有一个字节没有删掉。</p><p>按此设置后输入中文不会出现乱码</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250110163500423.png" alt="image-20250110163500423"></p><h2 id="创建多文件"><a href="#创建多文件" class="headerlink" title="创建多文件"></a>创建多文件</h2><p><a href="https://www.bilibili.com/video/BV1RB4y1i71i?spm_id_from=333.788.videopod.episodes&vd_source=a9d487fcf1a579639c6348eb5a9321db&p=157">https://www.bilibili.com/video/BV1RB4y1i71i?spm_id_from=333.788.videopod.episodes&amp;vd_source=a9d487fcf1a579639c6348eb5a9321db&amp;p=157</a></p><h2 id="keil主题配置"><a href="#keil主题配置" class="headerlink" title="keil主题配置"></a>keil主题配置</h2><p>非常nice的一个主题配色</p><p><a href="https://blog.csdn.net/wsstony579/article/details/53128206">https://blog.csdn.net/wsstony579/article/details/53128206</a></p><h2 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h2><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111180622650.png" alt="image-20250111180622650" style="zoom:67%;"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111180601816.png" alt="image-20250111180601816" style="zoom:67%;"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111181343717.png" alt="image-20250111181343717" style="zoom:67%;"><p>1.新建文件夹</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111185458919.png" alt="image-20250111185458919"></p><p>2.在文件夹内新建.c .h文件</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111185543920.png" alt="image-20250111185543920"></p><p>3.添加.c文件</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111185623718.png" alt="image-20250111185623718"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111185646516.png" alt="image-20250111185646516"></p><p>4.将.h文件路径包含进去，否则编译器找不到</p><p>魔术棒-&gt;c51-&gt;Include Paths 添加.h存放位置</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111181210122.png" alt="image-20250111181210122"></p><p>5.在.c文件中包含对应.h，在.h里写如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H__</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250112202028899.png" alt="image-20250112202028899" style="zoom:80%;"><p>可以把一些固定的代码当作模板，后面需要用的时候直接双击即可，不用重复自己敲代码，提升效率。</p><h1 id="C51语言基础"><a href="#C51语言基础" class="headerlink" title="C51语言基础"></a>C51语言基础</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250110203426972.png" alt="image-20250110203426972" style="zoom:50%;"><h3 id="sfr-特殊功能寄存器"><a href="#sfr-特殊功能寄存器" class="headerlink" title="sfr(特殊功能寄存器)"></a>sfr(特殊功能寄存器)</h3><p>8051单片机的特殊功能寄存器分布在内部数据存储区的地址单元80H~FFH中。sfr数据类型占用一个内存单元（一个字节）。<strong>利用它可以访问单片机内部的所有特殊功能寄存器</strong>。eg”sfr P1&#x3D;0x90”定义了P1口在内部的寄存器中，在程序后续的语句中可以用”P1&#x3D;0xff”语句，使P1口的所有引脚输出为高电平，来操作特殊功能寄存器</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111124834310.png" alt="image-20250111124834310"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sfr P2 = <span class="number">0xA0</span>;</span><br><span class="line"><span class="comment">//将符号P2与地址0xA0关联起来,P2被定义为SFR,编译器会将其视为一个8位寄存器。然后当你在程序中写P2 = 0xfe;时，编译器会将这个操作翻译为：将值0xfe写入地址为0xA0的寄存器。</span></span><br></pre></td></tr></table></figure><p><strong>为什么<code>P2 = 0xfe;</code>能直接赋值</strong></p><ul><li>在C语言中，<code>P2</code>被定义为SFR，编译器会<strong>将其视为一个8位寄存器</strong>。</li><li>当你对<code>P2</code>赋值时，编译器会生成对应的机器指令，<strong>将值写入<code>0xA0</code>地址的寄存器</strong>。</li><li>硬件会根据写入的值，直接控制P2端口的状态。</li></ul><p><strong>赋值过程</strong></p><p>当你执行<code>P2 = 0xfe;</code>时，实际发生了以下过程：</p><ol><li>编译器处理：<ul><li>编译器知道<code>P2</code>对应地址<code>0xA0</code>，因此将<code>P2 = 0xfe;</code>翻译为：**将值<code>0xfe</code>写入地址<code>0xA0</code>**。</li></ul></li><li>硬件执行：<ul><li>单片机的硬件会将值<code>0xfe</code>（二进制<code>1111 1110</code>）写入P2端口的输出寄存器。</li><li>P2端口的每个引脚（P2.0到P2.7）会根据这个值设置电平状态：<ul><li><code>0</code>表示低电平。</li><li><code>1</code>表示高电平。</li></ul></li><li>因此，P2.0输出低电平，P2.1到P2.7输出高电平。</li></ul></li></ol><h3 id="sbit-特殊功能位"><a href="#sbit-特殊功能位" class="headerlink" title="sbit(特殊功能位)"></a>sbit(特殊功能位)</h3><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250110203141038.png" alt="image-20250110203141038"></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111124847597.png" alt="image-20250111124847597"></p><p>在8051系列单片机（如STC89C52）中：</p><ul><li><strong>SFR的地址</strong>是8位的，范围是<code>0x80</code>到<code>0xFF</code>。</li><li>每个SFR占用一个字节（8位），例如<code>P2</code>的地址是<code>0xA0</code>。</li><li><strong>位地址</strong>是对SFR的每一位单独寻址的地址。8051单片机支持位寻址，因此每个SFR的每一位都有一个独立的位地址</li><li><strong>SFR地址</strong>（如<code>0xA0</code>）是对整个8位寄存器的操作地址。</li><li><strong>位地址</strong>（如<code>0xA0</code>到<code>0xA7</code>）是对SFR中某一位的操作地址。</li></ul><p>eg:</p><p>字节操作（字节地址<code>0xA0</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P2 = <span class="number">0xfe</span>;  <span class="comment">// 将P2端口的8位设置为1111 1110</span></span><br></pre></td></tr></table></figure><ul><li>操作的是字节地址<code>0xA0</code>，影响整个<code>P2</code>端口。</li></ul><p>位操作（位地址<code>0xA0</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sbit P2_0 = P2^<span class="number">0</span>;  <span class="comment">// 定义P2.0的位地址</span></span><br><span class="line">P2_0 = <span class="number">0</span>;          <span class="comment">// 将P2.0设置为0</span></span><br></pre></td></tr></table></figure><ul><li>操作的是位地址<code>0xA0</code>，只影响<code>P2.0</code>这一位。</li><li>**字节地址<code>0xA0</code>**：用于操作整个<code>P2</code>端口的8位。</li><li>**位地址<code>0xA0</code>**：用于操作<code>P2</code>端口的第0位（P2.0）。</li><li>虽然它们的地址值相同，但它们的用途和操作对象完全不同。</li></ul><h3 id="位寻址"><a href="#位寻址" class="headerlink" title="位寻址"></a>位寻址</h3><p>可位寻址的寄存器可以对它的每一位单独赋值，不可位寻址的寄存器只能整体赋值</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250115193711698.png" alt="image-20250115193711698"></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250115193733687.png" alt="image-20250115193733687"></p><h2 id="数据运算"><a href="#数据运算" class="headerlink" title="数据运算"></a>数据运算</h2><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250110205733185.png" alt="image-20250110205733185" style="zoom:50%;"><p>123÷10&#x3D;12</p><p>123%10&#x3D;3     %取余可以用来判断一个数是否可被另一个数整除。</p><p>0011 1100&lt;&lt;1  -&gt;   0111 1000</p><p>0011 1100&gt;&gt;2  -&gt;   0000 1111</p><p>0001 1000&amp;0010 1010  -&gt;  0000 1000</p><p>0001 1000|0010 1010  -&gt;  0011 1010</p><p>0001 1000^0010 1010  -&gt;  0011 0010 相同取0 不同取1</p><p>~0001 1000 -&gt;  1110 0111</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM0_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD&amp;=<span class="number">0xF0</span>;<span class="comment">//1111 0000 高4位为T1，保持不变，低4位为T0，清0</span></span><br><span class="line">    TMOD|=<span class="number">0x01</span>;<span class="comment">//0000 0001 选择为定时器0模式，工作方式1，使用或运算可以不干扰高四位</span></span><br><span class="line">    </span><br><span class="line">    TH0=<span class="number">0xFC</span>;<span class="comment">//给定时器赋初值，定时1ms</span></span><br><span class="line">    TL0=<span class="number">0x18</span>;</span><br><span class="line">    </span><br><span class="line">    ET0=<span class="number">1</span>;<span class="comment">//打开定时器0中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">    </span><br><span class="line">    TR0=<span class="number">1</span>;<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h3><p>在c语言中，尤其是单片机的<a href="https://so.csdn.net/so/search?q=C51&spm=1001.2101.3001.7020">C51</a>中，移位运算操作很常见。实现移位操作的方法有两种：一是利用<strong>移位运算符</strong>，二是利用<strong>移位函数</strong>。</p><p>区别：</p><p>1.移位运算符，是系统内置的运算操作，编译编译不用包含相关头文件；而移位函数编译要包含<strong>intrins.h</strong>头文件。</p><p>2.&lt;&lt;和&gt;&gt;的移位规则数据从一端移动到另外一端，数据尾部移走后会补0，数据头部移到最前端后会<strong>溢出</strong>，溢出的数据就<strong>被抹掉</strong>了。<br> _crol_等函数是是循环移位，<strong>首位相接</strong>，数据前端移动到尾部后，会从尾部再次进入队列，数据<strong>不会溢出</strong>。运算符是<strong>线性队列</strong>，循环移位函数是<strong>环形队列</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> _crol_ (</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> c,        <span class="comment">/* 要被进行 位左移 的形式参数 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> b);       <span class="comment">/* 要进行的 位移数 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250110213906743.png" alt="image-20250110213906743"></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111110451884.png" alt="image-20250111110451884"></p><h2 id="子函数"><a href="#子函数" class="headerlink" title="子函数"></a>子函数</h2><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111110533229.png" alt="image-20250111110533229"></p><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111181442588.png" alt="image-20250111181442588" style="zoom:67%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REG52.H&gt;</span><span class="comment">//在安装目录搜索头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span><span class="comment">//在程序目录搜索头文件</span></span></span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="LED"><a href="#LED" class="headerlink" title="LED"></a>LED</h2><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250110195012155.png" alt="image-20250110195012155" style="zoom:65%;"><p>8个led对应P2寄存器的八个I&#x2F;O口，置低电平则可使LED导通发光。</p><h3 id="2-1-点亮第一个LED"><a href="#2-1-点亮第一个LED" class="headerlink" title="2-1 点亮第一个LED"></a>2-1 点亮第一个LED</h3><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250110201354031.png" alt="image-20250110201354031"></p><p>在REGX52.H中已经定义了P2寄存器，可以直接对其赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">P2=<span class="number">0xfe</span>; <span class="comment">//1111 1110 让P2.0为低电平 从而使LED1亮; 将值0xfe写入地址为0xA0的寄存器</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P2各位在头文件已经被定义，故也可单独对P2的某一位进行赋值操作：</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250110201939191.png" alt="image-20250110201939191"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">P2_0=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-LED闪烁"><a href="#2-2-LED闪烁" class="headerlink" title="2-2 LED闪烁"></a>2-2 LED闪烁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay500ms</span><span class="params">()</span><span class="comment">//@12.000MHz  延时500ms，该函数由STC-ISP软件生成</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j, k;</span><br><span class="line"></span><br><span class="line">_nop_();<span class="comment">//空语句，定义在INTRINS.H中，使用该函数时需包含INTRINS.H</span></span><br><span class="line">i = <span class="number">4</span>;</span><br><span class="line">j = <span class="number">205</span>;</span><br><span class="line">k = <span class="number">187</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--k);</span><br><span class="line">&#125; <span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">P2=<span class="number">0xfe</span>; <span class="comment">//1111 1110 </span></span><br><span class="line">Delay500ms();</span><br><span class="line">P2=<span class="number">0xff</span>; <span class="comment">//1111 1110 </span></span><br><span class="line">Delay500ms();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延时函数由STC-ISP软件生成</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250110163702305.png" alt="image-20250110163702305"></p><h3 id="2-3-LED流水灯"><a href="#2-3-LED流水灯" class="headerlink" title="2-3 LED流水灯"></a>2-3 LED流水灯</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay500ms</span><span class="params">()</span><span class="comment">//@12.000MHz  延时500ms，该函数由STC-ISP软件生成</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j, k;</span><br><span class="line"></span><br><span class="line">_nop_();<span class="comment">//空语句，定义在INTRINS.H中，使用该函数时需包含INTRINS.H</span></span><br><span class="line">i = <span class="number">4</span>;</span><br><span class="line">j = <span class="number">205</span>;</span><br><span class="line">k = <span class="number">187</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--k);</span><br><span class="line">&#125; <span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">P2=<span class="number">0xfe</span>; <span class="comment">//1111 1110 </span></span><br><span class="line">Delay500ms();</span><br><span class="line">P2=<span class="number">0xfd</span>; <span class="comment">//1111 1101</span></span><br><span class="line">Delay500ms();</span><br><span class="line">P2=<span class="number">0xfb</span>; <span class="comment">//1111 1011 </span></span><br><span class="line">Delay500ms();</span><br><span class="line">P2=<span class="number">0xf7</span>; <span class="comment">//1111 0111 </span></span><br><span class="line">Delay500ms();</span><br><span class="line">P2=<span class="number">0xef</span>; <span class="comment">//1110 1111 </span></span><br><span class="line">Delay500ms();</span><br><span class="line">P2=<span class="number">0xdf</span>; <span class="comment">//1101 1111 </span></span><br><span class="line">Delay500ms();</span><br><span class="line">P2=<span class="number">0xbf</span>; <span class="comment">//1011 1111 </span></span><br><span class="line">Delay500ms();</span><br><span class="line">P2=<span class="number">0x7f</span>; <span class="comment">//0111 1111 </span></span><br><span class="line">Delay500ms();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延迟函数"><a href="#延迟函数" class="headerlink" title="延迟函数"></a>延迟函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span><span class="comment">//@12.000MHz 参数ms为需要延迟几毫秒</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"><span class="keyword">while</span>(ms)</span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">j = <span class="number">239</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">ms--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="独立按键"><a href="#独立按键" class="headerlink" title="独立按键"></a>独立按键</h2><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250110200504735.png" alt="image-20250110200504735" style="zoom:67%;"><p>单片机上电后默认为高电平，按下按键后，I&#x2F;O口接地，变为低电平。检测I&#x2F;O口高低电平状态即可知道按键是否被按下。</p><h3 id="3-1独立按键控制LED亮灭"><a href="#3-1独立按键控制LED亮灭" class="headerlink" title="3-1独立按键控制LED亮灭"></a>3-1独立按键控制LED亮灭</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实验现象：按下按键1，LED亮，松开后LED灭</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(P3_1==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">P2_0=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">P2_0=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2独立按键控制LED状态"><a href="#3-2独立按键控制LED状态" class="headerlink" title="3-2独立按键控制LED状态"></a>3-2独立按键控制LED状态</h3><h4 id="软件消抖"><a href="#软件消抖" class="headerlink" title="软件消抖"></a>软件消抖</h4><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250110215436695.png" alt="image-20250110215436695" style="zoom:67%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实验现象：每按一次LED状态变一次</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"><span class="keyword">while</span>(ms)</span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">j = <span class="number">239</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">ms--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(P3_1==<span class="number">0</span>)<span class="comment">//按键被按下</span></span><br><span class="line">&#123;</span><br><span class="line">Delay_ms(<span class="number">20</span>);<span class="comment">//软件消抖 以免按键还没松开 但由于抖动 单片机误以为按键松开进行相应的操作</span></span><br><span class="line"><span class="keyword">while</span>(P3_1==<span class="number">0</span>);<span class="comment">//手松开前一直停在这里</span></span><br><span class="line">Delay_ms(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">P2_0=~P2_0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2独立按键控制LED显示二进制"><a href="#3-2独立按键控制LED显示二进制" class="headerlink" title="3-2独立按键控制LED显示二进制"></a>3-2独立按键控制LED显示二进制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"><span class="keyword">while</span>(ms)</span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">j = <span class="number">239</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">ms--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LEDNum=<span class="number">0</span>;<span class="comment">//char刚好8位 与寄存器位数相同</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(P3_1==<span class="number">0</span>)<span class="comment">//按键被按下</span></span><br><span class="line">&#123;</span><br><span class="line">Delay_ms(<span class="number">20</span>);<span class="comment">//软件消抖 以免按键还没松开 但由于抖动 单片机误以为按键松开进行相应的操作</span></span><br><span class="line"><span class="keyword">while</span>(P3_1==<span class="number">0</span>);<span class="comment">//手松开前一直停在这里</span></span><br><span class="line">Delay_ms(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">LEDNum++;</span><br><span class="line">P2=~LEDNum;<span class="comment">//LED是低电平亮，取反</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3独立按键控制LED移位-有思维"><a href="#3-3独立按键控制LED移位-有思维" class="headerlink" title="3-3独立按键控制LED移位(有思维)"></a>3-3独立按键控制LED移位(有思维)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实验现象：按键1LED左移，按键2LED右移</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LEDNum=<span class="number">0</span>;<span class="comment">//char刚好8位 与寄存器位数相同</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"><span class="keyword">while</span>(ms)</span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">j = <span class="number">239</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">ms--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">P2=~<span class="number">0x01</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(P3_0==<span class="number">0</span>)<span class="comment">//按键被按下</span></span><br><span class="line">&#123;</span><br><span class="line">Delay_ms(<span class="number">20</span>);<span class="comment">//软件消抖 以免按键还没松开 但由于抖动 单片机误以为按键松开进行相应的操作</span></span><br><span class="line"><span class="keyword">while</span>(P3_0==<span class="number">0</span>);<span class="comment">//手松开前一直停在这里</span></span><br><span class="line">Delay_ms(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">LEDNum++;</span><br><span class="line"><span class="keyword">if</span>(LEDNum&gt;=<span class="number">8</span>)</span><br><span class="line">LEDNum=<span class="number">0</span>;</span><br><span class="line">P2=~(<span class="number">0x01</span>&lt;&lt;LEDNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(P3_1==<span class="number">0</span>)<span class="comment">//按键被按下</span></span><br><span class="line">&#123;</span><br><span class="line">Delay_ms(<span class="number">20</span>);<span class="comment">//软件消抖 以免按键还没松开 但由于抖动 单片机误以为按键松开进行相应的操作</span></span><br><span class="line"><span class="keyword">while</span>(P3_1==<span class="number">0</span>);<span class="comment">//手松开前一直停在这里</span></span><br><span class="line">Delay_ms(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(LEDNum==<span class="number">0</span>)</span><br><span class="line">LEDNum=<span class="number">7</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LEDNum--;</span><br><span class="line"></span><br><span class="line">P2=~(<span class="number">0x01</span>&lt;&lt;LEDNum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数码管"><a href="#数码管" class="headerlink" title="数码管"></a>数码管</h2><p>数码管是由多个发光二极管封装在一起组成的“8”字型的器件。</p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111101223027.png" alt="image-20250111101223027" style="zoom:67%;"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111101711029.png" alt="image-20250111101711029" style="zoom:53%;"><p><strong>对于四位一体数码管，eg:共阴，让第三个数码管亮其余灭,则位选1101,第三个数码管显示数字1，让7，4端口高电平，即给整个数码管01100000，若位选时为0000，则四个数码管都显示1，共阴极这种设计是四个数码管的A,B,C….分别在同一条线上，可以节省单片机I&#x2F;O资源</strong></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111100427053.png" alt="image-20250111100427053"></p><p>该单片机数码管为公阴极。74HC245是一个信号缓冲器，由于单片机引脚的驱动能力较弱，通过该缓冲器后，输出的电流更大（利用它自己接的VCC输出）</p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111103017979.png" alt="image-20250111103017979" style="zoom:50%;"><p>LED1-8接到<strong>138译码器</strong>的输出端</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111103147929.png" alt="image-20250111103147929"></p><p>138译码器输入端为A,B,C(P22,P23,P24)，输出端为Y0-Y7(LED1-8)，由三个输入端控制8个输出端。 G1,G2A,G2B为使能端（此电路设计时已经接好，单片机上电就可以用该译码器）。</p><p>给CBA（C为高位）写二进制，转换成的十进制即要让输出端哪一位亮。eg:给CBA 101,101转换成十进制即5，即让Y5为0</p><p><strong>总结：驱动方式：用138译码器选中哪个数码管亮，再用245缓冲器给段码数据使数码管显示对应数字</strong></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111161002712.png" alt="image-20250111161002712"></p><h3 id="4-1静态数码管显示"><a href="#4-1静态数码管显示" class="headerlink" title="4-1静态数码管显示"></a>4-1静态数码管显示</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> NixieTable[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0X6D</span>,<span class="number">0X7D</span>,<span class="number">0X07</span>,<span class="number">0x7F</span>,<span class="number">0X6F</span>&#125;;<span class="comment">//数码管段码表，对应数字0-9</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NixieTube</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Location,Number)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从右往左</span></span><br><span class="line"><span class="keyword">switch</span>(Location)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:P2_4=<span class="number">0</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:P2_4=<span class="number">0</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:P2_4=<span class="number">0</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:P2_4=<span class="number">0</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:P2_4=<span class="number">1</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:P2_4=<span class="number">1</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:P2_4=<span class="number">1</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:P2_4=<span class="number">1</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">P0=NixieTable[Number];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">NixieTube(<span class="number">7</span>,<span class="number">3</span>);<span class="comment">//从右往左数第七个数码管显示数字3</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2动态数码管显示"><a href="#4-2动态数码管显示" class="headerlink" title="4-2动态数码管显示"></a>4-2动态数码管显示</h3><p>利用人眼视觉暂留和数码管显示的余晖（先让第一个数码管显示1，第二关显示2，第三个显示3，不断地扫描，由于视觉暂留可以看到123）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> NixieTable[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0X6D</span>,<span class="number">0X7D</span>,<span class="number">0X07</span>,<span class="number">0x7F</span>,<span class="number">0X6F</span>&#125;;<span class="comment">//数码管段码表，对应数字0-9</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"><span class="keyword">while</span>(ms)</span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">j = <span class="number">239</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">ms--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">NixieTube</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Location,Number)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从右往左</span></span><br><span class="line"><span class="keyword">switch</span>(Location)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:P2_4=<span class="number">0</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:P2_4=<span class="number">0</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:P2_4=<span class="number">0</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:P2_4=<span class="number">0</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:P2_4=<span class="number">1</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:P2_4=<span class="number">1</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:P2_4=<span class="number">1</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:P2_4=<span class="number">1</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">P0=NixieTable[Number];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">NixieTube(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">Delay_ms(<span class="number">1</span>);</span><br><span class="line">NixieTube(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">Delay_ms(<span class="number">1</span>);</span><br><span class="line">NixieTube(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">Delay_ms(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111165931402.png" alt="image-20250111165931402"></p><h2 id="LCD1602显示屏"><a href="#LCD1602显示屏" class="headerlink" title="LCD1602显示屏"></a>LCD1602显示屏</h2><p>普中、51单片机LCD引脚与数码管和D3,D4,D5冲突，与其它引脚不冲突</p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111202800133.png" alt="image-20250111202800133" style="zoom:80%;"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111203012292.png" alt="image-20250111203012292" style="zoom:50%;"> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowChar</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">char</span> Char)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">char</span> *String)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowSignedNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowHexNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowBinNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span>;</span><br><span class="line"></span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_ShowChar(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">3</span>,<span class="string">&quot;Hello word&quot;</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">9</span>,<span class="number">123</span>,<span class="number">3</span>);</span><br><span class="line">LCD_ShowSignedNum(<span class="number">1</span>,<span class="number">13</span>,<span class="number">-66</span>,<span class="number">2</span>);</span><br><span class="line">LCD_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,<span class="number">0xA8</span>,<span class="number">2</span>);</span><br><span class="line">LCD_ShowBinNum(<span class="number">2</span>,<span class="number">4</span>,<span class="number">0xAA</span>,<span class="number">8</span>);</span><br></pre></td></tr></table></figure><h3 id="5-1-LCD"><a href="#5-1-LCD" class="headerlink" title="5-1 LCD"></a>5-1 LCD</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LCD1602.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_Init();</span><br><span class="line"></span><br><span class="line">LCD_ShowBinNum(<span class="number">2</span>,<span class="number">4</span>,<span class="number">0xAA</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">result++;</span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">1</span>,result,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵键盘"><a href="#矩阵键盘" class="headerlink" title="矩阵键盘"></a>矩阵键盘</h2><p>按键以矩阵的形式连接在I&#x2F;O上。</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111222000568.png" alt="image-20250111222000568"></p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250111225558421.png" alt="image-20250111225558421" style="zoom:67%;"><h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a><strong>检测方法</strong></h3><p>1.行列式扫描法（将矩阵按键拆分为独立按键） 2.线翻转法</p><p>行列式扫描法一行一行扫描，检测的次数不定，线翻转法只用检测两次，一次定行一次定列。</p><p><strong>行列式扫描法</strong>（编程最简单最无脑，但相比线翻转法效率低）</p><p>原理：P17,P16,P15,P14为矩阵的4行，P13,P12,P11,P10为矩阵的4列，给行赋1011，则是单独看第二行，此时它们一端接地，只用检测P13,P12,P11,P10的电平状态即可知道该行有没有被按下的……以此类推，可以逐行&#x2F;列扫描，由于此开发板引脚冲突，蜂鸣器会一直响，所以在此用逐列扫描。</p><p>普通按键是直接给它一端接地，矩阵键盘两端连的是两个I&#x2F;O，行列式扫描法是通过令一个I&#x2F;O为低电平达到和普通键盘一样的效果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">MatrixKey</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeyNumber=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">P1=<span class="number">0xFF</span>;</span><br><span class="line">P1_3=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(P1_7==<span class="number">0</span>)&#123;Delay_ms(<span class="number">20</span>);<span class="keyword">while</span>(P1_7==<span class="number">0</span>);Delay_ms(<span class="number">20</span>);KeyNumber=<span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_6==<span class="number">0</span>)&#123;Delay_ms(<span class="number">20</span>);<span class="keyword">while</span>(P1_6==<span class="number">0</span>);Delay_ms(<span class="number">20</span>);KeyNumber=<span class="number">5</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_5==<span class="number">0</span>)&#123;Delay_ms(<span class="number">20</span>);<span class="keyword">while</span>(P1_5==<span class="number">0</span>);Delay_ms(<span class="number">20</span>);KeyNumber=<span class="number">9</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_4==<span class="number">0</span>)&#123;Delay_ms(<span class="number">20</span>);<span class="keyword">while</span>(P1_4==<span class="number">0</span>);Delay_ms(<span class="number">20</span>);KeyNumber=<span class="number">13</span>;&#125;</span><br><span class="line"></span><br><span class="line">P1=<span class="number">0xFF</span>;</span><br><span class="line">P1_2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(P1_7==<span class="number">0</span>)&#123;Delay_ms(<span class="number">20</span>);<span class="keyword">while</span>(P1_7==<span class="number">0</span>);Delay_ms(<span class="number">20</span>);KeyNumber=<span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_6==<span class="number">0</span>)&#123;Delay_ms(<span class="number">20</span>);<span class="keyword">while</span>(P1_6==<span class="number">0</span>);Delay_ms(<span class="number">20</span>);KeyNumber=<span class="number">6</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_5==<span class="number">0</span>)&#123;Delay_ms(<span class="number">20</span>);<span class="keyword">while</span>(P1_5==<span class="number">0</span>);Delay_ms(<span class="number">20</span>);KeyNumber=<span class="number">10</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_4==<span class="number">0</span>)&#123;Delay_ms(<span class="number">20</span>);<span class="keyword">while</span>(P1_4==<span class="number">0</span>);Delay_ms(<span class="number">20</span>);KeyNumber=<span class="number">14</span>;&#125;</span><br><span class="line"></span><br><span class="line">P1=<span class="number">0xFF</span>;</span><br><span class="line">P1_1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(P1_7==<span class="number">0</span>)&#123;Delay_ms(<span class="number">20</span>);<span class="keyword">while</span>(P1_7==<span class="number">0</span>);Delay_ms(<span class="number">20</span>);KeyNumber=<span class="number">3</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_6==<span class="number">0</span>)&#123;Delay_ms(<span class="number">20</span>);<span class="keyword">while</span>(P1_6==<span class="number">0</span>);Delay_ms(<span class="number">20</span>);KeyNumber=<span class="number">7</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_5==<span class="number">0</span>)&#123;Delay_ms(<span class="number">20</span>);<span class="keyword">while</span>(P1_5==<span class="number">0</span>);Delay_ms(<span class="number">20</span>);KeyNumber=<span class="number">11</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_4==<span class="number">0</span>)&#123;Delay_ms(<span class="number">20</span>);<span class="keyword">while</span>(P1_4==<span class="number">0</span>);Delay_ms(<span class="number">20</span>);KeyNumber=<span class="number">15</span>;&#125;</span><br><span class="line"></span><br><span class="line">P1=<span class="number">0xFF</span>;</span><br><span class="line">P1_0=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(P1_7==<span class="number">0</span>)&#123;Delay_ms(<span class="number">20</span>);<span class="keyword">while</span>(P1_7==<span class="number">0</span>);Delay_ms(<span class="number">20</span>);KeyNumber=<span class="number">4</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_6==<span class="number">0</span>)&#123;Delay_ms(<span class="number">20</span>);<span class="keyword">while</span>(P1_6==<span class="number">0</span>);Delay_ms(<span class="number">20</span>);KeyNumber=<span class="number">8</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_5==<span class="number">0</span>)&#123;Delay_ms(<span class="number">20</span>);<span class="keyword">while</span>(P1_5==<span class="number">0</span>);Delay_ms(<span class="number">20</span>);KeyNumber=<span class="number">12</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_4==<span class="number">0</span>)&#123;Delay_ms(<span class="number">20</span>);<span class="keyword">while</span>(P1_4==<span class="number">0</span>);Delay_ms(<span class="number">20</span>);KeyNumber=<span class="number">16</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> KeyNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线翻转法</p><p>先让四行为0，检测哪一列被按下（该列上任何一个按键被按下都会导致该列代表的I&#x2F;O为低电平）</p><p>再让四列为0，检测哪一行被按下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">MatrixKey_flip_scan</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeyNumber=<span class="number">0</span>;</span><br><span class="line">P1=<span class="number">0x0f</span>;<span class="comment">//00001111 先让四行为0         </span></span><br><span class="line"><span class="keyword">if</span>(P1!=<span class="number">0x0f</span>)<span class="comment">//读取按键是否按下,若不为0x0f说明检测到某列上有按键被按下</span></span><br><span class="line">&#123;</span><br><span class="line">Delay_ms(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">if</span>(P1!=<span class="number">0x0f</span>)<span class="comment">//再次检测键盘是否按下</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//测试列</span></span><br><span class="line">P1=<span class="number">0x0f</span>;</span><br><span class="line"><span class="keyword">switch</span>(P1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span>(<span class="number">0X07</span>):KeyNumber=<span class="number">1</span>;<span class="keyword">break</span>;<span class="comment">//0x07 0000 0111</span></span><br><span class="line"><span class="keyword">case</span>(<span class="number">0X0b</span>):KeyNumber=<span class="number">2</span>;<span class="keyword">break</span>;<span class="comment">//0x0b 0000 1011</span></span><br><span class="line"><span class="keyword">case</span>(<span class="number">0X0d</span>): KeyNumber=<span class="number">3</span>;<span class="keyword">break</span>;<span class="comment">//0x0d 0000 1101</span></span><br><span class="line"><span class="keyword">case</span>(<span class="number">0X0e</span>):KeyNumber=<span class="number">4</span>;<span class="keyword">break</span>;<span class="comment">//0x0e 0000 1110</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试行</span></span><br><span class="line">P1=<span class="number">0Xf0</span>;</span><br><span class="line"><span class="keyword">switch</span>(P1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span>(<span class="number">0X70</span>):KeyNumber=KeyNumber;<span class="keyword">break</span>;<span class="comment">//0x70 0111 0000 </span></span><br><span class="line"><span class="keyword">case</span>(<span class="number">0Xb0</span>):KeyNumber=KeyNumber+<span class="number">4</span>;<span class="keyword">break</span>;<span class="comment">//0xb0 1011 0000</span></span><br><span class="line"><span class="keyword">case</span>(<span class="number">0Xd0</span>): KeyNumber=KeyNumber+<span class="number">8</span>;<span class="keyword">break</span>;<span class="comment">//0xd0 1101 0000</span></span><br><span class="line"><span class="keyword">case</span>(<span class="number">0Xe0</span>):KeyNumber=KeyNumber+<span class="number">12</span>;<span class="keyword">break</span>;<span class="comment">//0xe0 1110 0000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(P1!=<span class="number">0xf0</span>);<span class="comment">//有按键按下</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">KeyNumber=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> KeyNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-矩阵键盘读取并显示在LCD"><a href="#6-1-矩阵键盘读取并显示在LCD" class="headerlink" title="6-1 矩阵键盘读取并显示在LCD"></a>6-1 矩阵键盘读取并显示在LCD</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LCD1602.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MatrixKey.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeyNum=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;zzxnb666&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//KeyNum=MatrixKey();</span></span><br><span class="line">KeyNum=MatrixKey_flip_scan();</span><br><span class="line"><span class="keyword">if</span>(KeyNum)</span><br><span class="line">&#123;</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,KeyNum,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-矩阵键盘密码锁"><a href="#6-2-矩阵键盘密码锁" class="headerlink" title="6-2 矩阵键盘密码锁"></a>6-2 矩阵键盘密码锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LCD1602.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MatrixKey.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeyNum,Count=<span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> PassWord=<span class="number">0</span>;<span class="comment">//int最大为65535 五位数 若给它赋值六位数及以上就会出错</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;Password:&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//KeyNum=MatrixKey();</span></span><br><span class="line">KeyNum=MatrixKey_flip_scan();<span class="comment">//获取键值</span></span><br><span class="line"><span class="keyword">if</span>(KeyNum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(KeyNum&lt;=<span class="number">10</span>)<span class="comment">//如果S1-S10按键按下，输入密码</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Count&lt;<span class="number">4</span>)<span class="comment">//最多输入4位数</span></span><br><span class="line">&#123;</span><br><span class="line">PassWord*=<span class="number">10</span>;<span class="comment">//密码左移一位</span></span><br><span class="line">PassWord+=KeyNum%<span class="number">10</span>;<span class="comment">//1-9对10取余为1-9,10对10取余为0</span></span><br><span class="line">&#125;</span><br><span class="line">Count++;</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,PassWord,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">11</span>)<span class="comment">//若S11按下，确认</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(PassWord==<span class="number">2345</span>)<span class="comment">//正确密码</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">14</span>,<span class="string">&quot;OK &quot;</span>);</span><br><span class="line">PassWord=<span class="number">0</span>;<span class="comment">//密码清0</span></span><br><span class="line">Count=<span class="number">0</span>;<span class="comment">//计次清0，可再次输入</span></span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,PassWord,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">14</span>,<span class="string">&quot;ERR&quot;</span>);</span><br><span class="line">PassWord=<span class="number">0</span>;</span><br><span class="line">Count=<span class="number">0</span>;</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,PassWord,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">12</span>)<span class="comment">//取消</span></span><br><span class="line">&#123;</span><br><span class="line">PassWord=<span class="number">0</span>;</span><br><span class="line">Count=<span class="number">0</span>;</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,PassWord,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中断系统-重要"><a href="#中断系统-重要" class="headerlink" title="中断系统(重要)"></a>中断系统(重要)</h2><h3 id="中断概念"><a href="#中断概念" class="headerlink" title="中断概念"></a>中断概念</h3><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250114214017637.png" alt="image-20250114214017637"></p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250113121039615.png" alt="image-20250113121039615" style="zoom:60%;"><p>中断源：引起中断的源头</p><p>中断优先级：中断允许多个中断源（外部中断，串口中断，定时器中断……）存在，当多个中断源同时出现时，谁的中断优先级高就先相应谁，先执行高的再执行低的，然后再返回主程序。若两个中断优先级相同，通过查询次序来决定谁先（有一个固定的顺序）。</p><p>中断嵌套：当执行一个中断时，若此时出现了一个比它优先级更高的中断，则要转向执行高优先级的，然后再返回优先级低的那个继续执行，然后再返回主程序。对于51来说比较少，对于STM32,DSP等中断更复杂，则更容易出现中断嵌套。</p><p>中断的开启关闭，使用哪一个中断等等 都是有特殊功能寄存器来设置的</p><h3 id="中断结构"><a href="#中断结构" class="headerlink" title="中断结构"></a>中断结构</h3><p>8个中断请求源：<strong>INT0,INT1</strong>,INT2,INT3,<strong>TIM0,TIM1</strong>,TIM2,<strong>UART</strong>   加粗部分对于所有51内核的单片机都有</p><p>所有中断都有4个中断优先级</p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250113135129899.png" alt="image-20250113135129899" style="zoom:67%;"><p>INT0的IT0决定的是下降沿触发还是低电平触发，IE0是中断标志位（当中断源到来时由单片机自动置1），EA为全局总中断，IP是用来设置中断优先级</p><p>TCON（中断请求标志）,IE（中断允许控制）,IP都是寄存器   </p><h3 id="中断寄存器"><a href="#中断寄存器" class="headerlink" title="中断寄存器"></a>中断寄存器</h3><p><strong>TCON（中断请求标志）</strong></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250113171843543.png" alt="image-20250113171843543"></p><p><strong>IE（中断允许控制）</strong></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250113171807611.png" alt="image-20250113171807611"></p><p><strong>中断响应条件</strong></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250113172317209.png" alt="image-20250113172317209"></p><h3 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a><strong>中断优先级</strong></h3><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250113171949116.png" alt="image-20250113171949116"></p><h3 id="中断号"><a href="#中断号" class="headerlink" title="中断号"></a><strong>中断号</strong></h3><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250113172031193.png" alt="image-20250113172031193"></p><h3 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h3><p>51内核的单片机都有INT0,INT1；STC89C5X提供了4个外部中断，INT0,INT1,INT2,INT3</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250113174721897.png" alt="image-20250113174721897"></p><p>INT0的IT0决定的是下降沿触发还是低电平触发，IE0是中断标志位（当中断源到来时由单片机自动置1），EA为全局总中断，IP是用来设置中断优先级</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EA=<span class="number">1</span>;<span class="comment">//打开总中断开关</span></span><br><span class="line">EX0=<span class="number">1</span>;<span class="comment">//开外部中断0</span></span><br><span class="line">IT0=<span class="number">0</span>/<span class="number">1</span>;<span class="comment">//设置外部中断触发方式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">int0</span><span class="params">()</span> interrupt 0<span class="comment">//0为中断号 interrupt为中断关键字 int0为中断函数名，可自己定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//编写用户所需的功能代码,尽量不要写一些特别复杂，占用大量时间的代码，保证中断快进快出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于STC89C52单片机，INT0,INT1对应P3.2,P3.3      这里我们使用按键模拟外部中断触发                </p><p>​                              <img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250113180023559.png" alt="image-20250113180023559"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250113180037658.png" alt="image-20250113180037658"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250113195037070.png" alt="image-20250113195037070" style="zoom:50%;"></p><h4 id="外部中断实验"><a href="#外部中断实验" class="headerlink" title="外部中断实验"></a>外部中断实验</h4><p>通过独立按键K3,K4控制LED1,LED2亮灭。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY3 P3_2 <span class="comment">//与INT0相连</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY4 P3_3 <span class="comment">//与INT1相连</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1 P2_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2 P2_1 </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exti0_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">EA=<span class="number">1</span>;</span><br><span class="line">EX0=<span class="number">1</span>;</span><br><span class="line">IT0=<span class="number">1</span>;<span class="comment">//下降沿触发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exti1_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">EA=<span class="number">1</span>;</span><br><span class="line">EX1=<span class="number">1</span>;</span><br><span class="line">IT1=<span class="number">1</span>;<span class="comment">//下降沿触发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">exti0_init();</span><br><span class="line">exti1_init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exti0</span><span class="params">()</span> interrupt 0</span><br><span class="line">&#123;</span><br><span class="line">Delay_ms(<span class="number">20</span>);<span class="comment">//先消抖</span></span><br><span class="line"><span class="keyword">if</span>(KEY3==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED1=!LED1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exti1</span><span class="params">()</span> interrupt 2</span><br><span class="line">&#123;</span><br><span class="line">Delay_ms(<span class="number">20</span>);<span class="comment">//先消抖</span></span><br><span class="line"><span class="keyword">if</span>(KEY4==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED2=!LED2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对其模块化封装：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Header: exti.c</span></span><br><span class="line"><span class="comment">// File Name: STC89C51外部中断模块 </span></span><br><span class="line"><span class="comment">// Author: 张志雄</span></span><br><span class="line"><span class="comment">// Date: 2025/1/14</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exti.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  exti0初始化 下降沿触发</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exti0_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">EA=<span class="number">1</span>;</span><br><span class="line">EX0=<span class="number">1</span>;</span><br><span class="line">IT0=<span class="number">1</span>;<span class="comment">//下降沿触发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  exti1初始化 下降沿触发</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exti1_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">EA=<span class="number">1</span>;</span><br><span class="line">EX1=<span class="number">1</span>;</span><br><span class="line">IT1=<span class="number">1</span>;<span class="comment">//下降沿触发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  exti0中断服务函数</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exti0</span><span class="params">()</span> interrupt 0</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//用户代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  exti1中断服务函数</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exti1</span><span class="params">()</span> interrupt 2</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//用户代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __EXTI_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __EXTI_H__</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exti0_init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">exti1_init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="定时器（重要）"><a href="#定时器（重要）" class="headerlink" title="定时器（重要）"></a>定时器（重要）</h2><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250114214141840.png" alt="image-20250114214141840"></p><p>定时器作用： </p><p>1.可用于计时系统，实现软件计时，或者使程序每隔一固定时间完成一项操作</p><p>2.替代长时间delay,提高CPU的运行效率和处理速度</p><p>51内核的定时器都有T0,T1,对于STCC9852单片机，还有T3</p><p>51单片机有两组定时计数器，既可以定时又可以计数；</p><p>定时器计数器与单片机CPU相互独立，工作过程自动完成，不需要CPU参与；</p><p>定时计数器是根据机器内部的时钟（使用定时功能）或外部的脉冲信号（使用计数功能）来对寄存器进行加1； </p><h3 id="CPU时序周期相关知识"><a href="#CPU时序周期相关知识" class="headerlink" title="CPU时序周期相关知识"></a>CPU时序周期相关知识</h3><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250113223443880.png" alt="image-20250113223443880"></p><p>时钟周期（振荡周期）：单片机控制信号的基本时间单位。若时钟晶体震荡频率为fosc,则时钟周期Tosc&#x3D;1&#x2F;fosc.</p><p>机器周期：CPU完成一个基本操作所需要的时间为机器周期。单片机通常把执行一条指令的过程分为几个机器周期，AT89S51单片机每12个时钟周期为一个机器周期。Tcy&#x3D;12Tosc&#x3D;12&#x2F;fosc。eg:fosc&#x3D;12MHZ,Tcy&#x3D;12&#x2F;12&#x3D;1us.</p><p>指令周期：执行一条指令所需要的时间。</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250113224916285.png" alt="image-20250113224916285"></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250113224941611.png" alt="image-20250113224941611"></p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>详细的每一位介绍可以看参考手册。</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250115192122419.png" alt="image-20250115192122419"></p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250114093636787.png" alt="image-20250114093636787" style="zoom:50%;"><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250115193933757.png" alt="image-20250115193933757"></p><p>不可位寻址 只能对寄存器整体赋值</p><p>一般用方式1，方式2（串口波特率生成）。<strong>TMOD高四位控制T1，低四位控制T0</strong></p><p>GATE:门控位 1:（只需TR0&#x2F;TR1为1来决定定时计数器工作）0:（除了TR0&#x2F;TR1还需INT0&#x2F;INT1为1来决定定时计数器工作）</p><p>C&#x2F;T: 1（计数模式）0（定时模式）</p><p>M1，M0：工作方式</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250114094733511.png" alt="image-20250114094733511"></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250115193910592.png" alt="image-20250115193910592"></p><p>可位寻址 可对寄存器中的每一位单独赋值</p><p>TF1：T1溢出标志位，溢出时自动置1，向CPU发出中断请求</p><p>TR1: T1定时计数器运行控制位 1:开始工作 0:停止工作</p><h3 id="工作方式（原理）"><a href="#工作方式（原理）" class="headerlink" title="工作方式（原理）"></a>工作方式（原理）</h3><p><strong>方式0：</strong></p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250114095146635.png" alt="image-20250114095146635" style="zoom:50%;"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250114211051491.png" alt="image-20250114211051491" style="zoom:67%;"><p>C&#x2F;T 若为1 计数器模式 将开关打到1 ，若为0 定时器模式 将开关打到0</p><p><strong>方式1（常用）：</strong> </p><p>不会自动装载初值 每次溢出进入中断后需要我们手动装载</p><p><strong>每来一个脉冲，16位(最大为65535)的计数器（TH,TL）里面的值就会自动加1，当计数达到最大值65535后，再+1就会溢出，TF0置1，向中断系统申请中断</strong></p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250114101303771.png" alt="image-20250114101303771" style="zoom:50%;"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250114215237257.png" alt="image-20250114215237257" style="zoom:80%;"><p><strong>方式2：</strong></p><p><strong>自动重装载（初值），用于串口波特率</strong></p><p><strong>将TL1,TH1赋为相同的初值，当TL1溢出后自动将TH1的值赋值给TL1</strong></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250117162729154.png" alt="image-20250117162729154"></p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250114101345916.png" alt="image-20250114101345916" style="zoom:50%;"><p>  方式3：</p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250114101647745.png" alt="image-20250114101647745" style="zoom:50%;"><h3 id="定时器配置-重要"><a href="#定时器配置-重要" class="headerlink" title="定时器配置(重要)"></a>定时器配置(重要)</h3><p>其实就是根据工作方式的图把相应的寄存器配一下</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250114101849411.png" alt="image-20250114101849411"></p><p><strong>外部晶振12MHZ,则机器周期&#x3D;1us，若想让定时器定时1ms</strong></p><p><strong>1ms&#x2F;1us&#x3D;1000次  初值&#x3D;65536-1000&#x3D;64536 将其转换为16进制为0xFC18，高八位写入TH，低八位写入TL</strong></p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250114113551152.png" alt="image-20250114113551152" style="zoom:80%;"><p> <strong>当要计时的时间比较大，次数超过65536的话，如500ms,我们可以设置定时器1ms，然后在定时器中断里设置一个变量cnt，每次进入中断时加一，当cnt&#x3D;500时即为500ms.</strong></p><p><strong>也可以这样算：</strong></p><p><strong>2^16&#x3D;65536 2^8&#x3D;256</strong> </p><p><strong>高八位&#x3D;65535&#x2F;(2^8),低八位&#x3D;65535%(2^8))         类比十进制:1880 取高2位和低2位，高二位&#x3D;1880&#x2F;(10^2)&#x3D;18,低二位&#x3D;1880%(10^2)&#x3D;80)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TH=<span class="number">65536</span>/<span class="number">256</span>;</span><br><span class="line">TL=<span class="number">65536</span>%<span class="number">256</span>;</span><br></pre></td></tr></table></figure><p>此外，在掌握了计算方法后，也可以使用定时器计算工具提高效率：</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250114114324053.png" alt="image-20250114114324053"></p><p>STC-ISP</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250115205758206.png" alt="image-20250115205758206"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM0_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD&amp;=<span class="number">0xF0</span>;<span class="comment">//1111 0000 高4位为T1，保持不变，低4位为T0，清0</span></span><br><span class="line">    TMOD|=<span class="number">0x01</span>;<span class="comment">//0000 0001 选择为定时器0模式，工作方式1，使用或运算可以不干扰高四位 </span></span><br><span class="line">    </span><br><span class="line">    TH0=<span class="number">0xFC</span>;<span class="comment">//给定时器赋初值，定时1ms</span></span><br><span class="line">    TL0=<span class="number">0x18</span>;</span><br><span class="line">    </span><br><span class="line">    ET0=<span class="number">1</span>;<span class="comment">//打开定时器0中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">    </span><br><span class="line">    TR0=<span class="number">1</span>;<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250114215302207.png" alt="image-20250114215302207" style="zoom:80%;"><p>可位寻址的寄存器可以对它的每一位单独赋值，不可位寻址的寄存器只能整体赋值</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250115193711698.png" alt="image-20250115193711698"></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250115193733687.png" alt="image-20250115193733687"></p><h3 id="定时器实验"><a href="#定时器实验" class="headerlink" title="定时器实验"></a>定时器实验</h3><p>1.通过定时器0中断控制D1指示灯间隔1s闪烁，定时器1中断控制D2指示灯间隔0.5s闪烁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1 P2_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2 P2_1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD&amp;=<span class="number">0xF0</span>;<span class="comment">//1111 0000 高4位为T1，保持不变，低4位为T0，清0</span></span><br><span class="line">    TMOD|=<span class="number">0x01</span>;<span class="comment">//0000 0001 选择为定时器0模式，工作方式1，使用或运算可以不干扰高四位</span></span><br><span class="line">    </span><br><span class="line">    TH0=<span class="number">0xFC</span>;<span class="comment">//给定时器赋初值，定时1ms</span></span><br><span class="line">    TL0=<span class="number">0x18</span>;</span><br><span class="line">    </span><br><span class="line">    ET0=<span class="number">1</span>;<span class="comment">//打开定时器0中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">    </span><br><span class="line">    TR0=<span class="number">1</span>;<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM1_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD&amp;=<span class="number">0x0F</span>;<span class="comment">//0000 1111 高4位为T1，清0，低4位为T0，保持不变</span></span><br><span class="line">    TMOD|=<span class="number">0x10</span>;<span class="comment">//0001 0000 选择为定时器0模式，工作方式1，使用或运算可以不干扰高四位</span></span><br><span class="line">    </span><br><span class="line">    TH1=<span class="number">0xFC</span>;<span class="comment">//给定时器赋初值，定时1ms</span></span><br><span class="line">    TL1=<span class="number">0x18</span>;</span><br><span class="line">    </span><br><span class="line">    ET1=<span class="number">1</span>;<span class="comment">//打开定时器0中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">    </span><br><span class="line">    TR1=<span class="number">1</span>;<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    TIM0_Init();</span><br><span class="line">TIM1_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> u16 cnt=<span class="number">0</span>;<span class="comment">//若不定义为static 下次重新调用后cnt又被初始化变成0了</span></span><br><span class="line"></span><br><span class="line">TH0=<span class="number">0xFC</span>;<span class="comment">//TIM0不会自动重装载 当溢出进入中断后需要我们手动装载 </span></span><br><span class="line">    TL0=<span class="number">0x18</span>;</span><br><span class="line"></span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span>(cnt==<span class="number">1000</span>)<span class="comment">//1s</span></span><br><span class="line">&#123;</span><br><span class="line">LED1=!LED1;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM1</span><span class="params">()</span> interrupt 3</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> u16 cnt=<span class="number">0</span>;<span class="comment">//若不定义为static 下次重新调用后cnt又被初始化变成0了</span></span><br><span class="line"></span><br><span class="line">TH1=<span class="number">0xFC</span>;<span class="comment">//TIM0不会自动重装载 当溢出进入中断后需要我们手动装载 </span></span><br><span class="line">    TL1=<span class="number">0x18</span>;</span><br><span class="line"></span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span>(cnt==<span class="number">500</span>)<span class="comment">//0.5s</span></span><br><span class="line">&#123;</span><br><span class="line">LED2=!LED2;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对定时器文件进行模块化封装：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Header: tim.c</span></span><br><span class="line"><span class="comment">// File Name: STC89C51单片机定时器模块</span></span><br><span class="line"><span class="comment">// Author: 张志雄</span></span><br><span class="line"><span class="comment">// Date: 2025/1/14</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1 P2_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2 P2_1</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  TIM0初始化 工作方式1</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD&amp;=<span class="number">0xF0</span>;<span class="comment">//1111 0000 高4位为T1，保持不变，低4位为T0，清0</span></span><br><span class="line">    TMOD|=<span class="number">0x01</span>;<span class="comment">//0000 0001 选择为定时器0模式，工作方式1，使用或运算可以不干扰高四位</span></span><br><span class="line">    </span><br><span class="line">    TH0=<span class="number">0xFC</span>;<span class="comment">//给定时器赋初值，定时1ms</span></span><br><span class="line">    TL0=<span class="number">0x18</span>;</span><br><span class="line">    </span><br><span class="line">    ET0=<span class="number">1</span>;<span class="comment">//打开定时器0中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">    </span><br><span class="line">    TR0=<span class="number">1</span>;<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  TIM1初始化 工作方式1</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM1_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD&amp;=<span class="number">0x0F</span>;<span class="comment">//0000 1111 高4位为T1，清0，低4位为T0，保持不变</span></span><br><span class="line">    TMOD|=<span class="number">0x10</span>;<span class="comment">//0001 0000 选择为定时器0模式，工作方式1，使用或运算可以不干扰高四位</span></span><br><span class="line">    </span><br><span class="line">    TH1=<span class="number">0xFC</span>;<span class="comment">//给定时器赋初值，定时1ms</span></span><br><span class="line">    TL1=<span class="number">0x18</span>;</span><br><span class="line">    </span><br><span class="line">    ET1=<span class="number">1</span>;<span class="comment">//打开定时器0中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">    </span><br><span class="line">    TR1=<span class="number">1</span>;<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  TIM0中断服务函数</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//用户代码</span></span><br><span class="line"><span class="comment">//若为工作方式1 每次进入中断需要重装载初值</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> cnt=<span class="number">0</span>;<span class="comment">//若不定义为static 下次重新调用后cnt又被初始化变成0了</span></span><br><span class="line"></span><br><span class="line">TH0=<span class="number">0xFC</span>;<span class="comment">//TIM0不会自动重装载 当溢出进入中断后需要我们手动装载 </span></span><br><span class="line">    TL0=<span class="number">0x18</span>;</span><br><span class="line"></span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span>(cnt==<span class="number">1000</span>)<span class="comment">//1s</span></span><br><span class="line">&#123;</span><br><span class="line">LED1=!LED1;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  TIM1中断服务函数</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM1</span><span class="params">()</span> interrupt 3</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//用户代码</span></span><br><span class="line"><span class="comment">//若为工作方式1 每次进入中断需要重装载初值</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> cnt=<span class="number">0</span>;<span class="comment">//若不定义为static 下次重新调用后cnt又被初始化变成0了</span></span><br><span class="line"></span><br><span class="line">TH1=<span class="number">0xFC</span>;<span class="comment">//方式1不会自动重装载 当溢出进入中断后需要我们手动装载 </span></span><br><span class="line">    TL1=<span class="number">0x18</span>;</span><br><span class="line"></span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span>(cnt==<span class="number">500</span>)<span class="comment">//0.5s</span></span><br><span class="line">&#123;</span><br><span class="line">LED2=!LED2;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tim.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TIM_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TIM_H__</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM1_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>2.定时器时钟</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LCD1602.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> Sec;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> Min;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> Hour;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    TIM0_Init();</span><br><span class="line">LCD_Init();</span><br><span class="line"></span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;Clock:&quot;</span>);</span><br><span class="line">LCD_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&quot;  :  :&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//LCD会占用相对较长时间 不适合放在中断函数中</span></span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,Hour,<span class="number">2</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">4</span>,Min,<span class="number">2</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">7</span>,Sec,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tim.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;INTRINS.H&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1 P2_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2 P2_1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Sec=<span class="number">55</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Min=<span class="number">59</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Hour=<span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  TIM0初始化 工作方式1</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">TMOD&amp;=<span class="number">0xF0</span>;<span class="comment">//1111 0000 高4位为T1，保持不变，低4位为T0，清0</span></span><br><span class="line">    TMOD|=<span class="number">0x01</span>;<span class="comment">//0000 0001 选择为定时器0模式，工作方式1，使用或运算可以不干扰高四位</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//给定时器赋初值，定时1ms</span></span><br><span class="line">    TH0=<span class="number">0xFC</span>;<span class="comment">//65536/256</span></span><br><span class="line">    TL0=<span class="number">0x18</span>;<span class="comment">//65536%256</span></span><br><span class="line">    </span><br><span class="line">    ET0=<span class="number">1</span>;<span class="comment">//打开定时器0中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">    </span><br><span class="line">    TR0=<span class="number">1</span>;<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  TIM1初始化 工作方式1</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM1_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">TMOD&amp;=<span class="number">0x0F</span>;<span class="comment">//0000 1111 高4位为T1，清0，低4位为T0，保持不变</span></span><br><span class="line">    TMOD|=<span class="number">0x10</span>;<span class="comment">//0001 0000 选择为定时器0模式，工作方式1，使用或运算可以不干扰高四位</span></span><br><span class="line">    </span><br><span class="line">    TH1=<span class="number">0xFC</span>;<span class="comment">//给定时器赋初值，定时1ms</span></span><br><span class="line">    TL1=<span class="number">0x18</span>;</span><br><span class="line">    </span><br><span class="line">    ET1=<span class="number">1</span>;<span class="comment">//打开定时器0中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">    </span><br><span class="line">    TR1=<span class="number">1</span>;<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  TIM0中断服务函数</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//用户代码</span></span><br><span class="line"><span class="comment">//若为工作方式1 每次进入中断需要重装载初值</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> cnt=<span class="number">0</span>;<span class="comment">//若不定义为static 下次重新调用后cnt又被初始化变成0了</span></span><br><span class="line"></span><br><span class="line">TH0=<span class="number">0xFC</span>;<span class="comment">//TIM0不会自动重装载 当溢出进入中断后需要我们手动装载 </span></span><br><span class="line">    TL0=<span class="number">0x18</span>;</span><br><span class="line"></span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span>(cnt==<span class="number">1000</span>)<span class="comment">//500ms</span></span><br><span class="line">&#123;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">Sec++;</span><br><span class="line"><span class="keyword">if</span>(Sec&gt;=<span class="number">60</span>)</span><br><span class="line">&#123;</span><br><span class="line">Sec=<span class="number">0</span>;</span><br><span class="line">Min++;</span><br><span class="line"><span class="keyword">if</span>(Min&gt;=<span class="number">60</span>)</span><br><span class="line">&#123;</span><br><span class="line">Min=<span class="number">0</span>;</span><br><span class="line">Hour++;</span><br><span class="line"><span class="keyword">if</span>(Hour&gt;=<span class="number">24</span>)</span><br><span class="line">&#123;</span><br><span class="line">Hour=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  TIM1中断服务函数</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM1</span><span class="params">()</span> interrupt 3</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//用户代码</span></span><br><span class="line"><span class="comment">//若为工作方式1 每次进入中断需要重装载初值</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> cnt=<span class="number">0</span>;<span class="comment">//若不定义为static 下次重新调用后cnt又被初始化变成0了</span></span><br><span class="line"></span><br><span class="line">TH1=<span class="number">0xFC</span>;<span class="comment">//方式1不会自动重装载 当溢出进入中断后需要我们手动装载 </span></span><br><span class="line">    TL1=<span class="number">0x18</span>;</span><br><span class="line"></span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span>(cnt==<span class="number">500</span>)<span class="comment">//0.5s</span></span><br><span class="line">&#123;</span><br><span class="line">LED2=!LED2;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h2><h3 id="直流电机"><a href="#直流电机" class="headerlink" title="直流电机"></a>直流电机</h3><p>​                                                          <img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250115232126933-1737001575563-4.png" alt="image-20250115232126933"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250115232431896-1737001584226-6.png" alt="image-20250115232431896" style="zoom:30%;"></p><p>直流有刷电机主要由永磁体（定子），线圈（转子），换向器组成；直流无刷电机主要由永磁体（转子），绕组线圈（定子），少了碳刷和换向器的摩擦。</p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250115234253196-1737001617581-8.png" alt="image-20250115234253196" style="zoom:67%;"><h3 id="PWM介绍"><a href="#PWM介绍" class="headerlink" title="PWM介绍"></a>PWM介绍</h3><p>​电机调速不能和LED呼吸灯一样接一个滑动变阻器就完事，因为在驱动电机的过程中会产生很大电流，对于电机来说会转化为机械能没事，但对于滑动变阻器，电流会转化为热能使其损坏。</p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116095501121-1737001653249-10.png" alt="image-20250116095501121" style="zoom:67%;"><p>最新的单片机TIM定时器都有输出PWM的功能，但STC89C52没有，我们用定时器中断来实现，同时也会方便后面学习其它单片机的理解。 </p><h3 id="实验1：LED呼吸灯"><a href="#实验1：LED呼吸灯" class="headerlink" title="实验1：LED呼吸灯"></a>实验1：LED呼吸灯</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;INTRINS.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED P2_0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Time,i;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(Time=<span class="number">0</span>;Time&lt;<span class="number">100</span>;Time++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">LED=<span class="number">0</span>;</span><br><span class="line">Delay_us(Time);</span><br><span class="line">LED=<span class="number">1</span>;</span><br><span class="line">Delay_us(<span class="number">100</span>-Time);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Time=<span class="number">100</span>;Time&gt;<span class="number">0</span>;Time--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">LED=<span class="number">0</span>;</span><br><span class="line">Delay_us(Time);</span><br><span class="line">LED=<span class="number">1</span>;</span><br><span class="line">Delay_us(<span class="number">100</span>-Time);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实验2：直流电机调速"><a href="#实验2：直流电机调速" class="headerlink" title="实验2：直流电机调速"></a>实验2：直流电机调速</h3><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116113208512-1737001671482-14.png" alt="image-20250116113208512"></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116120658461-1737001679357-16.png" alt="image-20250116120658461"></p><p><strong>该结构与最新单片机TIM定时器PWM硬件结构相似，在这里我们用软件来模拟这一结构：</strong></p><p>​<strong>首先配置定时器，每100us进一次定时器中断，每次进入中断后计数器（Counter）+1，同时与比较值(Compare)比较，若Counter&lt;Compare,置高电平，反之置低电平，在这里设置计数器最大到100后清0，pwm周期：100us*100&#x3D;10ms ，若pwm频率过小则电机会出现抖动（频繁启动停止），故我们要让pwm频率取到一个相对大的值，这时就可等效的获得所需要的模拟参量</strong></p><p><strong>定时器的作用就在于生成周期为T，每个周期内高电平持续时间为Compare的波形</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tim.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;INTRINS.H&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1 P2_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2 P2_1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOTOR P1_0</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LedMode=<span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Counter,Compare=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  TIM0初始化 100us@12.000HZ</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">TMOD&amp;=<span class="number">0xF0</span>;<span class="comment">//1111 0000 高4位为T1，保持不变，低4位为T0，清0</span></span><br><span class="line">    TMOD|=<span class="number">0x01</span>;<span class="comment">//0000 0001 选择为定时器0模式，工作方式1，使用或运算可以不干扰高四位</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//给定时器赋初值，定时100us</span></span><br><span class="line">    TH0=<span class="number">0xFF</span>;</span><br><span class="line">    TL0=<span class="number">0x9C</span>;</span><br><span class="line">    </span><br><span class="line">    ET0=<span class="number">1</span>;<span class="comment">//打开定时器0中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">    </span><br><span class="line">    TR0=<span class="number">1</span>;<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  TIM0中断服务函数</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//用户代码</span></span><br><span class="line"><span class="comment">//若为工作方式1 每次进入中断需要重装载初值</span></span><br><span class="line">    TH0=<span class="number">0xFF</span>;</span><br><span class="line">    TL0=<span class="number">0x9C</span>;</span><br><span class="line"><span class="comment">//Compare=50;</span></span><br><span class="line"></span><br><span class="line">Counter++;<span class="comment">//计数器</span></span><br><span class="line"><span class="keyword">if</span>(Counter&gt;=<span class="number">100</span>)Counter=<span class="number">0</span>;<span class="comment">//pwm周期：100us*100=10ms</span></span><br><span class="line"><span class="keyword">if</span>(Counter&lt;Compare)</span><br><span class="line">&#123;</span><br><span class="line">LED1=<span class="number">0</span>;</span><br><span class="line">MOTOR=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LED1=<span class="number">1</span>;</span><br><span class="line">MOTOR=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nixietube.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeyNum=<span class="number">0</span>,Speed=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> Compare;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">P2=<span class="number">0xfe</span>;</span><br><span class="line">    TIM0_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">KeyNum=Key();</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Speed++;</span><br><span class="line"><span class="keyword">if</span>(Speed&gt;=<span class="number">4</span>)Speed=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (Speed)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">Compare=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">Compare=<span class="number">60</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">Compare=<span class="number">80</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">Compare=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">NixieTube(<span class="number">1</span>,Speed);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="串口通信（重要）"><a href="#串口通信（重要）" class="headerlink" title="串口通信（重要）"></a>串口通信（重要）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116193708797.png" alt="image-20250116193708797" style="zoom:67%;"><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116224704361.png" alt="image-20250116224704361"></p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116194452836.png" alt="image-20250116194452836" style="zoom:60%;"><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116194922886.png" alt="image-20250116194922886"></p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116200105907.png" alt="image-20250116200105907" style="zoom:67%;"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116200845182.png" alt="image-20250116200845182" style="zoom:67%;"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116201908921.png" alt="image-20250116201908921" style="zoom:67%;"><h3 id="串口参数及时序图"><a href="#串口参数及时序图" class="headerlink" title="串口参数及时序图"></a>串口参数及时序图</h3><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116204330274.png" alt="image-20250116204330274"></p><p>通常用的串口传输格式为：1bit起始位+8bit数据位+1bit停止位(无奇偶校验位)</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116204353526.png" alt="image-20250116204353526"></p><p><strong>波特率</strong>：每秒钟传输二进制位数 eg:波特率为115200即1s传输二进制的位数115200个</p><p><strong>比特率</strong>：每秒钟传送二进制有效数据的位数，表示有效数据的传输速率。</p><p><strong>计算波特率和比特率</strong></p><p>例：在异步串行传输系统中，字符格式为：1个起始位，8个数据位、1个校验位、2个终止位。若要求每秒传送120个字符，试求传送的波特率和比特率。<br>解答：<br>根据题目给出的字符格式，有效数据为8位，一帧包含1+8+1+2&#x3D;12位</p><p>故波特率为：120*(1+8+1+2)&#x3D;1440 bps&#x3D;1440波特</p><p>又因为有效数据位为8位，而传送一个字符需1+8+1+2&#x3D;12位</p><p>故比特率为：1440*(8&#x2F;12)&#x3D;960 bps</p><p>(比特率还可以直接求：8*120&#x3D;960 bps) </p><h3 id="串口内部收发原理"><a href="#串口内部收发原理" class="headerlink" title="串口内部收发原理"></a>串口内部收发原理</h3><p>讲解视频：<a href="https://www.bilibili.com/video/BV1344y1M7pH/?spm_id_from=333.337.search-card.all.click&vd_source=a9d487fcf1a579639c6348eb5a9321db">https://www.bilibili.com/video/BV1344y1M7pH/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a9d487fcf1a579639c6348eb5a9321db</a></p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116232539779.png" alt="image-20250116232539779" style="zoom:70%;"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116212523392.png" alt="image-20250116212523392" style="zoom:70%;"><h3 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h3><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116212614576.png" alt="image-20250116212614576" style="zoom:67%;"><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116231436451.png" alt="image-20250116231436451"></p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116231600175.png" alt="image-20250116231600175" style="zoom:50%;"><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250117103834727.png" alt="image-20250117103834727"></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250117103847263.png" alt="image-20250117103847263"></p><p>注意是发送&#x2F;接收第8位后才置1</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250117124935563.png" alt="image-20250117124935563"></p><h3 id="工作方式，波特率"><a href="#工作方式，波特率" class="headerlink" title="工作方式，波特率"></a>工作方式，波特率</h3><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250121120807323.png" alt="image-20250121120807323"></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116232458199.png" alt="image-20250116232458199"></p><p><strong>T1溢出率：</strong>T1每秒溢出的次数,即1&#x2F;(T1的定时时间)，T1定时时间&#x3D;(12&#x2F;fosc)*(2^N-初值)，12&#x2F;fosc是计一次数的时间</p><p>定时&#x2F;计数器T1是串口通信的波特率发生器，此时通常将T1设置为定时器且工作于<strong>工作方式2</strong>(<strong>自动重装初值的8位定时器</strong>)（自动重装载，省去了每次进中断赋值的时间，定时更加准确），并屏蔽其中断。<strong>T1溢出率是T1每秒钟溢出的次数，该次数与T1的初值有关。</strong>若假设T1的初值为M，则T1相邻两次溢出之间的时间间隔为(256-M)&#x2F;(12&#x2F;fosc)，因此</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/58caac6bdf57efa70cc84d3c8cb6749b.png" alt="img"></p><p>式中，fosc为单片机的晶振频率。</p><p>9600 &#x3D; (2^SMOD &#x2F; 32) * 11059200 &#x2F; [12 *(256 - TH1)] </p><p>9600 &#x3D; (1 &#x2F; 32) * 921600 &#x2F; (256 - TH1)</p><p>9600 &#x3D; 28800 &#x2F; (256 - TH1)</p><p>TH1&#x3D;253 </p><h4 id="将十进制数-253-转换为十六进制"><a href="#将十进制数-253-转换为十六进制" class="headerlink" title="将十进制数 253 转换为十六进制"></a>将十进制数 253 转换为十六进制</h4><ol><li><strong>253 ÷ 16 &#x3D; 15</strong>，余数为 <strong>13</strong>（十六进制中 13 对应 ‘D’）。</li><li><strong>15 ÷ 16 &#x3D; 0</strong>，余数为 <strong>15</strong>（十六进制中 15 对应 ‘F’）。</li><li>将余数倒序排列，得到 <strong>FD</strong>。</li></ol><p>所以，十进制数 253 的十六进制表示为 <strong>0xFD</strong>。</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250117162856863.png" alt="image-20250117162856863"></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250117112621096.png" alt="image-20250117112621096"></p><p>最高波特率就是要让定时计数器溢出的尽可能快，技术次数N&#x3D;1，初值为255</p><p>最低波特率就是要让定时计数器溢出的尽可能慢，计数次数N&#x3D;256，初值为0</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250117130909760.png" alt="image-20250117130909760"></p><p>有误差是因为晶振是12MHZ，当晶振是11.0592MHZ时误差才为0，此时波特率越大误差越大</p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116233150040.png" alt="image-20250116233150040" style="zoom:67%;"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116233336581.png" alt="image-20250116233336581" style="zoom:67%;"><p>RI&#x3D;1丢弃数据是因为此时接收SBUF已经满了但是还没有传递到总线上，如果此时继续写入数据则会破坏原来收好的一包。</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250116233444506.png" alt="image-20250116233444506"></p><h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><p><strong>1.初始化：</strong></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250117102346667.png" alt="image-20250117102346667"></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250117102159872.png" alt="image-20250117102159872"></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250117104622207.png" alt="image-20250117104622207"></p><p>N即定时器计数次数，最大计数-N即T1初值</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250117110400970.png" alt="image-20250117110400970"></p><p>乙机可用始终查询或者中断的方式接收</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250117111013792.png" alt="image-20250117111013792"></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250117111424043.png" alt="image-20250117111424043"></p><h4 id="实验：串口助手发给单片机，单片机再传回串口助手"><a href="#实验：串口助手发给单片机，单片机再传回串口助手" class="headerlink" title="实验：串口助手发给单片机，单片机再传回串口助手"></a>实验：串口助手发给单片机，单片机再传回串口助手</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  晶振11.0592MHZ</span></span><br><span class="line"><span class="comment">  * @param  ival 定时器初值</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ival)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//配置串口寄存器</span></span><br><span class="line">SCON=<span class="number">0x50</span>;</span><br><span class="line">PCON=<span class="number">0x70</span>;<span class="comment">//波特率不加倍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置波特率（配置定时器1）</span></span><br><span class="line">TMOD&amp;=<span class="number">0x0F</span>;</span><br><span class="line">TMOD|=<span class="number">0x20</span>;<span class="comment">//0010 0000 方式2 8位自动重装定时/计数器 自动重装载无需软件赋初值（会占用时间）,所以定时更加准确 用于串口波特率配置 </span></span><br><span class="line">TH1=ival;</span><br><span class="line">TL1=ival;</span><br><span class="line"></span><br><span class="line">ET1=<span class="number">0</span>;<span class="comment">//禁止定时器中断</span></span><br><span class="line">ES=<span class="number">1</span>;<span class="comment">//打开串口接收中断</span></span><br><span class="line">EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line"></span><br><span class="line">TR1=<span class="number">1</span>;<span class="comment">//打开定时器 TCON寄存器中的一位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个字节的数据到SBUF中，写入后会由硬件自动完成发送，发送完成后硬件会把TI置1,需要软件清0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Byte)</span></span><br><span class="line">&#123;</span><br><span class="line">SBUF=Byte;    <span class="comment">//向缓存器中写入数据</span></span><br><span class="line"><span class="keyword">while</span>(!TI); <span class="comment">//等待是否完成</span></span><br><span class="line">TI=<span class="number">0</span>;         <span class="comment">//复位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_SendString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *str)</span><span class="comment">//参数是指针</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(*str !=<span class="string">&#x27;\0&#x27;</span> )  <span class="comment">//字符串是以\0结尾的</span></span><br><span class="line">&#123;</span><br><span class="line">UART_SendByte(*str);</span><br><span class="line">str++;  <span class="comment">//地址加1.依次发送</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart</span><span class="params">()</span> interrupt 4</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> rec_data=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(RI==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">RI=<span class="number">0</span>;<span class="comment">//清零RI </span></span><br><span class="line"><span class="comment">//一个一个字节接收一个一个字节发送</span></span><br><span class="line">rec_data=SBUF;<span class="comment">//读取SBUF数据存到rec_data</span></span><br><span class="line">UART_SendByte(rec_data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单片机系统的并行扩展"><a href="#单片机系统的并行扩展" class="headerlink" title="单片机系统的并行扩展"></a>单片机系统的并行扩展</h2><h3 id="51单片机最小系统"><a href="#51单片机最小系统" class="headerlink" title="51单片机最小系统"></a>51单片机最小系统</h3><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250118111210550.png" alt="image-20250118111210550"></p><p>​                             <img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250118112145181.png" alt="image-20250118112145181" style="zoom:67%;"></p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250118113116918.png" alt="image-20250118113116918" style="zoom:67%;"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250118113156726.png" alt="image-20250118113156726" style="zoom:70%;"><h3 id="存储器扩展"><a href="#存储器扩展" class="headerlink" title="存储器扩展"></a>存储器扩展</h3><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250118114104519.png" alt="image-20250118114104519" style="zoom:67%;"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250118114937463.png" alt="image-20250118114937463" style="zoom:67%;"><p>​                                   <img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250118120734977.png" alt="image-20250118120734977"></p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250118120944559.png" alt="image-20250118120944559" style="zoom:67%;"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250118121225752.png" alt="image-20250118121225752" style="zoom:67%;"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250118121405652.png" alt="image-20250118121405652" style="zoom:67%;"><h4 id="程序存储器扩展"><a href="#程序存储器扩展" class="headerlink" title="程序存储器扩展"></a>程序存储器扩展</h4><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250118121605765.png" alt="image-20250118121605765"></p><p>简化画法：</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250118122226965.png" alt="image-20250118122226965"></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250118122545598.png" alt="image-20250118122545598"></p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250118122635779.png" alt="image-20250118122635779" style="zoom:67%;"><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250118122838242.png" alt="image-20250118122838242" style="zoom:67%;"><h4 id="数据存储器扩展"><a href="#数据存储器扩展" class="headerlink" title="数据存储器扩展"></a>数据存储器扩展</h4><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250118123057700.png" alt="image-20250118123057700" style="zoom:67%;"><h1 id="2024期末题"><a href="#2024期末题" class="headerlink" title="2024期末题"></a>2024期末题</h1><h2 id="1-外部中断"><a href="#1-外部中断" class="headerlink" title="1.外部中断"></a>1.外部中断</h2><p>​如下图所示，在单片机P1口上接有8只LED，全灭。在<strong>外部中断1</strong>输入引脚（P3.3）接一只按钮开关K1，每按一次按钮开关K1，使外部中断1引脚接地，产生一个<strong>低电平触发</strong>的外部中断请求。在中断服务程序中，使低4位的LED保持灭，高4位的LED亮，如此交替闪烁10次。然后从中断程序返回，控制8只LED全亮。请补充完整下列程序的主函数main()和终端服务程序int1()。</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250121100953889.png" alt="image-20250121100953889"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K1 P3_3</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">333</span>;j++)</span><br><span class="line">    &#123;;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//开总中断</span></span><br><span class="line">    EX1=<span class="number">1</span>;<span class="comment">//开外部中断1</span></span><br><span class="line">    IT1=<span class="number">0</span>;<span class="comment">//低电平触发</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P1=<span class="number">0x00</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">int1</span><span class="params">()</span> interrupt 2</span><br><span class="line">&#123;</span><br><span class="line">    uchar m;</span><br><span class="line">    EX1=<span class="number">0</span>;<span class="comment">//关闭外部中断1</span></span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;<span class="number">10</span>;m++)</span><br><span class="line">    &#123;</span><br><span class="line">        P1=<span class="number">0x0f</span>;</span><br><span class="line">        Delay(<span class="number">500</span>);</span><br><span class="line">        P1=<span class="number">0xf0</span>;</span><br><span class="line">        Delay(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     EX1=<span class="number">1</span>;<span class="comment">//开启外部中断1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><p>1.LED是低电平点亮</p><p>2.外部中断1：中断号为2    低电平触发：IT1&#x3D;0；</p><p>3.进入中断程序后EX1&#x3D;0;是为了关闭外部中断1，此时再按按键没用，直到中断函数中执行完毕后，再令EX1&#x3D;1;</p><p>4.若头文件为REGX52.H，可以用P3_3,在头文件已经定义了P3_3，若为reg52.h，头文件只定义了P3，操控第三位的话是P3^3, 可令sbit key&#x3D;P3^3;</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250121102557365.png" alt="image-20250121102557365"></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250121102614909.png" alt="image-20250121102614909"></p><p>INT1的IT1决定外部中断1是下降沿触发还是低电平触发（外部中断1输入引脚接的是按键，当按键按下，引脚接地，低电平触发外部中断，进入中断服务程序），IE1是中断标志位（当中断源到来时由单片机自动置1），EX1，为外部中断1控制开关，EA为全局总中断控制开关，IP是用来设置中断优先级，默认是0，不用管。</p><h2 id="2-串口双机通信"><a href="#2-串口双机通信" class="headerlink" title="2.串口双机通信"></a>2.串口双机通信</h2><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250121114919014.png" alt="image-20250121114919014"></p><p>题目分析：</p><p>1.编写甲机在定时&#x2F;计数器T1工作在<strong>方式2</strong>下的串口方式<strong>1</strong>的发送程序，晶振位11.0592MHZ,波特率为9600bit&#x2F;s</p><p>2.甲机只能发送，<strong>不能接收</strong></p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250114101345916.png" alt="image-20250114101345916" style="zoom:50%;"><p>定时器工作方式2：自动重装载（初值），用于串口波特率</p><p>将TL1,TH1赋为相同的初值，当TL1溢出后自动将TH1的值赋值给TL1</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250121120821775.png" alt="image-20250121120821775"></p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250121115638729.png" alt="image-20250121115638729"></p><p>串口工作方式1：8位的异步通信方式，通常用于双机通信</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250121121758633.png" alt="image-20250121121758633"></p><p>波特率计算</p><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250121190558887.png" alt="image-20250121190558887"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> temp=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*配置串口寄存器*/</span></span><br><span class="line"><span class="comment">//Serial Control 串行控制寄存器 可位寻址 SM0 SM1 SM2 REN TB8 RB8 TI RI</span></span><br><span class="line">SCON=<span class="number">0x40</span>;<span class="comment">//工作方式1（SM0 0 SM1 1） 禁止串口接收(REN 0) 0100 0000 = 0X40</span></span><br><span class="line"><span class="comment">//Power Control 波特率选择寄存器 不可位寻址 SMOD SMOD0 - POF GF1 GF0 PD IDL</span></span><br><span class="line">PCON=<span class="number">0x00</span>;<span class="comment">//波特率不加倍 (SMOD 0) 其余位也全为0 其实可以不用配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置波特率（配置定时器1）*/</span></span><br><span class="line"><span class="comment">//Timer Mode Register 定时器模式寄存器 GATE C/T M1 M0 GATE C/T M1 M0</span></span><br><span class="line">TMOD&amp;=<span class="number">0x0F</span>;<span class="comment">//清楚定时器1模式位 定时器0模式位不变</span></span><br><span class="line">TMOD|=<span class="number">0x20</span>;<span class="comment">//0010 0000 方式2 </span></span><br><span class="line">TH1=<span class="number">0xfd</span>;</span><br><span class="line">TL1=<span class="number">0xfd</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断</span></span><br><span class="line">ET1=<span class="number">0</span>;<span class="comment">//禁止定时器中断</span></span><br><span class="line">ES=<span class="number">1</span>;<span class="comment">//打开串口接收中断</span></span><br><span class="line">EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line"></span><br><span class="line">TR1=<span class="number">1</span>;<span class="comment">//打开定时器 TCON寄存器中的一位</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp=P3;</span><br><span class="line">SBUF=temp;</span><br><span class="line"><span class="keyword">while</span>(!TI);</span><br><span class="line">TI=<span class="number">0</span>;</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-写数据到片内片外RAM"><a href="#3-写数据到片内片外RAM" class="headerlink" title="3.写数据到片内片外RAM"></a>3.写数据到片内片外RAM</h2><p>​编写C51程序，记录函数(x+1)^2的值（x&#x3D;0到19），将函数值存入片内RAM的30H为首地址的连续单元中，再将个位数不为6的函数值读入到片外RAM以1000H为首地址的连续单元中，并在屏幕上显示个位数不为6的函数值的个数。</p><p>答案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line">xdata <span class="type">unsigned</span> <span class="type">int</span> buffer[<span class="number">20</span>]_at_0x1000H;</span><br><span class="line">data <span class="type">unsigned</span> <span class="type">int</span> buf[<span class="number">20</span>]_at_0x30H;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        buf=(i+<span class="number">1</span>)*(i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(buf[i]%<span class="number">10</span>!=<span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">         buffer[j++]=buf[i];   </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;j&quot;</span>,%d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PS:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">xdata <span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">256</span>] _at_0x5000;</span><br><span class="line"><span class="comment">/*xdata</span></span><br><span class="line"><span class="comment">    xdata 是 8051 单片机 中的一个存储类型修饰符，表示变量存储在 外部数据存储器（External Data Memory） 中。</span></span><br><span class="line"><span class="comment">    8051 单片机的内存分为多个区域：</span></span><br><span class="line"><span class="comment">        data：内部 RAM（128 字节）。</span></span><br><span class="line"><span class="comment">        idata：间接寻址的内部 RAM（256 字节）。</span></span><br><span class="line"><span class="comment">        xdata：外部扩展的 RAM（最大 64KB）。</span></span><br><span class="line"><span class="comment">    使用 xdata 表示这个数组将存储在外部 RAM 中。*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">_at_ 0x5000</span></span><br><span class="line"><span class="comment">    _at_ 是一个编译器特定的关键字（例如 Keil C51 编译器），用于将变量或数组放置在 指定的内存地址。</span></span><br><span class="line"><span class="comment">    0x5000 是内存地址的十六进制表示，表示数组 databuf 将从外部 RAM 的 0x5000 地址开始存储。</span></span><br><span class="line"><span class="comment">    由于数组大小为 256 字节，因此 databuf 将占用从 0x5000 到 0x50FF 的内存空间。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250122112113101.png" alt="image-20250122112113101"></p><h2 id="4-动态数码管"><a href="#4-动态数码管" class="headerlink" title="4.动态数码管"></a>4.动态数码管</h2><p><img src="/2025/01/14/KEIL%E4%BD%BF%E7%94%A8/image-20250122085339251.png" alt="image-20250122085339251"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：</span><br><span class="line"><span class="number">0x01</span>；</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)；</span><br><span class="line">i&lt;<span class="number">3</span>；</span><br><span class="line">(_crol_(j,<span class="number">1</span>))&amp;<span class="number">0x07</span>     <span class="comment">//0x07将j的值限制在0x01 0x02 0x04之间 因为题目只有三个数码管</span></span><br></pre></td></tr></table></figure><p>在c语言中，尤其是单片机的<a href="https://so.csdn.net/so/search?q=C51&spm=1001.2101.3001.7020">C51</a>中，移位运算操作很常见。实现移位操作的方法有两种：一是利用<strong>移位运算符</strong>，二是利用<strong>移位函数</strong>。</p><p>区别：</p><p>1.移位运算符，是系统内置的运算操作，编译编译不用包含相关头文件；而移位函数编译要包含<strong>intrins.h</strong>头文件。</p><p>2.&lt;&lt;和&gt;&gt;的移位规则数据从一端移动到另外一端，数据尾部移走后会补0，数据头部移到最前端后会<strong>溢出</strong>，溢出的数据就<strong>被抹掉</strong>了。<br> _crol_等函数是是循环移位，<strong>首位相接</strong>，数据前端移动到尾部后，会从尾部再次进入队列，数据<strong>不会溢出</strong>。运算符是<strong>线性队列</strong>，循环移位函数是<strong>环形队列</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> _crol_ (</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> c,        <span class="comment">/* 要被进行 位左移 的形式参数 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> b);       <span class="comment">/* 要进行的 位移数 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>此题我觉得有点问题，一方面是它段码表{0xf9,0xa4,0xb0}一般共阳极来说确实表示的是1，2，3，但是带到图中却表示的并不是1，2，3,不过这个不影响做题</strong></p><p><strong>第二方面是他说的左边第一个，左边第二个，左边第三个，是不是从左起的意思，这样的话文档里的答案是有问题的它是0x01，也就是从最右边第一个开始，依次向左。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webots&amp;python</title>
      <link href="/2024/02/19/Webots-python/"/>
      <url>/2024/02/19/Webots-python/</url>
      
        <content type="html"><![CDATA[<p>首先是可以从报错内容看到提示指定的python版本，由于是新电脑，压根还没装python，所以先去官网下载了一下</p><p>然后文件报错:</p><p>ModuleNotFoundError: No module named ‘protobot’  意思应该是没有protobot这个python包</p><p>然后我在下载的文件夹里的电机驱动函数库找到了protobot这个文件夹,然后把它放到了webots工程里，</p><p><img src="/2024/02/19/Webots-python/image-20240219224457877.png" alt="image-20240219224457877"></p><p>在readme文件里看到安装它的方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd src </span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><p>按照上面的输入，然后出现下面报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Installing build dependencies ... error</span><br><span class="line">  error: subprocess-exited-<span class="keyword">with</span>-error</span><br><span class="line"></span><br><span class="line">  × pip subprocess to install build dependencies did <span class="keyword">not</span> run successfully.</span><br><span class="line">  │ exit code: <span class="number">1</span></span><br><span class="line">  ╰─&gt; [<span class="number">8</span> lines of output]</span><br><span class="line">      WARNING: Retrying (Retry(total=<span class="number">4</span>, connect=<span class="literal">None</span>, read=<span class="literal">None</span>, redirect=<span class="literal">None</span>, status=<span class="literal">None</span>)) after connection broken by <span class="string">&#x27;SSLError(SSLEOFError(8, &#x27;</span>EOF occurred <span class="keyword">in</span> violation of protocol (_ssl.c:<span class="number">1122</span>)<span class="string">&#x27;))&#x27;</span>: /simple/setuptools/</span><br><span class="line">      WARNING: Retrying (Retry(total=<span class="number">3</span>, connect=<span class="literal">None</span>, read=<span class="literal">None</span>, redirect=<span class="literal">None</span>, status=<span class="literal">None</span>)) after connection broken by <span class="string">&#x27;SSLError(SSLEOFError(8, &#x27;</span>EOF occurred <span class="keyword">in</span> violation of protocol (_ssl.c:<span class="number">1122</span>)<span class="string">&#x27;))&#x27;</span>: /simple/setuptools/</span><br><span class="line">      WARNING: Retrying (Retry(total=<span class="number">2</span>, connect=<span class="literal">None</span>, read=<span class="literal">None</span>, redirect=<span class="literal">None</span>, status=<span class="literal">None</span>)) after connection broken by <span class="string">&#x27;SSLError(SSLEOFError(8, &#x27;</span>EOF occurred <span class="keyword">in</span> violation of protocol (_ssl.c:<span class="number">1122</span>)<span class="string">&#x27;))&#x27;</span>: /simple/setuptools/</span><br><span class="line">      WARNING: Retrying (Retry(total=<span class="number">1</span>, connect=<span class="literal">None</span>, read=<span class="literal">None</span>, redirect=<span class="literal">None</span>, status=<span class="literal">None</span>)) after connection broken by <span class="string">&#x27;SSLError(SSLEOFError(8, &#x27;</span>EOF occurred <span class="keyword">in</span> violation of protocol (_ssl.c:<span class="number">1122</span>)<span class="string">&#x27;))&#x27;</span>: /simple/setuptools/</span><br><span class="line">      WARNING: Retrying (Retry(total=<span class="number">0</span>, connect=<span class="literal">None</span>, read=<span class="literal">None</span>, redirect=<span class="literal">None</span>, status=<span class="literal">None</span>)) after connection broken by <span class="string">&#x27;SSLError(SSLEOFError(8, &#x27;</span>EOF occurred <span class="keyword">in</span> violation of protocol (_ssl.c:<span class="number">1122</span>)<span class="string">&#x27;))&#x27;</span>: /simple/setuptools/</span><br><span class="line">      Could <span class="keyword">not</span> fetch URL https://pypi.org/simple/setuptools/: There was a problem confirming the ssl certificate: HTTPSConnectionPool(host=<span class="string">&#x27;pypi.org&#x27;</span>, port=<span class="number">443</span>): Max retries exceeded <span class="keyword">with</span> url: /simple/setuptools/ (Caused by SSLError(SSLEOFError(<span class="number">8</span>, <span class="string">&#x27;EOF occurred in violation of protocol (_ssl.c:1122)&#x27;</span>))) - skipping</span><br><span class="line">      ERROR: Could <span class="keyword">not</span> find a version that satisfies the requirement setuptools&gt;=<span class="number">40.8</span><span class="number">.0</span> (<span class="keyword">from</span> versions: none)</span><br><span class="line">      ERROR: No matching distribution found <span class="keyword">for</span> setuptools&gt;=<span class="number">40.8</span><span class="number">.0</span></span><br><span class="line">      [end of output]</span><br><span class="line"></span><br><span class="line">  note: This error originates <span class="keyword">from</span> a subprocess, <span class="keyword">and</span> <span class="keyword">is</span> likely <span class="keyword">not</span> a problem <span class="keyword">with</span> pip.</span><br><span class="line">error: subprocess-exited-<span class="keyword">with</span>-error</span><br><span class="line"></span><br><span class="line">× pip subprocess to install build dependencies did <span class="keyword">not</span> run successfully.</span><br><span class="line">│ exit code: <span class="number">1</span></span><br><span class="line">╰─&gt; See above <span class="keyword">for</span> output.</span><br><span class="line"></span><br><span class="line">note: This error originates <span class="keyword">from</span> a subprocess, <span class="keyword">and</span> <span class="keyword">is</span> likely <span class="keyword">not</span> a problem <span class="keyword">with</span> pip.</span><br></pre></td></tr></table></figure><p>然后我问chatgpt，它列出的原因里有一条说可能是代理的原因，然后我把梯子关了，报错少了很多:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> Installing build dependencies ... error</span><br><span class="line">  error: subprocess-exited-with-error</span><br><span class="line"></span><br><span class="line">  × pip subprocess to install build dependencies did not run successfully.</span><br><span class="line">  │ <span class="built_in">exit</span> code: <span class="number">1</span></span><br><span class="line">  ╰─&gt; [<span class="number">2</span> lines of output]</span><br><span class="line">      ERROR: Could not find a version that satisfies the requirement setuptools&gt;=<span class="number">40.8</span><span class="number">.0</span> (from versions: none)</span><br><span class="line">      ERROR: No matching distribution found <span class="keyword">for</span> setuptools&gt;=<span class="number">40.8</span><span class="number">.0</span></span><br><span class="line">      [end of output]</span><br><span class="line"></span><br><span class="line">  note: This error originates from a subprocess, and is likely not a problem with pip.</span><br><span class="line">error: subprocess-exited-with-error</span><br><span class="line"></span><br><span class="line">× pip subprocess to install build dependencies did not run successfully.</span><br><span class="line">│ <span class="built_in">exit</span> code: <span class="number">1</span></span><br><span class="line">╰─&gt; See above <span class="keyword">for</span> output.        我把梯子关了之后还剩这些报错</span><br></pre></td></tr></table></figure><p>继续问chatgpt，回答说</p><p><img src="/2024/02/19/Webots-python/image-20240219225116935.png" alt="image-20240219225116935"></p><p>先是pip install –upgrade setuptools，然后还是报错，然后使用清华大学镜像，pip install setuptools -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%B1Ok%E4%BA%86%E3%80%82%E6%8E%A5%E7%9D%80%E5%B0%B1%E7%BB%A7%E7%BB%AD%E5%89%8D%E9%9D%A2%E7%9A%84cd">https://pypi.tuna.tsinghua.edu.cn/simple，然后就Ok了。接着就继续前面的cd</a> src , pip install -e .就可以正常安装这个protobot包了，中间电脑不要熄屏，以免下载中断报错，得重新再下载。</p><p>这样，这个webots工程就正常跑起来了，这次问题的原因主要还是自己对python环境的不熟悉，安装python包都不知道怎么装。</p><p><img src="/2024/02/19/Webots-python/image-20240219225436046.png" alt="image-20240219225436046"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webots报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2024/02/03/%E9%98%9F%E5%88%97/"/>
      <url>/2024/02/03/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="http://t.csdnimg.cn/DY7gy">http://t.csdnimg.cn/DY7gy</a></p><p><strong>环形缓冲区</strong>是<a href="https://so.csdn.net/so/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F&spm=1001.2101.3001.7020">嵌入式</a>系统中十分重要的一种数据结构，比如在<strong>串口</strong>处理中，串口中断接收数据直接往环形缓冲区丢数据，而应用可以从环形缓冲区取数据进行处理，这样数据在读取和写入的时候都可以在这个缓冲区里循环进行，程序员可以根据自己需要的数据大小来决定自己使用的缓冲区大小，<strong>不用担心数组越界</strong>。</p><p><img src="/2024/02/03/%E9%98%9F%E5%88%97/image-20240203112201743.png" alt="image-20240203112201743"></p><p><strong>队列</strong>的基本概念：队列 (Queue)：是一种先进先出(First In First Out ,简称 FIFO)的线性表，只允许在一端插入（入队），在另一端进行删除（出队）。</p><p>队列头就是指向已经存储的数据，并且这个数据是待处理的。下一个CPU处理的数据就是1；而队列尾则指向可以进行写数据的地址。</p><h2 id="队列是什么"><a href="#队列是什么" class="headerlink" title="队列是什么"></a><strong>队列是什么</strong></h2><p>队列是一种很常见的数据结构，满足先进先出的方式，如果我们设定队列的最大长度，那就意味着进队列和出队列的元素的数量实则满足一种动态平衡。</p><p>如果我们把首次添加入队列的元素作为一个一维坐标的原点，那么随着队列中元素的添加，坐标原点到队尾元素的长度会无穷无尽的增大，随这之前添入的元素不断出列，对头对应的下标点也在不断增大。这样，进队列和出队列的元素的数量就对应到对头和队尾下标点的移动</p><p>因此我们评判一个队列长度是否溢出原先约定的最大长度，实则就是在评判队尾坐标点与队头坐标点之间的差值，无论是出队列还是入队列，队头和队尾的坐标都在不断增大</p><p><img src="/2024/02/03/%E9%98%9F%E5%88%97/84497721b6c4413c8558e4266b886ddc.png" alt="img"></p><h2 id="front指针和rear指针的引入"><a href="#front指针和rear指针的引入" class="headerlink" title="front指针和rear指针的引入"></a><strong>front指针和rear指针的引入</strong></h2><p>虽然队尾和队头的下标在不断增大，但是我们对于队列的研究只需要局限在队头与队尾之间的元素，坐标原点到队头之间的元素已经算作出列元素，并不需要研究。因此我们不妨将队列在逻辑上放入一个事先设定容量的一维数组中，只要这个数组的容量是队列中元素的个数+1就行，为什么要这么设定待会再讲。我们想要达到的目的是，无论出列还是入列，本质上是通过修改数组中元素的值，那些已经出列的元素所在的下标位需要放置新入列的元素，并在逻辑上保证新入列元素位于队尾就行。</p><p>因此，我们不得不得引入头指针front和尾指针rear，对指针指向的数组下标对应空间进行操作，来修改数组中元素的值。</p><h2 id="front指针和rear指针的理解"><a href="#front指针和rear指针的理解" class="headerlink" title="front指针和rear指针的理解"></a><strong>front指针和rear指针的理解</strong></h2><p>front：初始值为0，对应索引位待出列，若当前指向的数组下标的元素要出列，则先执行出列动作(实际上不用操作，出列的索引位可以被新入队的元素覆盖)，随后front指针就要向后一位，即front++</p><p>rear：初始值为0，对应索引位待入列，若当前指向的数组下标有元素要入列，则先执行入列动作（索引位元素赋值），随后front指针就要向后一位，即rear++</p><h2 id="队列最大长度匹配数组容量导致一种错误的解决方案"><a href="#队列最大长度匹配数组容量导致一种错误的解决方案" class="headerlink" title="队列最大长度匹配数组容量导致一种错误的解决方案"></a>队列最大长度匹配数组容量导致一种错误的解决方案</h2><p>这就会有一个问题，随着队列中元素的不断更迭，front和rear很快就会超过数组容量，造成数组索引越界</p><p><img src="/2024/02/03/%E9%98%9F%E5%88%97/dd50472cf4ba4aad8fe5e565ccfe39de.png" alt="img"></p><p>比如上图所示，front&#x3D;2，也就是说已经有两个元素出列了，因此rear&#x3D;5与rear&#x3D;6对应的两个元素理应可以入列，但是我们发现数组maxsize&#x3D;5，不存在索引位5和6，强行对这两个下标赋值会造成索引越界异常indexOutException 。但是我们发现此时数组中索引位0和1都空着，完全可以将这两个位置利用起来，因此我们可以想办法让实际的rear值转化为等效的rear值，也就是是让rear&#x3D;5转化为rear&#x3D;0，同理rear6转化为rear&#x3D;1。怎么做到呢？无疑是通过取余！</p><p>每次新元素入队后， 执行rear&#x3D;(rear)%maxSize操作，随后执行rear++操作右移rear指针</p><p>像上图中的rear&#x3D;rear%5乍一看好像没问题，但实际上这种取余方式是有问题的，出现这种取余方式的根源在于我们想让队列最大长度与数组容量保持一致，下文会详细说明这种解决方案的错误之处。</p><h2 id="指针的往复移动：逻辑上的环形"><a href="#指针的往复移动：逻辑上的环形" class="headerlink" title="指针的往复移动：逻辑上的环形"></a>指针的往复移动：逻辑上的环形</h2><p>出队和入队的方向是从右向左，而front与rear指针的移动方向却是从左到右循环往复（指向数组末尾后按照取余算法又重置为数组开头），因此我们可以把单向数组在逻辑上理解成环形数组，指针的循环往复移动理解成按照顺时针或逆时针（只要规定某一方向就好）单向移动</p><p>  环形队列小知识：</p><p>  环形队列是在实际编程极为有用的数据结构,它有如下特点。</p><p>  它是一个首尾相连的FIFO的数据结构，采用数组的线性空间,数据组织简单。能很快知道队列是否满为空。能以很快速度的来存取数据。</p><p>   因为有简单高效的原因，甚至在硬件都实现了环形队列。 </p><p>   环形队列广泛用于网络数据收发，和不同程序间数据交换（比如内核与应用程序大量交换数据,从硬件接收大量数据）均使用了环形队列。</p><h2 id="队列为空的判别"><a href="#队列为空的判别" class="headerlink" title="队列为空的判别"></a>队列为空的判别</h2><p>我们怎么判断队列为空呢？</p><p>如果我们按照指针从左到右的方向移动，当front指针和rear指针重合时，front指针对应的索引位之前的索引位都已经出列完毕，而rear指针对应的索引位以及之后的所有索引位还未有元素入列。</p><p>所以队列是否为空的判别：front&#x3D;&#x3D;rear</p><p><img src="/2024/02/03/%E9%98%9F%E5%88%97/a053efb0385e4714b8889ecd98ba2d31.png" alt="img"></p><h2 id="rear-rear-maxSize解决方案的问题"><a href="#rear-rear-maxSize解决方案的问题" class="headerlink" title="rear&#x3D;rear%maxSize解决方案的问题"></a>rear&#x3D;rear%maxSize解决方案的问题</h2><p> 入队图示<br>下图展示了maxSize&#x3D;5的数组中，front&#x3D;0保持不变，元素依次入列直到满载，rear指针的移动情况：</p><p><img src="/2024/02/03/%E9%98%9F%E5%88%97/42a1d7c1976b4e7db62cd01c7b7c2fdc.png" alt="img"></p><p> front&#x3D;rear&#x3D;0的歧义<br> 可以看到，如果我们认为队列容量与数组容量应该持平，那么当第五个元素50入列后，本来rear&#x3D;4执行了rear++的操作后，rear&#x3D;5，随后rear将会通过取余算法rear&#x3D;rear%maxSize重置为0，这是我们解决方案的核心！</p><p>但关键点就在这里，我们发现空载时front&#x3D;rear&#x3D;0，满载时依然有front&#x3D;rear&#x3D;0！这样子我们就无法判断front&#x3D;rear时，队列是空还是满，因此rear&#x3D;rear%maxSize这种解决方案是不被允许的</p><h2 id="新的解决方案：置空位的引入"><a href="#新的解决方案：置空位的引入" class="headerlink" title="新的解决方案：置空位的引入"></a>新的解决方案：置空位的引入</h2><p>新的解决方案<br>       每次新元素入队后， 执行rear&#x3D;(rear+1)%maxSize操作，该操作包含rear++操作</p><p>置空位的引入<br>       并且我们人为规定，数组中必须留有一个索引位不得放置元素，必须置空！！！如何实现我们的人为规定呢？那就要先探索当数组满载后front和rear指针之间有啥关系</p><p> 入队图示<br>下图展示了maxSize&#x3D;5的数组中，front&#x3D;0保持不变，元素依次入列直到满载，rear指针的移动情况：</p><p><img src="/2024/02/03/%E9%98%9F%E5%88%97/fc276df1cfb14836b200b9ab1791347a.png" alt="img"></p><pre><code>   人为的让最后一位置空，所以当元素40入列后，数组已经满载   满载后数据之间的关系：</code></pre><p>front&#x3D;0<br>rear&#x3D;(rear+1)%maxSize&#x3D;(3+1)%5&#x3D;4  (注： 执行完arr[rear]&#x3D;40，再执行  rear&#x3D;(rear+1)%maxSize)<br>(rear+1)%maxSize&#x3D;(4+1)%5&#x3D;0&#x3D;front<br>       当我们认为的满载发生后，最后一位置空，发现此时rear和front之间的关系为(rear+1)%maxSize&#x3D;(4+1)%5&#x3D;0&#x3D;front，因此这个关系可以作为满载的条件</p><pre><code>   因为处于满载状态，我们无法再往队列添加元素，只能从队列取出元素，也就是进行出列的操作，而一旦我们执行了出列的操作，比如将索引位i=0上的元素10出列后，则front右移，即执行front=(front+1)%maxSize操作，最终front=1。   若随后又添加元素入列，即在索引位i=4上添加元素50，随后又会执行rear=(rear+1)%maxSize操作，最终rear=0。   rear=0≠front=1，此时就不会出现之前那种错误方案中 rear=front=0导致歧义的情况，而一旦 rear=front=0，必然表示队列为空，因此这种解决方案是行得通的</code></pre><h2 id="队列为满的判别"><a href="#队列为满的判别" class="headerlink" title="队列为满的判别"></a>队列为满的判别</h2><p>​      当我们认为的满载发生后，最后一位置空，发现此时rear和front之间的关系为(rear+1)%maxSize&#x3D;(4+1)%5&#x3D;0&#x3D;front，因此这个关系可以作为满载的条件</p><h2 id="队列中元素的个数"><a href="#队列中元素的个数" class="headerlink" title="队列中元素的个数"></a>队列中元素的个数</h2><p>​      numValid&#x3D;(rear+maxSize-front)%maxSize，大家可以带入数据验证一下</p><pre><code> 实际上：   当rear在front之后(这里指的是数组中索引位的前后，并非逻辑上的前后)，有效数据个数=rear-front=(rear+maxSize-front)%maxSize   当rear在front之前(这里指的是数组中索引位的前后，并非逻辑上的前后)，有效数据个数=(rear+maxSize-front)%maxSize</code></pre><h2 id="值得注意的一些细节"><a href="#值得注意的一些细节" class="headerlink" title="值得注意的一些细节"></a>值得注意的一些细节</h2><p>细节1<br>      置空位虽然是人为引入的，但这不意味这置空位的位置是随意的，实际上，只有队列满后才会将剩下的位置作为置空位，一旦置空位出现，rear和front永远不可能指向同一个索引位，因为你会惊奇的发现置空位恰号将rear和front隔开了.</p><pre><code> 置空位就像一把锁，一旦上锁就只能通过出队列操作解锁</code></pre><p>继续执行获取元素操作出队列（解锁）：</p><p><img src="/2024/02/03/%E9%98%9F%E5%88%97/bda71bd117674644bbe8c8c44c782aa3.png" alt="img"></p><p>上图中60入列后满载，可以看到置空位再次出现，但30➡40➡50➡60➡置空位 形成了逻辑上的闭环</p><p>细节2<br>从闭环的角度理解，front永远不可能在循环中超过rear，最多只能和rear相遇。</p><p>因为置空位的出现，rear不可能拉front一圈，也就避免了rear在超过front的情况下主动与front相遇</p><p>下图中的maxSize-1对应的就是置空位，rear是无法越过置空位的。只有front主动顺时针追赶上rear，它俩才会相遇，而此时队列内就没有元素，为空</p><p><img src="/2024/02/03/%E9%98%9F%E5%88%97/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Mjk2NDE3,size_16,color_FFFFFF,t_70.png" alt="img"></p><p> 细节3<br>队列的最大长度queueMaxsize&#x3D;数组容量arrayMaxSize-1  （由于置空位要占一位）</p><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RINGBUFF_LEN 256;</span></span><br><span class="line"><span class="comment">//定义一个缓冲区结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 Head;           </span><br><span class="line">    u16 Tail;</span><br><span class="line">    u8 Ring_Buff[RINGBUFF_LEN];</span><br><span class="line">&#125;RingBuff_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*若想更灵活，可以用动态内存分配方式（如使用指针）来实现可变长度的缓冲区</span></span><br><span class="line"><span class="comment">typedef struct</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">u16 Head;</span></span><br><span class="line"><span class="comment">u16 Tail;</span></span><br><span class="line"><span class="comment">u8* Ring_Buff;</span></span><br><span class="line"><span class="comment">&#125;RingBuff_t;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 初始化函数，传入所需长度</span></span><br><span class="line"><span class="comment">void RingBuff_Init(RingBuff_t rbuff, size_t len)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Head = 0;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Tail = 0;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Ring_Buff = (u8)malloc(len * sizeof(u8));</span></span><br><span class="line"><span class="comment">    if (!rbuff-&gt;Ring_Buff) &#123;</span></span><br><span class="line"><span class="comment">    // 处理内存分配失败的情况...</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">在C语言中，u8* Ring_Buff; 是一个指向无符号8位整型（通常代表字节）的指针。它本身并不是一个数组，但可以用来指向一块内存区域，这块内存可以被当作数组来处理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当你通过 malloc 函数为 Ring_Buff 分配了足够长度的内存后，你就可以像操作数组那样对这块内存进行读写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个ringBuff的缓冲区</span></span><br><span class="line">RingBuff_t ringBuff;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化环形缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RingBuff_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//初始化相关信息</span></span><br><span class="line">   ringBuff.Head = <span class="number">0</span>;</span><br><span class="line">   ringBuff.Tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">u8 <span class="title function_">Write_RingBuff</span><span class="params">(u8 data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ringBuff.Head=(ringBuff.Tail+<span class="number">1</span>)%maxSize) <span class="comment">//缓冲区满</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> FLASE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ringBuff.Ring_Buff[ringBuff.Tail]=data;<span class="comment">//在Tail对应索引位写入数据</span></span><br><span class="line">    ringBuff.Tail=(ringBuff.Tail+<span class="number">1</span>)%RINGBUFF_LEN; <span class="comment">//ringBuff.Tail++; 防止越界非法访问</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读数据</span></span><br><span class="line"><span class="number">10u</span>8 Read_RingBuff(u8 *rData)</span><br><span class="line"><span class="number">11</span>&#123;</span><br><span class="line"><span class="number">12</span>   <span class="keyword">if</span>(ringBuff.Head==ringBuff.Tail)<span class="comment">//判断非空</span></span><br><span class="line"><span class="number">13</span>    &#123;</span><br><span class="line"><span class="number">14</span>       <span class="keyword">return</span> FLASE;</span><br><span class="line"><span class="number">15</span>    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">16</span>   *rData = ringBuff.Ring_Buff[ringBuff.Head];<span class="comment">//先进先出FIFO，从缓冲区头出</span></span><br><span class="line"></span><br><span class="line"><span class="number">18</span>   ringBuff.Head = (ringBuff.Head+<span class="number">1</span>)%RINGBUFF_LEN;<span class="comment">// ringBuff.Head++;防止越界非法访问</span></span><br><span class="line">    </span><br><span class="line"><span class="number">20</span>   <span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环形缓冲区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Keil5进行debug</title>
      <link href="/2024/02/01/Keil5/"/>
      <url>/2024/02/01/Keil5/</url>
      
        <content type="html"><![CDATA[<h1 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h1><p><strong>转载自</strong>：<a href="https://blog.csdn.net/u012749085/article/details/126830777">https://blog.csdn.net/u012749085/article/details/126830777</a></p><p>实例调试：</p><p><a href="https://www.bilibili.com/video/BV1Jw411i7Fz?p=25&vd_source=a9d487fcf1a579639c6348eb5a9321db">https://www.bilibili.com/video/BV1Jw411i7Fz?p=25&amp;vd_source=a9d487fcf1a579639c6348eb5a9321db</a></p><p>9:25~11:05</p><h2 id="基本调试操作"><a href="#基本调试操作" class="headerlink" title="基本调试操作"></a>基本调试操作</h2><p>    首先点击”Debug-&gt;Start&#x2F;Stop Debug Session”或下图2位置，进入调试。<br><img src="/2024/02/01/Keil5/9261723051f340f5aeed4eb814510373.png" alt="9261723051f340f5aeed4eb814510373"><br>    如果前面工程配置里选择了复位调试，则进入调试后，会停在main函数头部<br><img src="/2024/02/01/Keil5/edca277b4e14435289c0f4b8d61f8129.png" alt="edca277b4e14435289c0f4b8d61f8129"></p><h3 id="复位（Reset）"><a href="#复位（Reset）" class="headerlink" title="复位（Reset）"></a>复位（Reset）</h3><p>对程序进行复位操作，根据烧录器不同的复位方式配置会触发不同的复位类型。<br><img src="/2024/02/01/Keil5/431db5f05a5a4f8a9241b3297ba354f7.png" alt="431db5f05a5a4f8a9241b3297ba354f7"></p><h3 id="全速运行（Run）"><a href="#全速运行（Run）" class="headerlink" title="全速运行（Run）"></a>全速运行（Run）</h3><p>：使当前程序开始正常全速运行，直到程序遇到断点时停止。<br><img src="/2024/02/01/Keil5/126e06525a784dd38a9254a7cc7439f0.png" alt="126e06525a784dd38a9254a7cc7439f0"></p><h3 id="停止运行（Stop"><a href="#停止运行（Stop" class="headerlink" title="停止运行（Stop)"></a>停止运行（Stop)</h3><p>当程序全速运行时，点击此按键可停止程序运行，停的是当前点击时的程序运行位置。<br><img src="/2024/02/01/Keil5/01978f3c724c4fe1ae60e9760eb4a47d.png" alt="01978f3c724c4fe1ae60e9760eb4a47d"></p><h3 id="单步调试（Step）"><a href="#单步调试（Step）" class="headerlink" title="单步调试（Step）"></a>单步调试（Step）</h3><p>根据当前调试的窗口的语言，执行单条语句。如果遇到函数，则会进入函数内部。如果是在反汇编窗口中，则只执行一条汇编指令。<br><img src="/2024/02/01/Keil5/4b6afae81ba943c08d0132be4bcf0dc5.png" alt="4b6afae81ba943c08d0132be4bcf0dc5"></p><h3 id="单步跳过调试（Step-Over）"><a href="#单步跳过调试（Step-Over）" class="headerlink" title="单步跳过调试（Step Over）"></a>单步跳过调试（Step Over）</h3><p>如果是在C语言窗口中，则是按单条语句执行，与单步调试不同的是，遇到函数不会进入函数内部，而是直接全速运行函数，并跳到下一条语句。<br><img src="/2024/02/01/Keil5/1733c1bed7fa4337a2518bdb4b7224a6.png" alt="1733c1bed7fa4337a2518bdb4b7224a6"></p><h3 id="单步返回调试（Step-Out）"><a href="#单步返回调试（Step-Out）" class="headerlink" title="单步返回调试（Step Out）"></a>单步返回调试（Step Out）</h3><p>如果是在C语言窗口中，则是直接全速运行当前函数后面所有内容，直到函数返回上一级。<br><img src="/2024/02/01/Keil5/0bb2a0a028a944878718e1acb6015ad8.png" alt="0bb2a0a028a944878718e1acb6015ad8"></p><h3 id="插入-移除断点"><a href="#插入-移除断点" class="headerlink" title="插入&#x2F;移除断点"></a>插入&#x2F;移除断点</h3><p>如果当前光标所在行未有断点，则插入断点（前提是当前行可以插入，如果无法插入会显示一个感叹号），在有断点的情况下则是移除断点。插入断点后，当前行前面会有个红圆表示断点位置。也可以通过直接点击红圆位置进行插入&#x2F;移除断点的操作。另一种断点方式，是通过指令来控制，当然也可以使用Keil提供的界面化操作，设置某个变量读或写时触发断点。不过目前貌似有部分芯片不支持这种操作。注：断点最多只能打7个。<br><img src="/2024/02/01/Keil5/5e09882eba154da695506d661cc6008a.png" alt="5e09882eba154da695506d661cc6008a"></p><p>    使能&#x2F;禁止断点：开启或禁止当前光标所在行的断点。禁止后红圆变成白圆。<br><img src="/2024/02/01/Keil5/c2a18ac2d197488c89d53693f22fb0be.png" alt="c2a18ac2d197488c89d53693f22fb0be"></p><p>    禁止所有断点：禁止当前所有的断点。<br><img src="/2024/02/01/Keil5/b42659b410604a88ab3c433d924b5aa6.png" alt="b42659b410604a88ab3c433d924b5aa6"></p><p>    删除所有断点：删除所有断点。<br><img src="/2024/02/01/Keil5/3c3c10be6e59420eb579ec7eb2a98972.png" alt="3c3c10be6e59420eb579ec7eb2a98972"></p><h2 id="调试窗口"><a href="#调试窗口" class="headerlink" title="调试窗口"></a>调试窗口</h2><h3 id="变量查看窗口"><a href="#变量查看窗口" class="headerlink" title="变量查看窗口"></a>变量查看窗口</h3><p>——Watch1，Watch2</p><p>    通过”View-&gt;Watch Windows-&gt;Watch1、Watch2”可以选择打开Watch窗口，也可以在工具栏<img src="/2024/02/01/Keil5/90b073560ba849b7ba3c658ad2c4f5cd-1.png" alt="90b073560ba849b7ba3c658ad2c4f5cd-1">这里打开。再点击一次则可以关闭。</p><p><img src="/2024/02/01/Keil5/76e14a916c584a70b49dc8a0136d4c23.gif" alt="76e14a916c584a70b49dc8a0136d4c23"></p><p>    通过选中一个变量，右键添加入对应的Watch窗口，可以追踪查看当前变量的变化状态。注意，只有全局变量可以全程监视，临时变量只有在进入当前函数中才可监视到其数据，用static关键词修饰的变量无法监视。<br><img src="/2024/02/01/Keil5/dbe562eff930488cb804bc827cdb04cf.gif" alt="dbe562eff930488cb804bc827cdb04cf"></p><p>    如果当前变量没有实时更新，则需要点击”View-&gt;Periodic Window Update”将其勾选上。<br><img src="/2024/02/01/Keil5/1265f5d49d684580ba808bbeb3ef554b.png" alt="1265f5d49d684580ba808bbeb3ef554b"><br>    在”Watch”窗口中，可以查看当前变量名称、值、数据类型，如果当前变量类型为结构体，则可以以对应的结构形式进行展开查看。<br><img src="/2024/02/01/Keil5/324b2248d8d84028a4c363d0f95ac1b7.png" alt="324b2248d8d84028a4c363d0f95ac1b7"></p><h3 id="内存查看窗口"><a href="#内存查看窗口" class="headerlink" title="内存查看窗口"></a>内存查看窗口</h3><p>——Memory</p><p>    通过”View-&gt;Memory Windows-&gt;Memory1&#x2F;2&#x2F;3&#x2F;4”打开Memory窗口，也可以通过工具栏Memory窗口<br>这个图标打开。打开的状态下再按一次则可关闭。</p><p><img src="/2024/02/01/Keil5/3ef3ddae558949199d25fbecaf1f27ac-1.png" alt="3ef3ddae558949199d25fbecaf1f27ac-1"><br>    在Memory窗口中输入想要查看内存的起始地址，另外右上角的锁可以把当前界面锁定下来。<br><img src="/2024/02/01/Keil5/e0e6df70592546a590f315a11de0e0f3.gif" alt="e0e6df70592546a590f315a11de0e0f3"><br>    另外如果查看的是Ram的地址，那其中的数据也可以直接通过此窗口进行修改。<br><img src="/2024/02/01/Keil5/1f94d24204584c39890962c5cdbedbf9.gif" alt="1f94d24204584c39890962c5cdbedbf9"></p><h3 id="系统视窗"><a href="#系统视窗" class="headerlink" title="系统视窗"></a>系统视窗</h3><p>——System Viewer Windows（这个根据不同芯片会有不同的展示）</p><p>    可以在”Peripherals”选项栏中选择”System Viewer”系统视窗中对应的外设，选择”Core Peripherals”则是内核调试窗口。另外系统视窗也可以通过工具栏中<img src="/2024/02/01/Keil5/1063891a98944597b35ab22eb677fe99.png" alt="1063891a98944597b35ab22eb677fe99">这个位置可以打开。<br>    这个窗口用于查看当前单片机外设及内核寄存器的值，在调试外设底层时经常会使用到。<br>    在这个窗口中可以直接修改外设寄存器的值，当然部分只读寄存器是无法修改的，有些则是需要在特定条件下才可以设置生效，具体就得看对应的芯片手册里寄存器的说明了。<br><img src="/2024/02/01/Keil5/4a171f6094dc4835a67b6bdb97da575e.gif" alt="4a171f6094dc4835a67b6bdb97da575e"></p><h3 id="调度关系窗口"><a href="#调度关系窗口" class="headerlink" title="调度关系窗口"></a>调度关系窗口</h3><p>——Call Stack Window</p><p>    可以在”View-&gt;Call Stack Window”打开此窗口，也可以在工具栏在这里插入图片描述这个位置打开 。<br>在这里插入图片描述<br>    这个窗口用于查看当前程序调度关系，当出现有进入硬件错误异常调试时可以快速定位到是哪里触发的异常。这个窗口是的调度关系是从当前程序堆栈里获取的数据并将其图形化，所以如果当前堆栈数据被破坏，则此窗口也将无法查看调度关系。<br>    该窗口里显示的调度关系是从下至上调用的，最上面的表示当前程序所处的函数。展开对应的函数，可以查看各层调用函数跳转之前保存的一些临时变量等信息。<br>在这里插入图片描述</p><h3 id="寄存器窗口"><a href="#寄存器窗口" class="headerlink" title="寄存器窗口"></a>寄存器窗口</h3><p>——Register Window</p><p>    该窗口可在”View-&gt;Registers Window”处打开，也可以在工具栏<img src="/2024/02/01/Keil5/abf2e937414b4dd581fc726c4b0c6813.png" alt="abf2e937414b4dd581fc726c4b0c6813">这个位置打开。</p><p><img src="/2024/02/01/Keil5/7e3a1bd9811247438e1bfcaf96d6fa2a.gif" alt="7e3a1bd9811247438e1bfcaf96d6fa2a">    这个窗口用于查看当前内核的相关寄存器，如汇编里常说的15个通用寄存器。当然调试中比较常用的是其中的SP、LR、PC三个寄存器。SP为当前栈的地址位置，PC为当前程序地址，LR为函数跳转前的地址，即当前函数返回的地址。<br><img src="/2024/02/01/Keil5/fb99ad40b4dd410abd262ceef2d86ea7.png" alt="fb99ad40b4dd410abd262ceef2d86ea7"><br>    另外”Banked”中的MSP为当前程序系统主栈，PSP则为操作系统的任务栈，这两者的区别是，如果使用了操作系统，则当前任务中的所有调度关系使用的是任务栈，而类似中断这种内核的操作使用的是主栈；如果未使用操作系统，则只会使用主栈，不会使用任务栈。<br><img src="/2024/02/01/Keil5/8f85703656554426acdf336f03d5fede.png" alt="8f85703656554426acdf336f03d5fede"><br>    通过”Internal”可以查看当前是处在中断还是任务中，Mode为”Thread”表示是在线程&#x2F;任务中，或者是函数中（非中断)，为”Handle”表示是在中断中；Privilege为”Privelege”表示当前处于特权模式。Stack为”PSP”表示当前使用的是任务栈，为”MSP”则表示使用的是主栈。<br><img src="/2024/02/01/Keil5/a0acc7b34aff41b4a887cd35ccf95afc.png" alt="a0acc7b34aff41b4a887cd35ccf95afc"></p><h3 id="反汇编调试窗口"><a href="#反汇编调试窗口" class="headerlink" title="反汇编调试窗口"></a>反汇编调试窗口</h3><p>——Disassembly Window</p><p>    该窗口在”View-&gt;Disassembly Window”中可以打开，也可以在工具栏中<img src="/2024/02/01/Keil5/afb0592b40264def8902fe7b7afd619a.png" alt="afb0592b40264def8902fe7b7afd619a">这个位置打开。<br><img src="/2024/02/01/Keil5/4590aac5e1c5439d9bae08e55b115af2.gif" alt="4590aac5e1c5439d9bae08e55b115af2"><br>    该窗口是通过bin文件反汇编出来的汇编文件（汇编跟二进制原本就是一一对应的关系）。当设置了优化等级后，部分C语言的调试会变得困难（汇编跟C语言不是一一对应，而程序运行又是完全根据汇编来走的)，此时可能需要使用汇编窗口进行调试。</p><h3 id="命令窗口"><a href="#命令窗口" class="headerlink" title="命令窗口"></a>命令窗口</h3><p>——Command Window</p><p>    该窗口在”View-&gt;Command Window”中可以打开，也可能在工具栏<img src="/2024/02/01/Keil5/9d7f28936ba24fb697579edf39d7ff4f.png" alt="9d7f28936ba24fb697579edf39d7ff4f">这个位置打开。<br><img src="/2024/02/01/Keil5/0d449233d79a467ba66edb0bd2e658c4.gif" alt="0d449233d79a467ba66edb0bd2e658c4"><br>    这个窗口可用来输入一些控制命令，比如保存输出当前内存地址等。在命令窗口中输入如下导出指令，按下回车即可导出数据</p><pre><code>save filename startAddr,endAddr</code></pre><p>filename：导出数据的文件名，无论后缀是什么，导出的格式都是十六进制文件。没有输入路径时，文件自动保存在当前工程根目录下。<br>startAddr, endAddr：需要导出数据的起始地址和结束地址，也可以通过表达式写出来。</p><p>例如：</p><pre><code>save ExportData.hex 0x08000000, 0x08000000+0x2000函数地址表——Symbols Window</code></pre><p>    该窗口在”View-&gt;Symbols Window”中打开，也可能在工具栏在这里插入图片描述这个位置打开。<br>在这里插入图片描述</p><p>    可以查看当前所有程序的函数调用关系及其所在地址。</p><h3 id="串口调试窗口"><a href="#串口调试窗口" class="headerlink" title="串口调试窗口"></a>串口调试窗口</h3><p>——Serial Windows</p><p>    该窗口在”View-&gt;Serial Windows”中打开，也可以在工具栏<img src="/2024/02/01/Keil5/9fd418aa9fb44e3f8a1fd5115405765e.png" alt="9fd418aa9fb44e3f8a1fd5115405765e">这个位置打开。<br><img src="/2024/02/01/Keil5/d502d6586ae2490bbe15f8bc2f578a83-1706774116563-42.gif" alt="d502d6586ae2490bbe15f8bc2f578a83"><br>暂未使用过，后续再添加。</p><h3 id="逻辑分析窗口"><a href="#逻辑分析窗口" class="headerlink" title="逻辑分析窗口"></a>逻辑分析窗口</h3><p>——Analysis Windows</p><p>    该窗口在”View-&gt;Analysis Windows”中打开，也可以在工具栏在<img src="/2024/02/01/Keil5/9537a7eb27a445cb87feb4df0e988650.png" alt="9537a7eb27a445cb87feb4df0e988650">这个位置打开。<br><img src="/2024/02/01/Keil5/7f19e574ef214902922c21804ac11166.gif" alt="7f19e574ef214902922c21804ac11166"><br>    这个貌似只能在软件模拟仿真中使用，如果使用硬件调试，需要硬件支持。</p><h3 id="跟踪窗口"><a href="#跟踪窗口" class="headerlink" title="跟踪窗口"></a>跟踪窗口</h3><p>——Trace Windows</p><p>    该窗口可以在”View-&gt;Trace Windows”中打开，也可以在工具栏<img src="/2024/02/01/Keil5/b96037874d53409dac4c3714eabcb0fc.png" alt="b96037874d53409dac4c3714eabcb0fc">这个位置打开。<br>暂时未使用过，后续再添加。</p><h2 id="调试应用"><a href="#调试应用" class="headerlink" title="调试应用"></a>调试应用</h2><p><strong>HardFault（硬件错误）</strong></p><p>    这个可以算是最常见的一个问题了，在开发过程中多多少少会遇到过程序死机的问题，而死机的大部分原因都是进入的HardFault中断，即常说的硬件错误中断。要想知道这个怎么调试，首先得清楚这是什么，怎么触发。<br>    触发原因：内存溢出，堆栈溢出，数组越界，中断错误，除0（在某些编译器下会有错误）等。前面三个，可以归结为都是内存异常操作导致，但因为其出现方式不一样，所以调试方式也不同。<br>    从现象反推，当出现这个错误时，第一时间查看函数的调度关系，看最后是死在哪个位置。如果不是堆栈溢出，一般来说是可以直接查到进入硬件错误前的最后执行的代码位置的。当然内存溢出跟数组越界也有可能导致无法查看调度关系，因为这个调度关系就是从程序运行栈里取出数据进行展示，所以当栈数据被破坏，则无法使用此方式进行调试。<br>    知道死机位置后（其实大概率就是因为某个异常指针的引用导致的问题），此时就去查找异常指针出现的原因。首先从逻辑层面看，异常指针是否是因为某个逻辑给指针赋了个错误值。<br>    其次是数据越界的角度来看，在Map文件中查找该指针的内存地址，查看其内存前后是否存在一些数组或结构体，然后去检查前后数组或结构体的操作是否存在下标溢出，指针偏移错误等问题。<br>    还有最后一种，就是直接从内存里获取数据作为指针地址进行引用，此类用法一般是在日志操作或GUI中比较常用，这种情况就要去内存数据来源是否存在问题。<br>    除以上三种可能性外，还有一种可能对一些人是涉及知识盲区的，就是引用地址没有地址对齐。这一部分是涉及内核的一些知识。这里简单讲下，对于M0内核，指针引用地址需要根据其引用的数据类型进行对齐。比如以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> *p = <span class="number">0x20000001</span>;</span><br><span class="line">*p = <span class="number">20</span>;<span class="comment">/* 这句一执行就会导致异常 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种是操作指针本身的地址没有4字节对齐，也会出现问题。如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 实际这样子定义编译器会报错（在Keil中编译），这里只是为了直观表示 */</span></span><br><span class="line"><span class="type">uint32_t</span> *p __attribute__((at(<span class="number">0x20000001</span>)));</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">p = <span class="number">0x20000010</span>;<span class="comment">/* 这句一执行就会导致异常 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复位</strong>    </p><p>复位有几种类型，一是看门狗复位，二是软件复位，三是硬件复位。复位类型可以通过芯片自带的复位寄存器进行查看。不过查看前需要手动清除所有复位标志，不然其复位标志会一直保留着。<br>    先讲下看门狗复位，当单片机开启看门狗后，很多问题都会变成复位问题，比如上面说的HardFault，因为HardFault也是一个中断，只是默认中断里是一个While(1)的死循环，所以当进入中断后，一段时间没有喂狗操作，就会触发复位。或者一些操作陷入死循环的，均是同理。这里我们把这一类问题都归为死循环问题。处理方式，先把看门狗关掉，然后调试看停在哪个死循环中，如果是HardFault，那就看上面硬件错误的处理方式。如果是其他死循环，那就看是什么条件触发的。死循环的问题相对来说比较好找。<br>    另外一种比较难处理的看门狗复位问题，莫过于某些操作时间过长，导致喂狗不及时。比如读写Flash时，通常会关闭中断，当大量读写时，其操作时间不可小靓，未开看门狗的情况下会有肉眼可见的程序卡顿，开了看门狗的情况下则通常会触发程序复位。这种类型的问题，通过关闭看门狗可能也无法定位到具体位置，因为程序还可以正常执行，只是在某些程序段会变得比较卡顿。对于这种问题，最好的方式是通过代码对比，通过对比原本没出问题的代码和出问题代码的差异性，锁定问题大体出现的位置，再通过程序执行时间进行估算。也可以借助一个独立的定时器，在一些时间操作较长的可疑之处计时。比如程序调用了某个底层未开源函数，那可以在调用前后打印定时器的计数，来计算函数运行的时间。当然也可以通过Keil自带的调试计数值来计算运行时间。<br>    软件复位就比较好找了，一般是需要人为调试内核的复位接口进行复位，所以只要查看是哪些位置触发的调用复位函数的条件就可以锁定问题点。<br>    硬件复位就只能从外围电路进行切入了，考虑干扰、连锡等问题。当然有些硬件复位是通过一个硬件看门狗进行复位的，如果是这种应用，那参考内部看门狗的问题排查方式。</p><p><strong>逻辑时序类调试</strong></p><p>    时序类的用断点调试法就很难做到了，特别是那种时序要求很严格的。就比如Modbus通信，协议是规定了一帧数据中每两个字节间隔时间不能超过1.5字符。所以想要在一帧数据中，按一个字节一个字节断点调试从机是不可能的，主机不会给你休息的时间。这时候就必须得添加一些测试代码了，添加测试代码最重要的一个原则，是不能变更原本的功能。所以一般在数据流向的关键路径上添加一些监控变量，通过监控变量的变化来识别时序是否出现错误。<br>    另外也可以使用逻辑分析窗口，把对应的变量添加进窗口中，通过时间变化查看变量对应的变化关系，以此来判断逻辑时序是否正常。</p><p><strong>内存调试</strong></p><p>    如果有涉及boot或日志记录功能的编写，那肯定会涉及大量内存的对比及调试，这时候可以利用上面提到的小技巧，在命令窗口那里输入save filename.hex StartAddr, EndAddr把对应的内存数据打印出来。</p><p><strong>底层外设调试</strong></p><p>    这个打开对应外设的寄存器界面，对着芯片用户手册查看每个寄存器的功能进行调试，只有对寄存器功能熟悉了才有对应的调试手段。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、有时候在watch窗口中，变量值不会刷新，这时候就需要查看一下”View-&gt;Periodic Window Update”是否已勾选，如果没勾选，变量只有在第一次添加或停止调试时才会刷新。另外当窗口里一次性加载了一个很大的数组，当展开数组时，变量刷新也会变得很慢，并且软件会变卡顿。</p><p>2、当选择了非0级优化时，调试可能会变得困难，具体表现在断点调试。比如现在下面的代码，代码优化的关系，有可能把case0、1、2里的return 1都合并成一行，导致运行调试时，无论当前程序进入了哪个分支，使用断点时都只会进其中一个。所以当开启代码优化等级后，需要注意断点调试将变得不可信。另外优化编译后，有部分代码也将无法打断点（被优化的代码）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (xx)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">&#123;</span><br><span class="line">do_something0();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line">do_something1();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">&#123;</span><br><span class="line">do_something2();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时应该去看汇编的实现，其执行顺序与汇编一致。</p><p>3、目前发现有部分工程在一些电脑上调试时，打断点后在删除断点之前退出调试，会导致Keil崩溃，只能结束进程重启。</p><p>4、当开启内部看门狗并且未打开调试关看门狗功能时，停止运行一段时间后会复位。</p><p>5、在全速运行时，有时打断点会无效，取消断点也无效，貌似是Keil本身的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vscode&amp;Keil</title>
      <link href="/2024/01/30/vscode-keil/"/>
      <url>/2024/01/30/vscode-keil/</url>
      
        <content type="html"><![CDATA[<p>前言：之前一直用的keil软件开发stm32的工程，越来越觉得keil的界面模糊不好看，于是尝试转移到vscode平台，目前实现的功能是cubemx生成工程文件后可用vscode打开并编译烧录，如果有调试需求还是在keil上。使用Vscode搭配keil，更加优雅的进行开发</p><p>对比图：</p><img src="/2024/01/30/vscode-keil/image-20240131162907970.png" alt="image-20240131162907970" style="zoom:67%;"><img src="/2024/01/30/vscode-keil/image-20240131162933189.png" alt="image-20240131162933189" style="zoom:60%;"><h1 id="1-安装MinGW"><a href="#1-安装MinGW" class="headerlink" title="1.安装MinGW"></a>1.安装MinGW</h1><p>把MinGW压缩包解压到常用的一个位置，</p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;新建-&gt;添加，将MinGW的bin文件夹路径复制到新建的环境变量中。</p><h1 id="2-安装Keil-Assistant插件"><a href="#2-安装Keil-Assistant插件" class="headerlink" title="2.安装Keil Assistant插件"></a>2.安装Keil Assistant插件</h1><p>安装后，右键点击扩展设置，将你的keil软件的UV4.exe的路径粘贴上去</p><p><img src="/2024/01/30/vscode-keil/image-20240130220057873.png" alt="image-20240130220057873"></p><p>然后如果安装成功的话，vscode左栏就会出现</p><p><img src="/2024/01/30/vscode-keil/image-20240130220235274.png" alt="image-20240130220235274"></p><p>依次为编译，烧录，重编译</p><h1 id="3-遇到的问题"><a href="#3-遇到的问题" class="headerlink" title="3.遇到的问题"></a>3.遇到的问题</h1><p>1.点击编译后出现</p><p>“文件名，目录或卷标语法不正确”</p><p>然后发现是在添加路径到Keil Assistant时路径开头写错了</p><p>2.修复第一个问题后，再次编译，出现</p><p><img src="/2024/01/30/vscode-keil/%7BWEJS9SE%25J%7BMGCUP6EYHMG.png" alt="{WEJS9~SE%J{MGCUP6EYHMG"></p><p>解决：先打开settings.json文件</p><p><img src="/2024/01/30/vscode-keil/image-20240130221023430.png" alt="image-20240130221023430"></p><p>把代码中的[U+202A]删掉即可，到此，可以正常编译和烧录。</p><p>目前的功能满足现在的使用需求，后面有时间可以学习下用GCC编译链开发STM32，学习下makefile,cmake,openocd相关的知识。</p><p><a href="https://www.bilibili.com/video/BV1Hi4y1r7b3/?spm_id_from=333.999.0.0&vd_source=a9d487fcf1a579639c6348eb5a9321db">https://www.bilibili.com/video/BV1Hi4y1r7b3/?spm_id_from=333.999.0.0&amp;vd_source=a9d487fcf1a579639c6348eb5a9321db</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vscode&amp;Keil </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Robotics learning path</title>
      <link href="/2024/01/30/Robotics/"/>
      <url>/2024/01/30/Robotics/</url>
      
        <content type="html"><![CDATA[<p>转载自</p><p>机器人工程师学习计划 - YY硕的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/22266788">https://zhuanlan.zhihu.com/p/22266788</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>很多朋友私信问我对机器人和人工智能感兴趣，该怎么展开学习。最近稍微有点空，我写写我的看法。</p><p>两年前，我在知乎回答<a href="https://www.zhihu.com/question/20435673/answer/29927998">如何定义「机器人」？ - YY硕的回答</a>中试图给机器人做出一个比较仔细的定义，我觉得机器人和人工智能最大的区别在于是否要和物理世界进行交互。今年初在另一篇知乎回答里<a href="https://www.zhihu.com/question/36653316/answer/85774195">对机器人或人工智能的研究会帮助我们更好的了解人类自己吗？ - YY硕的回答</a>我说到传感器是和物理世界交互的基础。后来，我又在知乎回答<a href="https://www.zhihu.com/question/45766810/answer/100301388">有哪些与控制、机器人等相关的 quotes？ - YY硕的回答</a>中提到莫拉维克悖论（<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Moravec%27s_paradox">Moravec’s paradox</a>），谈到了机器人学里公认的难题是在物理世界中实现类人的活动能力。</p><p>把之前的回答再翻出来是为了支持以下观点：机器人学的核心问题是做好和物理世界的交互。现在主流的机器人学分支里，处理与物理世界的交互的学科分为三类：传感器和处理算法（激光雷达，多目视觉，融合算法）；多刚体系统动力学控制（工业机器人动力学控制和接触力控制）；机器人自主移动（locomotion不知道该怎么翻译，轮式、足式、飞行等移动机器人的研究）。我建议对机器人学有兴趣的同学着重在这几个问题上面。</p><p>另外，根据世界第一的机器人教育机构卡耐基梅隆大学的机器人学博士的课程分类方式（</p><p><a href="https://link.zhihu.com/?target=https://www.ri.cmu.edu/wp-content/uploads/2017/01/COSAug2016.pdf">https://www.ri.cmu.edu/wp-content/uploads/2017/01/COSAug2016.pdfwww.ri.cmu.edu/wp-content/uploads/2017/01/COSAug2016.pdf</a></p><p>），机器人学有四个核心领域：</p><ol><li>感知。视觉传感器、图像传感器、触觉和力传感器、惯导等。</li><li>认知。人工智能、知识表达、规划、任务调度、机器学习等。</li><li>行为。运动学、动力学、控制、manipulation和locomotion等。</li><li>数学基础。最优估计、微分几何、计算几何、运筹学等。</li></ol><p>结合卡耐基梅隆大学的核心课程要求，我觉得我定义的机器人学核心问题算是基本没跑偏的。本文后面谈到的机器人项目都是以上述观点和课程要求为基础。</p><p>一些可能有争议性的观点：</p><ol><li>机器人学是富人的活动。虽然工业越来越发达，但好的开发板和电机还是非常贵。如果要下定决心学习机器人学并且做出实物，你必须找到做实物出来的资金。要么是自己花钱，要么就得找学校的机器人社团，或者找什么愿意资助年轻人学习的贵人。另外现在没有任何一本完整的书可以教你怎么造一个四旋翼空中机器人或者大狗机器人，你需要参考十几本不同的教科书，这些书不管中文版还是英文版都很贵。</li><li>机器人学是屠龙之术。这话是Ninebot创始人说的。虽然最近几年，平衡车、扫地机器人、多旋翼飞行器让机器人学开始进入人们的生活，但是可行的商业应用还是很少，而且已有的机器人和理论都还很难解决好与物理世界交互这件事情。所以一定要确保自己在机器人学这个道路上同时练好了能去其他行当吃饭的技能，比如编程、机械设计和硬件设计。也要做好心理准备，接受自己有可能在学会屠龙之术以后几年都造不出对社会有用的东西的事实。</li><li>基于上述所说的观点，如果是已经工作之后才想要学习机器人的话，可能已经太迟了，因为很可能<strong>兴趣战胜不了客观限制因素</strong>。如果作为兴趣去学习，只能学到做巡线小车和舵机机械臂什么的，可能也满足不了中二病的创造欲。</li></ol><p>个人认为机器人学是一个艰苦的道路，想要成为一个独挡一面的机器人工程师需要多年理论和实践的同步训练。理论学习和动手实践的过程还要互相排好时间表，在做某个实践项目的同时去学习最相关理论往往可以达到事半功倍的效果，但是同时那些不太相关的理论会看起来非常枯燥，因此如何妥善安排自己的实践项目也是很重要的事情。</p><p>这篇文章里我计划介绍一个电子工程、机械工程和计算机专业学生从大学一年级到研究生二年级的机器人学习计划，基本是我对自己过去学习方式的一个总结。按照这个方法来学习，能够成为一个能力全面，但是稍微偏软件一点的机器人工程师。这个六年的学习计划，估算下来，全年中每天在上课和完成课程要求之外要投入学习时间6-8个小时，这些时间一方面用于阅读课程知识的英文教材，一方面用于阅读其他学科的教材，一方面用于实践项目。</p><p>机器人工程师在大型项目里的定位类似于飞机系统里的总体设计师。和机械工程师、硬件工程师、软件工程师、算法工程师、控制工程师比起来，机器人工程师参与某个具体技术的时间较少，但是能够听得懂所有工程师说的话，能够作为不同模块间的协调人，带领整个团队去攻坚。当然如果机器人工程师能够在一个领域达到那个领域的工程师的优秀水平，肯定更好。</p><p>由于时间仓促，再加上个人水平有限，文章中如有纰漏和错误，恭请读者指出，谢谢。如果同学还有什么想知道的内容和教材，也欢迎留言交流。</p><h2 id="大一"><a href="#大一" class="headerlink" title="大一"></a><strong>大一</strong></h2><p>刚上大一，你的机器人生涯开始了。先看看学校的校园网能不能翻墙，不能的话自己去买个一年一百多块钱的VPN，先确保自己能上Google，不要心疼VPN的钱，这能让你在之后的职业生涯里节省上万块钱。然后去注册一个gmail账号，再注册stackoverflow账号，再注册github的账号，再注册CSDN账号，注册完登录上去逛逛，暂时先不要问为什么。</p><p>英语水平一定程度上会是机器人工程师水平的限制因素，英语是同学们在大学最该努力学的一门课，而且不止要把它当成课，要当成一种技能，当成生活的一部分。当你开始努力学习一些高级的机器人知识以后，有可能会非常难以找到中文的参考资料，这个时候如果啃不下英文的资料，进步速度和眼界就会受到很大影响。因此大一的时候要多看看红宝书，看看美剧。</p><p>不管是什么专业背景的同学，大学一年级一定要上好的课是微积分和线性代数。线性代数的重要性需要特别强调。一般来说，<strong>优秀的工程师和科学家在职业生涯中要学至少五次线性代数</strong>，大一学一遍、学凸优化的时候学一遍、学线性系统的时候学一遍、学机器学习的时候学一遍……如果在第一遍学的时候就看到对的书，刷到对的题，那么以后的学习会轻松很多。</p><p>网上有很多对于如何学好线性代数的讨论，比如知乎问题<a href="https://www.zhihu.com/question/20534668">如何理解线性代数？ - 数学学习</a>。Matrix67大神的文章<a href="https://link.zhihu.com/?target=http://www.matrix67.com/blog/archives/4294">随记：我们需要怎样的数学教育？</a>也很有启发。我个人对学习线性代数的建议是两本书，一本叫做《Linear Algebra Done Right》，另一本叫做《Linear Algebra Done Wrong》（<a href="https://link.zhihu.com/?target=https://www.math.brown.edu/~treil/papers/LADW/book.pdf">https://www.math.brown.edu/~treil&#x2F;papers&#x2F;LADW&#x2F;book.pdf</a>），我比较喜欢的是Done Wrong这本书，第一它是免费的，第二只需要读前6章两百页就够了，第三它页边距很大，打印出来有很多空白做练习题。另外一个较好的教材是<a href="https://link.zhihu.com/?target=http://open.163.com/special/opencourse/daishu.html">麻省理工公开课：线性代数</a>。不论如何，学线性代数一定要用国外的教材，千万不要用国内的教材。啃英文书很累，但是考虑到之后还要啃更多的英文书，线性代数已经算是很入门的了，一定要啃下来，同时还要刷足够多的课后题。</p><p>学完线性代数以后，一个自然而然的问题就是怎么能用计算机自己去计算矩阵的乘法、向量的乘法、向量的内积。因此引入了编程的学习。</p><p>不管同学的专业是什么，一定要在大学一年级尽早开始学编程。至于用哪种语言开始学习编程，我推荐Python，比较好的教材是<a href="https://link.zhihu.com/?target=http://open.163.com/special/opencourse/bianchengdaolun.html">麻省理工学院公开课：计算机科学及编程导论</a>，比较好的Python开发学习环境是Anacoda (<a href="https://link.zhihu.com/?target=http://www.continuum.io/downloads">http://www.continuum.io/downloads</a>)。熟悉Python以后，同学就可以开始玩玩Python的数值计算包Numpy，这个时候线性代数题基本上也刷的差不多，可以通过Numpy帮助自己解决线性代数问题了。</p><p>对任何人来说，Python是一把瑞士军刀，你可以用他干很多东西，比如自动回复邮件、自动收集信息。但是真要去造机器人，合适的工具并不是瑞士军刀，而是C&#x2F;C++这样简单粗暴的锤子和螺丝刀般的工具。在学习Python学到一定程度的时候（比如你听说有一种叫做cython的东西），最好开始学习C，而且要强迫自己练习用C的一维数组和指针来实现矩阵的加法、乘法、求逆等操作。之所以有高级的Python或者Java（不要问我Java哪里高级了）这些语言以后我们还需要去学C，是因为机器人上常用的不是完整的电脑，而是计算量有局限的嵌入式系统，嵌入式系统开发基本只能用C或者更低级的语言。</p><p>学习C我个人入门用的是清华大学出版的《<a href="https://link.zhihu.com/?target=http://product.dangdang.com/8880276.html">C++语言程序设计</a>》。虽然这个书标题是C++，但其实没什么太大问题。不过国内的C语言教材都有个巨大的问题是不引导学生去用Linux。近年来更好的一个教材是<a href="https://link.zhihu.com/?target=http://songjinshan.com/akabook/zh/index.html">http://songjinshan.com/akabook/zh/index.html</a>，这个网站的教材非常好，因为他教育学生用Linux环境作为程序编译的环境，而且还引入了一些计算机体系结构的介绍。</p><p>IT行业的程序员都会争论高级语言和低级语言哪个好，Linux和Windows哪个好，而对于机器人工程师来说，从现在到可预见的未来里，C是最好的语言，Linux是最好的操作系统，这都毋庸置疑。甚至对于Linux的发行版该选哪个，我们都是很少有质疑的：Ubuntu（<a href="https://link.zhihu.com/?target=http://www.ubuntu.com/global">The leading OS for PC, tablet, phone and cloud</a>）。原因是机器人操作系统ROS（<a href="https://link.zhihu.com/?target=http://www.ros.org/">ROS.org | Powering the world’s robots</a>）是基于Ubuntu开发的，因此在Ubuntu上运行最稳定。注意Ubuntu出了一个中文版叫做Kylin，个人感觉比较坑，建议大家不要装中文版。Ubuntu 作为一个开源操作系统，总是在快速迭代，2016年8月比较稳定的版本是14.04和16.04，建议同学安装14.04。</p><p>当你把C学得差不多，开始要学写包含多个头文件的程序时，一定要同时学习makefile的知识。这时候要上网去搜“Makefile详解”（<a href="https://link.zhihu.com/?target=http://tieba.baidu.com/p/591519800">Makefile详解（超级好）_mingw吧</a>）这篇文章看。</p><p>我自己在大学一年级的时候还学习了HTML和Javascript，到大一结束的时候已经能够熟练用Javascript手写一些动态页面。我个人觉得HTML和Javascript也是机器人工程师必备的技术，而不只是软件工程师的玩具。这是因为web技术实际上已经渗透到了编程的方方面面，比如json开始是Javascript里的一种object定义的方式，但现在已经成为了一种很标准的数据交互、参数配置的格式。另外AJAX能够帮助初学者理解一定的网络技术原理，而网络技术也是机器人工程师必备的技能。再者，制作GUI（图形用户界面）是常规debug的办法，而近年来一个流行的趋势是用webkit嵌入程序用HTML和Javascript作为图形界面的后端，而在机器人操作系统ROS（<a href="https://link.zhihu.com/?target=http://www.ros.org/">ROS.org | Powering the world’s robots</a>）里，通过rosbridge可以非常方便地把机器人程序的数据传递到websocket上，这句话看不懂没关系，反正你知道学学HTML和Javascript很重要就是了。更重要的是，HTML文档背后的DOM (Document Object Model)深刻地体现了面向对象的思想。大学中的面向对象程序设计一般都讲C++，在我看来应该讲HTML和Javascript。这一点不细说了，如果同学们去学习HTML和Javascript，自然会体会到。学习HTML和Javascript比较好的资料是<a href="https://link.zhihu.com/?target=http://www.w3schools.com/">http://www.w3schools.com/</a>，把网站左侧的“Learn HTML”、“Learn CSS”、“Learn Javascript”和“Learn JQuery”学完就行，别的部分还有很多花哨的技术，没有必要去学了。为了培养自己对Javascript的兴趣，可以上<a href="https://link.zhihu.com/?target=http://threejs.org/examples/">three.js &#x2F; examples</a>跪着看看热闹。</p><p>以上介绍的这些知识点、书和资料应该在大一期间就全部看完，然后利用大一的暑假好好巩固这些知识。比如开始用HTML和Javascript做一个自己的个人主页，刷一刷编程的题目，学用Python的奇技淫巧（比方说做一个自己的个人主页）。另外还可以抽时间学学数学知识，比如开始看看代数和离散数学。我大一的时候看到了两篇文章，认识到了数学的重要性，一个是MIT的CV大牛林达华写的[<a href="https://link.zhihu.com/?target=https://www.douban.com/group/topic/11115261/">转]MIT牛人解说数学体系</a>，另一个是前Goolge研究员吴军博士写的《数学之美》（<a href="https://link.zhihu.com/?target=https://book.douban.com/subject/10750155/">数学之美 (豆瓣)</a>）。当时林达华还在MIT读博士，而《数学之美》还没有成书。两篇文章看完以后我感觉自己整个人对数学的认识上了一个新的层次，此后一直在注意提高自己的数学水平，几年下来觉得收益很大。在之后的介绍里我还会多次强调需要学的数学知识和对应的教材。</p><h2 id="大二"><a href="#大二" class="headerlink" title="大二"></a><strong>大二</strong></h2><p>上大二的时候，你已经会了基本的编程知识和基本的数学知识。大二这一年应该投入在嵌入式系统的学习中，同时继续拓展自己多方面的能力。学校的机器人社团，比如做Robocon，RoboMasters的团队应该在招新了，赶快去加入，有了学长学姐的指导以及同辈朋友的鞭策，应该会进步的快一点。</p><p>大二应该掌握的技能：Solidworks画基本的机械图，基本的数字电路知识、数模转换，51单片机、AVR单片机、STM32单片机原理，UART、SPI、I2C、CAN等协议的原理和数据收发，STM32开发板的使用，电机转动和驱动的原理，PID的原理，调试四轮机器人底盘的移动，基本的传感器如陀螺仪、码盘、红外线、超声波的原理和读取方式，网络知识如配置IP配置路由器等，微电子焊接，金工技术。我在知乎回答<a href="https://www.zhihu.com/question/34670420/answer/59676472">如果程序员每天都浅尝辄止地学一些不同的新技术，长久以往，人会变成什么样子呢？ - YY硕的回答</a>里谈过机器人工程师需要的技能数量是IT行业全栈工程师技能数量的三倍以上，这些技能的基础都应该在大二开始积累。</p><p>如果同学们的专业是机械工程相关，那么大二的时候要深入学习solidworks做图，买机械加工手册学习各种机械的奇技淫巧。你的专业知识还不足以让你进行缜密的受力分析，不过你可以尽量多做一些机械结构出来感受它们的乐趣。</p><p>如果同学们的专业是硬件、电路相关，那么大二的时候要深入学习Altium Designer做图、制板、焊板。你要从现在开始，就给自己积累一个工作记录，可以就是简单的txt文件，记录你做过所有板子的bug、解决方案、学到的原理图、PCB layout的注意事项等等。积累很多年以后，你的这个工作记录会值很多钱。</p><p>学习这些技能的最好的方式，就是参加自己学校机器人社团的训练和方案设计。一般来说，学校的机器人社团招新之后会有训练和测试，让新人分组去做机器人，这个过程中如果愿意努力学，提高得会很快。如果你所在的大学是机器人比赛强校，比如西安交通大学，电子科技大学，哈尔滨工业大学，华中科技大学，东北大学等等（排名不分先后，没有提到你们学校名字的话我表示抱歉），那么你很幸运，你们学校的机器人社团有很好的积淀，有很多资源可以帮助你学习。基本上只要天天泡实验室，保证自己每天只睡6-7个小时（但还是要多去跑步、游泳保持身体健康），勤于向学长学姐请教，那么一定会提高得很快。</p><p>大二阶段特别要强调的是对动手能力的培养，包括机械材料的加工、电路焊接、制作导线和接头、连接路由器、配置网络、做网线等等。机械加工的工具有螺丝刀、锯、钻、锤子、车床、铣床、钻床，进阶选手可以学一下氧焊，这个比较危险，我没尝试过；电路焊接的工具有焊机、焊锡、洗板水、松香、吸锡器；制作导线的工具有剪子、剥线钳、夹头钳、网线钳各种钳；网络配置就是连连路由器插插网线，但是Linux系统下配置网络有时会非常麻烦，一定要多积累这方面的知识，因为将来你造的机器人多半会顶着一个无线路由器跑来跑去，甚至有的机器人上各个模块自己就能组起一个小局域网。这些技能的熟练掌握需要你花很多时间去做真正能用的机器人来练手。</p><p>对于该选择造一个怎么样的“真正能用的机器人”练手，最好的选择肯定是机器人比赛中的机器人。如果参加Robocon，你会跟着学长学姐们学着造有人那么高的巨大机械；如果参加RoboMasters，你会学着造比汽车还要灵活的机器人以及快速发弹的机构。其他一些小型的比赛比如飞思卡尔智能车，也是很好的训练，因为飞思卡尔智能车已经发展得很成熟，参加这个比赛的参赛资料就够学一阵子的，学完以后能够获得比较多的机器人技能。</p><p>如果没有太多学校机器人社团的资源，同学们还有一些小型的比赛比如挑战杯、大创比赛等等可以选择，以三五个人的小团队参与这些比赛。如果同学所在的学校连这些比赛都不组织大家参与，那就只好自己花钱了。国内开源机器人社区有很多资源可以利用来学习，比如自己买<a href="https://link.zhihu.com/?target=http://www.makeblock.com/">Arduino STEM educational Robot kits Building Platform</a>的各种开发套件做简单的机器人。Arduino的开发环境可能有些人不喜欢，因为它对硬件做了一级封装，如果更希望接触到单片机的本质，可以自己买STM32开发板学习。俗话说，没有什么嵌入式系统是一块STM32实现不了的，如果有，就用两块。STM32是ARM Cortex‑M家族中最为广泛应用的一款单片机，在网上也有很多的教材和开发板可供选择。在国内著名的电子论坛<a href="https://link.zhihu.com/?target=http://www.amobbs.com/forum-3020-1.html">STM32&#x2F;8 分论坛帖子清单 (amoBBS 阿莫电子论坛)</a>上，有很多参考资料，有问题也可以在这里和大家讨论学习。</p><p>如果你很想参加机器人比赛，身边也恰好有一些志同道合的小伙伴，但是学校不支持。没关系，来找我，我尽量通过大疆的关系说服你们学校支持你们参加RoboMasters。</p><p>虽然你是以机器人比赛为主线在探索机器人技术，但是要时刻记得，机器人比赛给你的理论方面的训练很差，还会让你养成一些坏习惯，比如凡事都希望用一些糙猛快的办法来解决。由于通常整个团队都没有太多的项目管理经验，到比赛前一段时间才会加紧功夫去做机器人，很多时候就会用“山寨”的办法去处理机器人的故障。比如说某个承重结构用久了会弯，为了赶比赛的进度，就拿锤子敲直了、再加一条辅助的结构在旁边继续用，而没有细致地去做建模、受力分析，思考是什么原因导致承重结构会变形。再比如说调PID参数就是生调乱改，而没有基于机器人的动力学模型去估测参数的大概范围。</p><p>大二的暑假，有可能你跟着学校的机器人队参加了一些机器人比赛。这是一个反思总结的好时机，为什么机器人队取得了这样那样的成绩？整个团队怎样才能更有效率？明年如何继续招新？暑假要把时间花在技术积累上面，这个时候可以回头思考思考之前准备比赛时用糙猛快的办法解决的问题如何能够细致地去解决。</p><p>如果大二的暑假没有参加机器人比赛，可以做一个舵机机器人，比如6条腿的蜘蛛，比如码垛机器人。舵机是机器人工程师的好朋友，一定要好好掌握。</p><p>另外你其他方面的能力也不能落下。大二结束的时候，你的Linux应该用的很熟练了，除了makefile，你也用起了cmake。你也应该开始理解Github存在的意义，因为你已经上去读了很多别人的代码，你也把自己的一些课程设计和小项目放在了Github上面。另外大二基本上了本专业一些比较难的基础课程，比如自动控制原理、机器学习、概率统计、材料和力学等课程，同学们会看到这些课程里又用到了线性代数和微积分的知识，以及建模的知识。这时候可以把大一的物理、线性代数和微积分再翻出来看看。</p><p>同学的学校应该给大二到大三的学生有开设面向对象的程序设计，一般用Java或C++教授。在面向对象的程序课里面，一定要积累3000行左右的代码的开发经验。经典的面向对象程序设计的练习通常是写游戏，比如俄罗斯方块，吃豆人等等，一定要自己能够做到完全手写一个完整的项目出来。</p><p>另外你可以开始学习Matlab当中的神器Simulink了。在大二这一年的学习中，你可能在不少课程里多多少少用到了Matlab。假设你已经在我的推荐下喜欢上了Python，你可能会觉得Matlab的计算工具没有比Python强多少；假设你自己在别人的推荐下喜欢上了mathematica（<a href="https://www.zhihu.com/question/27834147">Mathematica 到底有多厉害？ - Wolfram Mathematica</a>），你可能会觉得和Mathematica这种神一样的语言比起来，Matlab弱爆了。但是要注意的是，Matlab最强大的工具是Simulink，通过它你几乎可以仿真一切的物理系统和控制系统。我建议同学可以通过Simulink实现一个倒立摆，然后理解Matlab的强大之处。对此我强烈推荐一个很好的教材（<a href="https://link.zhihu.com/?target=http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction&section=SimulinkControl">http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction§ion=SimulinkControl</a>），它详细介绍了一些经典的控制系统如何分析以及用Simulink实现。然后我再强烈推荐一个讲Simulink里面一个更加和物理仿真贴近的工具Simscape（<a href="https://link.zhihu.com/?target=http://www.mathworks.com/help/control/examples/control-of-an-inverted-pendulum-on-a-cart.html">Control of an Inverted Pendulum on a Cart</a>）的文章。阅读并实现了这两篇文章里的内容，同学应该会对倒立摆有了比较深刻的认识。倒立摆是机器人学中一个非常重要的模型，因为火箭、导弹、双足机器人、四足机器人，基本都是倒立摆的变形。你自己实现出来的simulink模型一定要存好，以后可能还会再拿出来仔细看。</p><p>如果你按照我之前说的方法探索了一些HTML和Javascript的技术，那么JQuery，bootstrap，AngularJS你已经多多少少知道是怎么回事了。web后端的技术，比如PHP和MySQL，也可以了解一下，LAMP要学会怎么配置。如果有同学找你帮忙写小网站，尽量去帮个忙，帮别人做网站是提高自己系统编程能力的好练习。在做网站的过程中你可能还会顺便学一学如何用Photoshop和Illustrator让网站显得更漂亮。这些技能有最好，没空学也没关系。</p><h2 id="大三"><a href="#大三" class="headerlink" title="大三"></a><strong>大三</strong></h2><p>大三开始的时候，你可以在学校的机器人队里担任重要角色了，或者能够带领一个小团队参加小型的机器人比赛。你在系里甚至院里都小有名气了，可能有的人叫你大神，有的人觉得你技术还不错。但是一定要记得你现在的水平放到别的地方应该不算什么。每年我都往大疆的RoboMasters夏令营招进100个和你现在的水平相当的同学。</p><p>大三一定要培养出自己一个人独立造出一个完整机器人的能力，比如一个Robocon水平的机器人，或者一个RoboMasters的战车，或者一个四旋翼飞行器。</p><p>Robocon水平的机器人，涉及大量的机械设计，单片机开发，电机驱动的开发，码盘和超声波等传感器的读取，底盘运动学的计算，PID调试，任务调度逻辑的调试，舵机控制。RoboMasters的战车的机械部分简单一些，但是还需要进行云台的控制、发弹系统的控制、功率控制等方面的知识，另外你也可以不搞这些部分，学习学习视觉识别和自动打击，那么就要开始研究OpenCV（<a href="https://link.zhihu.com/?target=http://opencv.org/">OpenCV | OpenCV</a>）了。</p><p>四旋翼飞行器的机械部分最简单，但是算法比较复杂。对于大三学生来说，从零开始一步到位写一个稳定的飞控比较困难，因为飞控里面有很多细小的知识点要注意。目前我没有发现什么比较好的书籍推荐，已有的一些关于四旋翼系统的书要么太浅（上来就教你焊电路），要么太深（上来就教你state estimation），听说 <a href="https://www.zhihu.com/people/liu-top">@Liu Top</a>的exbot小组在写一个教材，我是非常期待的。学习四旋翼飞行器有下面几个步骤：</p><p>第一步：自己调一个小四轴飞起来</p><p>现在开源社区的人言必pixhawk，其实我觉得从学习的角度来说，pixhawk太贵，而且不适合学习，我比较推荐的是 <a href="https://link.zhihu.com/?target=https://chiplab7.taobao.com/">首页-第七实验室</a> 这家淘宝店卖的STM32F405飞控，买回来以后自己再随便买个机架（比如大疆F450）、接收机和遥控，就能按照飞控板附带的学习资料、调试软件飞起来。</p><p>第二步：看硬件图、读代码</p><p>chiplab7的飞控板附带一大堆学习资料，对加速度计、陀螺和磁感计都有很仔细的解释，硬件链路图也很详细。chiplab7淘宝掌柜的又很认真负责，我学用的时候，发现代码有bug和看不懂的地方，都可以直接找掌柜问。</p><p>看完代码以后，对一个飞控系统的基本模块：姿态解算、控制解算、混控输出、遥控器处理、嵌入式处理就很明白了。然而这里面有很多技术是需要另外学习的。除了基本的嵌入式编程以外，还有要把大二大三学的信号处理方面的知识再捡起来看看。因为飞行器在空中有振动，会让加速度计产生噪声，为了把这些噪声去除掉，需要对加速度计给出的信号做低通滤波处理，如何选择滤波器的参数呢？如果滤波滤得太狠，延迟就会比较大，对控制的表现会有影响；如果滤波滤得不够，可能会有一些低频的噪声偶尔会出现，导致加速度计的观测不能用。另外最重要的是要理解姿态解算和控制解算这两块知识。chiplab7的飞控板的代码采用的是最简单的互补滤波算法做为姿态解算模块，然后控制解算是对欧拉角的三个角度做闭环PID控制，基本都是基础的基础了。</p><p>第三步：小修小改加深理解</p><p>chiplab7的飞控是靠气压计定高的，飞行效果非常奔放。这时候可以淘宝买个20块钱的超声波模块，然后自己写个高度环去稳定飞控的定高表现。</p><p>我觉得这个过程至关重要，因为高度控制相对来说是个比较直观理解PID控制的方式，而且chiplab7的飞控加高度控制非常好加。工作量不大，因为改善效果很显著，所以可以让人很有成就感，加深继续学习的乐趣。</p><p>第四步：理解核心的数学和控制知识</p><p>这一部分大三是肯定来不及学的，但是我还是在这里列出来，因为这些知识你之后都需要慢慢学，我也会在之后不断重复提到这些知识点。</p><p>姿态解算和控制解算涉及的知识有：</p><ol><li>刚体姿态的表示、运动学方程和动力学方程。主要是对牛顿-欧拉方程的认识和理解、刚体姿态的欧拉角表示法、姿态与角速度的关系等等。</li></ol><p>这部分说复杂不复杂，说简单也不简单，我同样是没有找到一本完整的书全都介绍过的，是学了好几个不同的书和论文以后搞明白的。现在看起来是从维基百科入手比较靠谱。</p><ol start="2"><li>自动控制原理。讲PID的书和文章就多了去了，没有太多复杂的书。</li><li>线性估计基本原理。其实就是互补滤波：<a href="https://link.zhihu.com/?target=http://www.pieter-jan.com/node/11">Reading a IMU Without Kalman: The Complementary Filter</a> 。拿这个关键词百度各种搜就会了。</li></ol><p>第五步：重头开始造轮子</p><p>知乎著名网友vczh曾经说过，学习要抱着勇于造轮子的心态才能进步。所以在熟悉了别人飞控基础上，可以自己重头造一个飞控的轮子。可以自己从芯片开始重新画一个飞控板，读读STM32的芯片手册、读读各种传感器的芯片手册，自己手画一个飞控的原理图、做PCB layout、制板自己焊元件，全套花不了1000块钱，能够加深很多对硬件的理解。这一部分如果大三没空，也可以不搞了。</p><p>制造整个机器人的过程中要特别重视文档的积累。在你大三末期，你可能随着学校的机器人队备战比赛，你可能主力负责一台机器人。你应该自己列一个excel表格，把机器人用了几颗螺丝，几根导线，每个零件的规格是什么，都列出来。这个表格一方面可以用来帮助团队管理机器人的物料，一方面也是你自己的经验技术积累，将来你做的其他机器人可能多多少少都是Robocon、RoboMasters机器人的变形。</p><p>另一个积累是建一个自己的buglist，buglist包括什么呢，可以像冷大这样：<a href="https://www.zhihu.com/question/46824735/answer/115202408?from=profile_answer_card">做控制、机器人等算法工程师是怎样一种体验？ - 冷哲的回答</a>，就简单把一些自己的发生过的问题和最后的解决办法罗列下来。比如说“杜邦线接插位不稳固容易脱开，接好后应该用电工胶布再裹一圈”，“外发给淘宝加工的机械图纸，要特别注意和加工商沟通有没有漏掉一些细节，如沉头螺丝孔，关键的倒角”等等。你也可以帮其他机器人的问题也做这样的记录。buglist可以就是一个简单的文本文件，如果你一直往里面积累自己工作中的记录，等你将来工作了，这个文件可能会值很多钱。</p><p>大三的时候学校应该会开设软件工程的课程。不管你是不是这个专业，上不上这门课，都应该主动去听一听，甚至跟着课程的设计作业一起做一做。软件工程我觉得是机器人工程师必须具备的意识，因为一个机器人系统里涉及大量的硬件系统和软件功能，软件的部分往往还会涉及不同的语言、不同的编译环境、不同的开发工具链。几个人合作的话，大家的专业背景、编程习惯都不相同，这就导致不同的代码和模块之间的协议沟通非常复杂，必须尽早用UML和其他软件工程的工具帮助团队理解和互相沟通。</p><p>大三的时候学校应该还会开设操作系统原理和嵌入式系统原理的课程，而大二的时候讲过计算机组成原理（所谓的微机原理）。从大三开始同学需要开始体会实时操作系统和非实时操作系统的区别、原理以及使用时需要注意的地方。这是一个比较杂的知识点，我目前没有找到很好的教材去介绍。在STM32上，有freeRTOS，uCOS，Vxworks这么几种实时操作系统；Linux是一种非实时操作系统，但是可以通过打补丁变成实时操作系统。这些操作系统的细节在机器人开发中都会多多少少被涉及到，同学们可以随时上Google和CSDN去查大神们的介绍。</p><p>另外特别重要的一点是机器人系统里的嵌入式平台都有烧坏的可能性，有可能在某个嵌入式Linux平台上面辛辛苦苦写了一个多月代码，这个平台突然烧坏了，代码也就丢了。因此你的机器人如果有嵌入式Linux系统在里面，一定要尽早顶起来路由器，代码定时提交SVN或者git。</p><p>大三的暑假你可能会作为学校机器人队的主力去参赛了。备战比赛和参赛是一件磨练心性的事情。我在学生时代体会过和胜利擦肩而过的痛苦，体会过没机会再来一年的遗憾；也在负责大疆RoboMasters比赛的过程中被那些痛苦和遗憾的学生当做发泄的对象，非常有感触。我觉得参加机器人比赛，很努力，然后失败了，是一件让人快速成长的事情。同学如果有机会，一定应该参加至少一届机器人比赛。</p><p>大三的暑假你也可以选择来参加大疆的RoboMasters夏令营，关于夏令营大家可以看这个知乎问答了解更多：<a href="https://www.zhihu.com/question/49986388">参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新</a>。每年我们都在全国范围内寻找有一定技术基础的学生，让他们一起分组做一个自动机器人的挑战。这个夏令营，作为组织负责人，不谦虚地说，我觉得应该是全世界范围内最好的技术类夏令营。</p><p>大三的暑假有一件很重要的事情就是思考自己大四应该干什么。一般来说，你现在的能力保本校研究生肯定没有问题，当然你也可以选择考其他学校的研究生或者出国留学。虽然说你现在能力已经很全面了，但是你还需要2-3年的时间全面提升自己更多的能力，才能迈向卓越之路。不管是出国还是保研，最重要的目的是给自己争取到未来2-3年能够在一个优秀的环境中安心提升自己，有比较好的学习资源，能够参与到一些不错的项目中去。可能其他有些行当，出国留学始终是比在国内待着更好的选择，但是机器人行业并不是这样。我们国家这两年在机器人方面提高也很快，而且我们国家现在比较有钱。就像我开始说的那样，机器人是富人的活动，现在你在国内也能找到一些很有钱的实验室可以造比较牛逼的机器人。另外国外很多比较强的机器人公司也都在做比较敏感的军方项目，去找实习可能比较受限制。</p><p>出国去学机器人学方面的知识你有很多不错的选择，比如世界第一的机器人研究院卡耐基梅隆大学，或者麻省理工学院的CSAIL实验室。北美传统计算机四大名校（麻省理工学院，卡耐基梅隆大学，斯坦福大学，加州大学伯克利分校）里，除了斯坦福大学热火朝天在搞人工智能以外，其他几个学校的机器人研究都很不错。除了四大名校，你还有很多其他的选择，就像我开始说的那样，机器人是富人的活动，如果想接触到最好的机器人资源，你要选择有钱的实验室，而不是有名的实验室。</p><p>另外你还需要在大三的尾巴上选定自己将来的细分研究方向，而且开始往这个方向深挖，也就是我在文章开始提到的感知、认知、行为几个方向。当然同时你也不能放松其他方面的知识，尤其是数学基础。我在大三的暑假专门找数学系的同学给我开了个数学小讲座，学习了一点抽象代数的知识，对我后来学习密码学帮助很大。同时我也读了一些拓扑方面的教材（有一本很神奇的书叫做Topopogy Without Tears <a href="https://link.zhihu.com/?target=http://www.topologywithouttears.net/">http://www.topologywithouttears.net/</a>），这样才理解了为什么数学分析要用奇怪的符号去解释一些看起来很浅显的道理。</p><p>大三阶段的机器人工程师该学什么基础数学是众说纷纭的，在我看来，你要基本掌握“群是什么”，能够用代数的眼光去证明”det(AB) &#x3D; det(A)det(B)”，还要能理解“用一张纸就可以变出克莱因瓶”（当然是在四维空间里）。另外，你这个时候也要能够意识到自己需要再学一遍线性代数。</p><h2 id="大四"><a href="#大四" class="headerlink" title="大四"></a><strong>大四</strong></h2><p>大四开始了，你可以开始深挖自己的研究方向，同时也要开始学一些高级一点的通用技术和理论，这时候你和一般的机械、电子、计算机学生就不太一样了，你虽然也在狂编程，但也在狂学习物理和数学。通用技术包括ROS，simulink，gazebo和Vrep等工具。通用理论包括，再学一遍线性代数，学学凸优化、数值计算、旋转表示法等方面的知识。这些知识你在大四仅仅只能开一个头，因为你的大四要实习、毕业、考研、毕设，你会非常地忙。有些人会在大四进实验室和老师发论文，我个人觉得发论文这件事没必要操之过急。你的整个大学期间应该用在广泛涉猎各种各样的知识上面，而不是深入某一个细小的研究问题。</p><p>大四可以开始读一些著名入门书籍，我把这些书不分先后地列出来，你没有必要全部去读，而且每本书先读前几章就够了，能读多少尽量读多少。</p><ol><li>概率机器人学，<a href="https://link.zhihu.com/?target=https://www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623">https://www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623</a></li><li>凸优化，<a href="https://link.zhihu.com/?target=https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf">https://web.stanford.edu/~boyd&#x2F;cvxbook&#x2F;bv_cvxbook.pdf</a></li><li>线性系统理论，<a href="https://link.zhihu.com/?target=https://www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579">https://www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579</a></li><li>Multiple View Geometry in Computer Vision，<a href="https://link.zhihu.com/?target=http://www.robots.ox.ac.uk/~vgg/hzbook/">Multiple View Geometry in Computer Vision</a></li><li>线性估计，<a href="https://link.zhihu.com/?target=https://www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642">https://www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642</a></li><li>《机器学习》，周志华老师的书。</li><li>An Invitation to 3-D Vision，<a href="https://link.zhihu.com/?target=https://www.eecis.udel.edu/~cer/arv/readings/old_mkss.pdf">https://www.eecis.udel.edu/~cer&#x2F;arv&#x2F;readings&#x2F;old_mkss.pdf</a></li><li>Modern Control Systems，<a href="https://link.zhihu.com/?target=https://www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580">https://www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580</a></li><li>Rigid Body Dynamics，<a href="https://link.zhihu.com/?target=http://authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf">http://authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf</a>。说实话刚体动力学理论我没有找到特别好的书。但是刚体动力学理论很重要。</li><li>Feedback Systems: An Introduction for Scientists and Engineers，<a href="https://link.zhihu.com/?target=http://www.cds.caltech.edu/~murray/amwiki/index.php/Main_Page">FBSwiki</a></li></ol><p>就像我开始说的那样，这些书，大部分特别贵，还好有一些业界良心的作者放出了他们书的电子版。当然你也可以去一些名字都不能说的网站去找影印版。</p><p>在读上面这些书的时候，matlab，python都要放在手边，然后把书里面的知识尽量实践出来。很多教科书里都会在章节后面的习题里放一些写明是用matlab做的习题，要尽量多做一些这样的题。</p><p>你可能早就听说了ROS的大名，但是最好不要在大四之前去碰它。因为ROS用了很多操作系统和网络的底层技术。我在知乎回答<a href="https://www.zhihu.com/question/21958225/answer/20255931">高手可以谈谈ROS机器人操作平台开发的一些经验吗？ - YY硕的回答</a>里有简单的介绍。ROS的设计目标是把机器人的控制和传感器处理的软件和它的硬件隔离开，用上ROS以后，你可以方便地用到很多能直接跑的软件代码。但是ROS从入门到精通需要至少一年以上的时间，你必须不断地用，不断地尝试新的代码和硬件，才能对它熟悉起来。</p><p>ROS的可视化工具Rviz里面对于机器人旋转的表示用的是四元数，而在你之前研究四旋翼飞行器时，里面的代码表示旋转用的是欧拉角，做姿态解算用的可能是四元数。这个时候要开始有意识地去学习旋转表示法之间的区别和联系。</p><p>要重视大四期间的实习和毕业设计。很多大四的学生毕业设计都会非常颓地做一下，我觉得是不好的。要把做毕业设计的过程看做一个正式的项目。这个项目除了做好技术方面的工作，也要做好展示方面的工作。中国工程师的一大特点是，不会表达自己，可能做的东西水平很高，但是做出PPT就会犯字体花哨不正式、一页上面字太多，图文没有联系等表达上的问题。通过PPT介绍、展示自己的成果在工程师的职业生涯的任何一个阶段都非常重要，它甚至也一定程度上限制了机器人工程师能够达到的高度。只有能够把自己的成果清晰地表达给自己的团队，才能获得其他人的反馈、通过沟通提高团队的整体凝聚力和知识水平，这样自己在团队能够获得更多的认可，有助于团队整体工作效率的提高。我每年去参加几次学术会议，都在会议上感觉到一些中国的科研人员走到国际上以后，演讲能力很差就会导致他们的科研成果不受重视。当然其他国家的科研人员也是这样。</p><p>为了写出美观的技术报告和毕业论文，你可以开始学习Latex。Latex作为国际国内第一写作神器，学习资料在网上有很多。Latex的学习和使用同样也是需要不断地熟能生巧，多写多练就熟悉了。写毕业论文有个问题是怎么做出精美的矢量图，我推荐<a href="https://link.zhihu.com/?target=https://inkscape.org/en/">Draw Freely | Inkscape</a>，一个比Illustrator更轻量化、但是有些功能反而更强大的免费软件。</p><p>对于那些想申请出国留学的同学，你要做一个自己个人的成果展示，用网页的形式呈现比较好。把自己Github链接（如果你按我说的，大学第一天就申请Github账号，现在已经是一个三年的老油条了）、做过的机器人视频、写过的技术报告和文章（最好是英文的）放在上面。</p><p>关于毕业设计的选题，我推荐这么几个：</p><ol><li>手写双目视觉里程计。涉及到图像处理、特征匹配、位置解算、空间变换等等。</li><li>手写四旋翼飞行器基于GPS的轨迹规划。涉及到深挖四旋翼飞行器的运动原理、IMU原理、轨迹生成和优化等。</li><li>造一个被推了也不会倒的双足舵机机器人。涉及到舵机控制、倒立摆建模、动力学分析、PID控制、IMU原理等。</li><li>深度学习训练一个小车追人跑。涉及到深度学习工具包使用、数据集采集、数据集分析、小车控制等。</li><li>机械臂给人端茶倒水。这个相对来说土豪一点，因为能直接拿来用的机械臂都很贵，这个要看实验室有没有条件了。涉及到多自由度机械臂原理的学习、工具包的使用、轨迹规划等等。</li></ol><p>这几个项目要做好，都要持续投入三个月以上的时间以及一定的资金，每一个都是理论多于实践。当然同学们自己也可以自己选择自己的毕业设计题目，但是最好还是选做出来能跑能飞的东西，同时避免选择需要花大量时间去拧螺丝、焊板子的题目，尽量买现成的电机、开发板、3D打印结构，大四要多给自己留时间去看书和写代码。</p><p>大四到研究生之前的暑假，最好去一些比较不错的机器人公司实习一下，比如说大疆。当然你也可以继续做机器人比赛，比如RoboMasters和大疆的飞行器比赛。</p><h2 id="研究生一年级"><a href="#研究生一年级" class="headerlink" title="研究生一年级"></a><strong>研究生一年级</strong></h2><p>研究生的时候，你的目标比较清晰了，就是做一种机器人至少两年时间，并从中发掘出可以发表论文的知识点。上面我给出的书单里面，你要开始精读里面的几本。</p><p>如果做机器人视觉定位、传感器融合方面的研究，1、4、5、7四本书一定要精读。</p><p>如果做控制系统的研究，3、8、9、10一定要精读。</p><p>如果做规划算法的研究，那么还要读其他偏CS一些的书，比如讲A* search，random forest，图论方面知识的教材。由于我在这方面造诣不深，就不托大了。</p><p>如果学习随机系统的控制和最优控制，除了1、2、3，还要读一本神书Stochastic models estimation and control（<a href="https://link.zhihu.com/?target=https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf">https://www.cs.unc.edu/~welch&#x2F;kalman&#x2F;media&#x2F;pdf&#x2F;maybeck_ch1.pdf</a>）。</p><p>如果研究机器人视觉定位，几种常用的定位算法：PTAM（<a href="https://link.zhihu.com/?target=http://www.robots.ox.ac.uk/~gk/PTAM/">Parallel Tracking and Mapping for Small AR Workspaces (PTAM)</a>），ROS的标配VO（<a href="https://link.zhihu.com/?target=http://wiki.ros.org/viso2_ros">viso2_ros - ROS Wiki</a>），SVO（<a href="https://link.zhihu.com/?target=https://github.com/uzh-rpg/rpg_svo">GitHub - uzh-rpg&#x2F;rpg_svo: Semi-direct Visual Odometry</a>），LSD-SLAM（<a href="https://link.zhihu.com/?target=http://vision.in.tum.de/research/vslam/lsdslam">http://vision.in.tum.de/research/vslam/lsdslam</a>）ORB-SLAM（<a href="https://link.zhihu.com/?target=https://github.com/raulmur/ORB_SLAM2">GitHub - raulmur&#x2F;ORB_SLAM2: Real-Time SLAM for Monocular, Stereo and RGB-D Cameras, with Loop Detection and Relocalization Capabilities</a>），都必须自己学习之后全部跑一遍。只会用OpenCV的函数和这些工具包并不能说明你会视觉定位，必须要能自己手写出一个能用的才算。国内有一个很厉害的SLAM专家叫高翔，他的博客要关注一下：<a href="https://link.zhihu.com/?target=http://www.cnblogs.com/gaoxiang12/tag/%E6%9C%BA%E5%99%A8%E4%BA%BA/">机器人 - 标签</a>。由于SLAM这两年很火，研究的人很多，所以网上可以参考的资料也很多，比如<a href="https://link.zhihu.com/?target=https://github.com/hcdth011/ROS-Hydro-SLAM">https://github.com/hcdth011/ROS-Hydro-SLAM</a>，就在ROS上实现了几种定位算法的对比。</p><p>我现在非常不建议同学们选择从四旋翼飞行器的动力学控制里找问题作为研究课题。因为四旋翼飞行器的特点已经被研究透了。目前国际上对多旋翼飞行器的研究主要集中在造一些奇葩形状的飞行器，以及给多旋翼飞行器上安装一个机械臂去做力控制，这样做就对多旋翼飞行器控制的动力学造成了一些影响。因此需要同学对动力学和多自由度机械臂控制有比较深的认识。</p><p>自动导航和驾驶是这两年的热点，一方面汽车的自动化是大势所趋，另一方面多旋翼飞行器异军突起，产生了很多对自动飞行的需求。除了机器人视觉定位算法以外，同学还需要学习其他的传感器，以及这些传感器与视觉定位算法怎么融合。这里面有很多坑，比如计算量的问题，怎么保证融合算法不崩，怎么处理传感器的延时等等，都需要同学结合自己的项目去踩，坑踩得多了才能成长。如果大家想找一个多旋翼飞行器平台研究自动导航，我推荐大疆的M100，我已经在知乎回答<a href="https://www.zhihu.com/question/31586826/answer/65274168">RoboMasters2015夏令营是怎样的？ - YY硕的回答</a>里吹过一波M100，前面说过的今年夏令营的知乎回答<a href="https://www.zhihu.com/question/49986388">参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新</a>里也有人帮我吹了一波。</p><p>一些大学里学过的知识点，是必须结合研究生期间的项目的需求弄得很清楚的，比如三大变换（傅里叶变换，拉普拉斯变换，Z变换），旋转表示法（欧拉角、四元数、旋转矩阵），数值计算怎么防止矩阵出现数值问题等等。除了自己的项目，还需要把凸优化、卡尔曼滤波还有多自由度机械臂的控制学习一下。这三个领域的知识，是任何一种机器人都会用的到比较难的知识。</p><p>凸优化和凸优化的各种变形是非常重要的知识，因为各行各业里的研究问题，多半是会建立一个优化问题去解决的。上面提到的《Convex Optimization》<a href="https://link.zhihu.com/?target=https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf">https://web.stanford.edu/~boyd&#x2F;cvxbook&#x2F;bv_cvxbook.pdf</a>，也是一本神书，同学们一定要认真读一读。Matlab、Python、C++都有一些现成的工具包可以帮助你解优化问题，不过最好同学们能自己手写一些基本的优化算法，比如gradient descend，barrier method等等。另外现在主流的SLAM算法，后端都是通过一种叫做g2o的优化算法来出效果的。而且g2o能够整合bundle adjustment 和structure-from-motion这两大计算机视觉里的关键问题，可以说是一种很好的计算思想了，非常有必要学习一下g2o。</p><p>卡尔曼滤波在上面书单里的1和3都有提到，同时在神书Stochastic models estimation and control（<a href="https://link.zhihu.com/?target=https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf">https://www.cs.unc.edu/~welch&#x2F;kalman&#x2F;media&#x2F;pdf&#x2F;maybeck_ch1.pdf</a>）也有相当多的篇幅。卡尔曼滤波有好几种证明的方法，同学最好能自己学会1-2种。</p><p>多自由度的机械臂的难点在于机械臂的运动学正反解、运动学控制和动力学控制，基本是一个建模分析和数值算法实现的问题。如果你所在的学校没有一个财力雄厚的机器人实验室的话，你基本上没有机会接触到多自由度的机械臂。这时候之前学到的Simulink和就要学的Gazebo就派上用场了，你可以用Simscape里面的刚体搭一个多自由度机械臂，然后通过Simulink仿真去学习机械臂的控制；也可以用Gazebo的URDF语言写一个机械臂，然后通过Gazebo和ROS的接口去控制机械臂；也可以用ROS里面的著名工具包<a href="https://link.zhihu.com/?target=http://moveit.ros.org/">MoveIt! Motion Planning Framework</a>，不过MoveIt的问题是，他只能仿真运动学，而不能仿真动力学。工业领域对多自由度的机械臂控制通常用一个叫做D-H表示法的建模工具（<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters">Denavit</a>），这个东西我并不太会。我只会向同学们推荐我导师的著作《A mathematical introduction to robotic manipulation》（<a href="https://link.zhihu.com/?target=http://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf">http://www.cds.caltech.edu/~murray&#x2F;books&#x2F;MLS&#x2F;pdf&#x2F;mls94-complete.pdf</a>）。</p><p>有一个非常神奇的事实：《A mathematical introduction to robotic manipulation》这本机械臂控制领域的著名教材的第二章和计算机视觉领域的著名教材《An Invitation to 3-D Vision》的第二章基本是一样的，都在讲旋转表示法。这是因为所有的旋转表示法都可以归纳为一种优雅的李群结构：SO(3)群。而计算机视觉和机械臂控制都涉及到理解刚体的旋转，事实上用计算系统去观测和控制所有的刚体构成的系统，理解旋转都是很关键的问题。旋转表示法应该作为研究生阶段的一个重要学习的知识点。</p><p>李群和李代数是刚体旋转表示背后的数学理论，如果想要深挖一些，可以看这篇文章An elementary introduction to groups and representations的前50页（<a href="https://link.zhihu.com/?target=http://www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf">http://www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf</a>）。这是我自己读着觉得最好的文章，当然网上也有很多其他的介绍。</p><p>研究生阶段还要培养的一个能力是借助各种工具仿真机器人系统的能力。显然地，很多机器人系统真的造出来的话造价昂贵，需要在实际制造之前写一个比较真实的仿真系统出来测试算法。我觉得做仿真系统的能力直接衡量了机器人工程师的技术水平。当你开始要搭一个仿真系统的时候，第一步是通过欧拉方程和牛顿方程确定刚体的运动特点，甚至要自己写刚体二阶微分方程；第二步是确定刚体之间的互联关系，设计不同类型的关节，如果有软性连接需要加入弹簧阻尼模型；第三步是确定被仿真的刚体系统会不会和外界产生碰撞或者其他形式的力，如果有的话，需要设计合适的接触力和摩擦力仿真的模型。多旋翼飞行器的仿真是很简单的，不需要考虑什么接触力。但是多自由度机械臂基本都需要仿真接触力，不和物理世界去交互的机械臂只有很小的实用意义。而能够自行运动locomotion系统，比如双足、多足机器人，则涉及到更多的接触力，多到接触力都会影响仿真系统的数值稳定性。搭建一个仿真系统需要很强的系统建模能力和数值分析的能力，虽然Simulink、Gazebo、Vrep提供了不同程度的工具简化你的工作，但是要让仿真系统能够稳定运行，必须要能深入其中的细节。有些看起来很高大上的仿真工具，比如Nvida的PhysX，在仿真的时候是忽略掉科里奥利力的，如果不理解仿真的本质，可能就会忽略这一个重要的缺陷。</p><h2 id="研究生二年级"><a href="#研究生二年级" class="headerlink" title="研究生二年级"></a><strong>研究生二年级</strong></h2><p>你的学习计划接近尾声。现在你已经进入了一个很好的状态：看到一个机器人，能够很果断地分析出它用了什么传感器、执行器、计算平台大概是什么量级，他的执行机构能够承受多少力量。看到一个新的算法，能够大约判断清楚它的执行流程，在什么环节做了优化。看到一个新的没学过的知识，能够分析出它和你以前学过的什么知识有联系，你还需要再学什么才能弄明白这个知识点。</p><p>研究生二年级要深化第一年学到的那些技术和知识，要做到完整地读过四五本书，五十篇以上的论文。你已经积累了几万行代码的经验，也能熟练地谈论谁家的电机回差小，谁家的电机线性程度好。</p><p>你这个时候可以去写作一些论文，也可以开始学习一些更高级的技术和工具，比如用FPGA和GPU优化算法、魔改Linux内核、玩玩液压系统、了解更多机器学习的知识比如强化学习等等。你也可以从计算机图形学或者计算力学里面找到一些帮助你更好进行机器人仿真和系统分析的工具。由于你懂很多机器人方面的知识，你可以给学校的机器人队做指导，或者带队参加一些比较有挑战性的机器人比赛。</p><p>写到这里，我就不可能给出很多不同领域的指导了，因为随着学习的进一步深化，我自己熟悉的领域也在收缩。我只能对几个领域给出我的意见。</p><p>对视觉定位和传感器融合来说，SLAM急需新的突破，目前通过几何约束去实现loop closure看起来已经走入了死路，没法有更多的发展了，下一步可行的方向是与深度学习进行结合。具体的一些介绍可以阅读行业中大牛的一篇文章<a href="https://link.zhihu.com/?target=http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html">http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html</a>，记述了几个业界大牛们最新的观点。传感器融合技术，目前还有很多问题可以探索，因为传感器的延时、不均匀的信号，会给定位系统造成困扰，如何去除这些干扰，需要建立比较复杂的非线性优化问题，具体可以关注香港科技大学Shaojie Shen的工作。</p><p>对于多自由度机械手和机器人的locomotion来说，这里面还有非常多可以探索的研究问题。我前面提过接触力和摩擦力很难仿真，大神告诉我现在没有任何一种工具和理论能把接触力和摩擦力正确仿真出来，因此如何在机器人系统里妥善处理对这些力的控制，就是很难的问题了。现在业界的一个前沿发展方向，也是利用机器学习技术来帮助机器人学会处理这些外力，不过人类目前最优秀的多自由度机器人系统，Berkeley的Brett机器人，叠几块积木就要用十分钟（<a href="https://link.zhihu.com/?target=http://news.berkeley.edu/2015/05/21/deep-learning-robot-masters-skills-via-trial-and-error/">New ‘deep learning’ technique enables robot mastery of skills via trial and error</a>），显然还有很多提升的空间。这方面的问题同学可以关注知乎大神</p><p><a href="https://www.zhihu.com/people/70bcce80353eccd2938cbfa2ac856aab">@戴泓楷</a></p><p><a href="https://www.zhihu.com/people/0eeca981bb238839881694643181fa91">@周佳骥</a></p><p>。</p><p>最后我想再强调一遍表达能力的重要性。你可以从自己带的课程和机器人队入手，把自己这几年来学过的知识做成PPT讲给学生们听，然后让他们给你反馈。多做这样的练习，提升自己做演讲的能力，这将来会让你受益匪浅。</p><p>研究生二年级之后，你可以准备进机器人公司工作了，也可以根据你自己感兴趣的研究方向申请博士接着努力。由于你已经掌握了广博的知识和技能，你的职业生涯将会大有作为。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a><strong>结束语</strong></h2><p>我从2008年展开自己的机器人生涯。那一年波士顿动力刚刚发布他们的大狗机器人，Python还是很小众的语言，Ubuntu 8.04还很不稳定，Chrome还没有多少人知道。在之后的几年中我目击了深度神经网络的复兴，看到波士顿动力的机器人日渐强大，经历了ROS的起源和繁荣，帮助了大疆的崛起，深深为这个产业的未来感到激动。我希望这篇文章能够帮助更多的年轻人进入机器人学的海洋，为未来机器人学的继续发展贡献力量。</p>]]></content>
      
      
      <categories>
          
          <category> 机器人学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Robotics learning path </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS</title>
      <link href="/2024/01/29/FreeRTOS/"/>
      <url>/2024/01/29/FreeRTOS/</url>
      
        <content type="html"><![CDATA[<p>文档：</p><p><a href="https://rtos.100ask.net/zh/FreeRTOS/DShanMCU-F103/chapter6.html">https://rtos.100ask.net/zh/FreeRTOS/DShanMCU-F103/chapter6.html</a></p><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a><strong>项目介绍</strong></h1><p>裸机:</p><img src="/2024/01/29/FreeRTOS/image-20240116111924666.png" alt="image-20240116111924666" style="zoom:35%;"><p>freerots:</p><img src="/2024/01/29/FreeRTOS/image-20240116112000983.png" alt="image-20240116112000983" style="zoom:35%;"><img src="/2024/01/29/FreeRTOS/image-20240116112750136.png" alt="image-20240116112750136" style="zoom:67%;"><p>涉及到三个项目：音乐播放        打砖块游戏，汽车游戏</p><p><img src="/2024/01/29/FreeRTOS/image-20240116193203709.png" alt="image-20240116193203709"></p><p><img src="/2024/01/29/FreeRTOS/image-20240116201310758.png" alt="image-20240116201310758"></p><p>2-2,2-3讲自己创建一个freertos工程</p><p>从3.1开始正式讲freertos</p><h2 id="创建第一个多任务程序"><a href="#创建第一个多任务程序" class="headerlink" title="创建第一个多任务程序"></a>创建第一个多任务程序</h2><p>不同的嵌入式操作系统，如freertos,rt-thread,它们对相同的一个操作的函数名称不同，为了统一起来，增加了一个接口层cmsis_os ,我们直接用这个文件的函数就行了，这个函数会根据不同的操作系统进行选择相应的代码，这样你写出来的代码既可以运行在freertos也可以在rt-thread上。</p><p>创建工程时默认生成的任务，osThreadNew为cmsis_os中定义的函数</p><p><img src="/2024/01/29/FreeRTOS/image-20240117222125768.png" alt="image-20240117222125768"></p><p>我们要等会要用的是freertos的原生代码去创建任务</p><p><img src="/2024/01/29/FreeRTOS/image-20240117223144328.png" alt="image-20240117223144328"></p><p>在此创建自己的任务函数</p><p><img src="/2024/01/29/FreeRTOS/image-20240117224413771.png" alt="image-20240117224413771"></p><p>在此处创建自己的任务</p><p><img src="/2024/01/29/FreeRTOS/image-20240117224427446.png" alt="image-20240117224427446"></p><h1 id="ARM架构简明教程-硬件架构与汇编指令"><a href="#ARM架构简明教程-硬件架构与汇编指令" class="headerlink" title="ARM架构简明教程_硬件架构与汇编指令"></a>ARM架构简明教程_硬件架构与汇编指令</h1><p>我们去创建一个任务的时候，为什么要指定栈，你理解了栈之后，才能深入理解RTOS的本质，要想理解栈，你得对处理器的架构有所了解</p><p><img src="/2024/01/29/FreeRTOS/image-20240117225222942.png" alt="image-20240117225222942"></p><h2 id="ARM架构"><a href="#ARM架构" class="headerlink" title="ARM架构"></a>ARM架构</h2><p>CPU(计算)， 内存（RAM） ，FLSAH</p><p><strong>RISC</strong></p><p>ARM芯片属于精简指令集计算机(RISC：Reduced Instruction Set Computing)，它所用的指令比较简单，有如下特点：</p><p>① 对<strong>内存</strong>只有<strong>读、写</strong>指令</p><p>② 对于数据的<strong>运算</strong>是在<strong>CPU</strong>内部实现</p><p>③ 使用RISC指令的CPU复杂度小一点，易于设计</p><p><img src="/2024/01/29/FreeRTOS/09_arm.png" alt="09_arm"></p><p>对于上图所示的乘法运算a &#x3D; a * b，</p><p>在RISC中要使用4条汇编指令：</p><p>① 读内存a</p><p>② 读内存b</p><p>③ 计算a*b</p><p>④ 把结果写入内存</p><p><strong>提出问题</strong></p><p>问题：在CPU内部，用什么来保存a、b、a*b ？</p><p><strong>CPU内部寄存器</strong></p><p>CPU, 内存 , FLASH</p><p><img src="/2024/01/29/FreeRTOS/10_cpu.png" alt="10_cpu"></p><p>无论是cortex-M3&#x2F;M4，</p><p>还是cortex-A7，</p><p>CPU内部都有R0、R1、……、R15寄存器；</p><p>它们可以用来“暂存”数据。</p><p><img src="/2024/01/29/FreeRTOS/11_regs.png" alt="11_regs"></p><p>对于R13、R14、R15，还另有用途：</p><p>R13：别名<strong>SP</strong>(Stack Pointer)，栈指针</p><p>R14：别名<strong>LR</strong>(Link Register)，用来保存返回地址</p><p>R15：别名<strong>PC</strong>(Program Counter)，程序计数器，表示当前指令地址，写入新值即可跳转（往PC寄存器写入某个值，它就会跳过去执行对应的代码）</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><ul><li><p>读内存：Load</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line">LDR  R0, [R1, #4]  ; 读地址&quot;R1+4&quot;, 得到的4字节数据存入R0</span><br></pre></td></tr></table></figure></li><li><p>写内存：Stroe</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line">STR  R0, [R1, #4]  ; 把R0的4字节数据写入地址&quot;R1+4&quot;</span><br></pre></td></tr></table></figure></li><li><p>加减</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD R0, R1, R2  ; R0=R1+R2</span><br><span class="line">ADD R0, R0, #1  ; R0=R0+1</span><br><span class="line">SUB R0, R1, R2  ; R0=R1-R2</span><br><span class="line">SUB R0, R0, #1  ; R0=R0-1</span><br></pre></td></tr></table></figure></li><li><p>比较</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMP R0, R1  ; 结果保存在PSR(程序状态寄存器)</span><br></pre></td></tr></table></figure></li><li><p>跳转 (调用函数)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B  main  ; Branch, 直接跳转</span><br><span class="line">BL main  ; Branch and Link, 先把返回地址保存在LR寄存器里再跳转 （1.LR=返回地址（下一条指令），2.PC=调用函数的地址。 往PC寄存器写入某个值，它就会跳过去执行对应的代码）</span><br></pre></td></tr></table></figure><p>局部变量都保存在栈里。</p></li></ul><h3 id="C函数的反汇编"><a href="#C函数的反汇编" class="headerlink" title="C函数的反汇编"></a>C函数的反汇编</h3><p>C函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> a, <span class="keyword">volatile</span> <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> sum;</span><br><span class="line">    sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让Keil生成反汇编：（通过反汇编码，更好的理解栈）</p><p><img src="/2024/01/29/FreeRTOS/默认放置文件夹/Freertos/DShanMCU-F103开发板资料/5_程序源码/02_FreeRTOS程序/04_视频配套的文档/pic/12_keil_dis.png" alt="image-20230822132428937"></p><p>为例方便复制，制作反汇编的指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fromelf  --text  -a -c  --output=xxx.dis  xxx.axf</span><br></pre></td></tr></table></figure><p>C函数add的反汇编代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i.add</span><br><span class="line">add</span><br><span class="line">    0x08002f34:    b503        ..      PUSH     &#123;r0,r1,lr&#125;</span><br><span class="line">    0x08002f36:    b081        ..      SUB      sp,sp,#4</span><br><span class="line">    0x08002f38:    e9dd0101    ....    LDRD     r0,r1,[sp,#4]</span><br><span class="line">    0x08002f3c:    4408        .D      ADD      r0,r0,r1</span><br><span class="line">    0x08002f3e:    9000        ..      STR      r0,[sp,#0]</span><br><span class="line">    0x08002f40:    bd0e        ..      POP      &#123;r1-r3,pc&#125;</span><br></pre></td></tr></table></figure><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><h3 id="堆（heap）"><a href="#堆（heap）" class="headerlink" title="堆（heap）"></a>堆（heap）</h3><p>所谓堆，就是一块空闲的内存，你也可以管理这块内存，从其中取出（malloc）一部分，用完之后再把它释放(free)回去。</p><p>堆，heap，就是一块空闲的内存，需要提供管理函数 </p><ul><li>malloc：从堆里划出一块空间给程序使用</li><li>free：用完后，再把它标记为”空闲”的，可以再次使用</li></ul><h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 (stack)"></a>栈 (stack)</h3><p>栈是RTOS的基础,也是一块内存空间，CPU的SP寄存器指向它，可以用于<strong>函数调用，局部变量，多任务系统里保存现场</strong>，每一个任务都会有自己的栈。栈在内存（RAM）中。</p><p>栈，stack，函数调用时局部变量保存在栈中，当前程序的环境也是保存在栈中 </p><ul><li>可以从堆中分配一块空间用作栈</li></ul><p>提问1：LR被覆盖了，怎么办？</p><img src="/2024/01/29/FreeRTOS/image-20240118193830901.png" alt="image-20240118193830901" style="zoom:80%;"><p>答：在C入口，会首先划分出自己的栈，保存LR进栈里，保存局部变量，在每个函数的入口都会保存LR 以及必要的寄存器，以防后面操作将其覆盖</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g_cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">b_func</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">  a+=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">c_func</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">  a+=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">a_func</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  g_cnt=b_func(a);</span><br><span class="line">  g_cnt=c_func(g_cnt);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i=<span class="number">99</span>;</span><br><span class="line">a_func(i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码里，进入main函数后先调用a函数，然后在a函数中分别调用b,c函数</p><p>下面是对应的反汇编代码</p><p>第9行 BL a_func</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i.main</span><br><span class="line">    main</span><br><span class="line">        0x08000188:    b508        ..      PUSH     &#123;r3,lr&#125;</span><br><span class="line">        0x0800018a:    2063        c       MOVS     r0,#0x63</span><br><span class="line">        0x0800018c:    9000        ..      STR      r0,[sp,#0]</span><br><span class="line">        0x0800018e:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">        0x08000190:    f7ffffde    ....    BL       a_func ; 0x8000150</span><br><span class="line">        0x08000194:    2000        .       MOVS     r0,#0</span><br><span class="line">        0x08000196:    bd08        ..      POP      &#123;r3,pc&#125;</span><br></pre></td></tr></table></figure><p>a_func: 调用了b_func ,c_func</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a_func</span><br><span class="line">    0x08000150:    b501        ..      PUSH     &#123;r0,lr&#125;</span><br><span class="line">    0x08000152:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">    0x08000154:    f000f80c    ....    BL       b_func ; 0x8000170</span><br><span class="line">    0x08000158:    4904        .I      LDR      r1,[pc,#16] ; [0x800016c] = 0x20000004</span><br><span class="line">    0x0800015a:    6008        .`      STR      r0,[r1,#0]</span><br><span class="line">    0x0800015c:    4608        .F      MOV      r0,r1</span><br><span class="line">    0x0800015e:    6800        .h      LDR      r0,[r0,#0]</span><br><span class="line">    0x08000160:    f000f80c    ....    BL       c_func ; 0x800017c</span><br><span class="line">    0x08000164:    4901        .I      LDR      r1,[pc,#4] ; [0x800016c] = 0x20000004</span><br><span class="line">    0x08000166:    6008        .`      STR      r0,[r1,#0]</span><br><span class="line">    0x08000168:    bd08        ..      POP      &#123;r3,pc&#125;</span><br></pre></td></tr></table></figure><p>b_func</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b_func</span><br><span class="line">    0x08000170:    b501        ..      PUSH     &#123;r0,lr&#125;</span><br><span class="line">    0x08000172:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">    0x08000174:    1c80        ..      ADDS     r0,r0,#2</span><br><span class="line">    0x08000176:    9000        ..      STR      r0,[sp,#0]</span><br><span class="line">    0x08000178:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">    0x0800017a:    bd08        ..      POP      &#123;r3,pc&#125;</span><br></pre></td></tr></table></figure><p>c_func</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c_func</span><br><span class="line">        0x0800017c:    b501        ..      PUSH     &#123;r0,lr&#125;</span><br><span class="line">        0x0800017e:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">        0x08000180:    1c80        ..      ADDS     r0,r0,#2</span><br><span class="line">        0x08000182:    9000        ..      STR      r0,[sp,#0]</span><br><span class="line">        0x08000184:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">        0x08000186:    bd08        ..      POP      &#123;r3,pc&#125;</span><br></pre></td></tr></table></figure><p>对应的栈区域以及里面的内容</p><img src="/2024/01/29/FreeRTOS/image-20240118204432237.png" alt="image-20240118204432237" style="zoom:80%;"><p>提问2：<strong>局部变量</strong>在栈中是如何分配的？</p><p><img src="/2024/01/29/FreeRTOS/image-20240118231052162.png" alt="image-20240118231052162"></p><p>变量ch,buf,uch这三个变量没加volatile，它们优先使用寄存器来表示（随着变量越来越多，寄存器不够用，就在栈里分配空间）；变量i用了volatile,它在栈里给你分配了空间</p><p>提问3：为什么每个RTOS任务都有自己的栈？</p><p>每个任务都有自己的调用关系，自己的局部变量和现场</p><p><img src="/2024/01/29/FreeRTOS/image-20240119153109460.png" alt="image-20240119153109460"></p><p>​           </p><p>恢复现场：找到任务的结构体，得到任务的栈，SP地址，将寄存器的值从栈里恢复到CPU里面</p><h1 id="FreeRTOS源码结构概述"><a href="#FreeRTOS源码结构概述" class="headerlink" title="FreeRTOS源码结构概述"></a>FreeRTOS源码结构概述</h1><h2 id="FreeRTOS目录结构"><a href="#FreeRTOS目录结构" class="headerlink" title="FreeRTOS目录结构"></a>FreeRTOS目录结构</h2><p>使用STM32CubeMX创建的FreeRTOS工程中，FreeRTOS相关的源码如下:</p><p><img src="/2024/01/29/FreeRTOS/image1.png" alt="img"></p><p>主要涉及2个目录：</p><ul><li>Core <ul><li>Inc目录下的FreeRTOSConfig.h是配置文件</li><li>Src目录下的freertos.c是STM32CubeMX创建的默认任务</li></ul></li><li>Middlewares\Third_Party\FreeRTOS\Source <ul><li>根目录下是<strong>核心文件</strong>，这些文件是通用的</li><li>portable目录下是移植时需要实现的文件 <ul><li>目录名为：[compiler]&#x2F;[architecture]</li><li>比如：RVDS&#x2F;ARM_CM3，这表示cortexM3架构在RVDS工具上的移植文件</li></ul></li></ul></li></ul><p>7.2核心文件 FreeRTOS的<strong>最核心</strong>文件只有2个：</p><ul><li><p>FreeRTOS&#x2F;Source&#x2F;tasks.c</p></li><li><p>FreeRTOS&#x2F;Source&#x2F;list.c</p><p>其他文件的作用也一起列表如下：</p><p><img src="/2024/01/29/FreeRTOS/image2.jpg" alt="image2"></p></li></ul><h2 id="移植时涉及的文件"><a href="#移植时涉及的文件" class="headerlink" title="移植时涉及的文件"></a>移植时涉及的文件</h2><p>移植FreeRTOS时涉及的文件放在 <strong>FreeRTOS&#x2F;Source&#x2F;portable&#x2F;[compiler]&#x2F;[architecture]</strong> 目录下，比如：RVDS&#x2F;ARM_CM3，这表示cortexM3架构在RVDS或Keil工具上的移植文件。 里面有2个文件：</p><ul><li>port.c</li><li>portmacro.h</li></ul><h2 id="头文件相关"><a href="#头文件相关" class="headerlink" title="头文件相关"></a><strong>头文件相关</strong></h2><p> 头文件目录</p><p>FreeRTOS需要3个头文件目录：</p><ul><li>FreeRTOS本身的头文件：</li></ul><p>Middlewares\Third_Party\FreeRTOS\Source\include</p><ul><li>移植时用到的头文件：</li></ul><p>Middlewares\Third_Party\FreeRTOS\Source\portable[compiler][architecture]</p><ul><li>含有配置文件FreeRTOSConfig.h的目录：Core\Inc</li></ul><p> 头文件</p><p>列表如下：</p><p><img src="/2024/01/29/FreeRTOS/image3.jpg" alt="image3"></p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong>内存管理</strong></h2><p>文件在Middlewares\Third_Party\FreeRTOS\Source\portable\MemMang下，它也是放在“portable”目录下，表示你可以提供自己的函数。</p><p>源码中默认提供了5个文件，对应内存管理的5种方法。</p><p>后续章节会详细讲解。</p><p><img src="/2024/01/29/FreeRTOS/image4.jpg" alt="image4"></p><h2 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h2><p>在Core\Src\main.c的main函数里，初始化了FreeRTOS环境、创建了任务，然后启动调度器。源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Init scheduler */</span></span><br><span class="line">  osKernelInitialize();  <span class="comment">/* 初始化FreeRTOS运行环境 */</span></span><br><span class="line">  MX_FREERTOS_Init();    <span class="comment">/* 创建任务 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Start scheduler */</span></span><br><span class="line">  osKernelStart();       <span class="comment">/* 启动调度器 */</span></span><br></pre></td></tr></table></figure><h2 id="数据类型和编程规范"><a href="#数据类型和编程规范" class="headerlink" title="数据类型和编程规范"></a>数据类型和编程规范</h2><p><strong>数据类型</strong></p><p>每个移植的版本都含有自己的portmacro.h头文件，里面定义了2个数据类型：</p><ul><li>TickType_t： <ul><li>FreeRTOS配置了一个周期性的时钟中断：Tick Interrupt</li><li>每发生一次中断，中断次数累加，这被称为tick count</li><li>tick count这个变量的类型就是TickType_t</li><li>TickType_t可以是16位的，也可以是32位的</li><li>FreeRTOSConfig.h中定义configUSE_16_BIT_TICKS时，TickType_t就是uint16_t</li><li>否则TickType_t就是uint32_t</li><li>对于32位架构，建议把TickType_t配置为uint32_t</li></ul></li><li>BaseType_t： <ul><li>这是该架构最高效的数据类型</li><li>32位架构中，它就是uint32_t</li><li>16位架构中，它就是uint16_t</li><li>8位架构中，它就是uint8_t</li><li><strong>BaseType_t通常用作简单的返回值的类型，还有逻辑值，比如pdTRUE&#x2F;pdFALSE</strong></li><li><strong>在 RTOS 中，函数的返回值不仅仅局限于0、1和-1这样的简单逻辑值，它还可能表示优先级、任务句柄等多种信息，这些信息在某些情况下可能需要用到较大的数据宽度。因此，使用 <code>BaseType_t</code> 可以灵活适应各种情况。</strong></li></ul></li></ul><p><strong>变量名</strong></p><p>变量名有前缀：</p><p><img src="/2024/01/29/FreeRTOS/image5.jpg" alt="image5"></p><p><strong>函数名</strong></p><p>函数名的前缀有2部分：返回值类型、在哪个文件定义。</p><p><img src="/2024/01/29/FreeRTOS/image6.jpg" alt="image6"></p><p><strong>宏的名</strong></p><p>宏的名字是大小，可以添加小写的前缀。前缀是用来表示：宏在哪个文件中定义。</p><p><img src="/2024/01/29/FreeRTOS/image7.jpg" alt="image7"></p><p>通用的宏定义如下：</p><p><img src="/2024/01/29/FreeRTOS/image8.jpg" alt="image8"></p><h2 id="内存分配（栈）"><a href="#内存分配（栈）" class="headerlink" title="内存分配（栈）"></a>内存分配（栈）</h2><p>为了让FreeRTOS更容易使用，这些内核对象一般都是动态分配：用到时分配，不使用时释放。使用内存的动态管理功能，简化了程序设计：不再需要小心翼翼地提前规划各类对象，简化API函数的涉及，甚至可以减少内存的使用。</p><p>注意：我们经常”堆栈”混合着说，其实它们不是同一个东西：</p><ul><li><p>堆，heap，就是一块空闲的内存，需要提供管理函数 </p><ul><li>malloc：从堆里划出一块空间给程序使用</li><li>free：用完后，再把它标记为”空闲”的，可以再次使用</li></ul></li><li><p>栈，stack，函数调用时局部变量保存在栈中，当前程序的环境也是保存在栈中 </p><ul><li>可以从堆中分配一块空间用作栈</li></ul><img src="/2024/01/29/FreeRTOS/Temp\Temp\image1.png" alt="image1" style="zoom:80%;"></li></ul><p>FreeRTOS中内存管理的接口函数为：pvPortMalloc 、vPortFree，对应于C库的malloc、free。</p><p>cubemx中关于栈的配置：</p><img src="/2024/01/29/FreeRTOS/image-20240120112427199.png" alt="image-20240120112427199" style="zoom:67%;"><p><img src="/2024/01/29/FreeRTOS/image-20240120113241290.png" alt="image-20240120113241290"></p><p>用一个ucHeap数组来表示堆</p><p><img src="/2024/01/29/FreeRTOS/image-20240120112644538.png" alt="image-20240120112644538"></p><img src="/2024/01/29/FreeRTOS/image-20240120113523411.png" alt="image-20240120113523411" style="zoom:80%;"><p>heap4会合并相邻的空闲buffer，所以可解决碎片问题，一般都有heap4，如果有多块内存用heap5</p><p><img src="/2024/01/29/FreeRTOS/image-20240120114435751.png" alt="image-20240120114435751"></p><p>比如你想知道你分配的3072字节的栈空间够不够用，你可以让程序跑一段时间，然后调用这个函数来看看，如果它接近个位数或十位数，则容量很危险，我们要把栈空间分配大一点</p><h1 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h1><p>三要素：函数，栈，优先级</p><p>TCB:任务控制块（任务结构体）</p><p>任务控制块(TCB)通常包含了以下内容：</p><ul><li>任务堆栈指针：指向任务堆栈的顶部。</li><li>任务优先级：表示该任务的优先级等级。</li><li>任务状态：如运行、就绪、阻塞、挂起等。</li><li>延时计数器和超时时间：用于处理任务延时和超时唤醒。</li><li>其他可能的信息：如任务入口函数地址、任务ID或名称等。</li></ul><p>当创建一个新任务时，FreeRTOS会为该任务分配并初始化一个TCB，并返回这个TCB的指针作为任务句柄。这样，在后续操作中，通过任务句柄就能间接访问和修改对应任务的所有信息。</p><h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><p>a.动态分配</p><p><img src="/2024/01/29/FreeRTOS/image-20240120162524684.png" alt="image-20240120162524684"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">( TaskFunction_t pxTaskCode, <span class="comment">// 函数指针, 任务函数</span></span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, <span class="comment">// 任务的名字</span></span></span><br><span class="line"><span class="params">                        <span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="comment">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class="line"><span class="params">                        <span class="type">void</span> * <span class="type">const</span> pvParameters, <span class="comment">// 调用任务函数时传入的参数</span></span></span><br><span class="line"><span class="params">                        UBaseType_t uxPriority,    <span class="comment">// 优先级</span></span></span><br><span class="line"><span class="params">                        TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span>; <span class="comment">// 任务句柄, 以后使用它来操作这个任务</span></span><br></pre></td></tr></table></figure><p>pxTaskCode: 函数指针，指向我们的任务函数，在这里写我们自己写的任务函数的函数名。</p><p>pcName：任务名，没啥用，自己随便取，eg:  “LightTask”</p><p>usStackDepth: 栈大小，单位为字(word),一个字的大小取决于计算机处理器的位数。在大多数现代计算机中，一个字的大小通常是32位或64位，也就是说，一个字的大小通常是4个字节或8个字节。</p><p>pvParameters: 调用任务函数时传入的参数，即pxTaskCode的参数，如果它没有参数，直接写NULL就行</p><p>uxPriority：优先级范围：0~(configMAX_PRIORITIES – 1) 数值越小优先级越低， 如果传入过大的值，xTaskCreate会把它调整为(configMAX_PRIORITIES – 1)</p><p>pxCreatedTask：用于保存 xTaskCreate 的输出结果，即任务的句柄（task handle）。如果以后需要对该任务进行操作，如修改优先级，则需要使用此句柄。如果不需要使用该句柄，可以传入 NULL。</p><p>返回值：成功时返回 pdPASS，失败时返回 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY ，<strong>BaseType_t</strong>通常用作简单的返回值的类型、</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t xSoundTaskHandle;<span class="comment">//任务句柄</span></span><br><span class="line">BaseType_t ret;<span class="comment">//分辨任务的返回值,判断任务是否创建成功</span></span><br><span class="line"></span><br><span class="line">ret=xTaskCreate(PlayMusic,<span class="string">&quot;SoundTask&quot;</span>,<span class="number">128</span>,<span class="literal">NULL</span>,osPriorityNormal,xSoundTaskHandle);</span><br></pre></td></tr></table></figure><p>b.静态分配</p><p><img src="/2024/01/29/FreeRTOS/image-20240120162811825.png" alt="image-20240120162811825"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t <span class="title function_">xTaskCreateStatic</span> <span class="params">( </span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,   <span class="comment">// 函数指针, 任务函数</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,   <span class="comment">// 任务的名字</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth, <span class="comment">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * <span class="type">const</span> pvParameters,   <span class="comment">// 调用任务函数时传入的参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,      <span class="comment">// 优先级</span></span></span><br><span class="line"><span class="params">    StackType_t * <span class="type">const</span> puxStackBuffer, <span class="comment">// 静态分配的栈，就是一个buffer</span></span></span><br><span class="line"><span class="params">    StaticTask_t * <span class="type">const</span> pxTaskBuffer <span class="comment">// 静态分配的任务结构体的指针，用它来操作这个任务</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>pxTaskCode: 函数指针，指向我们的任务函数，在这里写我们自己写的任务函数的函数名。</p><p>pcName：任务名，没啥用，自己随便取，eg:  “LightTask”</p><p>ulStackDepth: 栈大小，值是你提前分配的栈（puxStackBuffer）所对应的大小,单位为字；<code>ulStackDepth</code>  在FreeRTOS中的单位通常根据具体平台和编译器的字长来确定。在32位架构下，一个“字”通常是32位，在16位架构下，则是16位。因此，当提到任务堆栈深度时，如果没有特别说明，可以根据目标处理器架构默认为该架构下的“字”长度。例如，在32位架构中，如果 <code>ulStackDepth</code> 设置为100，则意味着为任务分配了400字节（100 * 4）的堆栈空间。</p><p>pvParameters: 调用任务函数时传入的参数，即pxTaskCode的参数，如果它没有参数，直接写NULL就行</p><p>uxPriority：优先级范围：0~(configMAX_PRIORITIES – 1) 数值越小优先级越低， 如果传入过大的值，xTaskCreate会把它调整为(configMAX_PRIORITIES – 1)</p><p>puxStackBuffer:一个指向预分配的静态任务堆栈缓冲区的指针。这意味着开发者需要自己管理内存，而不是由系统动态分配。比如可以传入一个数组， 它的大小是usStackDepth*4。</p><p>pxTaskBuffer: 指向一个静态任务控制块（TCB）结构体的指针（StaticTask_t 是一个<strong>结构体</strong>类型，它就是TCB））。同样，这里要求开发者预先分配好存储TCB的空间。</p><p>返回值：成功时返回 pdPASS，失败时返回 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY ，<strong>BaseType_t</strong>通常用作简单的返回值的类型</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> StackType_t g_pucStackOfLightTask[<span class="number">128</span>*<span class="number">4</span>?];</span><br><span class="line"><span class="type">static</span> StaticTask_t g_TCBofLightTask;</span><br><span class="line"><span class="type">static</span> TaskHandle_t xLightTaskHandle;<span class="comment">//任务句柄</span></span><br><span class="line"></span><br><span class="line">xLightTaskHandle=xTaskCreateStatic(Led_Test,<span class="string">&quot;LightTask&quot;</span>,<span class="number">128</span>,<span class="literal">NULL</span>,osPriorityNormal,g_pucStackOfLightTask,&amp;g_TCBofLightTask);</span><br></pre></td></tr></table></figure><p><em><strong>疑惑：ulStackDepth和puxStackBuffer值的关系？</strong></em></p><h3 id="估算栈的大小"><a href="#估算栈的大小" class="headerlink" title="估算栈的大小"></a>估算栈的大小</h3><p>确定栈的大小并不容易，通常是根据估计来设定。精确的办法是查看反汇编代码。</p><p><strong>栈里面保存的东西：</strong></p><p><em><strong>1.返回地址LR寄存器，其它寄存器</strong></em>：取决于<strong>函数调用深度</strong>，一般选取最复杂的调用关系来计算</p><p><strong>理论上最多要保存的寄存器（9个）：</strong></p><p><img src="/2024/01/29/FreeRTOS/image-20240130114439040.png" alt="image-20240130114439040"></p><p>可以通过汇编代码查看函数保存的寄存器：</p><p><img src="/2024/01/29/FreeRTOS/image-20240130114341787.png" alt="image-20240130114341787"></p><p>eg: A-&gt;B-&gt;C-&gt;D-&gt;E       5级调用*（被调用者寄存器R4~R11 共8个，LR寄存器，总计9个）</p><p>5x9x4&#x3D;180</p><p>我们可以得出：调用深度越深，需要的栈越大。</p><p>但是用到栈最大的情况不一定是在最深的调用关系这里出现，可能一个函数里定义了一个巨大的局部变量，你得去看你的代码，找到使用局部变量最多的函数</p><p><em><strong>2.局部变量：</strong></em>取决于你的代码，比如你用了一个char buf[1000]</p><p><em><strong>3.现场：</strong></em>16x4 &#x3D;64 (16个寄存器)</p><p>通过1，2，3 你就可以大概估计出你这个程序用到的栈最大有多少，当然最精确的就是去看反汇编。</p><p>实例估计：</p><p><img src="/2024/01/29/FreeRTOS/image-20240130115953696.png" alt="image-20240130115953696"></p><p>4层调用:4x9x4&#x3D;144</p><p>局部变量： MUSI_Analysis()函数里有两个局部变量，4个字节，PassiveBuzzer_Set_Freq_Duty函数里有一个结构体，28字节。共计32字节</p><img src="/2024/01/29/FreeRTOS/image-20240130120203126.png" alt="image-20240130120203126" style="zoom:50%;"><p>现场：64字节</p><p>用到的栈约等于：144+32+64&#x3D;250字节</p><p>我们提供的栈是128字，即128*4字节&gt;250，所以粗略估算是够用的。</p><p><img src="/2024/01/29/FreeRTOS/image-20240130120504361.png" alt="image-20240130120504361"></p><p>精确计算栈的大小以后再说。</p><h3 id="创建任务-使用任务参数"><a href="#创建任务-使用任务参数" class="headerlink" title="创建任务_使用任务参数"></a>创建任务_使用任务参数</h3><p>创建两个任务，使用同一个函数，在LCD上打印不一样的信息</p><p><img src="/2024/01/29/FreeRTOS/image-20240131094453190.png" alt="image-20240131094453190"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  <span class="type">uint8_t</span> x;</span><br><span class="line">  <span class="type">uint8_t</span> y;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task1Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;Task1&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task2Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;Task2&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task3Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="string">&quot;Task3&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_LCDCanUse = <span class="number">1</span>;<span class="comment">/*定义一个全局变量来互斥访问LCD*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdPrintTask</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> *<span class="title">pInfo</span> =</span> params;</span><br><span class="line">  <span class="type">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*打印信息*/</span></span><br><span class="line">    <span class="keyword">if</span> (g_LCDCanUse)</span><br><span class="line">    &#123;</span><br><span class="line">      g_LCDCanUse = <span class="number">0</span>;</span><br><span class="line">      len = LCD_PrintString(pInfo-&gt;x, pInfo-&gt;y, pInfo-&gt;name);</span><br><span class="line">      len += LCD_PrintString(len, pInfo-&gt;y, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">      LCD_PrintSignedVal(len, pInfo-&gt;y, cnt++);</span><br><span class="line">      g_LCDCanUse = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mdelay(<span class="number">500</span>);<span class="comment">//没有添加这句时，其他任务没办法在屏幕上打印信息，比如任务3执行到中间被切换出去，此时g_LCDCanUse是0，其他任务进来也无法执行打印，当任务3执行完g_LCDCanUse=1,由于没有延时，瞬间g_LCDCanUse再次被赋值为0.这样当切换到其他任务时，还是不能运行，就导致只有一个task3执行了打印任务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xTaskCreate(LcdPrintTask, <span class="string">&quot;task1&quot;</span>, <span class="number">128</span>, &amp;g_Task1Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">xTaskCreate(LcdPrintTask, <span class="string">&quot;task2&quot;</span>, <span class="number">128</span>, &amp;g_Task2Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">xTaskCreate(LcdPrintTask, <span class="string">&quot;task3&quot;</span>, <span class="number">128</span>, &amp;g_Task3Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>提问：如何互斥地访问LCD?使用全局变量，大概率可以，但不是万无一失</p><p>提问：为何是后面创建的task3先运行？</p><h3 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h3><p>用遥控器删除任务</p><p>功能为：</p><p>当监测到遥控器的播放按键按下时，创建音乐播放任务</p><p>当监测到遥控器的Power案件按下后，删除音乐播放任务</p><p>删除任务时使用的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t xTaskToDelete )</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>pvTaskCode</td><td>任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。 也可传入NULL，这表示删除自己。</td></tr></tbody></table><p>怎么删除任务？举个不好的例子：</p><ul><li>自杀：vTaskDelete(NULL)</li><li>被杀：别的任务执行vTaskDelete(pvTaskCode)，pvTaskCode是自己的句柄</li><li>杀人：执行vTaskDelete(pvTaskCode)，pvTaskCode是别的任务的句柄</li></ul><p>一句话就是你要删除哪个任务，就传入这个任务的句柄到该函数s</p><p>提问：频繁的创建，删除任务，好吗？有什么坏处？</p><p>频繁的动态分配内存，释放内存，容易产生内存碎片，多次执行之后可能就分配不到内存了</p><p>不能简单的删除一个任务，然后就不管一些后续的清理工作了，要初始化到原来的状态。实际上一般删除任务用的较少，可以直接让任务读取这遥控器，让它自己去停止，做一些清除工作。</p><h3 id="优先级与阻塞"><a href="#优先级与阻塞" class="headerlink" title="优先级与阻塞"></a>优先级与阻塞</h3><p>前言：</p><p>在之前的程序里，播放音乐的时候效果都比较差，会慢半拍，比较卡顿，只要我们把其它任务注释掉就比较顺畅。</p><p>提高音乐播放器的优先级，使用<strong>vTaskDelay</strong>进行延时，就可以改善播放器效果，同时让其它任务不受影响s。</p><p>首先，我们让音乐播放的优先级+1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = xTaskCreate(PlayMusic, <span class="string">&quot;SoundTask&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, osPriorityNormal+<span class="number">1</span>, &amp;xSoundTaskHandle);</span><br></pre></td></tr></table></figure><p>现象：其他任务都不动了，而且按power键删除不了播放音乐任务</p><p>这是因为我们创建了一个高优先级的任务，它一直在运行，独占CPU</p><p>我们要修改这个高优先级的任务，让它在运行过程中主动放弃CPU资源，不再参与调度</p><p>将mdelay替换为vTaskDelay,在延时的过程中它不会参与调度。</p><p>内部机制：</p><h2 id="（重要）任务状态与调度理论"><a href="#（重要）任务状态与调度理论" class="headerlink" title="（重要）任务状态与调度理论"></a>（重要）任务状态与调度理论</h2><p>eg:实现音乐的暂停与继续播放</p><h3 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h3><p><strong>Running</strong>运行状态</p><p><strong>Ready</strong>就绪状态：当创建一个任务后，它就处于就绪状态</p><p><strong>Blocked</strong>阻塞状态(等待某些event) : 一个处于running状态的函数，当用vTaskDelay时，变成Blocked阻塞状态</p><p><strong>Suspend</strong>暂停状态：可以自己调用（必处于running状态）vTaskSuspend()函数，把自己放入暂停状态，或者由别的任务来调用该函数，把你放入暂停状态，别人处于running状态，你处于ready或blocked状态</p><p><img src="/2024/01/29/FreeRTOS/image13.png" alt="image13"></p><h3 id="任务管理与调度机制"><a href="#任务管理与调度机制" class="headerlink" title="任务管理与调度机制"></a>任务管理与调度机制</h3><p>P22 这节是很重要的<strong>理论</strong>介绍，好好体会</p><p><strong>调度：</strong></p><p>1.相同优先级的任务轮流运行。</p><p>2.最高优先级的任务先运行。</p><p><strong>高优先级的任务未执行完，低优先级的任务则无法运行</strong></p><p><strong>一旦高优先级的任务就绪，会马上运行，低优先级任务立刻停止</strong></p><p><strong>最高优先级的任务有多个，则它们轮流运行</strong></p><p><strong>记住RTOS的调度机制</strong>：就绪态的高优先级任务，一定会抢占低优先级的任务。高优先级的任务，不能总是运行。那么高优先级的任务，就应该“使用事件驱动”，比如发生了中断后，才唤醒高优先级的任务，它处理完数据后马上再次阻塞。现在就可以划分优先级了：第1种方法：按任务运行时间划分。比如能使用“事件驱动”的任务，可以设置它的优先级高一点，毕竟它平时大部分时间不运行，只有发生“某些事件（比如中断）”时才执行一会；需要长时间运行的任务，可以设置它的优先级低一点。第2种方法：按任务的紧急程度划分，比如不想丢失按键，那么按键的任务优先级就高；想GUI及时显示，GUI任务的优先级就高；但是要记住：高优先级的任务，一定不能长时间运行，否则其他低优先级的任务就无法运行了。</p><p>核心：<em><strong>链表</strong></em></p><img src="/2024/01/29/FreeRTOS/image-20240131203358178.png" alt="image-20240131203358178" style="zoom:67%;"><img src="/2024/01/29/FreeRTOS/image-20240131203658884.png" alt="image-20240131203658884" style="zoom:67%;"><p>pxReadyTasksLists[N],存放优先级为N的处于Ready&#x2F;Running状态的任务的TCB结构体</p><p><img src="/2024/01/29/FreeRTOS/image-20240131211122969.png" alt="image-20240131211122969"></p><p>阅读代码会发现有一个全局指针pxCurrentTCB,每创建一个任务时该指针都指向它，启动调度器后，由于全局指针指向的是最后创建的这个任务，所以先从它这里执行（这就是06节后面创建的task3反而先运行的原因）</p><p><strong>TICK中断</strong>：FREERTOS定义了一个时钟，TICK_RATE_HZ，cubemx中可以看到频率为1000，即1ms产生一次中断（Tick中断）</p><p>中断里会发生：</p><p>   1.cnt++ </p><p>   2.判断DelayedTaskList里任务是否可以恢复，如果时间到了，就把它移到就绪链表，发起调度</p><p>   3.发起调度</p><p><strong>调度靠中断实现，关闭中断则也无法调度</strong></p><p><strong>发起调度</strong>：从高优先级到低来开始遍历链表数组，直到找到一个非空链表，找到下一个要运行的任务（当前指针所指向任务的下一个），然后运行该任务，直到1ms后再次发生TICK中断。</p><p>当StartfaultTask检测到播放按键被按下，创建了一个优先级更高的任务，则该任务会立即运行，当执行到<strong>vTaskDelay</strong>(2)，则进入<strong>阻塞</strong>状态，阻塞2个TICK，它被从ReadyTaskList链表数组中删除，放到xDelayedTaskList链表数组中，主动放弃运行了，则触发调度，又去遍历链表数组，链表里有一个记录项index，会记录上一次运行的任务，则会从下一个任务来运行。当两个TICK到了，会判断DelayTaskList里任务是否可恢复，把他移出去，重新放入ReadList[25],然后开始发起调度。当被<strong>suspend挂起</strong>时，它会把你从ReadyTaskList链表里移出来,放到xSuspendedTaskList,当Resume时，则移出xSuspendTaskList，重新放到ReadyList</p><p><img src="/2024/01/29/FreeRTOS/image-20240131214952447.png" alt="image-20240131214952447"></p><p><img src="/2024/01/29/FreeRTOS/image-20240131215227772.png" alt="image-20240131215227772"></p><h3 id="空闲任务"><a href="#空闲任务" class="headerlink" title="空闲任务"></a>空闲任务</h3><p>优先级最低，为0，要么处于就绪或者运行状态，永远不会阻塞。</p><p>空闲任务(Idle任务)的作用之一：释放被删除的任务的内存。</p><p>除了上述目的之外，为什么必须要有空闲任务？一个良好的程序，它的任务都是事件驱动的：平时大部分时间处于阻塞状态。有可能我们自己创建的所有任务都无法执行，但是调度器必须能找到一个可以运行的任务：所以，我们要提供空闲任务。在使用vTaskStartScheduler()函数来创建、启动调度器时，这个函数内部会创建空闲任务：</p><ul><li>空闲任务优先级为0：它不能阻碍用户任务运行</li><li>空闲任务要么处于就绪态，要么处于运行态，永远不会阻塞</li></ul><img src="/2024/01/29/FreeRTOS/image-20240131232312235.png" alt="image-20240131232312235" style="zoom:67%;"><p>若Led_Test不是死循环，结束后不做处理直接退出的话，会直接进入到右侧错误函数，会关闭所有中断，进入死循环，所有任务都没办法继续执行。任务能够发生调度是依赖于TICK中断，现在中断都关了，则无法切换</p><p><em><strong>任务结束后，要用vTaskDelete(NULL)删除任务</strong></em></p><p>A杀B，由A给B收尸（清除工作，释放TCB结构体，释放栈） ；B自杀，空闲任务给它收尸</p><p>由于空闲任务优先级最低，若其他优先级的任务不主动放弃CPU，空闲任务无法执行，同时又有很多任务自杀，没人收尸，内存得不到释放，就会慢慢导致内存不足。</p><p>为了让空闲任务有机会运行，或者说是一种良好的编程习惯：</p><p>1.我们编写的任务函数，一般建议使用事件驱动，比如按下某个按键之后，它才会做某些事情，没有的话就阻塞。</p><p>2.延时函数，不要用死循环：mdelay替换为vTaskDelay,每个任务执行完用vTaskDelay（让当前任务不参与调度）进入阻塞状态（移出ReadyTaskList链表数组到xDelayTaskList），空闲任务才有机会运行。</p><p><strong>钩子函数</strong></p><p>我们可以添加一个空闲任务的钩子函数(<strong>Idle Task Hook Functions</strong>)，空闲任务的循环每执行一次，就会调用一次钩子函数。钩子函数的作用有这些：</p><ul><li>执行一些低优先级的、后台的、需要连续执行的函数       (比如可以打印出所有任务的栈信息)</li><li>测量系统的空闲时间：空闲任务能被执行就意味着所有的高优先级任务都停止了，所以测量空闲任务占据的时间，就可以算出处理器占用率。</li><li>让系统进入省电模式：空闲任务能被执行就意味着没有重要的事情要做，当然可以进入省电模式了。</li><li>空闲任务的钩子函数的限制：</li><li>不能导致空闲任务进入阻塞状态、暂停状态</li><li>如果你会使用vTaskDelete()来删除任务，那么钩子函数要非常高效地执行。如果空闲任务移植卡在钩子函数里的话，它就无法释放内存。</li></ul><h3 id="两个Delay函数"><a href="#两个Delay函数" class="headerlink" title="两个Delay函数"></a>两个Delay函数</h3><p>将<strong>mdelay</strong>替换为vTaskDelay,在延时的过程中任务不会参与调度，它不会阻塞让低优先级的任务有机会运行。</p><p>mdelay一直查询时间，不会使任务进入阻塞状态</p><p>vTaskDelay是把任务阻塞，这样低优先级的任务在它阻塞时也能运行。</p><p>有两个Delay函数：</p><ul><li><strong>vTaskDelay</strong>：至少等待指定个数的Tick Interrupt才能变为就绪状态</li><li><strong>vTaskDelayUntil</strong>：等待到指定的绝对时刻，才能变为就绪态。</li><li>它们阻塞的单位都是TICK</li></ul><p>这2个函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">( <span class="type">const</span> TickType_t xTicksToDelay )</span>; <span class="comment">/* xTicksToDelay: 等待多少给Tick */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pxPreviousWakeTime: 上一次被唤醒的时间</span></span><br><span class="line"><span class="comment"> * xTimeIncrement: 要阻塞到(pxPreviousWakeTime + xTimeIncrement)</span></span><br><span class="line"><span class="comment"> * 单位都是Tick Count</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskDelayUntil</span><span class="params">( TickType_t * <span class="type">const</span> pxPreviousWakeTime,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> TickType_t xTimeIncrement )</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pxPreviousWakeTime=xTaskGetTickCount();<span class="comment">//获得启示时间</span></span><br></pre></td></tr></table></figure><p>让每个任务启动时间的间隔是一个定值，周期性的启动运行，就要用vTaskDelayUntil</p><p>下面画图说明：</p><ul><li>使用vTaskDelay(n)时，进入、退出vTaskDelay的时间间隔至少是n个Tick中断</li><li>使用xTaskDelayUntil(&amp;Pre, n)时，前后两次退出xTaskDelayUntil的时间至少是n个Tick中断<ul><li>退出xTaskDelayUntil时任务就进入的就绪状态，一般都能得到执行机会</li><li>所以可以使用xTaskDelayUntil来让任务周期性地运行</li></ul></li></ul><p><img src="/2024/01/29/FreeRTOS/image14.png" alt="image14"></p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><strong>创建任务：</strong></p><p>xTaskCreate()</p><p>xTaskCreateStatic()</p><p><strong>挂起任务：</strong></p><p>vTaskSuspend()     </p><p>vTaskSuspendAll()</p><p><strong>恢复任务：</strong></p><p>vTaskResume()  让挂起的任务重新进入就绪状态</p><p> xTaskResumeFromISR() 专门用在中断服务程序中</p><p>xTaskResumeAll()</p><p><strong>删除任务：</strong></p><p>vTaskDelete() </p><p><strong>延时任务：</strong></p><p>vTaskDelay()   相对延时函数 </p><p>vTaskDelayUntil()  绝对延时函数(适用于周期性任务)</p><p><img src="/2024/01/29/FreeRTOS/image-20240201102602597.png" alt="image-20240201102602597"></p><h1 id="同步互斥与通信"><a href="#同步互斥与通信" class="headerlink" title="同步互斥与通信"></a>同步互斥与通信</h1><h2 id="同步与互斥的概念"><a href="#同步与互斥的概念" class="headerlink" title="同步与互斥的概念"></a>同步与互斥的概念</h2><p>在团队活动里，同事A先写完报表，经理B才能拿去向领导汇报。经理B必须等同事A完成报表，AB之间有依赖，B必须放慢脚步，被称为同步。在团队活动中，同事A已经使用会议室了，经理B也想使用，即使经理B是领导，他也得等着，这就叫互斥。经理B跟同事A说：你用完会议室就提醒我。这就是使用”同步”来实现”互斥”。</p><p>同一时间只能有一个人使用的资源，被称为临界资源。比如任务A、B都要使用串口来打印，串口就是临界资源。如果A、B同时使用串口，那么打印出来的信息就是A、B混杂，无法分辨。所以使用串口时，应该是这样：A用完，B再用；B用完，A再用。</p><h3 id="同步的例子"><a href="#同步的例子" class="headerlink" title="同步的例子"></a>同步的例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task1Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;Task1&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task2Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;Task2&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task3Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="string">&quot;Task3&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_LCDCanUse = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> g_calc_end = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> g_time = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> g_sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务1 计算加法，并计算加法运算的时间，然后删除任务</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CalcTask</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">  g_time = system_get_ns();</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    g_sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  g_calc_end = <span class="number">1</span>;</span><br><span class="line">  g_time = system_get_ns() - g_time;</span><br><span class="line">  vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务2 当计算任务没有结束时，一直执行while循环，直到计算任务结束,g_cal_end变为1，则可进行后面的打印信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdPrintTask</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LCD_PrintString(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;waiting&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (g_calc_end == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印信息 */</span></span><br><span class="line">    <span class="keyword">if</span> (g_LCDCanUse)</span><br><span class="line">    &#123;</span><br><span class="line">      g_LCDCanUse = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      LCD_ClearLine(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      len = LCD_PrintString(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;Sum:&quot;</span>);</span><br><span class="line">      LCD_PrintHex(len, <span class="number">0</span>, g_sum,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      LCD_ClearLine(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">      len = LCD_PrintString(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;Time(ms):&quot;</span>);</span><br><span class="line">      LCD_PrintSignedVal(len, <span class="number">2</span>, g_time/<span class="number">1000000</span>);</span><br><span class="line">      g_LCDCanUse = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  xTaskCreate(CalcTask, <span class="string">&quot;task1&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">  xTaskCreate(LcdPrintTask, <span class="string">&quot;task2&quot;</span>, <span class="number">128</span>, &amp;g_Task2Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>对于static volatile int g_calc_end &#x3D; 0;</p><p>​没有加volatile时，经过<strong>debug</strong>，发现程序一直会卡LcdPrintTask的while (g_calc_end &#x3D;&#x3D; 0);处，<strong>尽管在debug时显示g_calc_end为1还是一直卡在那里</strong>。这是因为在编译器做了一些优化，第一次使用这个变量时，它会去读内存，把这个变量的值读进CPU的某个寄存器，以后在任务2的那个while循环里，它一直都是去判断那个<strong>寄存器</strong>，但是那个寄存器得到的是这个变量原始的，老的值，它并<strong>没有每次都去内存里面读这个变量</strong>，更新那个寄存器，这是不对的，因为这个变量，是在其他任务里面被修改了，你去使用这个变量时，每次都应该去读内存，怎么办呢，<strong>在变量前加一个volatile就好了，告诉编译器，不要去优化它。</strong></p><p>​“在多任务环境下，编译器通常会对变量进行优化以提高代码执行效率。当一个变量被标记为 volatile 时，它告诉编译器这个变量的值可能在程序控制范围之外发生变化（例如由中断服务程序、硬件操作或者其他并发任务修改），因此每次访问该变量时都会从内存中重新读取。<em>编译器对变量的优化通常基于以下几种情况</em>：</p><ol><li><p><strong>局部性原理</strong>：编译器假设在一段连续执行的代码中，如果一个变量没有被显示地修改（比如通过赋值、函数调用或指针间接访问），其值就不会改变。因此，在循环内多次读取同一变量时，编译器可能会将该变量从内存加载到寄存器中，并在整个循环期间使用寄存器中的值，以减少对内存的访问。</p></li><li><p><strong>数据流分析</strong>：编译器会进行数据依赖性分析，如果它能确定某个变量在当前作用域内不会受外部因素影响而改变，即使这个变量是全局的，也可能对其进行优化。</p></li><li><p><strong>跨函数优化</strong>：编译器还可能进行跨函数优化，例如当函数没有明确的副作用或者编译器能够推断出函数内部对全局变量的修改不会影响到当前上下文时，也会选择不重新加载变量。”</p><p>应当在以下情况下考虑使用 <code>volatile</code> 关键字来修饰变量：</p><ul><li>变量可能被<strong>中断服务程序修改</strong>。</li><li>变量位于<strong>多线程环境且不同线程间共享并修改该变量</strong>。</li><li>变量与硬件寄存器映射相关，硬件可能会在软件不可见的情况下更改它们的值。</li><li>变量用于信号量、事件标志或其他同步机制。</li></ul></li></ol><p>上例LcdPrintTask任务的while函数，尽管没有后面的内容没有执行，但是它会执行while一直循环，也会占用CPU资源，实际打印出来的时间也不是计算任务实际的时间，而是实际时间的两倍，因为任务一二是每过一个TICK就交替执行的，这也是我们说的用静态变量来解决互斥问题的缺陷)。</p><p>所以使用同步的时候，我们需要考虑怎样提高处理器的性能，让那些等待的任务阻塞，不要参与CPU的调度。</p><p>PS:<br>debug过程</p><p><a href="https://www.bilibili.com/video/BV1Jw411i7Fz?p=25&vd_source=a9d487fcf1a579639c6348eb5a9321db">https://www.bilibili.com/video/BV1Jw411i7Fz?p=25&amp;vd_source=a9d487fcf1a579639c6348eb5a9321db</a></p><p>9:25~11:05</p><h3 id="互斥的例子"><a href="#互斥的例子" class="headerlink" title="互斥的例子"></a>互斥的例子</h3><p>示例1</p><p><img src="/2024/01/29/FreeRTOS/image-20240202100718491.png" alt="image-20240202100718491"></p><p>这三个任务都使用同一个函数，这个函数里面会在屏幕显示信息，屏幕就是临界资源，同一时间只能够有一个任务来访问，通过IIC访问硬件，如果不提供互斥保护措施的话 ，IIC时序会被打乱。</p><p><img src="/2024/01/29/FreeRTOS/image-20240202101126626.png" alt="image-20240202101126626"></p><p>因此，使用红框内的代码操作LCD时，必须互斥访问，A没有用完,B不能够使用<img src="/2024/01/29/FreeRTOS/image-20240202101238904.png" alt="image-20240202101238904"></p><p>目前是用的全局变量g_LCDCanUse来互斥保护，大部分情况是可以的，但理论上它是有缺陷的：</p><p>当A运行到108行被切换了，此时g_LCDCanUse&#x3D;1，B运行也可以进去，这样A和B都可以使用LCD，使IIC时序混乱。当程序运行成千上万次时，很有可能出现这样的问题。</p><p>示例2</p><img src="/2024/01/29/FreeRTOS/image-20240202101618191.png" alt="image-20240202101618191" style="zoom:80%;"><p>如果改成这样，看上去貌似没什么问题，但再往细看，执行bCanUse–这一条指令时，汇编发生了三个过程。先把bCanUse存入一个寄存器，把这个寄存器的值减一，然后再赋值给bCanUse,如果A在把bCanUse存到寄存器后被切换为B，此时bCanUse还是1，减1后为0，B可以运行，再切换为A时，因为保存的有现场，所以当时的R0&#x3D;1被保存下来，减1后为0，也可以运行LCD。这三个过程，它们是可以被切换的，虽然概率很小，但你不可能杜绝它。</p><p><img src="/2024/01/29/FreeRTOS/image-20240202103314866.png" alt="image-20240202103314866"></p><p><img src="/2024/01/29/FreeRTOS/image-20240202102710295.png" alt="image-20240202102710295"></p><p>从上面的例子可以看出，如果简单的使用这种全局变量来保护临界资源，虽然大概率没问题，但当程序运行很长时间后可能出问题。</p><p>解决方法可以是<strong>关中断</strong>：</p><p>示例1的代码改进如下：在第5~7行前关闭中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LCD_PrintString</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> *str)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> bCanUse = <span class="number">1</span>;</span><br><span class="line">  disable_irq();</span><br><span class="line">  <span class="keyword">if</span> (bCanUse)</span><br><span class="line">  &#123; </span><br><span class="line">       bCanUse = <span class="number">0</span>;</span><br><span class="line">       enable_irq();</span><br><span class="line">      <span class="comment">/* 使用LCD */</span></span><br><span class="line">       bCanUse = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  enable_irq();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例2的代码改进如下：在第5行前关闭中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LCD_PrintString</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> *str)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> bCanUse = <span class="number">1</span>;</span><br><span class="line">  disable_irq();</span><br><span class="line">  bCanUse--;</span><br><span class="line">  enable_irq();</span><br><span class="line">  <span class="keyword">if</span> (bCanUse == <span class="number">0</span>)</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="comment">/* 使用LCD */</span></span><br><span class="line">    bCanUse++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    disable_irq();</span><br><span class="line">    bCanUse++;</span><br><span class="line">    enable_irq();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样的话 确实能行 但其实B任务也会占用CPU资源，最好的是我们应该让它<strong>阻塞</strong>，A用完了之后再把B唤醒。</p><h3 id="通信的例子"><a href="#通信的例子" class="headerlink" title="通信的例子"></a>通信的例子</h3><p>通过一个全局变量设置状态,在AB里通信，也可能在这个全局变量还没改完就切换了，这样就通信失败了，要用互斥的方法来解决，同时要保持高效，要用阻塞。</p><h3 id="FreeRTOS的解决方案（概述）"><a href="#FreeRTOS的解决方案（概述）" class="headerlink" title="FreeRTOS的解决方案（概述）"></a>FreeRTOS的解决方案（概述）</h3><ul><li>用<strong>互斥</strong>的方法保证正确性</li><li>效率：等待者要进入<strong>阻塞</strong>状态（阻塞和唤醒机制来提高效率）</li><li>多种解决方案</li></ul><p><strong>队列</strong></p><p>可以认为队列是一个传送带，流水线，先进先出</p><p><img src="/2024/01/29/FreeRTOS/image-20240202112706799.png" alt="image-20240202112706799"></p><p><strong>事件组</strong></p><p><img src="/2024/01/29/FreeRTOS/image-20240202112808004.png" alt="image-20240202112808004"></p><p><strong>信号量</strong></p><p><img src="/2024/01/29/FreeRTOS/image-20240202112855635.png" alt="image-20240202112855635"> </p><p><strong>互斥量</strong></p><p><img src="/2024/01/29/FreeRTOS/image-20240202113014790.png" alt="image-20240202113014790"></p><p><strong>任务通知</strong></p><p><img src="/2024/01/29/FreeRTOS/image-20240202112947029.png" alt="image-20240202112947029"></p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>数据传输的方法</p><p><img src="/2024/01/29/FreeRTOS/image-20240202183047523.png" alt="image-20240202183047523"></p><h2 id="环形缓冲区"><a href="#环形缓冲区" class="headerlink" title="环形缓冲区"></a><strong>环形缓冲区</strong></h2><p>解释的很清楚： <a href="http://t.csdnimg.cn/DY7gy">http://t.csdnimg.cn/DY7gy</a></p><p>环形缓冲区是<a href="https://so.csdn.net/so/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F&spm=1001.2101.3001.7020">嵌入式</a>系统中十分重要的一种数据结构，比如在<strong>串口</strong>处理中，串口中断接收数据直接往环形缓冲区丢数据，而应用可以从环形缓冲区取数据进行处理，这样数据在读取和写入的时候都可以在这个缓冲区里循环进行，程序员可以根据自己需要的数据大小来决定自己使用的缓冲区大小，<strong>不用担心数组越界</strong>。</p><p><strong>队列</strong>的基本概念：队列 (Queue)：是一种先进先出(First In First Out ,简称 FIFO)的线性表，只允许在一端插入（入队），在另一端进行删除（出队）。</p><p>队列头就是指向已经存储的数据，并且这个数据是待处理的。下一个CPU处理的数据就是1；而队列尾则指向可以进行写数据的地址。</p><p>队列的最大长度queueMaxsize&#x3D;数组容量arrayMaxSize-1 （<strong>由于置空位要占一位,置空位是为了让空载和满载的判断条件区别开来，否则它们都是头&#x3D;尾，就不能因此来判断队列是空还是满</strong>），所以也引出了代码里的next_w。</p><p><strong>置空位</strong>虽然是人为引入的，但这不意味这置空位的位置是随意的，实际上，只有队列满后才会将剩下的位置作为置空位，一旦置空位出现，rear和front永远不可能指向同一个索引位，因为你会惊奇的发现置空位恰号将rear和front隔开了。</p><img src="/2024/01/29/FreeRTOS/image-20240202183437083.png" alt="image-20240202183437083" style="zoom:67%;"><p><strong>示例代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> buf[<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> head=<span class="number">0</span>,tail=<span class="number">0</span>;<span class="comment">//head对应索引位待出列，tail对应索引位待入列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断条件</span></span><br><span class="line"><span class="comment">//buf空</span></span><br><span class="line">head==tail</span><br><span class="line"><span class="comment">//buf满 </span></span><br><span class="line">head=(tail+<span class="number">1</span>)%maxSize<span class="comment">//引入了置空位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写的方法</span></span><br><span class="line"><span class="keyword">if</span>(next_w!=r)<span class="comment">//未满</span></span><br><span class="line">&#123;</span><br><span class="line">    buf(w)=val;</span><br><span class="line">    w++;</span><br><span class="line">    <span class="keyword">if</span>(w==<span class="number">8</span>)</span><br><span class="line">    w=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读</span></span><br><span class="line"><span class="keyword">if</span>(r!=w)<span class="comment">//有数据</span></span><br><span class="line">&#123;</span><br><span class="line">    val=buf[r];</span><br><span class="line">    r++;</span><br><span class="line">    <span class="keyword">if</span>(r==<span class="number">8</span>)</span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应用代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RINGBUFF_LEN 256;</span></span><br><span class="line"><span class="comment">//定义一个缓冲区结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 Head;           </span><br><span class="line">    u16 Tail;</span><br><span class="line">    u8 Ring_Buff[RINGBUFF_LEN];</span><br><span class="line">&#125;RingBuff_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*若想更灵活，可以用动态内存分配方式（如使用指针）来实现可变长度的缓冲区</span></span><br><span class="line"><span class="comment">typedef struct</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">u16 Head;</span></span><br><span class="line"><span class="comment">u16 Tail;</span></span><br><span class="line"><span class="comment">u8* Ring_Buff;</span></span><br><span class="line"><span class="comment">&#125;RingBuff_t;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 初始化函数，传入所需长度</span></span><br><span class="line"><span class="comment">void RingBuff_Init(RingBuff_t rbuff, size_t len)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Head = 0;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Tail = 0;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Ring_Buff = (u8)malloc(len * sizeof(u8));</span></span><br><span class="line"><span class="comment">    if (!rbuff-&gt;Ring_Buff) &#123;</span></span><br><span class="line"><span class="comment">    // 处理内存分配失败的情况...</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">在C语言中，u8* Ring_Buff; 是一个指向无符号8位整型（通常代表字节）的指针。它本身并不是一个数组，但可以用来指向一块内存区域，这块内存可以被当作数组来处理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当你通过 malloc 函数为 Ring_Buff 分配了足够长度的内存后，你就可以像操作数组那样对这块内存进行读写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个ringBuff的缓冲区</span></span><br><span class="line">RingBuff_t ringBuff;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化环形缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RingBuff_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//初始化相关信息</span></span><br><span class="line">   ringBuff.Head = <span class="number">0</span>;</span><br><span class="line">   ringBuff.Tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">u8 <span class="title function_">Write_RingBuff</span><span class="params">(u8 data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ringBuff.Head=(ringBuff.Tail+<span class="number">1</span>)%maxSize) <span class="comment">//缓冲区满</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> FLASE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ringBuff.Ring_Buff[ringBuff.Tail]=data;<span class="comment">//在Tail对应索引位写入数据</span></span><br><span class="line">    ringBuff.Tail=(ringBuff.Tail+<span class="number">1</span>)%RINGBUFF_LEN; <span class="comment">//ringBuff.Tail++; 防止越界非法访问</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读数据</span></span><br><span class="line"><span class="number">10u</span>8 Read_RingBuff(u8 *rData)</span><br><span class="line"><span class="number">11</span>&#123;</span><br><span class="line"><span class="number">12</span>   <span class="keyword">if</span>(ringBuff.Head==ringBuff.Tail)<span class="comment">//判断非空</span></span><br><span class="line"><span class="number">13</span>    &#123;</span><br><span class="line"><span class="number">14</span>       <span class="keyword">return</span> FLASE;</span><br><span class="line"><span class="number">15</span>    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">16</span>   *rData = ringBuff.Ring_Buff[ringBuff.Head];<span class="comment">//先进先出FIFO，从缓冲区头出</span></span><br><span class="line"></span><br><span class="line"><span class="number">18</span>   ringBuff.Head = (ringBuff.Head+<span class="number">1</span>)%RINGBUFF_LEN;<span class="comment">// ringBuff.Head++;防止越界非法访问</span></span><br><span class="line">    </span><br><span class="line"><span class="number">20</span>   <span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure><p>如果在使用场景里面只有两个任务，且不考虑阻塞-唤醒（效率），就可以使用环形缓冲区，注意不要添加一个全局变量计数值，两个任务都来修改它的话可能会出问题。</p><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>队列的本质是加了互斥措施，阻塞-唤醒机制的环形缓冲区 .</p><p>1.有环形buffer</p><p>2.两个链表: 阻塞时放到对应的链表里，Sender List, Receiver List</p><p>一个任务想去读队列，如果队列里没有数据读不到数据且愿意等待的话，它将会从就绪链表ReadyTaskList里移除，放到队列的接收链表Receiver List和一个Delay链表（超时时间）里，若有其他任务写队列，会把这个任务唤醒，从接收链表和Delay链表中删去，重新放到ReadyList中，若是超时的话则中断会唤醒它，放到就绪列表ReadyTaskList中，有机会运行时，它的返回值就是一个错误的，我们就知道没有数据，是超时唤醒它。</p><p>当阻塞时有两种唤醒的情况，一种是其他任务唤醒它，另一种是超时中断唤醒。</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p><img src="/2024/01/29/FreeRTOS/image-20240203165500251.png" alt="image-20240203165500251"></p><img src="/2024/01/29/FreeRTOS/image-20240204113223528.png" alt="image-20240204113223528" style="zoom:50%;"><p>挡球板任务一直执行while循环，尝试去读，无阻塞低效率。要将其改进为读队列A，红外中断解析出数据后写队列A</p><p>1.创建一个队列A</p><p>2.在红外ISR（中断）中写队列A</p><p>3.挡球板任务中读队列A</p><h2 id="队列集"><a href="#队列集" class="headerlink" title="队列集"></a>队列集</h2><p>队列集其实也是一个队列，只不过里面放的是队列的句柄。</p><p>如果对于每一个硬件都单独创建一个任务，任务需要栈空间，对于系统资源很浪费。</p><p>不管有多少个设备，只有一个任务，就不会很浪费系统资源，那么任务要怎么及时读到各个硬件的数据呢，一种是用轮询的方式（不断的运行，一直都没有阻塞，浪费CPU资源），另一种是用队列集。</p><p><img src="/2024/01/29/FreeRTOS/image-20240204173837321.png" alt="image-20240204173837321"></p><h3 id="内部机制"><a href="#内部机制" class="headerlink" title="内部机制"></a>内部机制</h3><p><img src="/2024/01/29/FreeRTOS/image-20240204173241805.png" alt="image-20240204173241805"></p><p>队列写了数据，必定会顺带把自己的句柄写入队列级（不用我们操作，freertos来做这些事）</p><h3 id="队列集实验"><a href="#队列集实验" class="headerlink" title="队列集实验"></a>队列集实验</h3><p>改进程序框架</p><p><img src="/2024/01/29/FreeRTOS/image-20240206093625049.png" alt="image-20240206093625049"></p><p>IRReceiver_IRQTimes_Parse是红外遥控器的中断函数，他解析出按键值后，会转换成游戏控制的键值，然后写入Platform队列,这就涉及到了业务上的东西，它把键值转换成游戏控制的值，这样就不纯粹了，硬件相关的程序，不应该跟业务密切相关</p><img src="/2024/01/29/FreeRTOS/image-20240206094359196.png" alt="image-20240206094359196" style="zoom:50%;"><p>若对每个硬件都单独创建一个任务，对于系统的资源有极大的浪费</p><img src="/2024/01/29/FreeRTOS/image-20240206094847424.png" alt="image-20240206094847424" style="zoom:50%;"><p>正确的做法：</p><img src="/2024/01/29/FreeRTOS/image-20240206093654826.png" alt="image-20240206093654826" style="zoom:50%;"><p>硬件相关的代码与游戏没有关系</p><h3 id="配置队列集文件"><a href="#配置队列集文件" class="headerlink" title="配置队列集文件"></a>配置队列集文件</h3><p>要使用队列集，得配置freeRTOS,发现CUBEMX没有相关设置</p><p><img src="/2024/01/29/FreeRTOS/image-20240206115409463.png" alt="image-20240206115409463"></p><p>在freeRTOS.h中找到</p><p><img src="/2024/01/29/FreeRTOS/image-20240206115628455.png" alt="image-20240206115628455"></p><p>可以直接修改，但是如果CUBEMX重新生成工程，它又被恢复，直接把它加到FreeRTOSConfig.h中</p><p>如果运行工程，发现程序正常运行，但少了一些东西，可能是内存不够，堆不够，把3072改大一点比如8000</p><p><img src="/2024/01/29/FreeRTOS/image-20240206120715546.png" alt="image-20240206120715546"></p><p>程序15与14现象是一样的，但是框架更漂亮了。</p><h4 id="增加姿态控制"><a href="#增加姿态控制" class="headerlink" title="增加姿态控制"></a>增加姿态控制</h4><p>这次不是从中断获取数据，而是要创建一个任务，在while循环里面读I2C获取数据，然后写队列，然后在game任务将队列加入队列集</p><p>注意创建MPU6050任务时的顺序</p><p>刚开始是在freertos.c，在game1_task创建后马上就创建了6050的任务，如果6050的任务运行了，队列写满了，然后才把这个队列放入队列集，由于写满了，无法再向队列写数据，队列集得不到队列的句柄。（读取队列需要在队列集力先有该队列的句柄，但是这里把队列加入队列集之前队列就满了，队列写不了数据队列集也有没有句柄可读了）</p><p><img src="/2024/01/29/FreeRTOS/image-20240207115825852.png" alt="image-20240207115825852"></p><p>所以应该要在将6050加入队列集的代码之后再创建6050的任务</p><p><img src="/2024/01/29/FreeRTOS/image-20240207120435680.png" alt="image-20240207120435680"></p><h4 id="（实验）分发数据给多个任务"><a href="#（实验）分发数据给多个任务" class="headerlink" title="（实验）分发数据给多个任务"></a>（实验）分发数据给多个任务</h4><p>赛车游戏</p><p>引入了一个有意思的东西，比如想使用同一个输入数据来控制多个任务，可以在驱动程序里面，去写多个队列，去写哪些队列，其决定权可以交给应用程序，应用程序调用一个所谓的<strong>注册函数</strong>把它的句柄告诉驱动程序，驱动程序会把它记录下来。</p><p>如果只是一个队列，三个任务从这个队列读数据，则一个任务把数据读走了之后，另外两个任务就读不到数据了，所以要给每个任务创建一个队列，在红外中断解析函数得到数据后直接使用DispatchKey函数分配，把数据给各个队列都写一份，各个队列依据数据里的control_key判断是否是自己的。</p><p>可以这么写，但是写的比较丑陋，以后增加一个队列的话，又得来修改这些代码，且代码跟car密切相关，那这套代码就只能用在car上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DispatchKey</span><span class="params">(<span class="keyword">struct</span> ir_data *pidata)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> QueueHandle_t g_xQueueCar1;</span><br><span class="line"><span class="keyword">extern</span> QueueHandle_t g_xQueueCar2;</span><br><span class="line"><span class="keyword">extern</span> QueueHandle_t g_xQueueCar3;</span><br><span class="line"></span><br><span class="line">xQueueSendFromISR(g_xQueueCar1, pidata, <span class="literal">NULL</span>);</span><br><span class="line">xQueueSendFromISR(g_xQueueCar2, pidata, <span class="literal">NULL</span>);</span><br><span class="line">xQueueSendFromISR(g_xQueueCar3, pidata, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//driver_ir_receiver.c</span></span><br><span class="line"><span class="type">static</span> QueueHandle_t g_xQueues[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterQueueHandle</span><span class="params">(QueueHandle_t queueHandle)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (g_queue_cnt &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">g_xQueues[g_queue_cnt] = queueHandle;</span><br><span class="line">g_queue_cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DispatchKey</span><span class="params">(<span class="keyword">struct</span> ir_data *pidata)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_queue_cnt; i++)</span><br><span class="line">&#123;</span><br><span class="line">xQueueSendFromISR(g_xQueues[i], pidata, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//game2.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> &#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="type">int</span> control_key;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> <span class="title">g_cars</span>[3] =</span> &#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, IR_KEY_1&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">17</span>, IR_KEY_2&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">34</span>, IR_KEY_3&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">car_game</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">g_framebuffer = LCD_GetFrameBuffer(&amp;g_xres, &amp;g_yres, &amp;g_bpp);</span><br><span class="line">draw_init();</span><br><span class="line">draw_end();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 画出路标 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">draw_bitmap(<span class="number">16</span>*j, <span class="number">16</span>+<span class="number">17</span>*i, roadMarking, <span class="number">8</span>, <span class="number">1</span>, NOINVERT, <span class="number">0</span>);</span><br><span class="line">draw_flushArea(<span class="number">16</span>*j, <span class="number">16</span>+<span class="number">17</span>*i, <span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建3个汽车任务 */</span></span><br><span class="line">    xTaskCreate(CarTask, <span class="string">&quot;car1&quot;</span>, <span class="number">128</span>, &amp;g_cars[<span class="number">0</span>], osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">    xTaskCreate(CarTask, <span class="string">&quot;car2&quot;</span>, <span class="number">128</span>, &amp;g_cars[<span class="number">1</span>], osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">    xTaskCreate(CarTask, <span class="string">&quot;car3&quot;</span>, <span class="number">128</span>, &amp;g_cars[<span class="number">2</span>], osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">CarTask</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> *<span class="title">pcar</span> =</span> params;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ir_data</span> <span class="title">idata</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建自己的队列 */</span></span><br><span class="line">QueueHandle_t xQueueIR = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ir_data));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册队列 */</span></span><br><span class="line">RegisterQueueHandle(xQueueIR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 显示汽车 */</span></span><br><span class="line">ShowCar(pcar);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 读取按键值:读队列 */</span></span><br><span class="line">xQueueReceive(xQueueIR, &amp;idata, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制汽车往右移动 */</span></span><br><span class="line"><span class="keyword">if</span> (idata.val == pcar-&gt;control_key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x &lt; g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 隐藏汽车 */</span></span><br><span class="line">HideCar(pcar);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调整位置 */</span></span><br><span class="line">pcar-&gt;x += <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x &gt; g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line">pcar-&gt;x = g_xres - CAR_LENGTH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重新显示汽车 */</span></span><br><span class="line">ShowCar(pcar);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先car_game()创建三个任务，对应三辆汽车，传入的&amp;g_cars[0]，&amp;g_cars[1]，&amp;g_cars[2]，其中存放着它们各自的参数。这三个任务使用同一个CarTask函数，只是参数不同。</p><p>在CarTask函数中，会创建一个队列，属于当前任务，然后把这个队列注册（加到g_xQueues[10]中）。</p><p>然后再中断解析函数中调用dispatch函数，使用for循环，把解析出的数据给每一个队列都写一份数据，对应任务识别到自己相应control_key后才会继续响应。</p><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><h2 id="本质-1"><a href="#本质-1" class="headerlink" title="本质"></a>本质</h2><p>信号量本质上也是一个队列，但是它不涉及数据的传输，只涉及到里面数据个数的统计</p><p>例子</p><p>把信号量看成门票</p><p>取票为take，放票为give</p><p><img src="/2024/01/29/FreeRTOS/image-20240215091923497.png" alt="image-20240215091923497"></p><p><strong>信号量与队列对比</strong></p><p><img src="/2024/01/29/FreeRTOS/image-20240215092142252.png" alt="image-20240215092142252"></p><p><img src="/2024/01/29/FreeRTOS/image-20240215092450514.png" alt="image-20240215092450514"></p><p>对于阻塞的任务，高优先级排在前面，当信号量增加时会先唤醒高优先级的任务，同等优先级任务按先来后到的顺序执行。</p><p><img src="/2024/01/29/FreeRTOS/image-20240215094215394.png" alt="image-20240215094215394"></p><p> <strong>例子</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> SemaphoreHandle_t g_xSemTicks;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">car_game</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">g_framebuffer = LCD_GetFrameBuffer(&amp;g_xres, &amp;g_yres, &amp;g_bpp);</span><br><span class="line">draw_init();</span><br><span class="line">draw_end();</span><br><span class="line">g_xSemTicks=xSemaphoreCreateCounting(<span class="number">3</span>, <span class="number">1</span>);<span class="comment">//创建信号量，最大值为3，初始值为1</span></span><br><span class="line"><span class="comment">/* 画出路标 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">draw_bitmap(<span class="number">16</span>*j, <span class="number">16</span>+<span class="number">17</span>*i, roadMarking, <span class="number">8</span>, <span class="number">1</span>, NOINVERT, <span class="number">0</span>);</span><br><span class="line">draw_flushArea(<span class="number">16</span>*j, <span class="number">16</span>+<span class="number">17</span>*i, <span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建3个汽车任务 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">draw_bitmap(g_cars[i].x, g_cars[i].y, carImg, <span class="number">15</span>, <span class="number">16</span>, NOINVERT, <span class="number">0</span>);</span><br><span class="line">draw_flushArea(g_cars[i].x, g_cars[i].y, <span class="number">15</span>, <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    xTaskCreate(CarTask, <span class="string">&quot;car1&quot;</span>, <span class="number">128</span>, &amp;g_cars[<span class="number">0</span>], osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">    xTaskCreate(CarTask, <span class="string">&quot;car2&quot;</span>, <span class="number">128</span>, &amp;g_cars[<span class="number">1</span>], osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">    xTaskCreate(CarTask, <span class="string">&quot;car3&quot;</span>, <span class="number">128</span>, &amp;g_cars[<span class="number">2</span>], osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">CarTask</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> *<span class="title">pcar</span> =</span> params;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ir_data</span> <span class="title">idata</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建自己的队列 */</span></span><br><span class="line">QueueHandle_t xQueueIR = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ir_data));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册队列 */</span></span><br><span class="line">RegisterQueueHandle(xQueueIR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 显示汽车 */</span></span><br><span class="line">ShowCar(pcar);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取信号量</span></span><br><span class="line">xSemaphoreTake(g_xSemTicks,portMAX_DELAY);<span class="comment">//获取信号量，也就是票，如果没获得就一直等待</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 控制汽车往右移动 */</span></span><br><span class="line">        <span class="keyword">if</span> (pcar-&gt;x &lt; g_xres - CAR_LENGTH)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 隐藏汽车 */</span></span><br><span class="line">            HideCar(pcar);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 调整位置 */</span></span><br><span class="line">            pcar-&gt;x += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (pcar-&gt;x &gt; g_xres - CAR_LENGTH)</span><br><span class="line">            &#123;</span><br><span class="line">                pcar-&gt;x = g_xres - CAR_LENGTH;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 重新显示汽车 */</span></span><br><span class="line">            ShowCar(pcar);</span><br><span class="line">            vTaskDelay(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pcar-&gt;x == g_xres - CAR_LENGTH)</span><br><span class="line">            &#123;</span><br><span class="line">                xSemaphoreGive(g_xSemTicks);<span class="comment">//汽车跑到终点后，释放信号量，同时唤醒正在等待的任务</span></span><br><span class="line">                vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h2><p>低优先级的任务先运行<img src="/2024/01/29/FreeRTOS/image-20240215103515812.png" alt="image-20240215103515812"></p><p>上面这个例子，低优先级的任务先创建，并取走了信号量，然后中优先级的任务创建，执行一些东西，阻塞第一个任务且它不去获得信号量，然后高优先级的任务创建，阻塞中优先级任务并调用take函数，由于信号量被低优先级的任务取走了，所以它会阻塞，中优先级的任务继续执行，汽车到终点后自杀结束任务，然后低优先级的任务继续执行，汽车执行到终点后释放信号量，高优先级的任务才开始运行，从而实现了优先级反转。</p><p><img src="/2024/01/29/FreeRTOS/image-20240215113332857.png" alt="image-20240215113332857"></p><h2 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h2><p>使用信号量时，先创建、然后去添加资源、获得资源。使用句柄来表示一个信号量。</p><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>使用信号量之前，要先创建，得到一个句柄；使用信号量时，要使用句柄来表明使用哪个信号量。 对于二进制信号量、计数型信号量，它们的创建函数不一样：</p><table><thead><tr><th></th><th>二进制信号量</th><th>计数型信号量</th></tr></thead><tbody><tr><td>动态创建</td><td>xSemaphoreCreateBinary 计数值初始值为0</td><td>xSemaphoreCreateCounting</td></tr><tr><td></td><td>vSemaphoreCreateBinary(过时了) 计数值初始值为1</td><td></td></tr><tr><td>静态创建</td><td>xSemaphoreCreateBinaryStatic</td><td>xSemaphoreCreateCountingStatic</td></tr></tbody></table><p>创建二进制信号量的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配信号量结构体 </span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinary</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinaryStatic</span><span class="params">( StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure><p>创建计数型信号量的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配信号量结构体 </span></span><br><span class="line"><span class="comment"> * uxMaxCount: 最大计数值</span></span><br><span class="line"><span class="comment"> * uxInitialCount: 初始计数值</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * uxMaxCount: 最大计数值</span></span><br><span class="line"><span class="comment"> * uxInitialCount: 初始计数值</span></span><br><span class="line"><span class="comment"> * pxSemaphoreBuffer: StaticSemaphore_t结构体指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCountingStatic</span><span class="params">( UBaseType_t uxMaxCount, </span></span><br><span class="line"><span class="params">                                                 UBaseType_t uxInitialCount, </span></span><br><span class="line"><span class="params">                                                 StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>对于动态创建的信号量，不再需要它们时，可以删除它们以回收内存。</p><p>vSemaphoreDelete可以用来删除二进制信号量、计数型信号量，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * xSemaphore: 信号量句柄，你要删除哪个信号量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure><h3 id="give-take"><a href="#give-take" class="headerlink" title="give&#x2F;take"></a>give&#x2F;take</h3><p>二进制信号量、计数型信号量的give、take操作函数是一样的。这些函数也分为2个版本：给任务使用，给ISR使用。列表如下：</p><table><thead><tr><th></th><th>在任务中使用</th><th>在ISR中使用</th></tr></thead><tbody><tr><td>give</td><td>xSemaphoreGive</td><td>xSemaphoreGiveFromISR</td></tr><tr><td>take</td><td>xSemaphoreTake</td><td>xSemaphoreTakeFromISR</td></tr></tbody></table><p>xSemaphoreGive的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure><p>xSemaphoreGive函数的参数与返回值列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>信号量句柄，释放哪个信号量</td></tr><tr><td>返回值</td><td>pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td></tr></tbody></table><p>pxHigherPriorityTaskWoken的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreGiveFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                        SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                        BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                    )</span>;</span><br></pre></td></tr></table></figure><p>xSemaphoreGiveFromISR函数的参数与返回值列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>信号量句柄，释放哪个信号量</td></tr><tr><td>pxHigherPriorityTaskWoken</td><td>如果释放信号量导致更高优先级的任务变为了就绪态， 则*pxHigherPriorityTaskWoken &#x3D; pdTRUE</td></tr><tr><td>返回值</td><td>pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td></tr></tbody></table><p>xSemaphoreTake的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">(</span></span><br><span class="line"><span class="params">                   SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                   TickType_t xTicksToWait</span></span><br><span class="line"><span class="params">               )</span>;</span><br></pre></td></tr></table></figure><p>xSemaphoreTake函数的参数与返回值列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>信号量句柄，获取哪个信号量</td></tr><tr><td>xTicksToWait</td><td>如果无法马上获得信号量，阻塞一会： 0：不阻塞，马上返回 portMAX_DELAY: 一直阻塞直到成功 其他值: 阻塞的Tick个数，可以使用*pdMS_TO_TICKS()*来指定阻塞时间为若干ms</td></tr><tr><td>返回值</td><td>pdTRUE表示成功</td></tr></tbody></table><p>xSemaphoreTakeFromISR的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreTakeFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                        SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                        BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                    )</span>;</span><br></pre></td></tr></table></figure><p>xSemaphoreTakeFromISR函数的参数与返回值列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>信号量句柄，获取哪个信号量</td></tr><tr><td>pxHigherPriorityTaskWoken</td><td>如果获取信号量导致更高优先级的任务变为了就绪态， 则*pxHigherPriorityTaskWoken &#x3D; pdTRUE</td></tr><tr><td>返回值</td><td>pdTRUE表示成功</td></tr></tbody></table><h1 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h1><p>是信号量的一种变种</p><h2 id="解决优先级反转"><a href="#解决优先级反转" class="headerlink" title="解决优先级反转"></a>解决优先级反转</h2><p>例</p><p><img src="/2024/01/29/FreeRTOS/image-20240215131331890.png" alt="image-20240215131331890"></p><p>学生在用超算（指纹验证），主任带人来参观实验室，对学生说太吵了，先别用，然后校长也来了要用超算，但是因为学生已经指纹验证了，所以它得等着，用互斥量的话就是校长临时<strong>提拔</strong>（学生继承校长优先级）学生到他的级别，然后学生继续用超算，用完了后就识相的<strong>恢复</strong>自己的级别（优先级），然后校长来用超算，校长用完了之后主任带人参观</p><h2 id="保护临界资源"><a href="#保护临界资源" class="headerlink" title="保护临界资源"></a><strong>保护临界资源</strong></h2><p>eg: I2C互斥访问，同时只能有一个使用I2C，否则会使数据传输失败。所以要加上互斥锁</p><p>单纯的使用全局变量来保护有风险，比如当任务二执行bInUsed&#x3D;1后，任务三被创建，任务二被阻塞，而bInUsed还没被清零，所以任务三一直卡在while。</p><p><img src="/2024/01/29/FreeRTOS/image-20240215135533456.png" alt="image-20240215135533456"></p><p>任务A访问这些全局变量、函数代码时，独占它，就是上个锁。这些全局变量、函数代码必须被独占地使用，它们被称为临界资源。</p><p>互斥量也被称为互斥锁，使用过程如下：</p><ul><li>互斥量初始值为1</li><li>任务A想访问临界资源，先获得并占有互斥量，然后开始访问</li><li>任务B也想访问临界资源，也要先获得互斥量：被别人占有了，于是<strong>阻塞</strong></li><li>任务A使用完毕，释放互斥量；任务B被唤醒、得到并占有互斥量，然后开始访问临界资源</li><li>任务B使用完毕，释放互斥量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//freertos.c</span></span><br><span class="line"><span class="type">static</span> SemaphoreHandle_t g_xI2CMutex; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetI2C</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*等待一个互斥量*/</span></span><br><span class="line">xSemaphoreTake(g_xI2CMutex, portMAX_DELAY);<span class="comment">//使用I2C之前，先去获得互斥量</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ReleaseI2C</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*释放互斥量*/</span></span><br><span class="line">xSemaphoreGive(g_xI2CMutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">g_xI2CMutex = xSemaphoreCreateMutex();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//draw.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">GetI2C</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ReleaseI2C</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//volatile int bInUsed = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">draw_flushArea</span><span class="params">(byte x, byte y, byte w, byte h)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//while (bInUsed);</span></span><br><span class="line">    <span class="comment">//taskENTER_CRITICAL();</span></span><br><span class="line">    <span class="comment">//bInUsed = 1;</span></span><br><span class="line">GetI2C();<span class="comment">//获取I2C </span></span><br><span class="line">LCD_FlushRegion(x, y, w, h)  <span class="comment">//使用I2C </span></span><br><span class="line">ReleaseI2C();<span class="comment">//使用完I2C后释放</span></span><br><span class="line">    <span class="comment">//bInUsed = 0;</span></span><br><span class="line">    <span class="comment">//taskEXIT_CRITICAL();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h2><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p>互斥量是一种特殊的二进制信号量。</p><p>使用互斥量时，先创建、然后去获得、释放它。使用句柄来表示一个互斥量。</p><p>创建互斥量的函数有2种：动态分配内存，静态分配内存，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个互斥量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配互斥量结构体 </span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutex</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个互斥量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutexStatic</span><span class="params">( StaticSemaphore_t *pxMutexBuffer )</span>;</span><br></pre></td></tr></table></figure><p>要想使用互斥量，需要在配置文件FreeRTOSConfig.h中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_MUTEXES 1</span></span><br></pre></td></tr></table></figure><h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><p>要注意的是，互斥量<strong>不能在ISR中使用</strong>。</p><p>各类操作函数，比如删除、give&#x2F;take，跟一般是信号量是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * xSemaphore: 信号量句柄，你要删除哪个信号量, 互斥量也是一种信号量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放 */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放(ISR版本) */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGiveFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                       SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                       BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                   )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获得 */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">(</span></span><br><span class="line"><span class="params">                   SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                   TickType_t xTicksToWait</span></span><br><span class="line"><span class="params">               )</span>;</span><br><span class="line"><span class="comment">/* 获得(ISR版本) */</span></span><br><span class="line">xSemaphoreGiveFromISR(</span><br><span class="line">                       SemaphoreHandle_t xSemaphore,</span><br><span class="line">                       BaseType_t *pxHigherPriorityTaskWoken</span><br><span class="line">                   );</span><br></pre></td></tr></table></figure><h1 id="事件组"><a href="#事件组" class="headerlink" title="事件组"></a>事件组</h1><h2 id="本质-2"><a href="#本质-2" class="headerlink" title="本质"></a>本质</h2><p>事件组可以简单地认为就是一个整数：</p><ul><li>每一位表示一个事件</li><li>每一位事件的含义由程序员决定，比如：Bit0表示用来串口是否就绪，Bit1表示按键是否被按下</li><li>这些位，值为1表示事件发生了，值为0表示事件没发生</li><li>一个或多个任务、ISR都可以去写这些位；一个或多个任务、ISR都可以去读这些位</li><li>可以等待某一位、某些位中的任意一个，也可以等待多位</li></ul><p><img src="/2024/01/29/FreeRTOS/image-20240216201437746.png" alt="image-20240216201437746"></p><p>事件组用一个整数来表示，其中的<strong>高8位留给内核使用</strong>，只能用其他的位来表示事件。那么这个整数是多少位的？</p><ul><li>如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件</li><li>如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件</li><li>configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑 <ul><li>如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位</li><li>如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位</li></ul></li></ul><p>例：car1或car2到站后，car3启动</p><p>car1,car2到站后，分别设置事件组bit0和bit1, car3一开始等待事件bit1或bit1, car1,car2任意一个先到站后，就会触发car3行驶</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xEventGroupSetBits(g_xEventCar,(<span class="number">1</span>&lt;&lt;<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//在二进制中，数字 1 通常表示为 `0001`。当你把它向左移动 1 位时，每一位都向左移动一位，最右边补上一个 0。所以，`1 &lt;&lt; 1` 的结果会是 `0010`，相当于bit1置1</span></span><br><span class="line"><span class="comment">//1&lt;&lt;0就是1保持不变，仍是0001,相当于bit0置1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">game2.c</span><br><span class="line">    </span><br><span class="line"><span class="type">static</span> EventGroupHandle_t g_xEventCar;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Car1Task</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> *<span class="title">pcar</span> =</span> params;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ir_data</span> <span class="title">idata</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QueueHandle_t xQueueIR = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ir_data));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RegisterQueueHandle(xQueueIR);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ShowCar(pcar);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//xSemaphoreTake(g_xSemTicks, portMAX_DELAY);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//xQueueReceive(xQueueIR, &amp;idata, portMAX_DELAY);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制汽车往右移动 */</span></span><br><span class="line"><span class="comment">//if (idata.val == pcar-&gt;control_key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x &lt; g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">HideCar(pcar);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pcar-&gt;x += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x &gt; g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line">pcar-&gt;x = g_xres - CAR_LENGTH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ShowCar(pcar);</span><br><span class="line"></span><br><span class="line">vTaskDelay(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x == g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置事件组:bit0*/</span></span><br><span class="line">xEventGroupSetBits(g_xEventCar,(<span class="number">1</span>&lt;&lt;<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Car2Task</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> *<span class="title">pcar</span> =</span> params;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ir_data</span> <span class="title">idata</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vTaskDelay(1000);</span></span><br><span class="line"></span><br><span class="line">QueueHandle_t xQueueIR = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ir_data));</span><br><span class="line"></span><br><span class="line">RegisterQueueHandle(xQueueIR);</span><br><span class="line"></span><br><span class="line">ShowCar(pcar);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//等待事件0</span></span><br><span class="line"><span class="comment">//xEventGroupWaitBits(g_xEventCar,(1&lt;&lt;0),pdTRUE,pdFALSE,portMAX_DELAY);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//xQueueReceive(xQueueIR, &amp;idata, portMAX_DELAY);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//if (idata.val == pcar-&gt;control_key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x &lt; g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line">HideCar(pcar);</span><br><span class="line"></span><br><span class="line">pcar-&gt;x += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x &gt; g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line">pcar-&gt;x = g_xres - CAR_LENGTH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShowCar(pcar);</span><br><span class="line"></span><br><span class="line">vTaskDelay(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//mdelay(50);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x == g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*设置事件组:bit1*/</span></span><br><span class="line">xEventGroupSetBits(g_xEventCar,(<span class="number">1</span>&lt;&lt;<span class="number">1</span>));</span><br><span class="line">vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Car3Task</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> *<span class="title">pcar</span> =</span> params;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ir_data</span> <span class="title">idata</span>;</span></span><br><span class="line"></span><br><span class="line">QueueHandle_t xQueueIR = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ir_data));</span><br><span class="line"></span><br><span class="line">RegisterQueueHandle(xQueueIR);</span><br><span class="line"></span><br><span class="line">ShowCar(pcar);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//等待事件: bit0 or bit1</span></span><br><span class="line">xEventGroupWaitBits(g_xEventCar,(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">1</span>),pdTRUE,pdFALSE,portMAX_DELAY);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//xQueueReceive(xQueueIR, &amp;idata, portMAX_DELAY);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//if (idata.val == pcar-&gt;control_key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x &lt; g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line">HideCar(pcar);</span><br><span class="line"></span><br><span class="line">pcar-&gt;x += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x &gt; g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line">pcar-&gt;x = g_xres - CAR_LENGTH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShowCar(pcar);</span><br><span class="line"></span><br><span class="line"><span class="comment">//vTaskDelay(50);</span></span><br><span class="line">mdelay(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x == g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line">vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件组的操作"><a href="#事件组的操作" class="headerlink" title="事件组的操作"></a>事件组的操作</h2><p>事件组和队列、信号量等不太一样，主要集中在2个地方：</p><ul><li><p>唤醒谁？ </p><ul><li>队列、信号量：事件发生时，只会唤醒<strong>一个</strong>任务</li><li>事件组：事件发生时，会唤醒<strong>所有符号条件</strong>的任务，简单地说它有”广播”的作用</li></ul></li><li><p>是否清除事件？ </p><ul><li>队列、信号量：是消耗型的资源，队列的数据被读走就没了；信号量被获取后就减少了</li><li>事件组：被唤醒的任务有两个选择，可以让事件保留不动，也可以清除事件</li></ul><p><img src="/2024/01/29/FreeRTOS/image-20240216202554552.png" alt="image-20240216202554552"></p></li></ul><p>以上图为列，事件组的<strong>常规操作</strong>如下：</p><ul><li>先创建事件组</li><li>任务C、D等待事件： <ul><li>等待什么事件？可以等待某一位、某些位中的任意一个，也可以等待多位。简单地说就是”或”、”与”的关系。</li><li>得到事件时，要不要清除？可选择清除、不清除。</li></ul></li><li>任务A、B产生事件：设置事件组里的某一位、某些位</li></ul><h2 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h2><p>改进姿态控制</p><img src="/2024/01/29/FreeRTOS/image-20240218110342799.png" alt="image-20240218110342799" style="zoom:67%;"><p>之前驱动MPU6050任务是先创建一个任务，在里面一直读I2C，然后写队列，这样的话如果姿态没变，还是一直在读I2C，浪费资源，</p><p>可以采用在中断中写事件组来唤醒任务，任务在开始一直等待事件，被唤醒后才去读I2C，写队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">driver_mpu6050.c</span><br><span class="line">    </span><br><span class="line"><span class="comment">//void EXTI9_5_IRQHandler()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Callback</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 设置事件组: bit0 */</span></span><br><span class="line">xEventGroupSetBitsFromISR(g_xEventMPU6050, (<span class="number">1</span>&lt;&lt;<span class="number">0</span>), <span class="literal">NULL</span>);<span class="comment">//在中断中注意是用另一套函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Task</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int16_t</span> AccX;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mpu6050_data</span> <span class="title">result</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="comment">//extern volatile int bInUsed;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">GetI2C</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">PutI2C</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;    </span><br><span class="line"><span class="comment">/* 等待事件:bit0 */</span></span><br><span class="line">xEventGroupWaitBits(g_xEventMPU6050, (<span class="number">1</span>&lt;&lt;<span class="number">0</span>), pdTRUE, pdFALSE, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//while (bInUsed);</span></span><br><span class="line"><span class="comment">//bInUsed = 1;</span></span><br><span class="line">GetI2C();</span><br><span class="line">ret = MPU6050_ReadData(&amp;AccX, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">PutI2C();</span><br><span class="line"><span class="comment">//bInUsed = 0;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == ret)</span><br><span class="line">&#123;</span><br><span class="line">MPU6050_ParseData(AccX, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;result);</span><br><span class="line"></span><br><span class="line">xQueueSend(g_xQueueMPU6050, &amp;result, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vTaskDelay(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中断配置"><a href="#中断配置" class="headerlink" title="中断配置"></a>中断配置</h3><p>注意使用中断的话，首先可以从原理图看到MPU6050的中断引脚是PB5</p><img src="/2024/01/29/FreeRTOS/image-20240218112736857.png" alt="image-20240218112736857" style="zoom:33%;"><p>在cubemx中，将PB5引脚配置成外部中断</p><p><img src="/2024/01/29/FreeRTOS/image-20240218112913156.png" alt="image-20240218112913156"></p><p><img src="/2024/01/29/FreeRTOS/image-20240218113102281.png" alt="image-20240218113102281"></p><p>触发中断时产生高电平信号，则配置PB5为上升沿触发</p><p><img src="/2024/01/29/FreeRTOS/image-20240218113214934.png" alt="image-20240218113214934"></p><p>然后配置NVIC使能</p><p><img src="/2024/01/29/FreeRTOS/image-20240218113313612.png" alt="image-20240218113313612"></p><p>接着我们要去找到PB5的中断处理函数</p><p><img src="/2024/01/29/FreeRTOS/image-20240218114355425.png" alt="image-20240218114355425"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (GPIO_Pin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> GPIO_PIN_5:<span class="comment">//PB5</span></span><br><span class="line">        &#123;</span><br><span class="line">            MPU6050_Callback();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> GPIO_PIN_10:</span><br><span class="line">        &#123;</span><br><span class="line">            IRReceiver_IRQ_Callback();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> GPIO_PIN_12:</span><br><span class="line">        &#123;</span><br><span class="line">            RotaryEncoder_IRQ_Callback();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次也要配置MPU6050中断引脚，并开启中断</p><p>需要我们去写MPU6050寄存器</p><p><img src="/2024/01/29/FreeRTOS/image-20240218114802622.png" alt="image-20240218114802622"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MPU6050_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">MPU6050_WriteRegister(MPU6050_PWR_MGMT_1, <span class="number">0x00</span>);</span><br><span class="line">MPU6050_WriteRegister(MPU6050_PWR_MGMT_2, <span class="number">0x00</span>);</span><br><span class="line">MPU6050_WriteRegister(MPU6050_SMPLRT_DIV, <span class="number">0x09</span>);</span><br><span class="line">MPU6050_WriteRegister(MPU6050_CONFIG, <span class="number">0x06</span>);</span><br><span class="line">MPU6050_WriteRegister(MPU6050_GYRO_CONFIG, <span class="number">0x18</span>);</span><br><span class="line">MPU6050_WriteRegister(MPU6050_ACCEL_CONFIG, <span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参考: https://blog.csdn.net/sjf8888/article/details/97912391 */</span></span><br><span class="line"><span class="comment">/* 配置中断引脚 */</span></span><br><span class="line">MPU6050_WriteRegister(MPU6050_INT_PIN_CFG, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使能中断 */</span></span><br><span class="line">MPU6050_WriteRegister(MPU6050_INT_ENABLE, <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">g_xQueueMPU6050 = xQueueCreate(MPU6050_QUEUE_LEN, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mpu6050_data));</span><br><span class="line">g_xEventMPU6050 = xEventGroupCreate();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="API-3"><a href="#API-3" class="headerlink" title="API"></a>API</h2><h3 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h3><p>使用事件组之前，要先创建，得到一个句柄；使用事件组时，要使用句柄来表明使用哪个事件组。</p><p>有两种创建方法：动态分配内存、静态分配内存。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个事件组，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配事件组结构体 </span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreate</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个事件组，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreateStatic</span><span class="params">( StaticEventGroup_t * pxEventGroupBuffer )</span>;</span><br></pre></td></tr></table></figure><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>对于动态创建的事件组，不再需要它们时，可以删除它们以回收内存。</p><p><strong>vEventGroupDelete</strong>可以用来删除事件组，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * xEventGroup: 事件组句柄，你要删除哪个事件组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vEventGroupDelete</span><span class="params">( EventGroupHandle_t xEventGroup )</span></span><br></pre></td></tr></table></figure><h3 id="设置事件"><a href="#设置事件" class="headerlink" title="设置事件"></a>设置事件</h3><p>可以设置事件组的某个位、某些位，使用的函数有2个：</p><ul><li>在任务中使用<strong>xEventGroupSetBits()</strong></li><li>在ISR中使用<strong>xEventGroupSetBitsFromISR()</strong></li></ul><p>有一个或多个任务在等待事件，如果这些事件符合这些任务的期望，那么任务还会被唤醒。</p><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置事件组中的位</span></span><br><span class="line"><span class="comment"> * xEventGroup: 哪个事件组</span></span><br><span class="line"><span class="comment"> * uxBitsToSet: 设置哪些位? </span></span><br><span class="line"><span class="comment"> *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span></span><br><span class="line"><span class="comment"> *              可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span></span><br><span class="line"><span class="comment"> * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupSetBits</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> EventBits_t uxBitsToSet )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置事件组中的位</span></span><br><span class="line"><span class="comment"> * xEventGroup: 哪个事件组</span></span><br><span class="line"><span class="comment"> * uxBitsToSet: 设置哪些位? </span></span><br><span class="line"><span class="comment"> *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span></span><br><span class="line"><span class="comment"> *              可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span></span><br><span class="line"><span class="comment"> * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有, pdFALSE-没有</span></span><br><span class="line"><span class="comment"> * 返回值: pdPASS-成功, pdFALSE-失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xEventGroupSetBitsFromISR</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> EventBits_t uxBitsToSet,</span></span><br><span class="line"><span class="params">  BaseType_t * pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure><p>值得注意的是，ISR中的函数，比如队列函数<strong>xQueueSendToBackFromISR</strong>、信号量函数<strong>xSemaphoreGiveFromISR</strong>，它们会唤醒某个任务，最多只会唤醒1个任务。</p><p>但是设置事件组时，有可能导致多个任务被唤醒，这会带来很大的不确定性。所以<strong>xEventGroupSetBitsFromISR</strong>函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。</p><p>如果后台任务的优先级比当前被中断的任务优先级高，<strong>xEventGroupSetBitsFromISR</strong>会设置*<strong>pxHigherPriorityTaskWoken</strong>为pdTRUE。</p><p>如果daemon task成功地把队列数据发送给了后台任务，那么<strong>xEventGroupSetBitsFromISR</strong>的返回值就是pdPASS。</p><h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h3 id="等待事件"><a href="#等待事件" class="headerlink" title="等待事件"></a>等待事件</h3><p>使用<strong>xEventGroupWaitBits</strong>来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。</p><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventBits_t <span class="title function_">xEventGroupWaitBits</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> BaseType_t xClearOnExit,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> BaseType_t xWaitForAllBits,</span></span><br><span class="line"><span class="params">                                 TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><p>先引入一个概念：unblock condition。一个任务在等待事件发生时，它处于阻塞状态；当期望的时间发生时，这个状态就叫”unblock condition”，非阻塞条件，或称为”非阻塞条件成立”；当”非阻塞条件成立”后，该任务就可以变为就绪态。</p><p>函数参数说明列表如下：</p><table><thead><tr><th align="center"><strong>参数</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">xEventGroup</td><td align="left">等待哪个事件组？</td></tr><tr><td align="center">uxBitsToWaitFor</td><td align="left">等待哪些位？哪些位要被测试？</td></tr><tr><td align="center">xWaitForAllBits</td><td align="left">怎么测试？是”AND”还是”OR”？ pdTRUE: 等待的位，全部为1; pdFALSE: 等待的位，某一个为1即可</td></tr><tr><td align="center">xClearOnExit</td><td align="left">函数提出前是否要清除事件？ pdTRUE: 清除uxBitsToWaitFor指定的位 pdFALSE: 不清除</td></tr><tr><td align="center">xTicksToWait</td><td align="left">如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count</td></tr><tr><td align="center">返回值</td><td align="left">返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td></tr></tbody></table><p>举例如下：</p><table><thead><tr><th align="center">事件组的值</th><th align="center">uxBitsToWaitFor</th><th align="center">xWaitForAllBits</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">0100</td><td align="center">0101</td><td align="center">pdTRUE</td><td align="left">任务期望bit0,bit2都为1， 当前值只有bit2满足，任务进入阻塞态； 当事件组中bit0,bit2都为1时退出阻塞态</td></tr><tr><td align="center">0100</td><td align="center">0110</td><td align="center">pdFALSE</td><td align="left">任务期望bit0,bit2某一个为1， 当前值满足，所以任务成功退出</td></tr><tr><td align="center">0100</td><td align="center">0110</td><td align="center">pdTRUE</td><td align="left">任务期望bit1,bit2都为1， 当前值不满足，任务进入阻塞态； 当事件组中bit1,bit2都为1时退出阻塞态</td></tr></tbody></table><p>你可以使用*xEventGroupWaitBits()<em>等待期望的事件，它发生之后再使用</em>xEventGroupClearBits()*来清除。但是这两个函数之间，有可能被其他任务或中断抢占，它们可能会修改事件组。</p><p>可以使用设置<em>xClearOnExit</em>为pdTRUE，使得对事件组的测试、清零都在*xEventGroupWaitBits()*函数内部完成，这是一个原子操作。</p><h3 id="-3"><a href="#-3" class="headerlink" title></a></h3><h3 id="同步点"><a href="#同步点" class="headerlink" title="同步点"></a>同步点</h3><p>有一个事情需要多个任务协同，比如：</p><ul><li>任务A：炒菜</li><li>任务B：买酒</li><li>任务C：摆台</li><li>A、B、C做好自己的事后，还要等别人做完；大家一起做完，才可开饭</li></ul><p>使用 <strong>xEventGroupSync()</strong> 函数可以同步多个任务：</p><ul><li>可以设置某位、某些位，表示自己做了什么事</li><li>可以等待某位、某些位，表示要等等其他任务</li><li>期望的时间发生后， <strong>xEventGroupSync()</strong> 才会成功返回。</li><li><strong>xEventGroupSync</strong>成功返回后，会清除事件</li></ul><p><strong>xEventGroupSync</strong> 函数原型如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventBits_t xEventGroupSync(    EventGroupHandle_t xEventGroup,</span><br><span class="line">                                const EventBits_t uxBitsToSet,</span><br><span class="line">                                const EventBits_t uxBitsToWaitFor,</span><br><span class="line">                                TickType_t xTicksToWait );</span><br></pre></td></tr></table></figure><p>参数列表如下：</p><table><thead><tr><th align="center"><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">xEventGroup</td><td>哪个事件组？</td></tr><tr><td align="center">uxBitsToSet</td><td>要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1</td></tr><tr><td align="center">uxBitsToWaitFor</td><td>等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1</td></tr><tr><td align="center">xTicksToWait</td><td>如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count</td></tr><tr><td align="center">返回值</td><td>返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td></tr></tbody></table><p>参数列表如下：</p><table><thead><tr><th align="center"><strong>参数</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">xEventGroup</td><td align="left">哪个事件组？</td></tr><tr><td align="center">uxBitsToSet</td><td align="left">要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1</td></tr><tr><td align="center">uxBitsToWaitFor</td><td align="left">等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1</td></tr><tr><td align="center">xTicksToWait</td><td align="left">如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count</td></tr><tr><td align="center">返回值</td><td align="left">返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td></tr></tbody></table><h1 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h1><h2 id="本质-3"><a href="#本质-3" class="headerlink" title="本质"></a>本质</h2><p>我们使用队列、信号量、事件组等等方法时，并不知道对方是谁。使用任务通知时，可以明确指定：通知哪个任务。</p><p>使用队列、信号量、事件组时，我们都要事先创建对应的结构体，双方通过中间的结构体通信：</p><p><img src="/2024/01/29/FreeRTOS/image-20240218161725184.png" alt="image-20240218161725184"></p><p>使用任务通知时，任务结构体TCB中就包含了内部对象，可以直接接收别人发过来的”通知”：</p><p><img src="/2024/01/29/FreeRTOS/image-20240218161736115.png" alt="image-20240218161736115"></p><h2 id="通知状态和通知值"><a href="#通知状态和通知值" class="headerlink" title="通知状态和通知值"></a>通知状态和通知值</h2><p>每个任务都有一个结构体：TCB(Task Control Block)，里面有<strong>2个成员</strong>：</p><ul><li>一个是uint8_t类型，用来表示<strong>通知状态</strong></li><li>一个是uint32_t类型，用来表示<strong>通知值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tskTaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* configTASK_NOTIFICATION_ARRAY_ENTRIES = 1 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint8_t</span> ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class="line">    ......</span><br><span class="line">&#125; tskTCB;</span><br></pre></td></tr></table></figure><p>通知状态有3种取值：</p><ul><li>taskNOT_WAITING_NOTIFICATION：任务没有在等待通知</li><li>taskWAITING_NOTIFICATION：任务在等待通知</li><li>taskNOTIFICATION_RECEIVED：任务接收到了通知，也被称为pending(有数据了，待处理)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">define</span> taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 )  <span class="comment">/* 也是初始状态 */</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )</span></span><br></pre></td></tr></table></figure><p><strong>通知值可以有很多种类型：</strong></p><ul><li>计数值</li><li>位(类似事件组)</li><li>任意数值</li></ul><p>场景1：</p><p>B最开始是taskNOT_WAITING_NOTIFICATION ，然后因为一些其它东西阻塞了（不是因为要等待任务通知），状态仍是taskNOT_WAITING_NOTIFICATION ，这时A发来通知，也无法唤醒B，但是B确实是收到了通知，所以状态改变为taskNOTIFICATION_RECEIVED，然后过一段时间后任务不再阻塞，这时候状态仍是taskNOTIFICATION_RECEIVED，然后这时如果任务B想看看收到的东西，它会调用函数，这时由于之前已经收到了东西，所以状态直接变为taskNOT_WAITING_NOTIFICATION。</p><p><img src="/2024/01/29/FreeRTOS/image-20240218155829995.png" alt="image-20240218155829995"></p><p>场景2：开始时B的状态为taskNOT_WAITING_NOTIFICATION，然后它想等待通知，阻塞，状态变为 taskWAITING_NOTIFICATION，这时A发来通知，状态切换为taskNOTIFICATION_RECEIVED，唤醒B后状态又变为taskNOT_WAITING_NOTIFICATION   </p><p><img src="/2024/01/29/FreeRTOS/image-20240218155227592.png" alt="image-20240218155227592"></p><h2 id="实验-2"><a href="#实验-2" class="headerlink" title="实验"></a>实验</h2><p>让第一辆车到达终点后发出任务通知给第二辆第三辆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">game2.c</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TaskHandle_t g_TaskHandleCar2;</span><br><span class="line"><span class="type">static</span> TaskHandle_t g_TaskHandleCar3;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Car1Task</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> *<span class="title">pcar</span> =</span> params;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ir_data</span> <span class="title">idata</span>;</span></span><br><span class="line"></span><br><span class="line">QueueHandle_t xQueueIR = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ir_data));</span><br><span class="line"></span><br><span class="line">RegisterQueueHandle(xQueueIR);</span><br><span class="line"></span><br><span class="line">ShowCar(pcar);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if (idata.val == pcar-&gt;control_key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x &lt; g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line">HideCar(pcar); </span><br><span class="line"></span><br><span class="line">pcar-&gt;x += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x &gt; g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line">pcar-&gt;x = g_xres - CAR_LENGTH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShowCar(pcar);</span><br><span class="line"></span><br><span class="line">vTaskDelay(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x == g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 发出任务通知给car2,car3 */</span></span><br><span class="line">xTaskNotifyGive(g_TaskHandleCar2);</span><br><span class="line"></span><br><span class="line">xTaskNotify(g_TaskHandleCar3, <span class="number">100</span>, eSetValueWithOverwrite);</span><br><span class="line"></span><br><span class="line">vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Car2Task</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> *<span class="title">pcar</span> =</span> params;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ir_data</span> <span class="title">idata</span>;</span></span><br><span class="line"></span><br><span class="line">QueueHandle_t xQueueIR = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ir_data));</span><br><span class="line"></span><br><span class="line">RegisterQueueHandle(xQueueIR);</span><br><span class="line"></span><br><span class="line">ShowCar(pcar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待任务通知</span></span><br><span class="line">ulTaskNotifyTake(pdTRUE, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//if (idata.val == pcar-&gt;control_key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x &lt; g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line">HideCar(pcar);</span><br><span class="line"></span><br><span class="line">pcar-&gt;x += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x &gt; g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line">pcar-&gt;x = g_xres - CAR_LENGTH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShowCar(pcar);</span><br><span class="line"></span><br><span class="line">vTaskDelay(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x == g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 释放信号量 */</span></span><br><span class="line"><span class="comment">//xSemaphoreGive(g_xSemTicks);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置事件组: bit1 */</span></span><br><span class="line"><span class="comment">//xEventGroupSetBits(g_xEventCar, (1&lt;&lt;1));</span></span><br><span class="line"></span><br><span class="line">vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Car3Task</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> *<span class="title">pcar</span> =</span> params;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ir_data</span> <span class="title">idata</span>;</span></span><br><span class="line"><span class="type">uint32_t</span> val;</span><br><span class="line"></span><br><span class="line">QueueHandle_t xQueueIR = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ir_data));</span><br><span class="line"></span><br><span class="line">RegisterQueueHandle(xQueueIR);</span><br><span class="line"></span><br><span class="line">ShowCar(pcar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待任务通知</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">&#123;</span><br><span class="line">xTaskNotifyWait(~<span class="number">0</span>, ~<span class="number">0</span>, &amp;val, portMAX_DELAY);</span><br><span class="line">&#125; <span class="keyword">while</span> (val != <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//if (idata.val == pcar-&gt;control_key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x &lt; g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line">HideCar(pcar);</span><br><span class="line"></span><br><span class="line">pcar-&gt;x += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x &gt; g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line">pcar-&gt;x = g_xres - CAR_LENGTH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShowCar(pcar);</span><br><span class="line"></span><br><span class="line">mdelay(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pcar-&gt;x == g_xres - CAR_LENGTH)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 释放信号量 */</span></span><br><span class="line"><span class="comment">//xSemaphoreGive(g_xSemTicks);</span></span><br><span class="line">vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="API-4"><a href="#API-4" class="headerlink" title="API"></a>API</h2><p> <strong>任务通知的使用</strong></p><p>使用任务通知，可以实现轻量级的<strong>队列(长度为1)、邮箱(覆盖的队列)、计数型信号量、二进制信号量、事件组</strong>。</p><h3 id="两类函数"><a href="#两类函数" class="headerlink" title="两类函数"></a>两类函数</h3><p>任务通知有2套函数，<strong>简化版、专业版</strong>，列表如下：</p><ul><li>简化版函数的使用比较简单，它实际上也是使用专业版函数实现的</li><li>专业版函数支持很多参数，可以实现很多功能</li></ul><table><thead><tr><th></th><th>简化版</th><th>专业版</th></tr></thead><tbody><tr><td>发出通知</td><td>xTaskNotifyGive vTaskNotifyGiveFromISR</td><td>xTaskNotify xTaskNotifyFromISR</td></tr><tr><td>取出通知</td><td>ulTaskNotifyTake</td><td>xTaskNotifyWait</td></tr></tbody></table><h3 id="xTaskNotifyGive-ulTaskNotifyTake"><a href="#xTaskNotifyGive-ulTaskNotifyTake" class="headerlink" title="xTaskNotifyGive&#x2F;ulTaskNotifyTake"></a>xTaskNotifyGive&#x2F;ulTaskNotifyTake</h3><p>在任务中使用xTaskNotifyGive函数，在ISR中使用vTaskNotifyGiveFromISR函数，都是直接给其他任务发送通知：</p><ul><li>使得<strong>通知值加一</strong>   cnt++</li><li>并使得通知状态变为”pending”，也就是<strong>taskNOTIFICATION_RECEIVED</strong>，表示有数据了、待处理</li></ul><p>可以使用ulTaskNotifyTake函数来取出通知值：</p><ul><li>如果通知值等于0，则阻塞(可以指定超时时间)</li><li>当通知值大于0时，任务从阻塞态进入就绪态</li><li>在ulTaskNotifyTake返回之前，还可以做些清理工作：<strong>把通知值减一</strong>，或者把通知值清零</li></ul><p>使用ulTaskNotifyTake函数可以实现轻量级的、高效的二进制信号量、计数型信号量。</p><p><img src="/2024/01/29/FreeRTOS/image-20240218163259858.png" alt="image-20240218163259858"></p><p>这几个函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyGive</span><span class="params">( TaskHandle_t xTaskToNotify )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskNotifyGiveFromISR</span><span class="params">( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyTake</span><span class="params">( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><p>xTaskNotifyGive函数的参数说明如下：</p><table><thead><tr><th align="center"><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">xTaskToNotify</td><td>任务句柄(创建任务时得到)，给哪个任务发通知</td></tr><tr><td align="center">返回值</td><td>必定返回pdPASS</td></tr></tbody></table><p>vTaskNotifyGiveFromISR函数的参数说明如下：</p><table><thead><tr><th align="center"><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">xTaskHandle</td><td>任务句柄(创建任务时得到)，给哪个任务发通知</td></tr><tr><td align="center">pxHigherPriorityTaskWoken</td><td>被通知的任务，可能正处于阻塞状态。 此函数发出通知后，会把它从阻塞状态切换为就绪态。 如果被唤醒的任务的优先级，高于当前任务的优先级， 则”*pxHigherPriorityTaskWoken”被设置为pdTRUE， 这表示在中断返回之前要进行任务切换。</td></tr></tbody></table><p>ulTaskNotifyTake函数的参数说明如下：</p><table><thead><tr><th align="center"><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">xClearCountOnExit</td><td>函数返回前是否清零： pdTRUE：把通知值清零 pdFALSE：如果通知值大于0，则把通知值减一</td></tr><tr><td align="center">xTicksToWait</td><td>任务进入阻塞态的超时时间，它在等待通知值大于0。 0：不等待，即刻返回； portMAX_DELAY：一直等待，直到通知值大于0； 其他值：Tick Count，可以用*pdMS_TO_TICKS()*把ms转换为Tick Count</td></tr><tr><td align="center">返回值</td><td>函数返回之前，在清零或减一之前的通知值。 如果xTicksToWait非0，则返回值有2种情况： 1. 大于0：在超时前，通知值被增加了 2. 等于0：一直没有其他任务增加通知值，最后超时返回0</td></tr></tbody></table><h3 id="xTaskNotify-xTaskNotifyWait"><a href="#xTaskNotify-xTaskNotifyWait" class="headerlink" title="xTaskNotify&#x2F;xTaskNotifyWait"></a>xTaskNotify&#x2F;xTaskNotifyWait</h3><p><strong>xTaskNotify</strong> 函数功能更强大，可以使用不同参数实现各类功能，比如：</p><ul><li>让接收任务的通知值加一：这时 <strong>xTaskNotify()</strong> 等同于 <strong>xTaskNotifyGive()</strong></li><li>设置接收任务的通知值的某一位、某些位，这就是一个轻量级的、更高效的事件组</li><li>把一个新值写入接收任务的通知值：上一次的通知值被读走后，写入才成功。这就是轻量级的、长度为1的队列</li><li>用一个新值覆盖接收任务的通知值：无论上一次的通知值是否被读走，覆盖都成功。类似 <strong>xQueueOverwrite()</strong> 函数，这就是轻量级的邮箱。</li></ul><p><strong>xTaskNotify()</strong> 比 <strong>xTaskNotifyGive()</strong> 更灵活、强大，使用上也就更复杂。<strong>xTaskNotifyFromISR()</strong> 是它对应的ISR版本。</p><p>这两个函数用来发出任务通知，使用哪个函数来取出任务通知呢？</p><p>使用 <strong>xTaskNotifyWait()</strong> 函数！它比 <strong>ulTaskNotifyTake()</strong> 更复杂：</p><ul><li>可以让任务等待(可以加上超时时间)，等到任务状态为”pending”(也就是有数据)</li><li>还可以在函数进入、退出时，清除通知值的指定位</li></ul><p>这几个函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotify</span><span class="params">( TaskHandle_t xTaskToNotify, <span class="type">uint32_t</span> ulValue, eNotifyAction eAction )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyFromISR</span><span class="params">( TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                               <span class="type">uint32_t</span> ulValue, </span></span><br><span class="line"><span class="params">                               eNotifyAction eAction, </span></span><br><span class="line"><span class="params">                               BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyWait</span><span class="params">( <span class="type">uint32_t</span> ulBitsToClearOnEntry, </span></span><br><span class="line"><span class="params">                            <span class="type">uint32_t</span> ulBitsToClearOnExit, </span></span><br><span class="line"><span class="params">                            <span class="type">uint32_t</span> *pulNotificationValue, </span></span><br><span class="line"><span class="params">                            TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><p>xTaskNotify函数的参数说明如下：</p><table><thead><tr><th align="center"><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">xTaskToNotify</td><td>任务句柄(创建任务时得到)，给哪个任务发通知</td></tr><tr><td align="center">ulValue</td><td>怎么使用ulValue，由eAction参数决定</td></tr><tr><td align="center">eAction</td><td>见下表</td></tr><tr><td align="center">返回值</td><td>pdPASS：成功，大部分调用都会成功 pdFAIL：只有一种情况会失败，当eAction为eSetValueWithoutOverwrite， 并且通知状态为”pending”(表示有新数据未读)，这时就会失败。</td></tr></tbody></table><p>eNotifyAction参数说明：</p><table><thead><tr><th align="center"><strong>eNotifyAction取值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">eNoAction</td><td>仅仅是更新通知状态为”pending”，未使用ulValue。 这个选项相当于轻量级的、更高效的二进制信号量。</td></tr><tr><td align="center">eSetBits</td><td>通知值 &#x3D; 原来的通知值 | ulValue，按位或。 相当于轻量级的、更高效的事件组。</td></tr><tr><td align="center">eIncrement</td><td>通知值 &#x3D; 原来的通知值 + 1，未使用ulValue。 相当于轻量级的、更高效的二进制信号量、计数型信号量。 相当于**xTaskNotifyGive()**函数。</td></tr><tr><td align="center">eSetValueWithoutOverwrite</td><td>不覆盖。 如果通知状态为”pending”(表示有数据未读)， 则此次调用xTaskNotify不做任何事，返回pdFAIL。 如果通知状态不是”pending”(表示没有新数据)， 则：通知值 &#x3D; ulValue。</td></tr><tr><td align="center">eSetValueWithOverwrite</td><td>覆盖。 无论如何，不管通知状态是否为”pendng”， 通知值 &#x3D; ulValue。</td></tr></tbody></table><p>xTaskNotifyFromISR函数跟xTaskNotify很类似，就多了最后一个参数<strong>pxHigherPriorityTaskWoken</strong>。在很多ISR函数中，这个参数的作用都是类似的，使用场景如下：</p><ul><li>被通知的任务，可能正处于阻塞状态</li><li><strong>xTaskNotifyFromISR</strong>函数发出通知后，会把接收任务从阻塞状态切换为就绪态</li><li>如果被唤醒的任务的优先级，高于当前任务的优先级，则”*pxHigherPriorityTaskWoken”被设置为pdTRUE，这表示在中断返回之前要进行任务切换。</li></ul><p>xTaskNotifyWait函数列表如下：</p><table><thead><tr><th align="center"><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">ulBitsToClearOnEntry</td><td>在xTaskNotifyWait入口处，要清除通知值的哪些位？ 通知状态不是”pending”的情况下，才会清除。 它的本意是：我想等待某些事件发生，所以先把”旧数据”的某些位清零。 能清零的话：通知值 &#x3D; 通知值 &amp; ~(ulBitsToClearOnEntry)。 比如传入0x01，表示清除通知值的bit0； 传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0</td></tr><tr><td align="center">ulBitsToClearOnExit</td><td>在xTaskNotifyWait出口处，如果不是因为超时推出，而是因为得到了数据而退出时： 通知值 &#x3D; 通知值 &amp; ~(ulBitsToClearOnExit)。 在清除某些位之前，通知值先被赋给”*pulNotificationValue”。 比如入0x03，表示清除通知值的bit0、bit1； 传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0</td></tr><tr><td align="center">pulNotificationValue</td><td>用来取出通知值。 在函数退出时，使用ulBitsToClearOnExit清除之前，把通知值赋给”*pulNotificationValue”。 如果不需要取出通知值，可以设为NULL。</td></tr><tr><td align="center">xTicksToWait</td><td>任务进入阻塞态的超时时间，它在等待通知状态变为”pending”。 0：不等待，即刻返回； portMAX_DELAY：一直等待，直到通知状态变为”pending”； 其他值：Tick Count，可以用*pdMS_TO_TICKS()*把ms转换为Tick Count</td></tr><tr><td align="center">返回值</td><td>1. pdPASS：成功 这表示xTaskNotifyWait成功获得了通知： 可能是调用函数之前，通知状态就是”pending”； 也可能是在阻塞期间，通知状态变为了”pending”。 2. pdFAIL：没有得到通知。</td></tr></tbody></table><p><img src="/2024/01/29/FreeRTOS/image-20240218164502153.png" alt="image-20240218164502153"></p><h1 id="软件定时器"><a href="#软件定时器" class="headerlink" title="软件定时器"></a>软件定时器</h1><p>在硬件中断函数中被调用</p><img src="/2024/01/29/FreeRTOS/image-20240220161204274.png" alt="image-20240220161204274" style="zoom:50%;"><p>软件定时器本质是一个结构体</p><img src="/2024/01/29/FreeRTOS/image-20240220161139904.png" alt="image-20240220161139904" style="zoom:50%;"><p>使用定时器跟使用手机闹钟是类似的：</p><ul><li>指定时间：启动定时器和运行回调函数，两者的间隔被称为定时器的周期(period)。</li><li>指定类型，定时器有两种类型： <ul><li>一次性(One-shot timers)： 这类定时器启动后，它的回调函数只会被调用一次； 可以手工再次启动它，但是不会自动启动它。</li><li>自动加载定时器(Auto-reload timers )： 这类定时器启动后，时间到之后它会自动启动它； 这使得回调函数被周期性地调用。</li></ul></li><li>指定要做什么事，就是指定回调函数</li></ul><p>实际的闹钟分为：有效、无效两类。软件定时器也是类似的，它由两种状态：</p><ul><li>运行(Running、Active)：运行态的定时器，当指定时间到达之后，它的回调函数会被调用</li><li>冬眠(Dormant)：冬眠态的定时器还可以通过句柄来访问它，但是它不再运行，它的回调函数不会被调用</li></ul><p>使用定时器跟使用手机闹钟是类似的：</p><ul><li>指定时间：启动定时器和运行回调函数，两者的间隔被称为定时器的周期(period)。</li><li>指定类型，定时器有两种类型： <ul><li>一次性(One-shot timers)： 这类定时器启动后，它的回调函数只会被调用一次； 可以手工再次启动它，但是不会自动启动它。</li><li>自动加载定时器(Auto-reload timers )： 这类定时器启动后，时间到之后它会自动启动它； 这使得回调函数被周期性地调用。</li></ul></li><li>指定要做什么事，就是指定回调函数</li></ul><p>实际的闹钟分为：有效、无效两类。软件定时器也是类似的，它由两种状态：</p><ul><li>运行(Running、Active)：运行态的定时器，当指定时间到达之后，它的回调函数会被调用</li><li>冬眠(Dormant)：冬眠态的定时器还可以通过句柄来访问它，但是它不再运行，它的回调函数不会被调用</li></ul><p>cubemx配置软件定时器任务优先级</p><p><img src="/2024/01/29/FreeRTOS/image-20240220111132903.png" alt="image-20240220111132903"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">beep.c</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TimerHandle_t g_TimerSound;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GameSoundTimer_Func</span><span class="params">( TimerHandle_t xTimer )</span></span><br><span class="line">&#123;</span><br><span class="line">PassiveBuzzer_Control(<span class="number">0</span>);<span class="comment">//停止蜂鸣器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buzzer_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 初始化蜂鸣器 */</span></span><br><span class="line">PassiveBuzzer_Init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建定时器 */</span></span><br><span class="line"></span><br><span class="line">g_TimerSound = xTimerCreate( <span class="string">&quot;GameSound&quot;</span>, </span><br><span class="line"><span class="number">200</span>,<span class="comment">//周期200ms</span></span><br><span class="line">pdFALSE,<span class="comment">//一次性定时器</span></span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">GameSoundTimer_Func);<span class="comment">//回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buzzer_buzz</span><span class="params">(<span class="type">int</span> freq, <span class="type">int</span> time_ms)</span></span><br><span class="line">&#123;</span><br><span class="line">PassiveBuzzer_Set_Freq_Duty(freq, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动定时器 */</span></span><br><span class="line">    <span class="comment">//使用 xTimerChangePeriod() 函数，除了能修改它的周期外，还可以让定时器的状态从冬眠态转换为运行态。</span></span><br><span class="line">xTimerChangePeriod(g_TimerSound, time_ms, <span class="number">0</span>);<span class="comment">//修改定时器的周期时，会使用新的周期重新计算它的超时时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">game1.c</span><br><span class="line"><span class="type">void</span> <span class="title function_">game1_draw</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// Block collision</span></span><br><span class="line">byte idx = <span class="number">0</span>;</span><br><span class="line">LOOP(BLOCK_COLS, x)</span><br><span class="line">&#123;</span><br><span class="line">LOOP(BLOCK_ROWS, y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!blocks[idx] &amp;&amp; ballX &gt;= x * <span class="number">4</span> &amp;&amp; ballX &lt; (x * <span class="number">4</span>) + <span class="number">4</span> &amp;&amp; ballY &gt;= (y * <span class="number">4</span>) + <span class="number">8</span> &amp;&amp; ballY &lt; (y * <span class="number">4</span>) + <span class="number">8</span> + <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">buzzer_buzz(<span class="number">2000</span>, <span class="number">100</span>);</span><br><span class="line">blocks[idx] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                draw_bitmap(x * <span class="number">4</span>, (y * <span class="number">4</span>) + <span class="number">8</span>, clearImg, <span class="number">3</span>, <span class="number">8</span>, NOINVERT, <span class="number">0</span>);                </span><br><span class="line">                draw_flushArea(x * <span class="number">4</span>, (y * <span class="number">4</span>) + <span class="number">8</span>, <span class="number">3</span>, <span class="number">8</span>);                </span><br><span class="line">blockCollide = <span class="literal">true</span>;</span><br><span class="line">score++;</span><br><span class="line">&#125;</span><br><span class="line">idx++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Platform collision</span></span><br><span class="line"><span class="type">bool</span> platformCollision = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!gameEnded &amp;&amp; ballY &gt;= g_yres - PLATFORM_HEIGHT - <span class="number">2</span> &amp;&amp; ballY &lt; <span class="number">240</span> &amp;&amp; ballX &gt;= platformX &amp;&amp; ballX &lt;= platformX + PLATFORM_WIDTH)</span><br><span class="line">&#123;</span><br><span class="line">platformCollision = <span class="literal">true</span>;</span><br><span class="line">buzzer_buzz(<span class="number">5000</span>, <span class="number">200</span>);<span class="comment">//以5000hz的频率响200ms(使用软件定时器)</span></span><br><span class="line">ball.y = g_yres - PLATFORM_HEIGHT - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(ball.velY &gt; <span class="number">0</span>)</span><br><span class="line">ball.velY = -ball.velY;</span><br><span class="line">ball.velX = ((<span class="type">float</span>)rand() / (RAND_MAX / <span class="number">2</span>)) - <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!gameEnded &amp;&amp; !platformCollision &amp;&amp; (ballY &gt; g_yres - <span class="number">2</span> || blockCollide))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ballY &gt; <span class="number">240</span>)</span><br><span class="line">&#123;</span><br><span class="line">buzzer_buzz(<span class="number">2500</span>, <span class="number">200</span>);<span class="comment">//以2500hz的频率响200ms(使用软件定时器)</span></span><br><span class="line">ball.y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!blockCollide)</span><br><span class="line">&#123;</span><br><span class="line">buzzer_buzz(<span class="number">2000</span>, <span class="number">200</span>);<span class="comment">//以2000hz的频率响200ms(使用软件定时器)</span></span><br><span class="line">ball.y = g_yres - <span class="number">1</span>;</span><br><span class="line">lives--;</span><br><span class="line">&#125;</span><br><span class="line">ball.velY *= <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>软件定时器部分，课程内容不是很多，后面用到了再继续补充吧。</p><h1 id="中断管理"><a href="#中断管理" class="headerlink" title="中断管理"></a>中断管理</h1><p>中断要尽快处理完 ，所以两套代码的实现方式不一样，也不能一样</p><p>在RTOS中，需要应对各类事件。这些事件很多时候是通过硬件中断产生，怎么处理中断呢？</p><p>假设当前系统正在运行Task1时，用户按下了按键，触发了按键中断。这个中断的处理流程如下：</p><ul><li>CPU跳到固定地址去执行代码，这个固定地址通常被称为中断向量，这个跳转时硬件实现的</li><li>执行代码做什么？ <ul><li>保存现场：Task1被打断，需要先保存Task1的运行环境，比如各类寄存器的值</li><li>分辨中断、调用处理函数(这个函数就被称为ISR，interrupt service routine)</li><li>恢复现场：继续运行Task1，或者运行其他优先级更高的任务</li></ul></li></ul><p>你要注意到，ISR是在内核中被调用的，ISR执行过程中，用户的任务无法执行。ISR要尽量快，否则：</p><ul><li>其他低优先级的中断无法被处理：实时性无法保证</li><li>用户任务无法被执行：系统显得很卡顿</li></ul><p>如果这个硬件中断的处理，就是非常耗费时间呢？对于这类中断的处理就要分为2部分：</p><ul><li>ISR：尽快做些清理、记录工作，然后触发某个任务</li><li>任务：更复杂的事情放在任务中处理</li><li>所以：需要ISR和任务之间进行通信</li></ul><p>要在FreeRTOS中熟练使用中断，有几个原则要先说明：</p><ul><li>FreeRTOS把任务认为是硬件无关的，任务的优先级由程序员决定，任务何时运行由调度器决定</li><li>ISR虽然也是使用软件实现的，但是它被认为是硬件特性的一部分，因为它跟硬件密切相关 <ul><li>何时执行？由硬件决定</li><li>哪个ISR被执行？由硬件决定</li></ul></li><li><strong>ISR的优先级高于任务</strong>：即使是优先级最低的中断，它的优先级也高于任务。任务只有在没有中断的情况下，才能执行。</li></ul><h2 id="切换任务"><a href="#切换任务" class="headerlink" title="切换任务"></a>切换任务</h2><h3 id="xHigherPriorityTaskWoken参数"><a href="#xHigherPriorityTaskWoken参数" class="headerlink" title="xHigherPriorityTaskWoken参数"></a>xHigherPriorityTaskWoken参数</h3><p>xHigherPriorityTaskWoken的含义是：是否有更高优先级的任务被唤醒了。如果为pdTRUE，则意味着后面要进行任务切换。</p><p>还是以写队列为例。</p><p>任务A调用 <strong>xQueueSendToBack()</strong> 写队列，有几种情况发生：</p><ul><li>队列满了，任务A阻塞等待，另一个任务B运行</li><li>队列没满，任务A成功写入队列，但是它导致另一个任务B被唤醒，任务B的优先级更高：任务B先运行</li><li>队列没满，任务A成功写入队列，即刻返回</li></ul><p>可以看到，在任务中调用API函数可能导致任务阻塞、任务切换，这叫做”context switch”，上下文切换。这个函数可能很长时间才返回，在函数的内部实现了任务切换。</p><p><strong>xQueueSendToBackFromISR()</strong> 函数也可能导致任务切换，但是不会在函数内部进行切换，而是返回一个参数：表示是否需要切换，函数原型与用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToBackFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                                      QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> <span class="type">void</span> *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                                   )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用法示例 */</span></span><br><span class="line"></span><br><span class="line">BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class="line">xQueueSendToBackFromISR(xQueue, pvItemToQueue, &amp;xHigherPriorityTaskWoken);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (xHigherPriorityTaskWoken == pdTRUE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 任务切换 */</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pxHigherPriorityTaskWoken参数，就是用来保存函数的结果：是否需要切换</p><ul><li>*pxHigherPriorityTaskWoken等于pdTRUE：函数的操作导致更高优先级的任务就绪了，ISR应该进行任务切换</li><li>*pxHigherPriorityTaskWoken等于pdFALSE：没有进行任务切换的必要</li></ul><p>为什么不在”FromISR”函数内部进行任务切换，而只是标记一下而已呢？为了效率！示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">XXX_ISR</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        xQueueSendToBackFromISR(...); <span class="comment">/* 被多次调用 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ISR中有可能多次调用”FromISR”函数，如果在”FromISR”内部进行任务切换，会浪费时间。解决方法是：</p><ul><li>在”FromISR”中标记是否需要切换</li><li>在ISR返回之前再进行任务切换</li><li>示例代码如下</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">XXX_ISR</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        xQueueSendToBackFromISR(..., &amp;xHigherPriorityTaskWoken); <span class="comment">/* 被多次调用 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 最后再决定是否进行任务切换 */</span></span><br><span class="line">    <span class="keyword">if</span> (xHigherPriorityTaskWoken == pdTRUE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 任务切换 */</span>    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的例子很常见，比如UART中断：在UART的ISR中读取多个字符，发现收到回车符时才进行任务切换。</p><p>在ISR中调用API时不进行任务切换，而只是在”xHigherPriorityTaskWoken”中标记一下，除了效率，还有多种好处：</p><ul><li>效率高：避免不必要的任务切换</li><li>让ISR更可控：中断随机产生，在API中进行任务切换的话，可能导致问题更复杂</li><li>可移植性</li><li>在Tick中断中，调用 <strong>vApplicationTickHook()</strong> ：它运行与ISR，只能使用”FromISR”的函数</li></ul><p>使用”FromISR”函数时，如果不想使用xHigherPriorityTaskWoken参数，可以设置为NULL。</p><h3 id="改进实时性"><a href="#改进实时性" class="headerlink" title="改进实时性"></a>改进实时性</h3><p><img src="/2024/01/29/FreeRTOS/image-20240220204009210.png" alt="image-20240220204009210"></p><p>之前的代码有点小问题,在中断函数结束之前，应该发起调度，这样如果唤醒了更高优先级的任务，能在退出中断后立即执行，否则的话中断结束后还是之前那个低优先级的任务执行直到下一个tick中断再次发起调度。</p><p>虽然影响的时间对人来说可能感觉不到有什么影响，但是对于计算机的实时性还是有影响的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DispatchKey</span><span class="params">(<span class="keyword">struct</span> ir_data *pidata)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">extern</span> QueueHandle_t g_xQueueCar1;</span><br><span class="line"><span class="keyword">extern</span> QueueHandle_t g_xQueueCar2;</span><br><span class="line"><span class="keyword">extern</span> QueueHandle_t g_xQueueCar3;</span><br><span class="line"></span><br><span class="line">xQueueSendFromISR(g_xQueueCar1, pidata, <span class="literal">NULL</span>);</span><br><span class="line">xQueueSendFromISR(g_xQueueCar2, pidata, <span class="literal">NULL</span>);</span><br><span class="line">xQueueSendFromISR(g_xQueueCar3, pidata, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_queue_cnt; i++)</span><br><span class="line">&#123;</span><br><span class="line">xQueueSendFromISR(g_xQueues[i], pidata, <span class="literal">NULL</span>);<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2024/01/29/FreeRTOS/image-20240220204412735.png" alt="image-20240220204412735" style="zoom:70%;"><p><img src="/2024/01/29/FreeRTOS/image-20240220203713300.png" alt="image-20240220203713300"></p><p><img src="/2024/01/29/FreeRTOS/image-20240220204544447.png" alt="image-20240220204544447"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DispatchKey</span><span class="params">(<span class="keyword">struct</span> ir_data *pidata)</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xHigherPriorityTaskWoken= pdFALSE;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">extern</span> QueueHandle_t g_xQueueCar1;</span><br><span class="line"><span class="keyword">extern</span> QueueHandle_t g_xQueueCar2;</span><br><span class="line"><span class="keyword">extern</span> QueueHandle_t g_xQueueCar3;</span><br><span class="line"></span><br><span class="line">xQueueSendFromISR(g_xQueueCar1, pidata, <span class="literal">NULL</span>);</span><br><span class="line">xQueueSendFromISR(g_xQueueCar2, pidata, <span class="literal">NULL</span>);</span><br><span class="line">xQueueSendFromISR(g_xQueueCar3, pidata, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_queue_cnt; i++)</span><br><span class="line">&#123;</span><br><span class="line">xQueueSendFromISR(g_xQueues[i], pidata, &amp;xHigherPriorityTaskWoken);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//中断服务函数结束前决定是否进行任务切换:xHigherPriorityTaskWoken为pdTRUE才切换</span></span><br><span class="line">    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对应的，把MPU6050和旋转编码器的中断服务函数也修改一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//void EXTI9_5_IRQHandler()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Callback</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  BaseType_t xHigherPriorityTaskWoken= pdFALSE;</span><br><span class="line">    </span><br><span class="line">xEventGroupSetBitsFromISR(g_xEventMPU6050, (<span class="number">1</span>&lt;&lt;<span class="number">0</span>), <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//中断服务函数结束前决定是否进行任务切换:xHigherPriorityTaskWoken为pdTRUE才切换</span></span><br><span class="line">  portYIELD_FROM_ISR(xHigherPriorityTaskWoken);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RotaryEncoder_IRQ_Callback</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> time;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint64_t</span> pre_time = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rotary_data</span> <span class="title">rdata</span>;</span></span><br><span class="line">   BaseType_t xHigherPriorityTaskWoken= pdFALSE;</span><br><span class="line">        </span><br><span class="line">time = system_get_ns();</span><br><span class="line"></span><br><span class="line">    mdelay(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (!RotaryEncoder_Get_S1())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    g_speed = (<span class="type">uint64_t</span>)<span class="number">1000000000</span>/(time - pre_time);</span><br><span class="line">    <span class="keyword">if</span> (RotaryEncoder_Get_S2())</span><br><span class="line">    &#123;</span><br><span class="line">        g_count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        g_count--;</span><br><span class="line">        g_speed = <span class="number">0</span> - g_speed;</span><br><span class="line">    &#125;</span><br><span class="line">    pre_time = time;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 写队列 */</span></span><br><span class="line">rdata.cnt   = g_count;</span><br><span class="line">rdata.speed = g_speed;</span><br><span class="line">xQueueSendFromISR(g_xQueueRotary, &amp;rdata, &amp;xHigherPriorityTaskWoken);</span><br><span class="line">    <span class="comment">//中断服务函数结束前决定是否进行任务切换:xHigherPriorityTaskWoken为pdTRUE才切换</span></span><br><span class="line">  portYIELD_FROM_ISR(xHigherPriorityTaskWoken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><p><strong>如何实现互斥操作</strong></p><p>屏蔽&#x2F;使能中断、暂停&#x2F;恢复调度器。</p><p>要独占式地访问临界资源，有3种方法：</p><ul><li>公平竞争：比如使用互斥量，谁先获得互斥量谁就访问临界资源，这部分内容前面讲过。</li><li><strong>谁要跟我抢，我就灭掉谁</strong>： <ul><li><strong>中断要跟我抢？我屏蔽中断</strong></li><li><strong>其他任务要跟我抢？我禁止调度器，不运行任务切换</strong></li></ul></li></ul><p>前面学过的队列，事件组，任务通知，信号量互斥量等等，其freertos内部都实现了互斥操作</p><p>eg:进入xQueueSend写队列函数内部一层一层看，最终能发现关中断，从而实现了互斥</p><img src="/2024/01/29/FreeRTOS/image-20240220231531704.png" alt="image-20240220231531704" style="zoom:50%;"><h2 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h2><p>屏蔽中断有两套宏：任务中使用、ISR中使用：</p><ul><li>任务中使用：<strong>taskENTER_CRITICA()&#x2F;taskEXIT_CRITICAL()</strong></li><li>ISR中使用：<strong>taskENTER_CRITICAL_FROM_ISR()&#x2F;taskEXIT_CRITICAL_FROM_ISR()</strong></li></ul><h3 id="-4"><a href="#-4" class="headerlink" title></a></h3><h3 id="在任务中屏蔽中断"><a href="#在任务中屏蔽中断" class="headerlink" title="在任务中屏蔽中断"></a>在任务中屏蔽中断</h3><p>在任务中屏蔽中断的示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在任务中，当前时刻中断是使能的</span></span><br><span class="line"><span class="comment"> * 执行这句代码后，屏蔽中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">taskENTER_CRITICAL();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问临界资源 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重新使能中断 */</span></span><br><span class="line">taskEXIT_CRITICAL();</span><br></pre></td></tr></table></figure><p>在 <strong>taskENTER_CRITICA()&#x2F;taskEXIT_CRITICAL()</strong> 之间：</p><ul><li><p>低优先级的中断被屏蔽了：优先级低于、等于 <strong>configMAX_SYSCALL_INTERRUPT_PRIORITY</strong></p></li><li><p>高优先级的中断可以产生：优先级高于 </p><p>configMAX_SYSCALL_INTERRUPT_PRIORITY</p><ul><li>但是，这些中断ISR里，不允许使用FreeRTOS的API函数</li></ul></li><li><p>任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生</p></li></ul><p>这套 <strong>taskENTER_CRITICA()&#x2F;taskEXIT_CRITICAL()</strong> 宏，是可以递归使用的，它的内部会记录嵌套的深度，只有嵌套深度变为0时，调用 <strong>taskEXIT_CRITICAL()</strong> 才会重新使能中断。</p><p>使用 <strong>taskENTER_CRITICA()&#x2F;taskEXIT_CRITICAL()</strong> 来访问临界资源是很粗鲁的方法：</p><ul><li>中断无法正常运行</li><li>任务调度无法进行</li><li>所以，之间的代码要尽可能快速地执行</li></ul><h3 id="-5"><a href="#-5" class="headerlink" title></a></h3><h3 id="在ISR中屏蔽中断"><a href="#在ISR中屏蔽中断" class="headerlink" title="在ISR中屏蔽中断"></a>在ISR中屏蔽中断</h3><p>要使用含有”FROM_ISR”后缀的宏，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vAnInterruptServiceRoutine</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 用来记录当前中断是否使能 */</span></span><br><span class="line">    UBaseType_t uxSavedInterruptStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 在ISR中，当前时刻中断可能是使能的，也可能是禁止的</span></span><br><span class="line"><span class="comment">     * 所以要记录当前状态, 后面要恢复为原先的状态</span></span><br><span class="line"><span class="comment">     * 执行这句代码后，屏蔽中断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 访问临界资源 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 恢复中断状态 */</span></span><br><span class="line">    taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );</span><br><span class="line">    <span class="comment">/* 现在，当前ISR可以被更高优先级的中断打断了 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <strong>taskENTER_CRITICA_FROM_ISR()&#x2F;taskEXIT_CRITICAL_FROM_ISR()</strong> 之间：</p><ul><li><p>低优先级的中断被屏蔽了：优先级低于、等于 <strong>configMAX_SYSCALL_INTERRUPT_PRIORITY</strong></p></li><li><p>高优先级的中断可以产生：优先级高于 </p><p>configMAX_SYSCALL_INTERRUPT_PRIORITY</p><ul><li>但是，这些中断ISR里，不允许使用FreeRTOS的API函数</li></ul></li><li><p>任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生</p></li></ul><h2 id="-6"><a href="#-6" class="headerlink" title></a></h2><h2 id="暂停调度器"><a href="#暂停调度器" class="headerlink" title="暂停调度器"></a>暂停调度器</h2><p>如果有别的任务来跟你竞争临界资源，你可以把中断关掉：这当然可以禁止别的任务运行，但是这代价太大了。它会影响到中断的处理。</p><p>如果只是禁止别的任务来跟你竞争，不需要关中断，暂停调度器就可以了：在这期间，中断还是可以发生、处理。</p><p>使用这2个函数来暂停、恢复调度器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 暂停调度器 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspendAll</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复调度器</span></span><br><span class="line"><span class="comment"> * 返回值: pdTRUE表示在暂定期间有更高优先级的任务就绪了</span></span><br><span class="line"><span class="comment"> *        可以不理会这个返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskResumeAll</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vTaskSuspendScheduler();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问临界资源 */</span></span><br><span class="line"></span><br><span class="line">xTaskResumeScheduler();</span><br></pre></td></tr></table></figure><p>这套 <strong>vTaskSuspendScheduler()&#x2F;xTaskResumeScheduler()</strong> 宏，是可以递归使用的，它的内部会记录嵌套的深度，只有嵌套深度变为0时，调用 <strong>taskEXIT_CRITICAL()</strong> 才会重新使能中断。</p><p>eg:多个函数调用LCD_PrintString函数</p><img src="/2024/01/29/FreeRTOS/image-20240220222635226.png" alt="image-20240220222635226" style="zoom:80%;"><h1 id="调试与优化"><a href="#调试与优化" class="headerlink" title="调试与优化"></a>调试与优化</h1><h2 id="精细调整栈的大小"><a href="#精细调整栈的大小" class="headerlink" title="精细调整栈的大小"></a>精细调整栈的大小</h2><p>当我们的程序越来越复杂，会创建很多任务，每个任务都有自己的栈，栈来自堆，当任务越来越多，堆可能就不够用，这时我们要来调整栈，不要让每个任务用的栈非常的大，要精确计算每一个任务用到的栈到底有多大</p><p><img src="/2024/01/29/FreeRTOS/image-20240221103137917.png" alt="image-20240221103137917"></p><h3 id="使用框架"><a href="#使用框架" class="headerlink" title="使用框架"></a>使用<strong>框架</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">game1_task</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;    </span><br><span class="line">    UBaseType_t freeNum;</span><br><span class="line">    TaskHandle_t xTaskHandle;</span><br><span class="line">  </span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     ......</span><br><span class="line">        xTaskHandle=xTaskGetCurrentTaskHandle();<span class="comment">//获取当前任务句柄，如果前面创建任务的时候已经给了句柄也可以不用这个</span></span><br><span class="line">        freeNum=uxTaskGetStackHighWaterMark(xTaskHandle);<span class="comment">//获取该任务空闲栈大小</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FreeStack of Task %s : %d \n\r&quot;</span>, pcTaskGetTaskName(xTaskHandle),freeNum);<span class="comment">//打印该任务的名字和空闲栈大小</span></span><br><span class="line">      </span><br><span class="line">        vTaskDelay(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/01/29/FreeRTOS/image-20240221114001482.png" alt="image-20240221114001482" style="zoom:50%;"><p>通过串口调试助手可以看到ColorTask的空闲栈还有63，而且这个任务比较简单，后面基本不太可能再加什么复杂的东西，这就很多比较浪费了了，可以设置小一点。</p><h2 id="打印所有任务的栈信息"><a href="#打印所有任务的栈信息" class="headerlink" title="打印所有任务的栈信息"></a>打印所有任务的栈信息</h2><p>如果在每个任务里添加函数去统计空闲栈有多少，有点麻烦了，我们可以一下子把所有任务的栈都给列出来：</p><ul><li>vTaskList ：获得任务的统计信息，形式为可读的字符串。注意，<strong>pcWriteBuffer必须足够大。</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskList</span><span class="params">( <span class="type">signed</span> <span class="type">char</span> *pcWriteBuffer )</span>;</span><br></pre></td></tr></table></figure><p>可读信息格式如下：</p><p>​ <img src="/2024/01/29/FreeRTOS/image6.png" alt="img"></p><p>配置流程:</p><p>在cubemx中，将其设置为Enable,这样就可以使用<strong>vTaskList</strong>函数</p><p><img src="/2024/01/29/FreeRTOS/image-20240221140916385.png" alt="image-20240221140916385"></p><p>为了不影响其它任务的运行，我们把它放到freertos的钩子函数中</p><p>先在cubemx中使能空闲任务的钩子函数</p><p><img src="/2024/01/29/FreeRTOS/image-20240221140940164.png" alt="image-20240221140940164"></p><p>然后cubemx会在freertos.c生成这个钩子函数，我们把打印代码放进去就行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">freertos.c</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">signed</span> <span class="type">char</span> pcWriteBuffer[<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vApplicationIdleHook</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">vTaskList(pcWriteBuffer);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n\r&quot;</span>,pcWriteBuffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span></span><br></pre></td></tr></table></figure><p>可以看到串口调试助手打印出了相关信息</p><p><img src="/2024/01/29/FreeRTOS/image-20240221141521618.png" alt="image-20240221141521618"></p><p>倒数第二列是该行对应任务的空闲栈，感觉大了就可以根据情况调小点</p><h2 id="打印任务消耗CPU资源的百分比"><a href="#打印任务消耗CPU资源的百分比" class="headerlink" title="打印任务消耗CPU资源的百分比"></a>打印任务消耗CPU资源的百分比</h2><p>统计任务看看它是否非常消耗CPU资源，如果很费CPU资源的话，需要我们去做优化。</p><p><strong>介绍</strong></p><p>对于同优先级的任务，它们按照时间片轮流运行：你执行一个Tick，我执行一个Tick。</p><p>是否可以在Tick中断函数中，统计当前任务的累计运行时间？</p><p>不行！很不精确，因为有更高优先级的任务就绪时，当前任务还没运行一个完整的Tick就被抢占了。</p><p>我们需要比Tick更快的时钟，比如Tick周期时1ms，我们可以使用另一个定时器，让它发生中断的周期时0.1ms甚至更短。</p><p>使用这个定时器来衡量一个任务的运行时间，原理如下图所示：</p><p><img src="/2024/01/29/FreeRTOS/image3.png" alt="img"></p><ul><li>切换到Task1时，使用更快的定时器记录当前时间T1</li><li>Task1被切换出去时，使用更快的定时器记录当前时间T4</li><li>(T4-T1)就是它运行的时间，累加起来</li><li>关键点：在 <strong>vTaskSwitchContext</strong> 函数中，使用 <strong>更快的定时器</strong> 统计运行时间</li></ul><h3 id="-7"><a href="#-7" class="headerlink" title></a></h3><p>  <strong>涉及的代码</strong></p><ul><li>配置</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configGENERATE_RUN_TIME_STATS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TRACE_FACILITY    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_STATS_FORMATTING_FUNCTIONS  1</span></span><br></pre></td></tr></table></figure><ul><li>实现宏 **portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()**，它用来初始化更快的定时器</li><li>实现这两个宏之一，它们用来返回当前时钟值(更快的定时器) <ul><li>portGET_RUN_TIME_COUNTER_VALUE()：直接返回时钟值</li><li>portALT_GET_RUN_TIME_COUNTER_VALUE(Time)：设置Time变量等于时钟值</li></ul></li></ul><p>代码执行流程：</p><ul><li>初始化更快的定时器：启动调度器时</li></ul><p><img src="/2024/01/29/FreeRTOS/image4.png" alt="img"></p><p>在任务切换时统计运行时间</p><p><img src="/2024/01/29/FreeRTOS/image5.png" alt="img"></p><ul><li><p>获得统计信息，可以使用下列函数 </p><ul><li>uxTaskGetSystemState：对于每个任务它的统计信息都放在一个TaskStatus_t结构体里</li><li>vTaskList：得到的信息是可读的字符串，比如</li><li>vTaskGetRunTimeStats： 得到的信息是可读的字符串</li></ul></li><li><p>vTaskGetRunTimeStats：获得任务的运行信息，形式为可读的字符串。注意，pcWriteBuffer必须足够大。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskGetRunTimeStats</span><span class="params">( <span class="type">signed</span> <span class="type">char</span> *pcWriteBuffer )</span>;</span><br></pre></td></tr></table></figure><p>可读信息格式如下：</p><p><img src="/2024/01/29/FreeRTOS/image7.png" alt="img"></p><h3 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h3><p>配置CUBEMX:</p><p><img src="/2024/01/29/FreeRTOS/image-20240221153308122.png" alt="image-20240221153308122"></p><p>然后会生成</p><img src="/2024/01/29/FreeRTOS/image-20240221154850024.png" alt="image-20240221154850024" style="zoom:80%;"><p>它一直返回0，这是不行的，我们要实现自己的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">driver_timer.c</span><br><span class="line"><span class="comment">//返回系统启动后过了多少时间(单位us)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">getRunTimeCounterValue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system_get_ns()/<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在空闲任务的钩子函数里调用vTaskGetRunTimeStats来打印CPU资源的百分比</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationIdleHook</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//vTaskList(pcWriteBuffer);</span></span><br><span class="line">  vTaskGetRunTimeStats(pcWriteBuffer);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n\r&quot;</span>,pcWriteBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以从串口调试助手看到MPU6050Task 我们没有晃动板子，但它仍占用了%4的内存，这是不应该的，需要我们对其优化，需要配置陀螺仪的寄存器，把数据就绪中断使能关掉，不然即使没有摇动板子，只要里面的数据就绪就会产生中断。</p><p><img src="/2024/01/29/FreeRTOS/image-20240221155201721.png" alt="image-20240221155201721"></p><p>完结撒花✿✿ヽ(°▽°)ノ✿，后面有时间多看看手册，根据每节课的任务需求，把代码自己再写一遍，做个项目,freertos就可以了，后面就是工作碰到了再补充。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog Building</title>
      <link href="/2024/01/28/blog-building/"/>
      <url>/2024/01/28/blog-building/</url>
      
        <content type="html"><![CDATA[<p>前言：之前一直想搭个博客，但是本身自己专业也不是学计算机的，从0开始搭建网站对于我的学习成本较高，就不了了之了，偶然发现了基于hexo框架+github的方式来搭建博客，参考了很多教程及视频，不是一帆风顺，也有好几次要放弃了，最后还是遇到问题就解决问题，到网上查资料，经过几天的努力,最后搭建了这个博客，目前差不多是个雏形，后面还会继续优化，在此写下这篇文档，记录下当时参考的一些资料文档。</p><h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><p>参考教程</p><p><a href="http://t.csdnimg.cn/ocJp5">http://t.csdnimg.cn/ocJp5</a></p><p><a href="http://t.csdnimg.cn/8707P">http://t.csdnimg.cn/8707P</a></p><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  <span class="comment">//清除缓存文件（包括生成的静态文件和草稿）。</span></span><br><span class="line"></span><br><span class="line">hexo g     <span class="comment">//生成静态文件，即将你的文章、页面等转换为 HTML 等静态文件。</span></span><br><span class="line">    </span><br><span class="line">hexo s<span class="comment">//启动服务器，用于预览博客效果。</span></span><br><span class="line"></span><br><span class="line">hexo d<span class="comment">//部署博客到指定的服务器，比如 GitHub Pages 或者 CSDN 等。</span></span><br></pre></td></tr></table></figure><h2 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h2><p>参考教程：</p><p><a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><p><a href="https://blog.csdn.net/mjh1667002013/article/details/129290903">https://blog.csdn.net/mjh1667002013/article/details/129290903</a></p><p>【使用Hexo搭建个人博客手摸手教学(8)|butterfly主题页面配置】 <a href="https://www.bilibili.com/video/BV1Fb4y1r7ja/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1Fb4y1r7ja/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></p><p>【【Hexo】2023年零基础玩转Hexo全网最全系列】 <a href="https://www.bilibili.com/video/BV1QD4y1F7pc/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1QD4y1F7pc/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></p><h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><h4 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;我的第一篇博客&quot;</span> <span class="comment">//新建一篇文章。</span></span><br></pre></td></tr></table></figure><p>​然后打开D:\Hexo\source\ _posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。<br>​你可以会直接在vscode里面编写这个markdown文件，可以实时预览，也可以用用其他编辑md文件的软件的工具编写。<br>​编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p><h4 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h4><p>修改<strong>主题</strong>配置文件 <code>_config.butterfly.yml</code>（在你用的那个主题的文件夹里的config文件修改）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">menu:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">list||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">    <span class="attr">link:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">    <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br><span class="line">  <span class="attr">Picture:</span> <span class="string">/gallery</span> <span class="string">||</span> <span class="string">fa-solid</span> <span class="string">fa-image</span></span><br></pre></td></tr></table></figure><p>最左侧的即是展示在网站右上侧的导航栏的各栏的名称,右边是对应的md文件,可以在其中修改该界面的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: zhixiong<span class="number">&#x27;</span>s page<span class="comment">//网页标题</span></span><br><span class="line">date: <span class="number">2024</span><span class="number">-01</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">30</span>:<span class="number">52</span></span><br><span class="line">type: <span class="string">&quot;tags&quot;</span></span><br><span class="line">top_img: <span class="string">&quot;./images/3.jpg&quot;</span> <span class="comment">//该网页最上方的图片</span></span><br></pre></td></tr></table></figure><p>然后后面的fa fa-link这种，是导航栏各个栏目的图标, 以及侧方个人信息栏社交图标，可在<a href="https://fontawesome.com/">https://fontawesome.com/</a> 查找使用。</p><h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><p><strong>上传图像</strong></p><p><em>网页图像</em></p><p>例 archive_img: <a href="http://www.xf5z.com/uploads/2013010764676533.jpg">http://www.xf5z.com/uploads/2013010764676533.jpg</a>   (右键图片，点击复制图片地址)</p><p><em>本地图像</em></p><p>index_img: “.&#x2F;images&#x2F;1.jpg”   (在source里建了个images文件夹，里面存放图片)</p><p><strong>Typora与hexo图片上传问题</strong></p><p><a href="https://www.cnblogs.com/yinyoupoet/p/13287385.html">https://www.cnblogs.com/yinyoupoet/p/13287385.html</a></p><p><strong>相册</strong></p><p><a href="https://www.bilibili.com/video/BV1Fw411Q7pS/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=a9d487fcf1a579639c6348eb5a9321db">https://www.bilibili.com/video/BV1Fw411Q7pS/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&amp;vd_source=a9d487fcf1a579639c6348eb5a9321db</a></p><p><a href="https://butterfly.js.org/posts/4aa8abbe/#Gallery%E7%9B%B8%E5%86%8A%E5%9C%96%E5%BA%AB">https://butterfly.js.org/posts/4aa8abbe/#Gallery%E7%9B%B8%E5%86%8A%E5%9C%96%E5%BA%AB</a></p><h4 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h4><p><a href="https://blog.csdn.net/qq_45173404/article/details/122877378">https://blog.csdn.net/qq_45173404/article/details/122877378</a></p><p>取消当前页面评论:</p><p>在md文件中加上comments: false</p><h4 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a>音乐播放器</h4><p><a href="https://butterfly.js.org/posts/507c070f/?highlight=apla">https://butterfly.js.org/posts/507c070f/?highlight=apla</a></p><h4 id="自定义侧边栏"><a href="#自定义侧边栏" class="headerlink" title="自定义侧边栏"></a>自定义侧边栏</h4><p><a href="https://butterfly.js.org/posts/ea33ab97/#widget-%E6%8E%92%E5%BA%8F">https://butterfly.js.org/posts/ea33ab97/#widget-%E6%8E%92%E5%BA%8F</a></p><h4 id="动态彩带"><a href="#动态彩带" class="headerlink" title="动态彩带"></a>动态彩带</h4><p>好看的彩带背景，会飘动。<br> 修改主题配置文件<code>_config.butterfly.yml</code>。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">canvas_fluttering_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># false 手机端不显示 true 手机端显示</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="文章分类"><a href="#文章分类" class="headerlink" title="文章分类"></a>文章分类</h4><p><a href="http://t.csdnimg.cn/Uc0Uy">http://t.csdnimg.cn/Uc0Uy</a></p><p>把文章归入分类只需在文章的顶部标题下方添加<code>categories</code>字段，即可自动创建分类名并加入对应的分类中。</p><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>把文章添加标签只需在文章的顶部标题下方添加<code>tags</code>字段，即可自动创建标签名并归入对应的标签中 。</p><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">title: Embedded C language</span><br><span class="line">date: <span class="number">2024</span><span class="number">-01</span><span class="number">-26</span> <span class="number">19</span>:<span class="number">04</span>:<span class="number">36</span></span><br><span class="line">description: C语言在单片机编程的一些重要应用</span><br><span class="line">comments: <span class="literal">true</span></span><br><span class="line">categories:</span><br><span class="line">- embedded</span><br><span class="line">tags:</span><br><span class="line">- C language programming</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Embedded C language</title>
      <link href="/2024/01/26/Embedded-C-language/"/>
      <url>/2024/01/26/Embedded-C-language/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式C语言与算法"><a href="#嵌入式C语言与算法" class="headerlink" title="嵌入式C语言与算法"></a>嵌入式C语言与算法</h1><p><img src="/2024/01/26/Embedded-C-language/image-20240115231828910.png" alt="image-20240115231828910"></p><p><img src="/2024/01/26/Embedded-C-language/image-20240115232323794.png" alt="image-20240115232323794"></p><h2 id="单片机预备知识"><a href="#单片机预备知识" class="headerlink" title="单片机预备知识"></a>单片机预备知识</h2><h3 id="数制"><a href="#数制" class="headerlink" title="数制"></a>数制</h3><p>（一）十进制数，ND</p><p>数集：0、1、2、3、4、5、6、7、8、9。</p><p>规则：逢十进一。</p><p>表示：十进制数的后缀为 D 且可以省略。</p><p>计算：十进制数可用加权展开式表示。10为基数，10的幂次方称为十进制数的加权数。<br>（二）二进制数，NB</p><p>数集：0、1。</p><p>规则：逢二进一。</p><p>表示：二进制数的后缀为 B 且不可省略。</p><p>计算：二进制数可用加权展开式表示。2 为基数，2 的幂次方称为二进制数的加权数。<br>（三）十六进制数，NH</p><p>数集：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F。</p><p>规则：逢十六进一。</p><p>表示：十六进制数的后缀为 H 且不可省略。</p><p>计算：十六进制数可用加权展开式表示。16 为基数，16 的幂次方称为十六进制数的加权数。<br>（四）八进制，NO</p><p>数集：0、1、2、3、4、5、6、7。</p><p>规则：逢八进一。</p><p>表示：八进制数的后缀为 O 且不可省略。</p><p>计算：八进制数可用加权展开式表示。8 为基数，8 的幂次方称为八进制数的加权数。</p><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><img src="/2024/01/26/Embedded-C-language/image-20250110151325988.png" alt="image-20250110151325988" style="zoom:50%;"><p> （一）二、八、十六进制转换为十进制之</p><p>利用上述<strong>加权展开式</strong>计算。</p><p><img src="/2024/01/26/Embedded-C-language/image-20250108120433505.png" alt="image-20250108120433505"><img src="/2024/01/26/Embedded-C-language/image-20250108120457205.png" alt="image-20250108120457205" style="zoom:50%;"></p><p>（二）十进制转换为二进制，八进制，十六进制</p><p>一般用<strong>连除法</strong></p><p><img src="/2024/01/26/Embedded-C-language/image-20250108120638117.png" alt="image-20250108120638117" style="zoom:40%;"><img src="/2024/01/26/Embedded-C-language/image-20250108120649353.png" alt="image-20250108120649353" style="zoom:40%;"><img src="/2024/01/26/Embedded-C-language/image-20250108120706048.png" alt="image-20250108120706048" style="zoom:40%;"></p><p>（三）二进制，八进制，十六进制间的相互转换 </p><p>1.二进制于八进制之间的转换</p><p>三位 二进制数 可以表示 一位 八进制数。</p><p>36O &#x3D; 011 110B      111 101 011B &#x3D; 753O<br>2.二进制于十六进制之间的转换</p><p>四位 二进制数 可以表示 一位 十六进制数。</p><p>36H &#x3D; 0011 0110B          1001 0011 0101 1111B &#x3D; 935F H</p><p><img src="/2024/01/26/Embedded-C-language/image-20250108124217917.png" alt="image-20250108124217917"></p><h3 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h3><p>实用数据有正数、负数之分，在计算机中用一位二进制数来区分：“0”代表“+”符号，“1”代表“-”符号。</p><p>符号位：这位数通常在二进制数中的最高位，称为符号位。</p><p>有符号数对应的真实数值称为真值。因符号位占一位，故有符号数的形式值不一定等于其真值。</p><p>例如，有符号数0111 1011B(形式值为123)的真值为+123，而有符号数1111 1011B（形式值为251）的真值为-123。</p><p><em><strong>有符号数具有 原码、反码、补码 三种表示法</strong></em>。</p><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>有符号数的原始表示法，<strong>最高位为符号位</strong>，“0”代表“+”符号，“1”代表“-”符号，其余为数值部分。</p><p>8位二进制原码范围1111 1111B—0111 1111B（-127—+127）。</p><p>对于无符号数 对应的范围是从0000 0000-1111 1111 (0-255 )。</p><img src="/2024/01/26/Embedded-C-language/image-20250109135049996.png" alt="image-20250109135049996" style="zoom:30%;"><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>正数的反码与原码相同；</p><p>负数的反码，符号位不变，数值部分各位取反。</p><h4 id="补码（计算机中都是补码）"><a href="#补码（计算机中都是补码）" class="headerlink" title="补码（计算机中都是补码）"></a>补码（计算机中都是补码）</h4><p>正数的补码与原码相同；</p><p>负数的补码，符号位不变，反码数值部分加一</p><p><strong>有符号数计算时，使用补码进行计算（用原码，反码计算会有错误，补码可以修复这个错误）</strong>，计算结果再求补，得到最终结果。</p><img src="/2024/01/26/Embedded-C-language/image-20250107171100886.png" alt="image-20250107171100886" style="zoom:80%;"><img src="/2024/01/26/Embedded-C-language/image-20250108130205227.png" alt="image-20250108130205227" style="zoom:33%;"><img src="/2024/01/26/Embedded-C-language/image-20250108130217882.png" alt="image-20250108130217882" style="zoom:40%;"><p><img src="/2024/01/26/Embedded-C-language/image-20250109134626575.png" alt="image-20250109134626575"></p><img src="/2024/01/26/Embedded-C-language/image-20250109135511329.png" alt="image-20250109135511329" style="zoom:40%;"><img src="/2024/01/26/Embedded-C-language/image-20250109135554838.png" alt="image-20250109135554838" style="zoom:80%;"><img src="/2024/01/26/Embedded-C-language/image-20250109135816331.png" alt="image-20250109135816331" style="zoom:80%;"><h3 id="位、字节和字"><a href="#位、字节和字" class="headerlink" title="位、字节和字"></a>位、字节和字</h3><p>（一）位（bit）b</p><p>比特，二进制数中的一位，是计算机内部数据存储的<strong>最小单位</strong>。</p><p>一个二进制位只可以表示 0 和 1 两种状态。<br>（二）字节（Byte）B</p><p>拜特，1 字节由 8 个二进制位构成（1B &#x3D; 8bit）。是计算机数据处理的<strong>基本单位</strong>。</p><p>B 可代“字节”使用。注意区分二进制数 B 。</p><p>KB可代“千字节”使用。 <strong>1KB &#x3D; 1024 B</strong> 。64KB &#x3D; 1024B * 64 &#x3D; 65536B<br>（三）字</p><p>计算机一次存取、加工和传送的数据长度称为字。</p><h3 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h3><p><img src="/2024/01/26/Embedded-C-language/image-20250108101835009.png" alt="image-20250108101835009"></p><h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><p>计算机中使用的字母、字符要用特定的二进制数表示。</p><p><img src="/2024/01/26/Embedded-C-language/image-20250108102550572.png" alt="image-20250108102550572"></p><p>0-&gt;48D A-&gt;65D a-&gt;97D</p><p>同一字母大小写相差32D，化为16进制为20H</p><p>简述C语言中的基础知识<br>    1).数据类型(常用char, short, int , long, signed, unsigned, float, double, sizeof)<br>    2).运算和控制( &#x3D;, +, -, *, while, do-while, if, else, switch, case, continue, break)<br>    3).数据存储(static, extern, const, volatile)<br>    4).结构(struct, enum, union, typedef)<br>    5).位操作和逻辑运算(&lt;&lt;, &gt;&gt;, &amp;, |, ~, ^)<br>    6).预处理(#define, #include, #if…#elif…#else…#endif等)</p><img src="/2024/01/26/Embedded-C-language/image-20240119170447733.png" alt="image-20240119170447733" style="zoom:67%;"><h2 id="1-char-short-int数据类型"><a href="#1-char-short-int数据类型" class="headerlink" title="1.char short int数据类型"></a>1.char short int数据类型</h2><p>对于单片机开发来说，是至关重要的。因为单片机有8位、16位、32位。如果不注意数据类型，不注意数据长度，那么在编写代码的时候，很容易就会造成数据溢出，导致程序出现bug，而且还很难发现原因。</p><p>如果熟悉stm32单片机开发的同学，看官方的例程时，使用的数据类型往往都是重新定义过的类型，很少有直接使用原始数据类型的，比如GPIOIO口设置。</p><p>为什么要这样做吗？不嫌麻烦吗？自己平时写程序的时候，往往都是直接使用数据类型的默认名，也依然可以正常使用，没什么问题。但是官方为什么一定要重新定义一次数据类型呢？</p><p>个说白了就是大局观的问题，因为官方比我们个人更具有大局观。个人面对的可能也只有几个平台和几款单片机。而官方面对的是多个平台和多种单片机的，这就不得不考虑数据兼容问题了。比如在32位单片机上的算法移植到8位单片机上，代码运行起来后，到处都是数据溢出。要挨个去修改变量的数据类型，那么这时候，作为开发者来说，奔溃不奔溃？抓狂不抓狂？</p><p>所以为了解决这个问题，官方就会在每个平台下，给数据类型，重新命名一次，如果需要更换平台，那么只需要替换这个数据重命名的头文件即可。</p><p>在32位单片机中int是32位，而在8位单片机中long 才是32位。那么在32位单片机上的int型变量，如果直接移植到8位单片机上的话，那么肯定就会出现数据溢出的问题。</p><p>那么如果使用了重命名后的新变量类型 uint32_t ，不论在8位和32位的单片机上，这个数据都会是32位，这样通过数据类型的重定义，就避免了，同样的数据类型，在不同平台上长度不一致的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br></pre></td></tr></table></figure><p>不同平台数据类型所占字节对比：</p><p>（1个字节有8位）</p><p><img src="/2024/01/26/Embedded-C-language/image-20240113193817299.png" alt="image-20240113193817299"></p><p><img src="/2024/01/26/Embedded-C-language/image-20250110180951482.png" alt="image-20250110180951482"></p><p>int 即一个装数据的小盒子，对于51单片机（8位单片机），int占两个字节(16位，即16个二进制位)，能表示在0~2^16间的数（无符号）</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>见”union共同体”章节</p><h4 id="实例应用"><a href="#实例应用" class="headerlink" title="实例应用"></a>实例应用</h4><p>1.<em>智能家居：网关协议，mac地址上报？</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *mac=<span class="string">&quot;192.168.31.84&quot;</span></span><br><span class="line"><span class="type">char</span> mac_array[<span class="number">4</span>]=&#123;<span class="number">192</span>,<span class="number">168</span>,<span class="number">31</span>,<span class="number">84</span>&#125;</span><br></pre></td></tr></table></figure><p>mac地址如上所示为”192.168.31.84”，为了将其上传到服务器，在定通讯协议时，会和服务器的同事沟通好，收到下面这样一个mac_array数组时，就在每两个数之间加一个小数点来表示mac地址。</p><p>即我们将mac地址转化为一个char类型的数组上传到服务器。</p><p>提问：<strong>为什么mac_array数组的类型用char,而不用int等数据类型？</strong></p><p>答：你可以把数据类型当成一个容器来存放数字，只是它们的容量不同，比如</p><p>char占用1个字节的内存空间，一个字节有8位，能存放0~255之间的数字，因此char类型很适合表示0-255之间的整数，这个范围完全满足IP地址中每个字段的需求。</p><p>如果使用int类型，它通常占用4个字节的内存空间，0-65535，对于用来储存仅需0-255之间的数值而言过于庞大，将浪费大量存储空间，因此在这种情况下，使用char类型更为合适</p><p>2.<em>奶茶机器人：温度采集，小数点如何上报云端？</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> temp = <span class="number">37.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> temp_array[<span class="number">2</span>] = &#123;<span class="number">37</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>服务器发过来unix时间戳 :1607143247，一般是发的hex，即发的是5FCB0F4F，我们接受这串数据，并将其重新解析为时间</p><p>5FCB0F4F  {0x5F,0xCB,0x0F,0x4F} </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> time_buffer[<span class="number">4</span>]=&#123;<span class="number">0x5F</span>,<span class="number">0xCB</span>,<span class="number">0x0F</span>,<span class="number">0x4F</span>&#125;;<span class="comment">//十六进制的一位等于四位二进制</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> time;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">u8Tou32B</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (((((((<span class="type">unsigned</span> <span class="type">int</span>)buffer[<span class="number">0</span>])&lt;&lt;<span class="number">8</span>)|buffer[<span class="number">1</span>])&lt;&lt;<span class="number">8</span>)|buffer[<span class="number">2</span>])&lt;&lt;<span class="number">8</span>)|buffer[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    time=u8Tou32B(time_buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time =%ld s\n&quot;</span>,time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5FCB0F4F  {0x5F,0xCB,0x0F,0x4F} </p><p>u8Tou32B函数的作用是将一个包含四个字节的unsigned char数组转换成一个unsigned int类型的32位无符号整数，就是把5F,CB,0F,4F拼起来。</p><p>继续对上面的u8Tou32B函数进行优化得</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">u8Tou32B_optimized</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;result, buffer, <span class="keyword">sizeof</span>(result));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    time = u8Tou32B_optimized(time_buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time = %u s\n&quot;</span>, time); <span class="comment">// 使用%u正确打印无符号整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-位操作"><a href="#2-位操作" class="headerlink" title="2.位操作"></a>2.位操作</h2><h3 id="位，字节，进制"><a href="#位，字节，进制" class="headerlink" title="位，字节，进制"></a>位，字节，进制</h3><p>1个字节&#x3D;8个二进制位</p><h4 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h4><p>0b开头，只有0，1，一个字节有8位，该字节能表示的最大数字是把所有位都设置为1：(11111111)&#x3D;256,因此1字节可储存0~255范围内的数字。</p><p>通常unsignedchar 用1字节表示的范围是0<del>255，而signed char 用1字节表示的范围是-128</del>+127.</p><h4 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h4><p>0x开头，用0~15表示数字（0-9，10-15为A-F）</p><p><em><strong>每个十六进制位都对应一个4位的二进制数（即4个二进制位）</strong></em>（2^4&#x3D;16,即一个四位的二进制数可以表示从0到15的所有整数值），那么两个十六进制位恰好对应一个8位字节。第一个十六进制表示前4位，第2个十六进制位表示后4位</p><p>不同类型数据的转换可见union共同体章节</p><h3 id="位逻辑运算符"><a href="#位逻辑运算符" class="headerlink" title="位逻辑运算符"></a>位逻辑运算符</h3><p><img src="/2024/01/26/Embedded-C-language/image-20240113211004993.png" alt="image-20240113211004993"> </p><p>位与&amp;:对于每个位，只有两个对象中相应的位都为1时，结果才为1        &amp;&#x3D;</p><p>（10010011）&amp;（00111101）&#x3D;（00010001）</p><p>常见用法: ch&amp;&#x3D;0xff(0xff二进制形式是11111111，这个掩码保持ch中最后8位不变，其它位都设置为0)   </p><p>位或|:只要有一个1就为1       |&#x3D;</p><p>（10010011）|（00111101）&#x3D;（10111111）</p><p>0x20|0x0C&#x3D;0x2C</p><p>位异或^:</p><p>取反~:把0变为1，1变为0</p><p>在c语言中，<code>!</code>和<code>~</code>均表示取反。</p><p>这两个符号的区别在于：</p><ul><li><strong><code>!</code></strong> : 代表<strong>逻辑取反</strong>，即：把非0的数值变为0，0变为1;</li><li><em><strong>*<code>~</code>*</strong></em> : 表示<strong>按位取反</strong>，即在数值的二进制表示方式上,将0变为1，将1变为0。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM0_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD&amp;=<span class="number">0xF0</span>;<span class="comment">//1111 0000 高4位为T1，保持不变，低4位为T0，清0</span></span><br><span class="line">    TMOD|=<span class="number">0x01</span>;<span class="comment">//0000 0001 选择为定时器0模式，工作方式1，使用或运算可以不干扰高四位</span></span><br><span class="line">    </span><br><span class="line">    TH0=<span class="number">0xFC</span>;<span class="comment">//给定时器赋初值，定时1ms</span></span><br><span class="line">    TL0=<span class="number">0x18</span>;</span><br><span class="line">    </span><br><span class="line">    ET0=<span class="number">1</span>;<span class="comment">//打开定时器0中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">    </span><br><span class="line">    TR0=<span class="number">1</span>;<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h3><p>按位与运算符常用于掩码（mask）。所谓掩码指的是一些设置为开（1）或关（0）的位组合</p><p>常见用法: ch&amp;&#x3D;0xff(0xff二进制形式是11111111，这个掩码保持ch中最后8位不变，其它位都设置为0)</p><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>左移&lt;&lt;:  将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）</p><p>（10001010）&lt;&lt;2&#x3D;(001010000)</p><p>右移&gt;&gt;:  (10001010)&gt;&gt;2&#x3D;(00100010)</p><h4 id="1-设置或检查特定的标志位"><a href="#1-设置或检查特定的标志位" class="headerlink" title="1.设置或检查特定的标志位"></a><strong>1.设置或检查特定的标志位</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xEventGroupSetBits(g_xEventCar,(<span class="number">1</span>&lt;&lt;<span class="number">1</span>));</span><br><span class="line"><span class="comment">//在二进制中，数字 1 通常表示为 `0001`。当你把它向左移动 1 位时，每一位都向左移动一位，最右边补上一个 0。所以，`1 &lt;&lt; 1` 的结果会是 `0010`，相当于bit1置1</span></span><br><span class="line"><span class="comment">//1&lt;&lt;0就是1保持不变，仍是0001,相当于bit0置1</span></span><br></pre></td></tr></table></figure><h4 id="2-从较大单元中提取一些位"><a href="#2-从较大单元中提取一些位" class="headerlink" title="2.从较大单元中提取一些位"></a>2.从较大单元中提取一些位</h4><p>此处可链接到“十六进制”章节中</p><p>（<em><strong>每个十六进制位都对应一个4位的二进制数（即4个二进制位）</strong></em>（2^4&#x3D;16,即一个四位的二进制数可以表示从0到15的所有整数值），那么两个十六进制位恰好对应一个8位字节。第一个十六进制表示前4位，第2个十六进制位表示后4位）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE_MASK 0xff</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> color =<span class="number">0x002a162f</span>;<span class="comment">//一个十六进制位对应四个二进制位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> blue,green,red;</span><br><span class="line"></span><br><span class="line">red=color&amp;BYTE_MASK;<span class="comment">//取color低8位</span></span><br><span class="line">green=(color&gt;&gt;<span class="number">8</span>)&amp;BYTE_MASK;<span class="comment">//将color右移8位（8个二进制位），再用掩码取低8位，则可使green取color中间8位</span></span><br><span class="line">blue=(color&gt;&gt;<span class="number">16</span>)&amp;BYTE_MASK;<span class="comment">//将color右移16位（16个二进制位)，再用掩码取低8位，则可使blue取color高8位</span></span><br></pre></td></tr></table></figure><p><img src="/2024/01/26/Embedded-C-language/image-20240114140043073.png" alt="image-20240114140043073"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_SET_INPUT_POS:</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(data, &amp;(odrive_set-&gt;input_pos), <span class="number">4</span>);<span class="comment">//4个字节 32位 ，input_pos也是32位，复制到data数组中  uint8_t data[8]  ，yi会将数组前四位补齐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//odrive_set-&gt;vel_ff  vel_ff有16位 两个字节 ,data的一个元素的类型是uint8_t,有8位</span></span><br><span class="line">       data[<span class="number">4</span>] = odrive_set-&gt;vel_ff &amp; <span class="number">0x00FF</span>;<span class="comment">//保留低8位</span></span><br><span class="line"><span class="comment">//packetlength &amp; 0x00FF中的&amp;是先把&amp;两边的值转换成二进制形式，然后在进行按位运算</span></span><br><span class="line">       data[<span class="number">5</span>] = odrive_set-&gt;vel_ff &gt;&gt; <span class="number">8</span>;<span class="comment">//取高8位</span></span><br><span class="line"></span><br><span class="line">       data[<span class="number">6</span>] = odrive_set-&gt;current_ff &amp; <span class="number">0x00FF</span>;</span><br><span class="line">       data[<span class="number">7</span>] = odrive_set-&gt;current_ff &gt;&gt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       header.RTR = CAN_RTR_DATA;</span><br><span class="line">       header.DLC = <span class="number">8</span>;</span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h2><p>float candy[365];&#x2F;<em>内含365个float类型元素的数组</em>&#x2F;</p><h2 id="4-结构体struct"><a href="#4-结构体struct" class="headerlink" title="4.结构体struct"></a>4.结构体struct</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><strong>结构</strong>体是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p><p>结构体中的数据成员可以是基本数据类型（如 int、float、char 等），也可以是其他结构体类型、指针类型等。</p><p>关键字–struct, union, typedef</p><p>运算符: . ,-&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title function_">xxx</span><span class="params">(标签，这个结构体的名字)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​xxx(变量定义);</span><br><span class="line"></span><br><span class="line">&#125;xxx(结构变量);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明结构类型</span></span><br><span class="line"><span class="comment">/*1*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> daty;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span>;</span><span class="comment">/*定义某种结构类型的变量*/</span></span><br><span class="line"><span class="comment">/*2*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;p1,p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*3*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;p1,p2;</span><br><span class="line"><span class="comment">/*4*/</span></span><br><span class="line"><span class="keyword">typedef</span> &#123;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> daty;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;today;</span><br><span class="line"></span><br><span class="line">today Today1;</span><br></pre></td></tr></table></figure><p>在一般情况下，标签、变量定义，结构变量这 3 部分至少要出现 2 个</p><h4 id="tyepedef-struct"><a href="#tyepedef-struct" class="headerlink" title="tyepedef struct"></a>tyepedef struct</h4><p>typedef是类型定义的意思。typedef <a href="https://so.csdn.net/so/search?q=struct&spm=1001.2101.3001.7020">struct</a> 是为了使用这个结构体方便。</p><p>具体区别在于:<br> 若struct <a href="https://so.csdn.net/so/search?q=node&spm=1001.2101.3001.7020">node</a> {}这样来定义结构体的话。在申请node 的变量时，需要这样写，struct node n;<br> 若用typedef，可以这样写，typedef struct node{}NODE; 。在申请变量时就可以这样写，NODE n;<br> 区别就在于使用时，是否可以省去struct这个关键字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;Stu;</span><br><span class="line">于是在声明变量的时候就可：Stu stu1;</span><br><span class="line">如果没有<span class="keyword">typedef</span>就必须用<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>;</span>来声明</span><br><span class="line">这里的Stu实际上就是<span class="class"><span class="keyword">struct</span> <span class="title">Student</span>的别名。</span></span><br></pre></td></tr></table></figure><h4 id="例-odrive-stm32驱动代码（可作为使用结构体时的模板）"><a href="#例-odrive-stm32驱动代码（可作为使用结构体时的模板）" class="headerlink" title="例 odrive&amp;stm32驱动代码（可作为使用结构体时的模板）"></a>例 odrive&amp;stm32驱动代码（可作为使用结构体时的模板）</h4><p>建立结构声明（模板），定义结构变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*odrive.h*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> axis_error;</span><br><span class="line">  <span class="type">uint32_t</span> axis_current_state;</span><br><span class="line">  <span class="type">uint32_t</span> motor_error;</span><br><span class="line">  <span class="type">uint32_t</span> encoder_error;</span><br><span class="line">  <span class="type">uint32_t</span> sensorless_error;</span><br><span class="line">  <span class="type">float</span> encoder_pos_estimate;</span><br><span class="line">  <span class="type">float</span> encoder_vel_estimate;</span><br><span class="line">  <span class="type">int32_t</span> encoder_shadow_count;</span><br><span class="line">  <span class="type">int32_t</span> encoder_cpr_count;</span><br><span class="line">  <span class="type">float</span> iq_setpoint;</span><br><span class="line">  <span class="type">float</span> iq_measured;</span><br><span class="line">  <span class="type">float</span> sensorless_pos_estimate;</span><br><span class="line">  <span class="type">float</span> sensorless_vel_estimate;</span><br><span class="line">  <span class="type">float</span> vbus_voltage;</span><br><span class="line">&#125; OdriveAxisGetState_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把odrive_set_axis0()声明为一个OdriveAxisSetState_t（在odrive.h定义的结构体）类型的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*odrive.c*/</span></span><br><span class="line">OdriveAxisSetState_t odrive_set_axis0;</span><br><span class="line">OdriveAxisSetState_t odrive_set_axis1;</span><br></pre></td></tr></table></figure><h4 id="结构的初始化"><a href="#结构的初始化" class="headerlink" title="结构的初始化"></a>结构的初始化</h4><p>struct date today&#x3D;{07,31,2014};</p><h4 id="结构成员"><a href="#结构成员" class="headerlink" title="结构成员"></a>结构成员</h4><p>在C语言中，访问结构体成员时选择使用.或-&gt;主要取决于你当前操作的对象是<strong>结构体实例本身</strong>还是<strong>指向该结构体的指针</strong>：</p><p>•使用.（点号）的情况：当直接操作一个已知的结构体变量时，通过.来访问其内部成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>;</span></span><br><span class="line">stu1.name=<span class="string">&#x27;&#x27;John Doe&#x27;</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string">stu1.age = 20;</span></span><br></pre></td></tr></table></figure><p>•使用-&gt;（箭头）的情况：当操作的是指向结构体的指针时，用-&gt;来访问该指针所指向的结构体的成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">stuP</span>;</span></span><br><span class="line">stuP = &amp;stu1; <span class="comment">// 或者 stuP = malloc(sizeof(struct Student));</span></span><br><span class="line"></span><br><span class="line">stuP-&gt;name = <span class="string">&quot;Jane Smith&quot;</span>; <span class="comment">// 使用 -&amp;gt; 访问结构体指针 stuP 所指向的结构体的成员</span></span><br><span class="line">stuP-&gt;age = <span class="number">22</span>;</span><br></pre></td></tr></table></figure><p>简而言之，如果你有一个结构体变量名，就用.；如果你有一个指向结构体的指针，就用-&gt;。</p><h4 id="结构指针"><a href="#结构指针" class="headerlink" title="结构指针"></a>结构指针</h4><p>和数组不同，结构变量的名字不是结构变量的地址，必须使用&amp;运算符</p><h4 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h4><p>向函数传递结构体的信息：1.传递结构体成员  2.传递结构体地址  3.传递结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  GPIO_PIN_RESET = <span class="number">0</span>,</span><br><span class="line">  GPIO_PIN_SET</span><br><span class="line">&#125;GPIO_PinState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> MODER;    <span class="comment">/*!&lt; GPIO port mode register,               Address offset: 0x00      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> OTYPER;   <span class="comment">/*!&lt; GPIO port output type register,        Address offset: 0x04      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> OSPEEDR;  <span class="comment">/*!&lt; GPIO port output speed register,       Address offset: 0x08      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> PUPDR;    <span class="comment">/*!&lt; GPIO port pull-up/pull-down register,  Address offset: 0x0C      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> IDR;      <span class="comment">/*!&lt; GPIO port input data register,         Address offset: 0x10      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ODR;      <span class="comment">/*!&lt; GPIO port output data register,        Address offset: 0x14      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> BSRR;     <span class="comment">/*!&lt; GPIO port bit set/reset register,      Address offset: 0x18      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> LCKR;     <span class="comment">/*!&lt; GPIO port configuration lock register, Address offset: 0x1C      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AFR[<span class="number">2</span>];   <span class="comment">/*!&lt; GPIO alternate function registers,     Address offset: 0x20-0x24 */</span></span><br><span class="line">&#125; GPIO_TypeDef;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*传递结构体地址*/</span></span><br><span class="line">GPIO_PinState <span class="title function_">HAL_GPIO_ReadPin</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span><span class="comment">//第一位GPIO_TypeDef* GPIOx是传入结构体的地址，以便在这个函数中使用这个结构体</span></span><br><span class="line">&#123;</span><br><span class="line">  GPIO_PinState bitstatus;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GPIO_PIN(GPIO_Pin));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((GPIOx-&gt;IDR &amp; GPIO_Pin) != (<span class="type">uint32_t</span>)GPIO_PIN_RESET)<span class="comment">//操作对象是指向结构体的指针，访问该结构体成员时用-&gt;</span></span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = GPIO_PIN_SET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = GPIO_PIN_RESET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bitstatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p><em><strong>typedef 在 MDK 用得最多的就是定义结构体的类型别名和枚举类型了。</strong></em>(typedef struct, typedef enum)</p><p>利用typedef可以为某一类型自定义名称(为现有类型创建一个名称)，它没有创建任何新类型，只是为某个已存在的类型增加了一个方便使用的标签。</p><p>1.为经常出现的类型创建一个方便，易识别的类型名。</p><p>2.常用于给复杂的类型命名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用BYTE表示1字节的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> BYTE</span><br><span class="line"><span class="comment">//随后可以用BYTE来定义变量</span></span><br><span class="line">BYTE x,y[<span class="number">10</span>],*z;</span><br><span class="line"><span class="comment">//#define也可发挥上面同样的功能</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE unsigned char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以把typedef用于结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span></span><br><span class="line">    <span class="type">float</span> real;</span><br><span class="line">    <span class="type">float</span> imag;</span><br><span class="line">&#125;COMPLEX;</span><br><span class="line"><span class="comment">//然后可用COMPLEX类型代替complex结构</span></span><br><span class="line">用<span class="keyword">typedef</span>来命名一个结构类型时，可以省略该结构的标签。（见例odrive&amp;stm32驱动代码）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以为结体定义一个别名 GPIO_TypeDef，这样我们就可以在其他地方通过别名 GPIO_TypeDef 来定义结构体变量了。</p><p>方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> __IO <span class="type">uint32_t</span> CRL;</span><br><span class="line"> __IO <span class="type">uint32_t</span> CRH;</span><br><span class="line">…</span><br><span class="line">&#125; GPIO_TypeDef;</span><br></pre></td></tr></table></figure><p>Typedef 为结构体定义一个别名 GPIO_TypeDef。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_TypeDef _GPIOA,_GPIOB;</span><br></pre></td></tr></table></figure><p>GPIO_TypeDef 就跟 struct _GPIO 是等同的作用了</p><h3 id="enum枚举"><a href="#enum枚举" class="headerlink" title="enum枚举"></a>enum枚举</h3><p>enum枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。（一个被命名的整形常数的集合 ）</p><p>枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure><p>我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MON  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TUE  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WED  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THU  4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRI  5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAT  6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUN  7</span></span><br></pre></td></tr></table></figure><h4 id="声明枚举类型"><a href="#声明枚举类型" class="headerlink" title="声明枚举类型"></a>声明枚举类型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="枚举变量的定义"><a href="#枚举变量的定义" class="headerlink" title="枚举变量的定义"></a>枚举变量的定义</h4><p>我们可以通过以下三种方式来定义枚举变量</p><p><strong>1、先定义枚举类型，再定义枚举变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">day</span>;</span></span><br></pre></td></tr></table></figure><p><strong>2、定义枚举类型的同时定义枚举变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure><p><strong>3、省略枚举名称，直接定义枚举变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure><h4 id="typedef-enum"><a href="#typedef-enum" class="headerlink" title="typedef enum"></a>typedef enum</h4><p>是不是感觉和enum没什么区别，确实在一般的使用中两个的结果是差不多的。</p><p>但是如果你想定义一个和DAY类型一样的集合的情况下，使用typedef enum更方便</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">举例子：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> &#123;</span> MON, TUE=<span class="number">2</span>, WED, THU, FRI, SAT, SUN  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">workday</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">restday</span>;</span></span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> &#123;</span> MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN  &#125;DAY_TYPE; </span><br><span class="line"></span><br><span class="line">DAY_TYPE workday,restday;</span><br></pre></td></tr></table></figure><p>（此处用法与typedef struct一样）</p><p>枚举（enum）成员的值默认是整型，并且从0开始递增。虽然枚举类型本身不直接支持十六进制的声明方式，但你可以手动为枚举成员赋值，这个值可以是任何整数常量，当然包括十六进制表示的整数</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  MSG_CO_NMT_CTRL = <span class="number">0x000</span>,      <span class="comment">// CANOpen NMT Message REC</span></span><br><span class="line">  MSG_SET_INPUT_POS = <span class="number">0x00C</span>,    <span class="comment">// 输入的电机目标位置</span></span><br><span class="line">  MSG_SET_INPUT_VEL = <span class="number">0x00D</span>,    <span class="comment">// 输入的电机目标转速-------###</span></span><br><span class="line">  MSG_CLEAR_ERRORS = <span class="number">0x018</span>,     <span class="comment">// 清除错误</span></span><br><span class="line">  MSG_CO_HEARTBEAT_CMD = <span class="number">0x700</span>, <span class="comment">// CANOpen NMT Heartbeat SEND</span></span><br><span class="line">&#125; Odrive_Commond;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用于switch case中：</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">odrv_write_msg</span><span class="params">(Axis_t axis, Odrive_Commond cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">switch</span>(cmd)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> MSG_GET_ENCODER_COUNT:</span><br><span class="line">        header.RTR = CAN_RTR_REMOTE;  <span class="comment">//数据帧的优先级大于远程帧，当有多个设备向一个ID同时发送数据时，用远程帧可以有效地避免总线冲突，即ID收到消息后会先回发数据帧，再处理远程帧</span></span><br><span class="line">        header.DLC = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MSG_SET_CONTROLLER_MODES:</span><br><span class="line">        data[<span class="number">0</span>] = odrive_set-&gt;control_mode;</span><br><span class="line">        data[<span class="number">4</span>] = odrive_set-&gt;input_mode;</span><br><span class="line">        header.RTR = CAN_RTR_DATA;</span><br><span class="line">        header.DLC = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MSG_SET_TRAJ_ACCEL_LIMITS:</span><br><span class="line">        <span class="built_in">memcpy</span>(data, &amp;(odrive_set-&gt;traj_accel_limit), <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp_word, &amp;(odrive_set-&gt;traj_decel_limit), <span class="number">4</span>);</span><br><span class="line">        data[<span class="number">4</span>] = tmp_word[<span class="number">0</span>];</span><br><span class="line">        data[<span class="number">5</span>] = tmp_word[<span class="number">1</span>];</span><br><span class="line">        data[<span class="number">6</span>] = tmp_word[<span class="number">2</span>];</span><br><span class="line">        data[<span class="number">7</span>] = tmp_word[<span class="number">3</span>];</span><br><span class="line">        header.RTR = CAN_RTR_DATA;</span><br><span class="line">        header.DLC = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//enum枚举常用于状态表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NORMAL,</span><br><span class="line">    CHANGE,</span><br><span class="line">&#125; FSMMode_e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PASSIVE = <span class="number">1</span>,    <span class="comment">// 阻尼</span></span><br><span class="line">    FALL = <span class="number">2</span>,       <span class="comment">// 卧倒</span></span><br><span class="line">    FIXEDSTAND = <span class="number">3</span>, <span class="comment">// 固定站立</span></span><br><span class="line">    FREESTAND = <span class="number">4</span>,  <span class="comment">// 自由站立</span></span><br><span class="line">    TROTING = <span class="number">5</span>,    <span class="comment">// 对角步态</span></span><br><span class="line">    WALKING = <span class="number">6</span>,    <span class="comment">// 行走步态</span></span><br><span class="line">    JUMP = <span class="number">7</span>,       <span class="comment">// 跳跃</span></span><br><span class="line">    JUMP2 = <span class="number">8</span>,      <span class="comment">// 跳跃2</span></span><br><span class="line">    JUMPL = <span class="number">9</span>,</span><br><span class="line">    JUMPL2 = <span class="number">10</span>,</span><br><span class="line">    JUMPR = <span class="number">11</span>,</span><br><span class="line">    JUMPR2 = <span class="number">12</span>,</span><br><span class="line">    catJUMP = <span class="number">13</span>,</span><br><span class="line">    catJUMP2 = <span class="number">14</span>,</span><br><span class="line">&#125; FSMState_e;</span><br></pre></td></tr></table></figure><h2 id="5-指针"><a href="#5-指针" class="headerlink" title="5.指针"></a>5.指针</h2><h3 id="指针偏移"><a href="#指针偏移" class="headerlink" title="指针偏移"></a>指针偏移</h3><p>指针可以作为数组用，数组号表示指针基地址偏移，很多代码都这么用的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span>  <span class="title function_">test</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">buffer[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第16行，memcpy函数从packet[1]的地址开始复制，数据依次复制到packet[1],packet[2],packet[3],packet[4]中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> floatVal;</span><br><span class="line">    <span class="type">uint8_t</span> byteVal[<span class="keyword">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">  &#125; data;</span><br><span class="line"></span><br><span class="line">  data.floatVal = val;<span class="comment">//共同体 val给共同体的data.floatVal后 如果用data.byteVal 共同体内data.floatVal中的数据会转变为byteVal[sizeof(float)]类型</span></span><br><span class="line">  <span class="built_in">memcpy</span>(bytes, data.byteVal, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//共同体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendPacket</span><span class="params">(<span class="type">float</span> angle, <span class="type">float</span> x, <span class="type">float</span> y)</span> &#123;<span class="comment">//float有4个字节，32位</span></span><br><span class="line">  <span class="type">uint8_t</span> packet[<span class="number">14</span>];   <span class="comment">// 数据包共14个字节</span></span><br><span class="line">  <span class="comment">// 填充帧头</span></span><br><span class="line">  packet[<span class="number">0</span>] = FRAME_HEADER;</span><br><span class="line">  <span class="comment">// 填充数据</span></span><br><span class="line">  floatToBytes(angle, &amp;packet[<span class="number">1</span>]);</span><br><span class="line">  floatToBytes(x, &amp;packet[<span class="number">5</span>]);</span><br><span class="line">  floatToBytes(y, &amp;packet[<span class="number">9</span>]);</span><br><span class="line">  <span class="comment">// 填充帧尾</span></span><br><span class="line">  packet[<span class="number">13</span>] = FRAME_TAIL;</span><br><span class="line">  <span class="comment">// 使用串口发送数据包</span></span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, packet, <span class="keyword">sizeof</span>(packet), HAL_MAX_DELAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>所谓函数指针即定义一个<em><strong>指向函数的指针变量</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span> x, <span class="type">int</span>  y);  <span class="comment">//注意：这里的括号不能掉，因为括号()的运算优先级比解引用运算符*高</span></span><br></pre></td></tr></table></figure><p>这个函数的类型是有两个整型参数，返回值是个整型。对应的函数指针类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*) (<span class="type">int</span> a, <span class="type">int</span> b);  </span><br></pre></td></tr></table></figure><p>对应的函数指针<strong>定义</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span> x, <span class="type">int</span>  y);  <span class="comment">//参数名可以去掉，并且通常都是去掉的。这样指针p就可以保存函数类型为两个整型参数，返回值是整型的函数地址了。</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>我们一般可以这么使用，通过函数指针调用函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxValue</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;    </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = <span class="literal">NULL</span>;  <span class="comment">//定义一个与maxValue兼容的指针</span></span><br><span class="line">p = maxValue;<span class="comment">//将这个指针指向maxValue函数</span></span><br><span class="line">p(<span class="number">20</span>, <span class="number">45</span>);  <span class="comment">//通过指针调用</span></span><br></pre></td></tr></table></figure><p><strong>应用案例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FSMMode_e mode;</span><br><span class="line">    FSMState_e currentState;</span><br><span class="line">    FSMState_e nextState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回调函数</span></span><br><span class="line">    <span class="type">void</span> (*enter)(<span class="type">void</span>);<span class="comment">/*函数指针*/</span>  </span><br><span class="line">    <span class="type">void</span> (*run)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">exit</span>)(<span class="type">void</span>);</span><br><span class="line">&#125; FSM_t;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FSM_t FSM ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (FSM.nextState)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FIXEDSTAND:</span><br><span class="line">        FSM.enter = FixedStand_Enter;<span class="comment">//将FSM.enter这个指针指向FixedStand_Enter函数</span></span><br><span class="line">        FSM.run = FixedStand_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = FixedStand_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">case</span> TROTING:</span><br><span class="line">        FSM.enter = Troting_Enter;</span><br><span class="line">        FSM.run = Troting_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Troting_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> WALKING:</span><br><span class="line">        FSM.enter = Walking_Enter;</span><br><span class="line">        FSM.run = Walking_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Walking_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> JUMP:</span><br><span class="line">        FSM.enter = Jump_Enter;</span><br><span class="line">        FSM.run = Jump_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Jump_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在C语言中，void (*enter)(void);、void (*run)(void); 和 void (*exit)(void); 这三个成员是函数指针类型。</p><p>具体解释如下：</p><ol><li><pre><code class="c">void (*enter)(void);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这是一个指向无参数且返回值为 void 的函数的指针。在结构体 FSM_t 中，它表示一个函数指针，当 FSM（有限状态机）进入某个状态时，可以通过调用这个函数指针指向的函数来执行相应的“进入”动作。</span><br><span class="line"></span><br><span class="line"> 2. ```c</span><br><span class="line">    void (*run)(void);</span><br></pre></td></tr></table></figure></code></pre></li></ol><p>同样是一个指向无参数且返回值为 void 的函数的指针。在状态机中，当处于某个状态并需要运行该状态的行为或处理逻辑时，可以调用这个“run”函数指针指向的函数。</p><ol start="3"><li><pre><code class="c">void (*exit)(void);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">依然是一个函数指针，指向无参数且返回值为 void 的函数。当 FSM 状态机从当前状态退出时，会调用这个“exit”函数指针指向的函数，用于执行离开状态时所需的动作或清理工作。</span><br><span class="line"></span><br><span class="line">因此，在实现一个基于此结构体的状态机时，你需要为每个状态分别定义对应的 enter、run 和 exit 函数，并将它们的地址赋给相应状态的 FSM_t 结构体实例中的这三个函数指针成员。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在C语言中，结构体（struct）可以包含各种数据类型，包括**基本数据类型、指针类型**等。在这个特定的FSM_t（有限状态机）结构体定义中，使用函数指针的主要原因是为了实现灵活且可扩展的设计。</span><br><span class="line"></span><br><span class="line">​1.灵活性：***通过将函数作为成员变量（以指针形式存在），可以在不同的实例中为这些函数赋予不同的具体实现，使得状态机的行为可以根据需求动态改变。***</span><br><span class="line"></span><br><span class="line">​2.扩展性：在设计模式上，这种方式符合面向对象编程中的“多态”思想。***每个状态可以有自己的enter、run和exit行为，只需要提供相应的函数实现即可。***</span><br><span class="line"></span><br><span class="line">​3.解耦合：函数指针将函数的具体实现与结构体（状态机）的定义解耦合，使得状态机的定义更简洁，逻辑更清晰，也方便后期维护和扩展。</span><br><span class="line"></span><br><span class="line">​4.高效性：虽然使用函数指针调用会引入一次间接寻址，但在很多情况下，这并不会对性能造成显著影响，而带来的设计优势远大于此微小的性能损耗。总结一下，这里使用函数指针而非直接定义函数，主要是为了构建一个更加灵活、可扩展、高内聚低耦合的状态机模型。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在C语言中，结构体（struct）不能直接包含函数。函数在C语言中不是一种数据类型，因此无法像变量那样存储在结构体中。但是，可以通过存储函数的指针来达到类似的效果，就像上述FSM_t结构体中的enter、run和exit成员那样。</span><br><span class="line"></span><br><span class="line">所以，准确地说，结构体内不能直接定义函数，但可以存储函数的地址，即函数指针，间接实现调用关联函数的功能。</span><br><span class="line"></span><br><span class="line">#### 回调函数</span><br><span class="line"></span><br><span class="line">应用：</span><br><span class="line">1.*送餐机器人：底盘移动到目标位置后，通知应用程序*</span><br><span class="line"></span><br><span class="line">2.*智能音箱：网络状态改变后，通知应用程序*</span><br><span class="line"></span><br><span class="line">3.*四足机器人项目FSM状态机也有用到回调函数的思想*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">//工具代码</span><br><span class="line">typedef struct&#123;</span><br><span class="line">int status;</span><br><span class="line">void (*statusChange)(); //存储后续要调用的回调函数地址</span><br><span class="line">&#125;T_Device;</span><br><span class="line"></span><br><span class="line">T_Device g_ Device;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">名称：回调函数</span><br><span class="line">作用：将传入的用户函数的地址赋给g_Device.statusChange,当满足条件时，执行该用户函数</span><br><span class="line">*/</span><br><span class="line">//void (*pstatusChange)(int status) 定义了一个指向函数的指针变量 pstatusChange，该函数没有返回值，并且接受一个整型参数 status。</span><br><span class="line">void addCallbackFunc(void (*pstatusChange)(int status))&#123;//将函数的地址传入并赋给g_Device.statusChange，这样g_Device.statusChange指向函数的入口地址</span><br><span class="line">g_Device.statusChange = pstatusChange ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void run()&#123;</span><br><span class="line">g_Device.status = 10;</span><br><span class="line">    if(g_Device.status == 10)&#123;</span><br><span class="line">        if(g_Device . statusChange != NULL)&#123;</span><br><span class="line">        g_Device.statusChange(g_Device.status);//callBack(10);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//用户代码</span><br><span class="line">void callBack(int status )&#123;&#125;</span><br><span class="line">    printf(&quot;callBack\n&quot;);</span><br><span class="line">    printf(&quot;status = %d\n&quot; ,status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    addCallbackFunc(callBack);//将 `callBack` 函数的地址作为参数传递给了 `addCallbackFunc` 函数，</span><br><span class="line">    run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><p>在 <code>main</code> 函数中调用 <code>addCallbackFunc(callBack);</code> 时，发生了以下事件：</p><ol><li><code>callBack</code> 是用户定义的一个函数，其原型为 <code>void callBack(int status)</code>。</li><li>当调用 <code>addCallbackFunc(callBack)</code> 时，将 <code>callBack</code> 函数的地址作为参数传递给了 <code>addCallbackFunc</code> 函数。</li><li>在 <code>addCallbackFunc</code> 函数内部，这个传入的参数 <code>pstatusChange</code> 被赋值给全局变量 <code>g_Device</code> 的成员 <code>statusChange</code>，即 <code>g_Device.statusChange = pstatusChange;</code>。因此，现在 <code>g_Device.statusChange</code> 指向了 <code>callBack</code> 函数的入口地址。</li><li>这样一来，就实现了回调函数的注册。当设备状态改变且满足触发条件时（如在 <code>run</code> 函数中），可以通过调用 <code>g_Device.statusChange(g_Device.status);</code> 来执行 <code>callBack</code> 函数，<strong>并将设备状态作为参数传递进去，从而实现对状态变化的响应和处理。</strong></li></ol><p>提问：为什么不能直接用if(g_Device.status&#x3D;&#x3D;10)，而非要用回调函数，这是多此一举吗</p><p>使用回调函数并不一定是在做无用功，它在某些情况下具有以下优点：</p><ol><li><strong>解耦合</strong>：通过回调函数，我们可以将处理状态变化的逻辑从设备状态管理代码中分离出来。这样可以使代码结构更加清晰，也<strong>更容易维护和扩展</strong>。例如，在本例中，具体的设备状态改变后的处理行为（即<code>callBack</code>函数中的内容）可以由用户自定义，而不是硬编码在<code>run</code>函数里。</li><li><strong>灵活性</strong>：当设备状态改变时，不同的应用程序可能需要执行不同的操作。使用回调函数允许我们在运行时动态地根据需要来指定要执行的操作，增加了程序的灵活性。</li><li><strong>事件驱动编程</strong>：回调函数是事件驱动编程模型的重要组成部分。在这种模式下，当某个特定事件（如设备状态改变）发生时，系统调用预先注册好的回调函数，<strong>而非直接在触发事件的地方编写处理逻辑。</strong></li></ol><p>所以，并不是多此一举，而是为了实现更灵活、解耦的软件设计和开发。当然，在简单场景下，如果状态改变后的处理逻辑固定且无需复用，直接写在<code>if(g_Device.status==10)</code>判断后也是可行的，但在复杂项目或者需要扩展性的情况下，回调函数就显得尤为重要了。</p><h3 id="void-修饰指针使用规则"><a href="#void-修饰指针使用规则" class="headerlink" title="void 修饰指针使用规则"></a>void 修饰指针使用规则</h3><p>void *</p><p>void 指针可以指向任意类型的数据，就是说可以用任意类型的指针对 void 指针对 void <a href="https://so.csdn.net/so/search?q=%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC&spm=1001.2101.3001.7020">指针赋值</a>。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a；</span><br><span class="line"><span class="type">void</span> *p；</span><br><span class="line">p=a；</span><br></pre></td></tr></table></figure><p>void 指针可以任意类型的数据，可以在程序中给我们带来一些好处，函数中形为指针类型时，我们可以将其定义为 void 指针，这样函数就可以接受任意类型的指针。如：</p><pre><code>void * memcpy(void *dest, const void *src, size_t len);void * memset ( void * buffer, int c, size_t num );</code></pre><p>这样，任何类型的指针都可以传入 memcpy 和 memset 中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型。</p><h2 id="6-常见关键词"><a href="#6-常见关键词" class="headerlink" title="6.常见关键词"></a>6.常见关键词</h2><h3 id="define宏定义关键词"><a href="#define宏定义关键词" class="headerlink" title="define宏定义关键词"></a>define宏定义关键词</h3><p>语法：<code>#define 标识符 字符串</code></p><ul><li><p>“标识符”为所定义的<strong>宏名</strong></p></li><li><p>“字符串”可以是<strong>常数</strong>、<strong>表达式</strong>、<strong>格式串</strong>等</p><p>#define SYSCLK_FREQ_72MHz 72000000</p></li></ul><h3 id="ifdef-条件编译"><a href="#ifdef-条件编译" class="headerlink" title="ifdef 条件编译"></a>ifdef 条件编译</h3><p>当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 标识符</span></span><br><span class="line">程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>作用是：当标识符已经被定义过(一般是用#define 命令定义)，则对程序段 1 进行编译，否则编译程序段 2。 其中#else 部分也可以没有，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span></span></span><br><span class="line">程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="extern变量声明"><a href="#extern变量声明" class="headerlink" title="extern变量声明"></a>extern变量声明</h3><p>在一个文件中定义的全局变量，如果在其它文件里想使用，需要在前面加上extern</p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>有时候，我们希望函数中局部变量的值在<strong>函数调用结束之后不会消失，而仍然保留其原值</strong>。即它所占用的存储单元不释放，在<strong>下一次调用该函数时，其局部变量的值仍然存在，也就是上一次函数调用结束时的值</strong>。这时候，我们就应该将该局部变量用关键字 static 声明为“<strong>静态局部变量</strong>”。</p><p>静态变量的作用：<strong>保持变量内容的持久性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt;= <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">            count();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">count</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*声明一个静态局部变量*/</span></span><br><span class="line">    <span class="type">static</span> num = <span class="number">0</span>;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该代码中，我们通过在 count() 函数里声明一个静态局部变量 num 来作为计数器。因为静态局部变量是在编译时赋初值的，且只赋初值一次，在程序运行时它已有初值。以后在每次调用函数时就<em><strong>不再重新赋初值，而是保留上次函数调用结束时的值</strong></em>。这样，count() 函数每次被调用的时候，静态局部变量 num 就会保持上一次调用的值，然后再执行自增运算，这样就实现了计数功能。同时，它又避免了使用全局变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_ChangeState</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C语言中，当一个函数前加上 static 关键字时，意味着该函数具有内部链接性（internal linkage），即该函数的作用范围被限制在当前编译单元内。对于这个函数而言，这意味着只有定义它的源文件以及包含它所在的头文件的其他源文件可以访问此函数，不会成为外部全局符号，从而避免不同编译单元之间产生符号冲突。</p><h3 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h3><p>程序开发人员可以在变量定义后，在程序的其他位置引用和修改变量。但程序中定义的一些变量，如圆周率PI&#x3D;3.14，黄金分割比例 g&#x3D;0.618，<em><strong>这些变量只需要被引用，不应该被修改</strong></em>。C语言中可以使用 const关键字修饰变量。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> pi = <span class="number">3.141592612</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,pi);</span><br></pre></td></tr></table></figure><h3 id="IO-volatile"><a href="#IO-volatile" class="headerlink" title="__IO(volatile)"></a>__IO(<strong>volatile</strong>)</h3><p><strong>volatile</strong>的含义为 <code>允许硬件改变变量的数值</code> 。告诉编译器不要优化这些代码</p><p><a href="https://blog.csdn.net/QWQ_DIODA/article/details/116712401">volatile 形变量可以被硬件改变</a>，在需要<strong>硬件</strong>改变变量的场合中不可或缺！！</p><p><img src="/2024/01/26/Embedded-C-language/image-20240114110255039.png" alt="image-20240114110255039"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__IO <span class="type">uint16_t</span> ADC_ConvertedValue;  <span class="comment">// 用于保存转换后的ADC值 </span></span><br><span class="line"><span class="comment">// 中断服务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (ADC_GetITStatus(ADCx,ADC_IT_EOC)==SET) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 读取ADC的转换值</span></span><br><span class="line">ADC_ConvertedValue = ADC_GetConversionValue(ADCx);</span><br><span class="line">&#125;</span><br><span class="line">ADC_ClearITPendingBit(ADCx,ADC_IT_EOC);<span class="comment">//清除ADCx的中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task1Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;Task1&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task2Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;Task2&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task3Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="string">&quot;Task3&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_LCDCanUse = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> g_calc_end = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> g_time = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> g_sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务1 计算加法，并计算加法运算的时间，然后删除任务</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CalcTask</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">  g_time = system_get_ns();</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    g_sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  g_calc_end = <span class="number">1</span>;</span><br><span class="line">  g_time = system_get_ns() - g_time;</span><br><span class="line">  vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务2 当计算任务没有结束时，一直执行while循环，直到计算任务结束,g_cal_end变为1，则可进行后面的打印信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdPrintTask</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LCD_PrintString(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;waiting&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (g_calc_end == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印信息 */</span></span><br><span class="line">    <span class="keyword">if</span> (g_LCDCanUse)</span><br><span class="line">    &#123;</span><br><span class="line">      g_LCDCanUse = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      LCD_ClearLine(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      len = LCD_PrintString(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;Sum:&quot;</span>);</span><br><span class="line">      LCD_PrintHex(len, <span class="number">0</span>, g_sum,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      LCD_ClearLine(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">      len = LCD_PrintString(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;Time(ms):&quot;</span>);</span><br><span class="line">      LCD_PrintSignedVal(len, <span class="number">2</span>, g_time/<span class="number">1000000</span>);</span><br><span class="line">      g_LCDCanUse = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  xTaskCreate(CalcTask, <span class="string">&quot;task1&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">  xTaskCreate(LcdPrintTask, <span class="string">&quot;task2&quot;</span>, <span class="number">128</span>, &amp;g_Task2Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>没有加volatile时，经过<strong>debug</strong>，发现程序一直会卡LcdPrintTask的while (g_calc_end &#x3D;&#x3D; 0);处，<strong>尽管在debug时显示g_calc_end为1还是一直卡在那里</strong>。这是因为在编译器做了一些优化，第一次使用这个变量时，它会去读内存，把这个变量的值读进CPU的某个寄存器，以后在任务2的那个while循环里，它一直都是去判断那个<strong>寄存器</strong>，但是那个寄存器得到的是这个变量原始的，老的值，它并<strong>没有每次都去内存里面读这个变量，更新那个寄存器</strong>，这是不对的，因为这个变量，是在其他任务里面被修改了，你去使用这个变量时，每次都应该去读内存，怎么办呢，<strong>在变量前加一个volatile就好了，告诉编译器，不要去优化它</strong>。</p><p>​“在多任务环境下，编译器通常会对变量进行优化以提高代码执行效率。当一个变量被标记为 volatile 时，它告诉编译器这个变量的值可能在程序控制范围之外发生变化（例如由中断服务程序、硬件操作或者其他并发任务修改），因此每次访问该变量时都会从内存中重新读取。<em>编译器对变量的优化通常基于以下几种情况</em>：</p><ol><li><p><strong>局部性原理</strong>：编译器假设在一段连续执行的代码中，如果一个变量没有被显示地修改（比如通过赋值、函数调用或指针间接访问），其值就不会改变。因此，在循环内多次读取同一变量时，编译器可能会将该变量从内存加载到寄存器中，并在整个循环期间使用寄存器中的值，以减少对内存的访问。</p></li><li><p><strong>数据流分析</strong>：编译器会进行数据依赖性分析，如果它能确定某个变量在当前作用域内不会受外部因素影响而改变，即使这个变量是全局的，也可能对其进行优化。</p></li><li><p><strong>跨函数优化</strong>：编译器还可能进行跨函数优化，例如当函数没有明确的副作用或者编译器能够推断出函数内部对全局变量的修改不会影响到当前上下文时，也会选择不重新加载变量。”</p><p>应当在以下情况下考虑使用 <code>volatile</code> 关键字来修饰变量：</p><ul><li>变量可能被<strong>中断服务程序修改</strong>。</li><li>变量位于<strong>多线程环境且不同线程间共享并修改该变量</strong>。</li><li>变量与硬件寄存器映射相关，硬件可能会在软件不可见的情况下更改它们的值。</li><li>变量用于信号量、事件标志或其他同步机制。</li></ul></li></ol><h3 id="union共同体（联合体）"><a href="#union共同体（联合体）" class="headerlink" title="union共同体（联合体）"></a>union共同体（联合体）</h3><h4 id="实现不同类型数据的转换"><a href="#实现不同类型数据的转换" class="headerlink" title="实现不同类型数据的转换"></a>实现不同类型数据的转换</h4><p><strong>C语言的union联合体，可实现不同类型数据的转换</strong></p><p>结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。联合体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</p><p><em>简单说就是你给联合体的一个变量赋值，然后表示联合体其中的另一个变量，之前那个赋值了的变量会自动赋给你要表示的这个量，从而实现不同类型数据的转换。</em></p><p><img src="/2024/01/26/Embedded-C-language/image-20240114200704804.png" alt="image-20240114200704804"></p><p><img src="/2024/01/26/Embedded-C-language/image-20240114192714039.png" alt="image-20240114192714039"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memcpy函数有三个参数，第一个是目标地址（通常是数组的某一位的地址，即将数据从数组的这一位开始复制），第二个是源地址，第三个是数据长度。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> floatVal;</span><br><span class="line">    <span class="type">uint8_t</span> byteVal[<span class="keyword">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">  &#125; data;</span><br><span class="line"></span><br><span class="line">  data.floatVal = val;<span class="comment">//共同体 val给共同体的data.floatVal后 如果用data.byteVal 共同体内data.floatVal中的数据会转变为byteVal[sizeof(float)]类型</span></span><br><span class="line">  <span class="built_in">memcpy</span>(bytes, data.byteVal, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//共同体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *destin, <span class="type">void</span> *source, <span class="type">unsigned</span> n)</span>;</span><br></pre></td></tr></table></figure><p><strong>以source指向的地址为起点，将连续的n个字节数据，复制到以destin指向的地址为起点的内存中。</strong><br>函数有三个参数，第一个是目标地址（通常是数组的某一位的地址，即将数据从数组的这一位开始复制），第二个是源地址，第三个是数据长度。<br>数据长度（第三个参数）的单位是字节（1byte &#x3D; 8bit）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> floatVal;</span><br><span class="line">    <span class="type">uint8_t</span> byteVal[<span class="keyword">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">  &#125; data;</span><br><span class="line"></span><br><span class="line">  data.floatVal = val;<span class="comment">//共同体 val给共同体的data.floatVal后 如果用data.byteVal 共同体内data.floatVal中的数据会转变为byteVal[sizeof(float)]类型</span></span><br><span class="line">  <span class="built_in">memcpy</span>(bytes, data.byteVal, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//共同体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendPacket</span><span class="params">(<span class="type">float</span> angle, <span class="type">float</span> x, <span class="type">float</span> y)</span> &#123;<span class="comment">//float有4个字节，32位</span></span><br><span class="line">  <span class="type">uint8_t</span> packet[<span class="number">14</span>];   <span class="comment">// 数据包共14个字节</span></span><br><span class="line">  <span class="comment">// 填充帧头</span></span><br><span class="line">  packet[<span class="number">0</span>] = FRAME_HEADER;</span><br><span class="line">  <span class="comment">// 填充数据</span></span><br><span class="line">  floatToBytes(angle, &amp;packet[<span class="number">1</span>]);<span class="comment">//从packet[1]的地址开始复制，数据依次复制到packet[1],packet[2],packet[3],packet[4]中</span></span><br><span class="line">  floatToBytes(x, &amp;packet[<span class="number">5</span>]);</span><br><span class="line">  floatToBytes(y, &amp;packet[<span class="number">9</span>]);</span><br><span class="line">  <span class="comment">// 填充帧尾</span></span><br><span class="line">  packet[<span class="number">13</span>] = FRAME_TAIL;</span><br><span class="line">  <span class="comment">// 使用串口发送数据包</span></span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, packet, <span class="keyword">sizeof</span>(packet), HAL_MAX_DELAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_ChangeState</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​1.static：</p><p>​在C语言中，当一个函数前加上 static 关键字时，意味着该函数具有内部链接性（internal linkage），即该函数的作用范围被限制在当前编译单元内。对于这个函数而言，这意味着只有定义它的源文件以及包含它所在的头文件的其他源文件可以访问此函数，不会成为外部全局符号，从而避免不同编译单元之间产生符号冲突。</p><p>​2.inline：</p><p>​inline 关键字提示编译器尝试将函数体直接插入到每个调用该函数的地方（即“内联”），而不是通过正常的函数调用机制（如压栈、跳转等）。这样做的目的是减少函数调用的开销，尤其是当<em><strong>函数体较小且频繁调用时，能够提高程序运行效率。</strong></em><br>​注意，尽管有 inline 关键字，但是否真正进行内联处理由编译器决定，编译器会根据实际情况判断是否采纳程序员的建议。</p><p>综合上述解释，在状态机的上下文中，static inline void FSM_ChangeState() 函数可能用于快速切换状态，由于其内联特性，编译器可能会将状态切换的相关操作直接嵌入到调用处，以提升代码执行速度，并且由于是静态函数，其使用和实现细节被隐藏在当前编译单元内，不对外部模块可见，有助于封装和管理复杂度。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p><img src="/2024/01/26/Embedded-C-language/image-20240114192455610.png" alt="image-20240114192455610"></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="串口数据包通讯协议"><a href="#串口数据包通讯协议" class="headerlink" title="串口数据包通讯协议"></a>串口数据包通讯协议</h2><p>uint8_t packet[14];  &#x2F;&#x2F;packet数组的一位是一个字节,此packet含14个字节</p><p>串口接收鲁棒性高，采用校验帧头、帧尾以及数据长度的方式，确保接收数据的稳定性。</p><p>之前一直没用过帧头帧尾，主要是之前用串口传输的数据量都不大，如果要传输多种数据，就需要用帧头帧尾确保数据传输的准确性</p><p>(STM32通讯系列–串口通讯】使用标准库、HAL库实现任意长度数据的收发（包含帧头、帧尾校验，配套完整开源程序）</p><p><a href="https://blog.csdn.net/qq_44343584/article/details/125654421?ops_request_misc=%7B%22request_id%22:%22166299541816800182785614%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=166299541816800182785614&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-125654421-null-null.142">https://blog.csdn.net/qq_44343584/article/details/125654421?ops_request_misc=%7B%22request%5Fid%22%3A%22166299541816800182785614%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=166299541816800182785614&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-125654421-null-null.142</a> )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//packet.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;packet.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> host 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> host<span class="comment">//发送数据包</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> packet_received = <span class="literal">false</span>;<span class="comment">//是否收到完整的数据包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转换单精度浮点数为字节</span></span><br><span class="line"><span class="comment">//@param1:浮点数</span></span><br><span class="line"><span class="comment">//@param2:字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> floatVal;</span><br><span class="line">    <span class="type">uint8_t</span> byteVal[<span class="keyword">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">  &#125; data;</span><br><span class="line"></span><br><span class="line">  data.floatVal = val;<span class="comment">//共同体 val给共同体的data.floatVal后 如果用data.byteVal 共同体内data.floatVal中的数据会转变为byteVal[sizeof(float)]类型</span></span><br><span class="line">  <span class="built_in">memcpy</span>(bytes, data.byteVal, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//共同体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* memcpy用法:</span></span><br><span class="line"><span class="comment">void *memcpy(void *destin, void *source, unsigned n);</span></span><br><span class="line"><span class="comment">以source指向的地址为起点，将连续的n个字节数据，复制到以destin指向的地址为起点的内存中。</span></span><br><span class="line"><span class="comment">函数有三个参数，第一个是目标地址，第二个是源地址，第三个是数据长度。</span></span><br><span class="line"><span class="comment">数据长度（第三个参数）的单位是字节（1byte = 8bit）。</span></span><br><span class="line"><span class="comment">一个float类型的函数有4个字节</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendPacket</span><span class="params">(<span class="type">float</span> angle, <span class="type">float</span> x, <span class="type">float</span> y)</span> &#123;</span><br><span class="line">  <span class="type">uint8_t</span> packet[<span class="number">14</span>];   <span class="comment">// 数据包共14个字节</span></span><br><span class="line">  <span class="comment">// 填充帧头</span></span><br><span class="line">  packet[<span class="number">0</span>] = FRAME_HEADER;</span><br><span class="line">  <span class="comment">// 填充数据</span></span><br><span class="line">  floatToBytes(angle, &amp;packet[<span class="number">1</span>]);</span><br><span class="line">  floatToBytes(x, &amp;packet[<span class="number">5</span>]);</span><br><span class="line">  floatToBytes(y, &amp;packet[<span class="number">9</span>]);</span><br><span class="line">  <span class="comment">// 填充帧尾</span></span><br><span class="line">  packet[<span class="number">13</span>] = FRAME_TAIL;</span><br><span class="line">  <span class="comment">// 使用串口发送数据包</span></span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, packet, <span class="keyword">sizeof</span>(packet), HAL_MAX_DELAY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析数据包</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// 定义缓冲区大小  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义缓冲区和指针</span></span><br><span class="line"><span class="type">uint8_t</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">uint8_t</span>* p_buffer = buffer;<span class="comment">//指向buffer缓冲区首地址的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义标志位，表示是否接收到完整的数据包</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> packet_received = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析数据包的函数 将数据包中数据赋给 angle x y</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ParseDataPacket</span><span class="params">(DataPacket* packet)</span> &#123;</span><br><span class="line">  <span class="type">uint8_t</span>* p = buffer + <span class="number">1</span>; <span class="comment">// 跳过帧头</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;packet-&gt;angle, p, <span class="keyword">sizeof</span>(<span class="type">float</span>)); <span class="comment">//buffer[1] buffer[2] buffer[3] buffer[4]</span></span><br><span class="line">  p += <span class="keyword">sizeof</span>(<span class="type">float</span>);<span class="comment">//指向buffer[5]</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;packet-&gt;x, p, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//buffer[5] buffer[6] buffer[7] buffer[8]</span></span><br><span class="line">  p += <span class="keyword">sizeof</span>(<span class="type">float</span>);<span class="comment">//指向buffer[9]</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;packet-&gt;y, p, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//buffer[9] buffer[10] buffer[11] buffer[12]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在串口接收中断中调用此函数，将接收到的数据存入缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HandleReceivedData</span><span class="params">(<span class="type">uint8_t</span> data)</span> &#123;</span><br><span class="line">  <span class="comment">// 如果缓冲区已满，清空缓冲区</span></span><br><span class="line">  <span class="keyword">if</span> (p_buffer &gt;= buffer + BUFFER_SIZE) &#123;</span><br><span class="line">    p_buffer = buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将数据存入缓冲区</span></span><br><span class="line">  *p_buffer++ = data;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断是否接收到完整的数据包</span></span><br><span class="line">  <span class="keyword">if</span> (p_buffer - buffer &gt;= <span class="keyword">sizeof</span>(DataPacket) + <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查帧头和帧尾是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (buffer[<span class="number">0</span>] ==FRAME_HEADER &amp;&amp; buffer[<span class="keyword">sizeof</span>(DataPacket) + <span class="number">1</span>] == FRAME_TAIL) &#123;</span><br><span class="line">      <span class="comment">// 接收到完整的数据包</span></span><br><span class="line">      packet_received = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空缓冲区</span></span><br><span class="line">    p_buffer = buffer;<span class="comment">//指针重新指向buffer数组首地址</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主函数中调用此函数，处理接收到的数据包</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ProcessReceivedData</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 如果接收到完整的数据包，则解析数据包</span></span><br><span class="line">  <span class="keyword">if</span> (packet_received) &#123;</span><br><span class="line">    DataPacket packet;</span><br><span class="line">    ParseDataPacket(&amp;packet);<span class="comment">//处理之后定义的packet中angle x y就有数据了 可以直接调用 eg: packet.angle</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理解析后的数据包，例如将数据包的内容显示到LCD屏幕上</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除标志位</span></span><br><span class="line">    packet_received = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**********************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 在主函数中循环调用此函数，以处理接收到的数据</span></span><br><span class="line"><span class="comment">//void Loop() &#123;</span></span><br><span class="line"><span class="comment">//  // 处理接收到的数据包</span></span><br><span class="line"><span class="comment">//  ProcessReceivedData();</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//  // 继续执行其他任务</span></span><br><span class="line"><span class="comment">//  // ...</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在中断中</span></span><br><span class="line"><span class="comment">//void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    // 读取接收数据寄存器</span></span><br><span class="line"><span class="comment">//    uint8_t data = (uint8_t)(huart-&gt;Instance-&gt;RDR &amp; 0xFF);</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    // 处理接收到的数据</span></span><br><span class="line"><span class="comment">//    HandleReceivedData(data);</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    // 继续启动接收中断</span></span><br><span class="line"><span class="comment">//    HAL_UART_Receive_IT(huart, &amp;data, 1);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PACKET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRAME_HEADER 0x7E   <span class="comment">// 帧头</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRAME_TAIL 0x7F     <span class="comment">// 帧尾</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> angle;</span><br><span class="line">  <span class="type">float</span> x;</span><br><span class="line">  <span class="type">float</span> y;</span><br><span class="line">&#125; DataPacket;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span>;<span class="comment">//转换单精度浮点数为字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendPacket</span><span class="params">(<span class="type">float</span> angle, <span class="type">float</span> x, <span class="type">float</span> y)</span>;<span class="comment">//发送数据包</span></span><br><span class="line"><span class="comment">//bool parsePacket(uint8_t* packet, float* angle, float* x, float* y);//解析数据包</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ParseDataPacket</span><span class="params">(DataPacket* packet)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ProcessReceivedData</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*PACKET_H*/</span></span></span><br></pre></td></tr></table></figure><h2 id="环形缓冲区"><a href="#环形缓冲区" class="headerlink" title="环形缓冲区"></a>环形缓冲区</h2><p><strong>环形缓冲区</strong>是<a href="https://so.csdn.net/so/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F&spm=1001.2101.3001.7020">嵌入式</a>系统中十分重要的一种数据结构，比如在<strong>串口</strong>处理中，串口中断接收数据直接往环形缓冲区丢数据，而应用可以从环形缓冲区取数据进行处理，这样数据在读取和写入的时候都可以在这个缓冲区里循环进行，程序员可以根据自己需要的数据大小来决定自己使用的缓冲区大小，<strong>不用担心数组越界</strong>。</p><p><strong>队列</strong>的基本概念：队列 (Queue)：是一种先进先出(First In First Out ,简称 FIFO)的线性表，只允许在一端插入（入队），在另一端进行删除（出队）。</p><p>队列头就是指向已经存储的数据，并且这个数据是待处理的。下一个CPU处理的数据就是1；而队列尾则指向可以进行写数据的地址。</p><p><strong>队列是什么</strong></p><p>队列是一种很常见的数据结构，满足先进先出的方式，如果我们设定队列的最大长度，那就意味着进队列和出队列的元素的数量实则满足一种动态平衡。</p><p>如果我们把首次添加入队列的元素作为一个一维坐标的原点，那么随着队列中元素的添加，坐标原点到队尾元素的长度会无穷无尽的增大，随这之前添入的元素不断出列，对头对应的下标点也在不断增大。这样，进队列和出队列的元素的数量就对应到对头和队尾下标点的移动</p><p>因此我们评判一个队列长度是否溢出原先约定的最大长度，实则就是在评判队尾坐标点与队头坐标点之间的差值，无论是出队列还是入队列，队头和队尾的坐标都在不断增大</p><p><img src="/2024/01/26/Embedded-C-language/84497721b6c4413c8558e4266b886ddc.png" alt="img"></p><p><strong>front指针和rear指针的引入</strong></p><p>虽然队尾和队头的下标在不断增大，但是我们对于队列的研究只需要局限在队头与队尾之间的元素，坐标原点到队头之间的元素已经算作出列元素，并不需要研究。因此我们不妨将队列在逻辑上放入一个事先设定容量的一维数组中，只要这个数组的容量是队列中元素的个数+1就行，为什么要这么设定待会再讲。我们想要达到的目的是，无论出列还是入列，本质上是通过修改数组中元素的值，那些已经出列的元素所在的下标位需要放置新入列的元素，并在逻辑上保证新入列元素位于队尾就行。</p><p>因此，我们不得不得引入头指针front和尾指针rear，对指针指向的数组下标对应空间进行操作，来修改数组中元素的值。</p><p><strong>front指针和rear指针的理解</strong></p><p>front：初始值为0，对应索引位待出列，若当前指向的数组下标的元素要出列，则先执行出列动作(实际上不用操作，出列的索引位可以被新入队的元素覆盖)，随后front指针就要向后一位，即front++</p><p>rear：初始值为0，对应索引位待入列，若当前指向的数组下标有元素要入列，则先执行入列动作（索引位元素赋值），随后front指针就要向后一位，即rear++</p><p><strong>队列最大长度匹配数组容量导致一种错误的解决方案</strong></p><p>这就会有一个问题，随着队列中元素的不断更迭，front和rear很快就会超过数组容量，造成数组索引越界</p><p><img src="/2024/01/26/Embedded-C-language/dd50472cf4ba4aad8fe5e565ccfe39de.png" alt="img"></p><p>比如上图所示，front&#x3D;2，也就是说已经有两个元素出列了，因此rear&#x3D;5与rear&#x3D;6对应的两个元素理应可以入列，但是我们发现数组maxsize&#x3D;5，不存在索引位5和6，强行对这两个下标赋值会造成索引越界异常indexOutException 。但是我们发现此时数组中索引位0和1都空着，完全可以将这两个位置利用起来，因此我们可以想办法让实际的rear值转化为等效的rear值，也就是是让rear&#x3D;5转化为rear&#x3D;0，同理rear6转化为rear&#x3D;1。怎么做到呢？无疑是通过取余！</p><p>每次新元素入队后， 执行rear&#x3D;(rear)%maxSize操作，随后执行rear++操作右移rear指针</p><p>像上图中的rear&#x3D;rear%5乍一看好像没问题，但实际上这种取余方式是有问题的，出现这种取余方式的根源在于我们想让队列最大长度与数组容量保持一致，下文会详细说明这种解决方案的错误之处。</p><p><strong>指针的往复移动：逻辑上的环形</strong></p><p>出队和入队的方向是从右向左，而front与rear指针的移动方向却是从左到右循环往复（指向数组末尾后按照取余算法又重置为数组开头），因此我们可以把单向数组在逻辑上理解成环形数组，指针的循环往复移动理解成按照顺时针或逆时针（只要规定某一方向就好）单向移动</p><p>  环形队列小知识：</p><p>  环形队列是在实际编程极为有用的数据结构,它有如下特点。</p><p>  它是一个首尾相连的FIFO的数据结构，采用数组的线性空间,数据组织简单。能很快知道队列是否满为空。能以很快速度的来存取数据。</p><p>   因为有简单高效的原因，甚至在硬件都实现了环形队列。 </p><p>   环形队列广泛用于网络数据收发，和不同程序间数据交换（比如内核与应用程序大量交换数据,从硬件接收大量数据）均使用了环形队列。</p><p><strong>队列为空的判别</strong></p><p>我们怎么判断队列为空呢？</p><p>如果我们按照指针从左到右的方向移动，当front指针和rear指针重合时，front指针对应的索引位之前的索引位都已经出列完毕，而rear指针对应的索引位以及之后的所有索引位还未有元素入列。</p><p>所以队列是否为空的判别：front&#x3D;&#x3D;rear</p><p><img src="/2024/01/26/Embedded-C-language/a053efb0385e4714b8889ecd98ba2d31.png" alt="img"></p><p><strong>rear&#x3D;rear%maxSize解决方案的问题</strong></p><p> 入队图示<br>下图展示了maxSize&#x3D;5的数组中，front&#x3D;0保持不变，元素依次入列直到满载，rear指针的移动情况：</p><p><img src="/2024/01/26/Embedded-C-language/42a1d7c1976b4e7db62cd01c7b7c2fdc.png" alt="img"></p><p> front&#x3D;rear&#x3D;0的歧义<br> 可以看到，如果我们认为队列容量与数组容量应该持平，那么当第五个元素50入列后，本来rear&#x3D;4执行了rear++的操作后，rear&#x3D;5，随后rear将会通过取余算法rear&#x3D;rear%maxSize重置为0，这是我们解决方案的核心！</p><p>但关键点就在这里，我们发现空载时front&#x3D;rear&#x3D;0，满载时依然有front&#x3D;rear&#x3D;0！这样子我们就无法判断front&#x3D;rear时，队列是空还是满，因此rear&#x3D;rear%maxSize这种解决方案是不被允许的</p><p><strong>新的解决方案：置空位的引入</strong></p><p>新的解决方案<br>       每次新元素入队后， 执行rear&#x3D;(rear+1)%maxSize操作，该操作包含rear++操作</p><p>置空位的引入<br>       并且我们人为规定，数组中必须留有一个索引位不得放置元素，必须置空！！！如何实现我们的人为规定呢？那就要先探索当数组满载后front和rear指针之间有啥关系</p><p> 入队图示<br>下图展示了maxSize&#x3D;5的数组中，front&#x3D;0保持不变，元素依次入列直到满载，rear指针的移动情况：</p><p><img src="/2024/01/26/Embedded-C-language/fc276df1cfb14836b200b9ab1791347a.png" alt="img"></p><pre><code>   人为的让最后一位置空，所以当元素40入列后，数组已经满载   满载后数据之间的关系：</code></pre><p>front&#x3D;0<br>rear&#x3D;(rear+1)%maxSize&#x3D;(3+1)%5&#x3D;4  (注： 执行完arr[rear]&#x3D;40，再执行  rear&#x3D;(rear+1)%maxSize)<br>(rear+1)%maxSize&#x3D;(4+1)%5&#x3D;0&#x3D;front<br>       当我们认为的满载发生后，最后一位置空，发现此时rear和front之间的关系为(rear+1)%maxSize&#x3D;(4+1)%5&#x3D;0&#x3D;front，因此这个关系可以作为满载的条件</p><pre><code>   因为处于满载状态，我们无法再往队列添加元素，只能从队列取出元素，也就是进行出列的操作，而一旦我们执行了出列的操作，比如将索引位i=0上的元素10出列后，则front右移，即执行front=(front+1)%maxSize操作，最终front=1。   若随后又添加元素入列，即在索引位i=4上添加元素50，随后又会执行rear=(rear+1)%maxSize操作，最终rear=0。   rear=0≠front=1，此时就不会出现之前那种错误方案中 rear=front=0导致歧义的情况，而一旦 rear=front=0，必然表示队列为空，因此这种解决方案是行得通的</code></pre><p><strong>队列为满的判别</strong></p><p>​      当我们认为的满载发生后，最后一位置空，发现此时rear和front之间的关系为(rear+1)%maxSize&#x3D;(4+1)%5&#x3D;0&#x3D;front，因此这个关系可以作为满载的条件</p><p><strong>队列中元素的个数</strong></p><p>​      numValid&#x3D;(rear+maxSize-front)%maxSize，大家可以带入数据验证一下</p><pre><code> 实际上：   当rear在front之后(这里指的是数组中索引位的前后，并非逻辑上的前后)，有效数据个数=rear-front=(rear+maxSize-front)%maxSize   当rear在front之前(这里指的是数组中索引位的前后，并非逻辑上的前后)，有效数据个数=(rear+maxSize-front)%maxSize</code></pre><p><strong>值得注意的一些细节</strong></p><p>细节1<br>      置空位虽然是人为引入的，但这不意味这置空位的位置是随意的，实际上，只有队列满后才会将剩下的位置作为置空位，一旦置空位出现，rear和front永远不可能指向同一个索引位，因为你会惊奇的发现置空位恰号将rear和front隔开了.</p><pre><code> 置空位就像一把锁，一旦上锁就只能通过出队列操作解锁</code></pre><p>继续执行获取元素操作出队列（解锁）：</p><p><img src="/2024/01/26/Embedded-C-language/bda71bd117674644bbe8c8c44c782aa3.png" alt="img"></p><p>上图中60入列后满载，可以看到置空位再次出现，但30➡40➡50➡60➡置空位 形成了逻辑上的闭环</p><p>细节2<br>从闭环的角度理解，front永远不可能在循环中超过rear，最多只能和rear相遇。</p><p>因为置空位的出现，rear不可能拉front一圈，也就避免了rear在超过front的情况下主动与front相遇</p><p>下图中的maxSize-1对应的就是置空位，rear是无法越过置空位的。只有front主动顺时针追赶上rear，它俩才会相遇，而此时队列内就没有元素，为空</p><p><img src="/2024/01/26/Embedded-C-language/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2Mjk2NDE3,size_16,color_FFFFFF,t_70.png" alt="img"></p><p> 细节3<br>队列的最大长度queueMaxsize&#x3D;数组容量arrayMaxSize-1  （由于置空位要占一位）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RINGBUFF_LEN 256;</span></span><br><span class="line"><span class="comment">//定义一个缓冲区结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 Head;           </span><br><span class="line">    u16 Tail;</span><br><span class="line">    u8 Ring_Buff[RINGBUFF_LEN];</span><br><span class="line">&#125;RingBuff_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*若想更灵活，可以用动态内存分配方式（如使用指针）来实现可变长度的缓冲区</span></span><br><span class="line"><span class="comment">typedef struct</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">u16 Head;</span></span><br><span class="line"><span class="comment">u16 Tail;</span></span><br><span class="line"><span class="comment">u8* Ring_Buff;</span></span><br><span class="line"><span class="comment">&#125;RingBuff_t;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 初始化函数，传入所需长度</span></span><br><span class="line"><span class="comment">void RingBuff_Init(RingBuff_t rbuff, size_t len)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Head = 0;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Tail = 0;</span></span><br><span class="line"><span class="comment">    rbuff-&gt;Ring_Buff = (u8)malloc(len * sizeof(u8));</span></span><br><span class="line"><span class="comment">    if (!rbuff-&gt;Ring_Buff) &#123;</span></span><br><span class="line"><span class="comment">    // 处理内存分配失败的情况...</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">在C语言中，u8* Ring_Buff; 是一个指向无符号8位整型（通常代表字节）的指针。它本身并不是一个数组，但可以用来指向一块内存区域，这块内存可以被当作数组来处理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当你通过 malloc 函数为 Ring_Buff 分配了足够长度的内存后，你就可以像操作数组那样对这块内存进行读写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个ringBuff的缓冲区</span></span><br><span class="line">RingBuff_t ringBuff;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化环形缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RingBuff_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//初始化相关信息</span></span><br><span class="line">   ringBuff.Head = <span class="number">0</span>;</span><br><span class="line">   ringBuff.Tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">u8 <span class="title function_">Write_RingBuff</span><span class="params">(u8 data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ringBuff.Head=(ringBuff.Tail+<span class="number">1</span>)%maxSize) <span class="comment">//缓冲区满</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> FLASE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ringBuff.Ring_Buff[ringBuff.Tail]=data;<span class="comment">//在Tail对应索引位写入数据</span></span><br><span class="line">    ringBuff.Tail=(ringBuff.Tail+<span class="number">1</span>)%RINGBUFF_LEN; <span class="comment">//ringBuff.Tail++; 防止越界非法访问</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读数据</span></span><br><span class="line"><span class="number">10u</span>8 Read_RingBuff(u8 *rData)</span><br><span class="line"><span class="number">11</span>&#123;</span><br><span class="line"><span class="number">12</span>   <span class="keyword">if</span>(ringBuff.Head==ringBuff.Tail)<span class="comment">//判断非空</span></span><br><span class="line"><span class="number">13</span>    &#123;</span><br><span class="line"><span class="number">14</span>       <span class="keyword">return</span> FLASE;</span><br><span class="line"><span class="number">15</span>    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="number">16</span>   *rData = ringBuff.Ring_Buff[ringBuff.Head];<span class="comment">//先进先出FIFO，从缓冲区头出</span></span><br><span class="line"></span><br><span class="line"><span class="number">18</span>   ringBuff.Head = (ringBuff.Head+<span class="number">1</span>)%RINGBUFF_LEN;<span class="comment">// ringBuff.Head++;防止越界非法访问</span></span><br><span class="line">    </span><br><span class="line"><span class="number">20</span>   <span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="基于状态机"><a href="#基于状态机" class="headerlink" title="基于状态机"></a>基于状态机</h2><p>当“喂一口饭”、“回一个信息”都需要花很长的时间，无论使用前面的哪种设计模式，都会退化到轮询模式的缺点：函数相互之间有影响。可以使用状态机来解决这个缺点，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态机</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        喂一口饭();</span><br><span class="line">        回一个信息();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main函数里，还是使用轮询模式依次调用2个函数。</p><p>关键在于这2个函数的内部实现：<strong>使用状态机，每次只执行一个状态的代码，减少每次执行的时间</strong>，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 喂一口饭(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 舀饭 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 喂饭 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 舀菜 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 喂菜 */</span></span><br><span class="line">            <span class="comment">/* 恢复到初始状态 */</span></span><br><span class="line">            state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> 回一个信息(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 查看信息 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 打字 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 发送 */</span></span><br><span class="line">            <span class="comment">/* 恢复到初始状态 */</span></span><br><span class="line">            state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以“喂一口饭”为例，函数内部拆分为4个状态：舀饭、喂饭、舀菜、喂菜。每次执行“喂一口饭”函数时，都只会执行其中的某一状态对应的代码。以前执行一次“喂一口饭”函数可能需要4秒钟，现在可能只需要1秒钟，就<strong>降低了对后面“回一个信息”的影响。</strong></p><p>同样的，“回一个信息”函数内部也被拆分为3个状态：查看信息、打字、发送。每次执行这个函数时，都只是执行其中一小部分代码，降低了对“喂一口饭”的影响。</p><p><strong>使用状态机模式，可以解决裸机程序的难题：假设有A、B两个都很耗时的函数，怎样降低它们相互之间的影响。但是很多场景里，函数A、B并不容易拆分为多个状态，并且这些状态执行的时间并不好控制。所以这并不是最优的解决方法，需要使用多任务系统。</strong></p><h2 id="FSM状态机"><a href="#FSM状态机" class="headerlink" title="FSM状态机"></a>FSM状态机</h2><p>首先初始化FSM状态机，FSM_Init(PASSIVE);</p><p>在一个while(1)中运行FSM_Run();</p><p>在外部触发条件下使用FSM_SetState( )来设置想切换的模式;此过程中FSM模式变为CHANGE模式（FSM.mode &#x3D; CHANGE;）</p><p>FSM的下一个状态变为FSM.nextState &#x3D; state；  </p><p>这样在FSM_Run();中 首先运行FSM.exit();  即当前的状态的exit函数，然后使用FSM_ChangeState();函数将FSM的进入，运行，退出函数改成要切换的状态所对应的  （每一个状态写一个单独的.c.h文件，然后所有.h文件放到FSM.h中，FSM.c文件直接用FSM.h就行）</p><p>​    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FSM.enter = Passive_Enter;</span><br><span class="line"></span><br><span class="line">FSM.run = Passive_Run;</span><br><span class="line"></span><br><span class="line">FSM.<span class="built_in">exit</span> = Passive_Exit;</span><br></pre></td></tr></table></figure><p>然后就是该状态的进入函数，此时切换状态这一过程已经结束了，FSM模式变为NOMARL模式，然后运行该状态的运行函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*FSM.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FSM.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">FSM_t FSM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态切换 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_ChangeState</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 当前状态为下一个状态 */</span></span><br><span class="line">    FSM.currentState = FSM.nextState;</span><br><span class="line">    <span class="comment">/* 设置当前函数指针 */</span></span><br><span class="line">    <span class="keyword">switch</span> (FSM.nextState)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FIXEDSTAND:</span><br><span class="line">        FSM.enter = FixedStand_Enter;</span><br><span class="line">        FSM.run = FixedStand_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = FixedStand_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">case</span> TROTING:</span><br><span class="line">        FSM.enter = Troting_Enter;</span><br><span class="line">        FSM.run = Troting_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Troting_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WALKING:</span><br><span class="line">        FSM.enter = Walking_Enter;</span><br><span class="line">        FSM.run = Walking_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Walking_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> JUMP:</span><br><span class="line">        FSM.enter = Jump_Enter;</span><br><span class="line">        FSM.run = Jump_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Jump_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 有限状态机初始化 */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_Init</span><span class="params">(FSMState_e state)</span></span><br><span class="line">&#123;</span><br><span class="line">    FSM.currentState = state;</span><br><span class="line">    FSM.nextState = state;</span><br><span class="line">    FSM_ChangeState();</span><br><span class="line">    FSM.enter();</span><br><span class="line">    FSM.mode = NORMAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 有限状态机运行 */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_Run</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (FSM.mode == NORMAL)</span><br><span class="line">    &#123;</span><br><span class="line">        FSM.run(); <span class="comment">// In normal mode, run current state.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (FSM.mode == CHANGE)</span><br><span class="line">    &#123;</span><br><span class="line">        FSM.<span class="built_in">exit</span>(); <span class="comment">// In changing mode, run the exit function for previous state,</span></span><br><span class="line">        FSM_ChangeState();</span><br><span class="line">        </span><br><span class="line">        FSM.enter(); <span class="comment">// and run the enter function for next state.</span></span><br><span class="line">        FSM.mode = NORMAL;</span><br><span class="line">        FSM.run(); <span class="comment">// then run the run function for current state.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 有限状态机设置状态 */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_SetState</span><span class="params">(FSMState_e state)</span></span><br><span class="line">&#123;</span><br><span class="line">    FSM.mode = CHANGE;</span><br><span class="line">    FSM.nextState = state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*FSM.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FSM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_FixedStand.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Passive.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Troting.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Fall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Walking.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Jump.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Jump2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_JumpL.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_JumpL2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_JumpR.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_JumpR2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_catJump.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_catJump2.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NORMAL,</span><br><span class="line">    CHANGE,</span><br><span class="line">&#125; FSMMode_e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PASSIVE = <span class="number">1</span>,    <span class="comment">// 阻尼</span></span><br><span class="line">    FALL = <span class="number">2</span>,       <span class="comment">// 卧倒</span></span><br><span class="line">    FIXEDSTAND = <span class="number">3</span>, <span class="comment">// 固定站立</span></span><br><span class="line">    FREESTAND = <span class="number">4</span>,  <span class="comment">// 自由站立</span></span><br><span class="line">    TROTING = <span class="number">5</span>,    <span class="comment">// 对角步态</span></span><br><span class="line">    WALKING = <span class="number">6</span>,    <span class="comment">// 行走步态</span></span><br><span class="line">    JUMP = <span class="number">7</span>,       <span class="comment">// 跳跃</span></span><br><span class="line">    JUMP2 = <span class="number">8</span>,      <span class="comment">// 跳跃2</span></span><br><span class="line">    JUMPL = <span class="number">9</span>,</span><br><span class="line">    JUMPL2 = <span class="number">10</span>,</span><br><span class="line">    JUMPR = <span class="number">11</span>,</span><br><span class="line">    JUMPR2 = <span class="number">12</span>,</span><br><span class="line">    catJUMP = <span class="number">13</span>,</span><br><span class="line">    catJUMP2 = <span class="number">14</span>,</span><br><span class="line">&#125; FSMState_e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FSMMode_e mode;</span><br><span class="line">    FSMState_e currentState;</span><br><span class="line">    FSMState_e nextState;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*enter)(<span class="type">void</span>); <span class="comment">//函数指针，见前面章节</span></span><br><span class="line">    <span class="type">void</span> (*run)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">exit</span>)(<span class="type">void</span>);</span><br><span class="line">&#125; FSM_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> FSM_t FSM;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FSM_Init</span><span class="params">(FSMState_e state)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FSM_Run</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FSM_SetState</span><span class="params">(FSMState_e state)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><img src="/2024/01/26/Embedded-C-language/image-20240116005300807.png" alt="image-20240116005300807"></p><h2 id="PID算法"><a href="#PID算法" class="headerlink" title="PID算法"></a>PID算法</h2><p><img src="/2024/01/26/Embedded-C-language/40125cfdc638a3fc5bf11b45a1e121ed.gif" alt="40125cfdc638a3fc5bf11b45a1e121ed"></p><p><a href="https://blog.csdn.net/skythinker616/article/details/123019829?fromshare=blogdetail&sharetype=blogdetail&sharerId=123019829&sharerefer=PC&sharesource=qq_52769953&sharefrom=from_link">https://blog.csdn.net/skythinker616/article/details/123019829?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=123019829&amp;sharerefer=PC&amp;sharesource=qq_52769953&amp;sharefrom=from_link</a></p><p><a href="https://blog.csdn.net/he__yuan/article/details/80739800?ops_request_misc=%257B%2522request%255Fid%2522%253A%25229a63092720f9f3c2fedf0fddb59c2d96%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=9a63092720f9f3c2fedf0fddb59c2d96&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-80739800-null-null.142%5Ev102%5Epc_search_result_base7&utm_term=pid%E5%8F%82%E6%95%B0&spm=1018.2226.3001.4187">https://blog.csdn.net/he__yuan/article/details/80739800?ops_request_misc=%257B%2522request%255Fid%2522%253A%25229a63092720f9f3c2fedf0fddb59c2d96%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=9a63092720f9f3c2fedf0fddb59c2d96&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-80739800-null-null.142^v102^pc_search_result_base7&amp;utm_term=pid%E5%8F%82%E6%95%B0&amp;spm=1018.2226.3001.4187</a></p><p><em><strong>概念</strong></em></p><p>PID，就是“比例（proportional）、积分（integral）、微分（derivative）</p><p>它可以将需要控制的物理量带到目标附近</p><p>它可以“预见”这个量的变化趋势</p><p>它也可以消除因为散热、阻力等因素造成的静态误差</p><p><strong>kP</strong></p><p>实际写程序时，<strong>就让偏差（目标减去当前）与调节装置的“调节力度”，建立一个一次函数的关系</strong>，就可以实现最基本的“比例”控制了~<br><strong>kP越大，调节作用越激进，kP调小会让调节作用更保守。</strong></p><p>刚才我们有了P的作用。你不难发现，只有P好像不能让平衡车站起来，水温也控制得晃晃悠悠，好像整个系统不是特别稳定，总是在“抖动”。</p><p><strong>kD</strong> </p><p><em><strong>阻尼</strong></em>， kD参数越大，向速度相反方向刹车的力道就越强。</p><p><strong>KI</strong> </p><p>设置一个积分量。只要偏差存在，就不断地对偏差进行积分（累加），并反应在调节力度上。</p><p>I的作用就是，减小静态情况下的误差（消除稳态误差），让受控物理量尽可能接近目标值。</p><p>在使用时还有个问题：需要设定积分限制。防止在刚开始加热时，就把积分量积得太大，难以控制。</p><p><em><strong>使用</strong></em></p><p><em><strong>需要及时更新数据，一般是写个while循环使用pid_calc，延时几毫秒更新1次</strong></em></p><p>1.DJ</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PID.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PID初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PID_Init</span><span class="params">(PID_t *pid, <span class="type">float</span> kp, <span class="type">float</span> ki, <span class="type">float</span> kd, <span class="type">float</span> max_out, <span class="type">float</span> max_iout)</span></span><br><span class="line">&#123;</span><br><span class="line">    pid-&gt;Kp = kp;</span><br><span class="line">    pid-&gt;Ki = ki;</span><br><span class="line">    pid-&gt;Kd = kd;</span><br><span class="line">    pid-&gt;max_out = max_out;</span><br><span class="line">    pid-&gt;max_iout = max_iout;</span><br><span class="line">    pid-&gt;err[<span class="number">0</span>] = pid-&gt;err[<span class="number">1</span>] = <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PID计算, 输入反馈值和预期值</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">PID_Calc</span><span class="params">(PID_t *pid, <span class="type">float</span> fdb, <span class="type">float</span> <span class="built_in">set</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pid-&gt;<span class="built_in">set</span> = <span class="built_in">set</span>;</span><br><span class="line">    pid-&gt;fdb = fdb;</span><br><span class="line">    pid-&gt;err[<span class="number">1</span>] = pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">    pid-&gt;err[<span class="number">0</span>] = pid-&gt;<span class="built_in">set</span> - pid-&gt;fdb;</span><br><span class="line"></span><br><span class="line">    pid-&gt;Pout = pid-&gt;Kp * pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">    pid-&gt;Iout += pid-&gt;Ki * pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">    pid-&gt;Dout = pid-&gt;Kd * pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid-&gt;Iout &gt; pid-&gt;max_iout)</span><br><span class="line">    &#123;</span><br><span class="line">        pid-&gt;Iout = pid-&gt;max_iout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid-&gt;Iout &lt; -pid-&gt;max_iout)</span><br><span class="line">    &#123;</span><br><span class="line">        pid-&gt;Iout = -pid-&gt;max_iout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid-&gt;out = pid-&gt;Pout + pid-&gt;Iout + pid-&gt;Dout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid-&gt;out &gt; pid-&gt;max_out)</span><br><span class="line">    &#123;</span><br><span class="line">        pid-&gt;out = pid-&gt;max_out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid-&gt;out &lt; -pid-&gt;max_out)</span><br><span class="line">    &#123;</span><br><span class="line">        pid-&gt;out = -pid-&gt;max_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pid-&gt;out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PID_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PID_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">float</span> Kp;</span><br><span class="line">    <span class="type">float</span> Ki;</span><br><span class="line">    <span class="type">float</span> Kd;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> max_out;  <span class="comment">// 最大输出</span></span><br><span class="line">    <span class="type">float</span> max_iout; <span class="comment">// 最大积分输出</span></span><br><span class="line">    <span class="type">float</span> err[<span class="number">2</span>];   <span class="comment">// 误差及上一次误差</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="type">float</span> fdb;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> out;</span><br><span class="line">    <span class="type">float</span> Pout;</span><br><span class="line">    <span class="type">float</span> Iout;</span><br><span class="line">    <span class="type">float</span> Dout;</span><br><span class="line">&#125; PID_t;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PID_Init</span><span class="params">(PID_t *pid, <span class="type">float</span> kp, <span class="type">float</span> ki, <span class="type">float</span> kd, <span class="type">float</span> max_out, <span class="type">float</span> max_iout)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">PID_Calc</span><span class="params">(PID_t *pid, <span class="type">float</span> fdb, <span class="type">float</span> <span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.电机位置环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*pid.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_pid.h&quot;</span></span></span><br><span class="line"><span class="comment">//1 0.10 0.1</span></span><br><span class="line"><span class="type">float</span> Position_KP=<span class="number">0.5</span>,Position_KI=<span class="number">0.00</span>,Position_KD=<span class="number">0.09</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Position_PID</span><span class="params">(<span class="type">int</span> reality,<span class="type">int</span> target)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> Bias,Pwm,Last_Bias,Integral_bias;</span><br><span class="line">     </span><br><span class="line">    Bias=target-reality;                            <span class="comment">/* 计算偏差 */</span></span><br><span class="line">    Integral_bias+=Bias;                        <span class="comment">/* 偏差累积 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Integral_bias&gt; <span class="number">3000</span>) Integral_bias = <span class="number">3000</span>;   <span class="comment">/* 积分限幅 */</span></span><br><span class="line">    <span class="keyword">if</span>(Integral_bias&lt;<span class="number">-3000</span>) Integral_bias =<span class="number">-3000</span>;</span><br><span class="line">    </span><br><span class="line">    Pwm = (Position_KP*Bias)                        <span class="comment">/* 比例环节 */</span></span><br><span class="line">         +(Position_KI*Integral_bias)               <span class="comment">/* 积分环节 */</span></span><br><span class="line">         +Position_KD*(Bias-Last_Bias);             <span class="comment">/* 微分环节 */</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(Pwm&gt;<span class="number">4000</span>) Pwm=<span class="number">4000</span>;</span><br><span class="line"><span class="keyword">if</span>(Pwm&lt;<span class="number">-4000</span>) Pwm=<span class="number">-4000</span>;</span><br><span class="line"><span class="comment">/*if(Pwm&gt;0&amp;&amp;Pwm&lt;1000)</span></span><br><span class="line"><span class="comment">Pwm=1000;</span></span><br><span class="line"><span class="comment">if(Pwm&lt;0&amp;&amp;Pwm&gt;-1000)</span></span><br><span class="line"><span class="comment">Pwm=-1000;*/</span></span><br><span class="line"></span><br><span class="line">    Last_Bias=Bias;                                 <span class="comment">/* 保存上次偏差 */</span></span><br><span class="line">    <span class="keyword">return</span> Pwm;                                     <span class="comment">/* 输出结果 */</span>              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>应用案例</strong></em></p><p><strong>循迹</strong>（写的不太好，看看就行）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_linewalking2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">bsp_GetLineWalking1(&amp;SADC1);</span><br><span class="line"><span class="keyword">if</span>(SADC1)</span><br><span class="line">&#123;</span><br><span class="line">Systick_Delay_ms(<span class="number">5</span>);</span><br><span class="line">bsp_GetLineWalking1(&amp;SADC1);</span><br><span class="line"><span class="keyword">if</span>(SADC1)</span><br><span class="line">&#123;</span><br><span class="line">car_STOP();</span><br><span class="line">Systick_Delay_ms(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Car_Run(<span class="number">10</span>,<span class="number">0.5</span>,<span class="number">3000</span>,<span class="number">3000</span>,<span class="number">3000</span>,<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Car_Run</span><span class="params">(<span class="type">float</span> kp,<span class="type">float</span> kd, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">MOTOR1_state(GO);       </span><br><span class="line">MOTOR2_state(GO);</span><br><span class="line">MOTOR4_state(GO);</span><br><span class="line">MOTOR3_state(GO);       </span><br><span class="line"></span><br><span class="line">Speed_1(PWMA(kp,kd,a));Speed_2(PWMB(kp,kd,b));Speed_3(PWMC(kp,kd,c));Speed_4(PWMD(kp,kd,d));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">PWMA</span> <span class="params">(u16 kp,u16 kd, u16 basic)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> error;</span><br><span class="line"><span class="type">double</span> mistake;</span><br><span class="line"><span class="type">double</span> fix1speed;</span><br><span class="line">u16 fix2speed;</span><br><span class="line">u16 olderror;</span><br><span class="line">u16 der;</span><br><span class="line"><span class="type">int</span> PWM;</span><br><span class="line"><span class="type">int</span> P;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  mistake= Get_Adc(ADC_CHANNE_ML) - Get_Adc(ADC_CHANNE_MR);<span class="comment">//左-右 F7-F9</span></span><br><span class="line">mistake=mistake/<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (mistake&gt;<span class="number">200</span>) error=<span class="number">200</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mistake==<span class="number">200</span>) error=<span class="number">200</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mistake&gt;<span class="number">0</span>&amp;&amp;mistake&lt;<span class="number">200</span>)error = mistake;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mistake&lt;<span class="number">0</span>&amp;&amp;mistake&gt;<span class="number">-200</span>) error=-mistake;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mistake==<span class="number">-200</span>) error=<span class="number">200</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mistake&lt;<span class="number">-200</span>) error=<span class="number">200</span>;</span><br><span class="line">  fix1speed = kp*error;</span><br><span class="line">olderror=error;</span><br><span class="line">der=error-olderror;</span><br><span class="line">fix2speed= kd*der;</span><br><span class="line"><span class="keyword">if</span> (Get_Adc(ADC_CHANNE_ML)&gt;Get_Adc(ADC_CHANNE_MR)) PWM = basic + fix1speed+fix2speed;  <span class="comment">//左边大于右边 说明黑线靠右  左轮应加速</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Get_Adc(ADC_CHANNE_ML)&lt;Get_Adc(ADC_CHANNE_MR)) PWM = basic - <span class="number">1</span>* (fix1speed+fix2speed);<span class="comment">//   黑线偏左   左轮应减速    3是电机正转和反转在相同pwm下速度不同</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Get_Adc(ADC_CHANNE_ML)== Get_Adc(ADC_CHANNE_MR)) PWM =basic;</span><br><span class="line"><span class="keyword">if</span> (PWM&lt;<span class="number">0</span>) PWM=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> PWM=PWM;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> PWM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>电机位置环</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Pos_ctrl_ML</span><span class="params">(<span class="type">float</span> rotationNum)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Moto = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Target_Position=Num_Encoder_Cnt(rotationNum,ENCODER_RESOLUTION,MOTOR_REDUCTION_RATIO);</span><br><span class="line">Read_Encoder(<span class="number">5</span>);</span><br><span class="line">Encoder_Cnt+=Encoder_cnt;<span class="comment">//每次读完清空是为了累加从每次起始点开始的脉冲数</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(Encoder_Cnt==Target_Position)</span><br><span class="line">        &#123;</span><br><span class="line">          Set_PWM_ML(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          Moto = Position_PID(Encoder_Cnt,Target_Position); </span><br><span class="line">          Set_PWM_ML(Moto);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf(&quot;Encoder_Cnt=%d\tTarget_Position=%d\tccr=%d\t\r\n&quot;,Encoder_Cnt,Target_Position,Moto);</span></span><br><span class="line">          HAL_Delay(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*pid.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_pid.h&quot;</span></span></span><br><span class="line"><span class="comment">//1 0.10 0.1</span></span><br><span class="line"><span class="type">float</span> Position_KP=<span class="number">0.5</span>,Position_KI=<span class="number">0.00</span>,Position_KD=<span class="number">0.09</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Position_PID</span><span class="params">(<span class="type">int</span> reality,<span class="type">int</span> target)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> Bias,Pwm,Last_Bias,Integral_bias;</span><br><span class="line">     </span><br><span class="line">    Bias=target-reality;                            <span class="comment">/* 计算偏差 */</span></span><br><span class="line">    Integral_bias+=Bias;                        <span class="comment">/* 偏差累积 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Integral_bias&gt; <span class="number">3000</span>) Integral_bias = <span class="number">3000</span>;   <span class="comment">/* 积分限幅 */</span></span><br><span class="line">    <span class="keyword">if</span>(Integral_bias&lt;<span class="number">-3000</span>) Integral_bias =<span class="number">-3000</span>;</span><br><span class="line">    </span><br><span class="line">    Pwm = (Position_KP*Bias)                        <span class="comment">/* 比例环节 */</span></span><br><span class="line">         +(Position_KI*Integral_bias)               <span class="comment">/* 积分环节 */</span></span><br><span class="line">         +Position_KD*(Bias-Last_Bias);             <span class="comment">/* 微分环节 */</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(Pwm&gt;<span class="number">4000</span>) Pwm=<span class="number">4000</span>;</span><br><span class="line"><span class="keyword">if</span>(Pwm&lt;<span class="number">-4000</span>) Pwm=<span class="number">-4000</span>;</span><br><span class="line"><span class="comment">/*if(Pwm&gt;0&amp;&amp;Pwm&lt;1000)</span></span><br><span class="line"><span class="comment">Pwm=1000;</span></span><br><span class="line"><span class="comment">if(Pwm&lt;0&amp;&amp;Pwm&gt;-1000)</span></span><br><span class="line"><span class="comment">Pwm=-1000;*/</span></span><br><span class="line"></span><br><span class="line">    Last_Bias=Bias;                                 <span class="comment">/* 保存上次偏差 */</span></span><br><span class="line">    <span class="keyword">return</span> Pwm;                                     <span class="comment">/* 输出结果 */</span>              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h1><h2 id="USART"><a href="#USART" class="headerlink" title="USART"></a>USART</h2><h2 id="CAN"><a href="#CAN" class="headerlink" title="CAN"></a>CAN</h2><h1 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h1><h2 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h2><p>根据编码类型分为增量式，绝对式和混合式。</p><img src="/2024/01/26/Embedded-C-language/image-20250314003658895.png" alt="image-20250314003658895" style="zoom:70%;"><img src="/2024/01/26/Embedded-C-language/image-20250314003828774.png" alt="image-20250314003828774" style="zoom:67%;"><img src="/2024/01/26/Embedded-C-language/image-20250314004220620.png" alt="image-20250314004220620" style="zoom:67%;"><p><img src="/2024/01/26/Embedded-C-language/image-20250314081614376.png" alt="image-20250314081614376"></p><p>分辨率即线数，即每转一圈输出的脉冲数。</p><p><img src="/2024/01/26/Embedded-C-language/image-20250314080533395.png" alt="image-20250314080533395"></p><p><img src="/2024/01/26/Embedded-C-language/image-20250314080629558.png" alt="image-20250314080629558"></p><p>码盘透过光线时，通道A输出1（高电平），通过检测高电平的数量来判断转过的位置，通过检测A和B谁先到高电平来判断运动的方向。若将计数策略从记录高电平转换为记录A上升沿和下降沿，则二倍频。A,B通道相差四分之一周期，若记数A，B的上升沿和下降沿，则在一个周期内可记录四次，即4倍频，将编码器分辨率提高4倍。比如这个编码器的分辨率为1000，最小分辨角度为3.6°，通过四倍频，其分辨率变为4000，最小分辨角度变为0.9°</p><p>M法适合高速。</p><img src="/2024/01/26/Embedded-C-language/image-20250314082104711.png" alt="image-20250314082104711" style="zoom:67%;"><p>eg: n&#x3D;8000&#x2F;(4000*2)&#x3D;1r&#x2F;s. </p><p>理想状态下测量的脉冲数是整数个，但由于开始测量时有可能处于一个脉冲的任意位置，对于速度很低的情况下，误差比较大，通过4倍频也可以起到减小误差的作用。</p><p>T法适合低速。</p><img src="/2024/01/26/Embedded-C-language/image-20250314082813041.png" alt="image-20250314082813041" style="zoom:67%;"><img src="/2024/01/26/Embedded-C-language/image-20250314084729775.png" alt="image-20250314084729775" style="zoom:67%;"><img src="/2024/01/26/Embedded-C-language/image-20250314084958407.png" alt="image-20250314084958407" style="zoom:67%;"><p>向上计数和向下计数即编码器旋转的方向。</p><img src="/2024/01/26/Embedded-C-language/image-20250314085151578.png" alt="image-20250314085151578" style="zoom:67%;"><h2 id="光电"><a href="#光电" class="headerlink" title="光电"></a>光电</h2><h2 id="超声波"><a href="#超声波" class="headerlink" title="超声波"></a>超声波</h2><h2 id="激光测距"><a href="#激光测距" class="headerlink" title="激光测距"></a>激光测距</h2><h2 id="陀螺仪"><a href="#陀螺仪" class="headerlink" title="陀螺仪"></a>陀螺仪</h2><h1 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h1><h2 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h2><p>​PWM 信号其实就是一高一低的一系列电平组合在一起，若I&#x2F;O口有集成模块（如STM32），可以直接通过芯片内部模块输出PWM信号，直接配置一些值即可；若没有（如51）则可给I&#x2F;O加一个定时器，对于你要求输出的PWM信号频率与你的定时器一致，用定时器中断来计数，但是这种方法一般不采用，除非对于精度、频率等要求不是很高可以这样实现。</p><img src="/2024/01/26/Embedded-C-language/image-20250223225504307.png" alt="image-20250223225504307" style="zoom:67%;"><p><strong>STM32输出PWM：</strong></p><p>让计数器从0数到自动重装载值arr，arr其实就是定时器的一个周期。当计数值小于输出比较寄存器(ccr)时输出高电平，大于比较寄存器(ccr)时输出低电平。</p><p>单片机内部时钟经过分频(psc)后得到定时器时钟，修改psc即可修改计数器记数的速度，通过修改自动重装载值可以调节PWM的周期频率，修改比较寄存器的大小(ccr)可改变占空比。</p><p><strong>PWM的频率</strong> &#x3D; 时钟频率 &#x2F; （自动重装值arr + 1）*（预分频值psc + 1），STM32的最时钟频率为72MHz &#x3D; 72 000 000 Hz</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TIM2时基单元配置</span></span><br><span class="line"><span class="comment">重要配置：TIM_Prescaler（预分频值）TIM_Period（定时周期）</span></span><br><span class="line"><span class="comment">将TIM_Period设置成999，则计数器会数1000个（TIM_Period+1）节拍为一个定时器的周期。这个和后面需要配置的TIM_Pulse共同控制着定时器输出波形的占空比。</span></span><br><span class="line"><span class="comment">TIM_Prescaler用来指定TIM时钟的分频值。也就是说它是进一步来分频TIM clock的。简单来说也就是定时器每一次数数的时间间隔是多少。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在标准库里如下设置可配置arr和psc：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInitStructure.TIM_Period=<span class="number">100</span> - <span class="number">1</span>;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="number">720</span> - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>占空比</strong> &#x3D; CCR &#x2F; (ARR + 1)，当Compare &#x3D; 50时，改PWM的占空比为50 &#x2F; （100 - 1 + 1）&#x3D;50%。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_SetCompare1(TIM2,Compare);<span class="comment">//将Compare的值写入指定定时器的捕获/比较寄存器1（CCR1），用于设置PWM的比较值进而改变占空比</span></span><br></pre></td></tr></table></figure><p>​             </p><p><strong>51单片机输出PWM：</strong></p><p><img src="/2024/01/26/Embedded-C-language/image-20250223225538270.png" alt="image-20250223225538270"></p><p>该结构与最新单片机TIM定时器PWM硬件结构相似，在这里我们用软件来模拟这一结构：</p><p>​首先配置定时器，每100us进一次定时器中断，每次进入中断后计数器（Counter）+1，同时与比较值(Compare)比较，若Counter&lt;Compare,置高电平，反之置低电平，在这里设置计数器最大到100后清0，pwm周期：100us*100&#x3D;10ms ，若pwm频率过小则电机会出现抖动（频繁启动停止），故我们要让pwm频率取到一个相对大的值，这时就可等效的获得所需要的模拟参量</p><p>定时器的作用就在于生成周期为T，每个周期内高电平持续时间为Compare的波形.。</p><p>以下为51单片机驱动有刷直流电机的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tim.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;INTRINS.H&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1 P2_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2 P2_1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOTOR P1_0</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LedMode=<span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Counter,Compare=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  TIM0初始化 100us@12.000HZ</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">TMOD&amp;=<span class="number">0xF0</span>;<span class="comment">//1111 0000 高4位为T1，保持不变，低4位为T0，清0</span></span><br><span class="line">    TMOD|=<span class="number">0x01</span>;<span class="comment">//0000 0001 选择为定时器0模式，工作方式1，使用或运算可以不干扰高四位</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//给定时器赋初值，定时100us</span></span><br><span class="line">    TH0=<span class="number">0xFF</span>;</span><br><span class="line">    TL0=<span class="number">0x9C</span>;</span><br><span class="line">    </span><br><span class="line">    ET0=<span class="number">1</span>;<span class="comment">//打开定时器0中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">    </span><br><span class="line">    TR0=<span class="number">1</span>;<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  TIM0中断服务函数</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//用户代码</span></span><br><span class="line"><span class="comment">//若为工作方式1 每次进入中断需要重装载初值</span></span><br><span class="line">    TH0=<span class="number">0xFF</span>;</span><br><span class="line">    TL0=<span class="number">0x9C</span>;</span><br><span class="line"><span class="comment">//Compare=50;</span></span><br><span class="line"></span><br><span class="line">Counter++;<span class="comment">//计数器</span></span><br><span class="line"><span class="keyword">if</span>(Counter&gt;=<span class="number">100</span>)Counter=<span class="number">0</span>;<span class="comment">//pwm周期：100us*100=10ms</span></span><br><span class="line"><span class="keyword">if</span>(Counter&lt;Compare)</span><br><span class="line">&#123;</span><br><span class="line">LED1=<span class="number">0</span>;</span><br><span class="line">MOTOR=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LED1=<span class="number">1</span>;</span><br><span class="line">MOTOR=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nixietube.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeyNum=<span class="number">0</span>,Speed=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> Compare;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">P2=<span class="number">0xfe</span>;</span><br><span class="line">    TIM0_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">KeyNum=Key();</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Speed++;</span><br><span class="line"><span class="keyword">if</span>(Speed&gt;=<span class="number">4</span>)Speed=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (Speed)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">Compare=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">Compare=<span class="number">60</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">Compare=<span class="number">80</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">Compare=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">NixieTube(<span class="number">1</span>,Speed);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/01/26/Embedded-C-language/image-20250314082719000.png" alt="image-20250314082719000"></p><h2 id="舵机"><a href="#舵机" class="headerlink" title="舵机"></a>舵机</h2><p>​舵机也叫也叫 RC 伺服器，通常用于机器人项目，也可以在遥控汽车，飞机等航模中找到它们。类似舵机这样的伺服系统通常由小型电动机，电位计，嵌入式控制系统和变速箱组成。电机输出轴的位置由内部电位计不断采样测量，并与微控制器（例如STM32,Arduino）设置的目标位置进行比较；根据相应的偏差，控制设备会调整电机输出轴的实际位置，使其与目标位置匹配，通过PWM向伺服器发送一个控制信号时，输出轴就可以转到特定的位置。只要控制信号持续不变，伺服机构就会保持相对的角度位置不变。如果控制信号发生变化，输出轴的位置也会相应发生变化。。这样就形成了闭环控制系统。</p><p>​                 <img src="/2024/01/26/Embedded-C-language/393007569bca865d959a9dc19ccf9687.png" alt="393007569bca865d959a9dc19ccf9687" style="zoom:60%;"><img src="/2024/01/26/Embedded-C-language/image-20250223214538198.png" alt="image-20250223214538198" style="zoom:67%;"></p><p>舵机上有三根线，分别是GND、VCC和PWM，也就是地线、电源线和信号线，其中的PWM波就是从信号线输入给舵机的。</p><p><strong>驱动方法</strong>：一般来说，舵机接收的<strong>PWM</strong>信号频率为50HZ，即<strong>周期为20ms</strong>。当<strong>高电平</strong>的脉宽在<strong>0.5ms-2.5ms</strong>之间时舵机就可以对应旋转到不同的角度。</p><p> 注意：不同类型和品牌的伺服电机之间最大位置和最小位置的角度可能会不同。许多伺服器仅旋转约170度（或者只有90度），但宽度为<strong>1.5 ms</strong>的伺服脉冲通常会将伺服设置为<strong>中间位置</strong>（通常是指定全范围的一半）</p><p><img src="/2024/01/26/Embedded-C-language/f10352defb8e6e710836d41b4aadb777.gif" alt="f10352defb8e6e710836d41b4aadb777"></p><p>对于常见的SG90舵机，0-180°分别对应着500-2500us的高电平时长</p><img src="/2024/01/26/Embedded-C-language/image-20250223220208996.png" alt="image-20250223220208996" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">占空比 = t / T 相关参数如下：</span><br><span class="line"></span><br><span class="line">t = 0.5ms——————-舵机会转到 0°</span><br><span class="line">t = 1.0ms——————-舵机会转到 45°</span><br><span class="line">t = 1.5ms——————-舵机会转到 90°</span><br><span class="line">t = 2.0ms——————-舵机会转到 135°</span><br><span class="line">t = 2.5ms——————-舵机会转到 180°</span><br></pre></td></tr></table></figure><p><strong>STM32实现：</strong></p><p>1.配置TIM定时器的周期为20ms（频率为50）：</p><p>PWM的频率 &#x3D; 时钟频率 &#x2F; （自动重装值arr + 1）*（预分频值psc + 1），STM32的最时钟频率为72MHz &#x3D; 72 000 000 Hz</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TIM2时基单元配置</span></span><br><span class="line"><span class="comment">重要配置：TIM_Prescaler（预分频值）TIM_Period（定时周期）</span></span><br><span class="line"><span class="comment">将TIM_Period设置成999，则计数器会数1000个（TIM_Period+1）节拍为一个定时器的周期。这个和后面需要配置的TIM_Pulse共同控制着定时器输出波形的占空比。</span></span><br><span class="line"><span class="comment">TIM_Prescaler用来指定TIM时钟的分频值。也就是说它是进一步来分频TIM clock的。简单来说也就是定时器每一次数数的时间间隔是多少。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在标准库里如下设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInitStructure.TIM_Period=<span class="number">100</span> - <span class="number">1</span>;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="number">720</span> - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>2.<strong>占空比</strong> &#x3D; CCR &#x2F; (ARR + 1)，当Compare &#x3D; 50时，改PWM的占空比为50 &#x2F; （100 - 1 + 1）&#x3D;50%。<strong>通过改变占空比即可改变舵机旋转的角度</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_SetCompare1(TIM2,Compare);<span class="comment">//将Compare的值写入指定定时器的捕获/比较寄存器1（CCR1），用于设置PWM的比较值进而改变占空比</span></span><br></pre></td></tr></table></figure><p>​                                                                                                                                                                                                                         </p><h2 id="步进电机"><a href="#步进电机" class="headerlink" title="步进电机"></a>步进电机</h2><p>​步进电机， 故名思意，按步前进的电机，一般通过驱动器控制，因为配合驱动器可细分步长和调节电流，改变电机的输出功率，提高控制精度。其控制策略为，给予电机一个pwm脉冲，则旋转一步，我们选择的是42步电机，即旋转42步，电机转一圈。因此，给的pwm脉冲越多，电机可以转越多的步，可以转越大的角度，即pwm脉冲数可以控制电机旋转的角度；而pwm波的频率，即一个完整pwm脉冲所用的时间，对应转速，频率越快，一个完整pwm脉冲所用的时间越短，电机转速越快。</p><ul><li>控制原理<br>通过 脉冲信号 控制步进角和转速，每个脉冲对应电机转动一个步距角（如<strong>1.8°&#x2F;步</strong>）。<ul><li>需配合 相位顺序（如全步、半步、微步）驱动线圈。</li></ul></li><li>驱动方式<ul><li>必须外接 步进驱动器（如A4988、TMC2209）处理<strong>电流分配和细分控制</strong>。</li><li>控制信号包括<strong>脉冲（PUL）、方向（DIR）和使能（EN）</strong>。</li></ul></li><li>特点<ul><li>开环控制，依赖脉冲计数定位，无累积误差。</li><li><strong>细分驱动可提高精度</strong>（如16细分下1.8°步距角变为0.1125°）。</li><li>低速扭矩大，但高速易失步，需合理选择驱动电流。</li></ul></li><li>典型应用<br>3D打印机、CNC机床、精密仪器等需要高精度定位的场景。</li></ul><h2 id="直流有刷电机"><a href="#直流有刷电机" class="headerlink" title="直流有刷电机"></a>直流有刷电机</h2><ul><li>控制原理<br>通过 <strong>电压极性 控制转向</strong>，电压幅值或<strong>PWM占空比 调节转速</strong>。</li><li>驱动方式<ul><li>需使用 H桥电路（如L298N、TB6612）实现正反转和调速。</li><li>PWM频率需匹配电机特性（通常<strong>1kHz~20kHz</strong>）。</li></ul></li><li>特点<ul><li>开环控制，无内置反馈，需外接编码器实现闭环。</li><li>结构简单、成本低，但电刷易磨损。</li><li>高速性能好，但低速扭矩较小。</li></ul></li><li>典型应用<br>玩具车、风扇、无人机螺旋桨等需要连续旋转和调速的场景。</li></ul><h1 id="3D打印"><a href="#3D打印" class="headerlink" title="3D打印"></a>3D打印</h1><p><img src="/2024/01/26/Embedded-C-language/image-20250325222427770.png" alt="image-20250325222427770"></p><p><img src="/2024/01/26/Embedded-C-language/image-20250325222930531.png" alt="image-20250325222930531"></p><p>FDM(熔融沉积成型技术)&amp;SLA（光固化成型技术）&amp;SLM（激光烧结技术）</p><p>FDM（最广泛）:</p><p>常见材料：</p><p>PLA，生物降解材料，环保无毒</p><p>ABS, 力学性能相对更好，抗冲击强度更高</p><p>FDM打印机操作简单，维护成本低</p><p>SLA</p><p>材料为光敏树脂</p><p><strong>1. FDM（熔融沉积成型，Fused Deposition Modeling）</strong></p><ul><li><strong>原理</strong>：通过加热喷嘴将热塑性材料（如PLA、ABS）熔融，逐层挤出堆积成型。</li><li><strong>特点</strong>：<ul><li><strong>材料</strong>：低成本塑料线材，可选颜色丰富。</li><li><strong>精度</strong>：较低（约±0.1-0.3mm），可见层纹。</li><li><strong>速度</strong>：较慢，依赖模型大小和层高。</li><li><strong>后处理</strong>：需去除支撑结构，表面需打磨。</li></ul></li><li><strong>优势</strong>：设备便宜（桌面级千元起）、操作简单、材料易获取。</li><li><strong>局限</strong>：强度各向异性，细节表现差。</li><li><strong>应用</strong>：原型验证、教育用途、简单功能件。</li></ul><hr><p><strong>2. SLA（光固化成型，Stereolithography）</strong></p><ul><li><strong>原理</strong>：紫外激光照射液态光敏树脂，逐层固化成型。</li><li><strong>特点</strong>：<ul><li><strong>材料</strong>：光敏树脂（刚性、柔性、耐高温等种类）。</li><li><strong>精度</strong>：极高（±0.05-0.1mm），表面光滑。</li><li><strong>速度</strong>：较快，但后期需二次固化。</li><li><strong>后处理</strong>：需酒精清洗、去除支撑，可能需UV固化。</li></ul></li><li><strong>优势</strong>：细节精细，适合复杂结构。</li><li><strong>局限</strong>：树脂脆性大，长期可能发黄，设备较贵（工业级数万元起）。</li><li><strong>应用</strong>：珠宝模具、牙科模型、高精度展示件。</li></ul><hr><p><strong>3. SLM（选择性激光熔化，Selective Laser Melting）</strong></p><ul><li><strong>原理</strong>：高能激光完全熔化金属粉末（如钛合金、不锈钢），逐层熔覆成型。</li><li><strong>特点</strong>：<ul><li><strong>材料</strong>：金属粉末（钛、铝、钢等），需惰性气体保护。</li><li><strong>精度</strong>：高（±0.05-0.1mm），接近锻造件强度。</li><li><strong>速度</strong>：慢，需支撑结构防止变形。</li><li><strong>后处理</strong>：去除支撑、热处理、机加工。</li></ul></li><li><strong>优势</strong>：直接制造致密金属件，力学性能优异。</li><li><strong>局限</strong>：设备昂贵（百万级）、技术门槛高。</li><li><strong>应用</strong>：航空航天零件、医疗植入物、汽车高性能部件。</li></ul><hr><p><strong>对比总结</strong></p><table><thead><tr><th><strong>技术</strong></th><th><strong>材料类型</strong></th><th><strong>精度</strong></th><th><strong>强度</strong></th><th><strong>成本</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td>FDM</td><td>热塑性塑料</td><td>低</td><td>中等（各向异性）</td><td>低</td><td>原型、教育模型</td></tr><tr><td>SLA</td><td>光敏树脂</td><td>极高</td><td>脆性</td><td>中高</td><td>精密零件、艺术品</td></tr><tr><td>SLM</td><td>金属粉末</td><td>高</td><td>极高（各向同性）</td><td>极高</td><td>工业级功能金属件</td></tr></tbody></table><hr><p><strong>选择建议</strong>：</p><ul><li><p><strong>快速验证&#x2F;教育</strong>：选FDM。</p></li><li><p><strong>高精度&#x2F;美观需求</strong>：选SLA。</p></li><li><p><strong>金属功能件</strong>：选SLM或类似金属打印技术（如DLMS）。</p></li></ul><p><img src="/2024/01/26/Embedded-C-language/image-20250327142803978.png" alt="image-20250327142803978"></p><p>CAD关注的是几何上的建模方式，后者关注的是加工的工艺参数，机床几何和动力学</p><p><img src="/2024/01/26/Embedded-C-language/image-20250327153135109.png" alt="image-20250327153135109"></p><p><img src="/2024/01/26/Embedded-C-language/image-20250327153210209.png" alt="image-20250327153210209"></p><h1 id="复试问题"><a href="#复试问题" class="headerlink" title="复试问题"></a>复试问题</h1><p>起重机大赛经验贴：<a href="https://zhuanlan.zhihu.com/p/460393760">https://zhuanlan.zhihu.com/p/460393760</a></p><p><strong>1.讲一下USART你是具体怎么用的</strong></p><p><strong>2.讲一下PID控制算法，你是怎么调试和优化PID参数的，遇到振荡、超调时你是怎么解决的</strong></p><p><strong>4.你每次是如何来选择合适的MCU作为项目的主控的</strong></p><p>我最看重的一般是它的外设资源，比如定时器数量，因为电机控制，编码器等等需要用到定时器的数量比较多，所以对定时器数量需求大。也看应用场景，如果只是个小项目用c8t6就够用了</p><p>列出项目所需的外设接口（如GPIO、UART、SPI、I2C、ADC、PWM等），确保MCU支持这些功能。</p><p>评估程序代码大小、数据存储需求，确定所需的Flash和RAM容量。</p><p>C8T6 是 48 引脚，VET6 是 100 引脚，ZET6 是 144 引脚。引脚越多，可用的 GPIO 和外设资源越多。</p><p>STM32F103C8T6：价格最低，适合低成本项目。</p><p>STM32F103VET6：价格中等，性价比高。</p><p>STM32F103ZET6：价格较高，适合需要大量外设和引脚的项目</p><ul><li>STM32F103C8T6：<ul><li>Flash：64 KB</li><li>RAM：20 KB</li></ul></li><li>STM32F103VET6：<ul><li>Flash：512 KB</li><li>RAM：64 KB</li></ul></li><li>STM32F103ZET6：<ul><li>Flash：512 KB</li><li>RAM：64 KB</li></ul></li></ul><p>C8T6 的存储资源较少，适合小型项目；VET6 和 ZET6 的 Flash 和 RAM 容量更大，适合更复杂的应用。</p><ul><li>STM32F103C8T6：<ul><li>外设较少，适合简单应用。</li><li>例如：2 个 SPI、2 个 I2C、3 个 USART、1 个 USB、2 个 12 位 ADC（10 通道），4个定时器。</li></ul></li><li>STM32F103VET6：<ul><li>外设更丰富。</li><li>例如：3 个 SPI、2 个 I2C、5 个 USART、1 个 USB、3个 12 位 ADC（16 通道）, 8个定时器。</li></ul></li><li>STM32F103ZET6：<ul><li>外设最丰富。</li><li>例如：3 个 SPI、2 个 I2C、5 个 USART、1 个 USB、3 个 12 位 ADC（21 通道），8个定时器。</li></ul></li></ul><p><strong>5.在C语言进行嵌入式开发时，如何保证代码的可读性和可维护性</strong></p><p>模块化封装，写好注释，变量起名字有实际意义最好为英文缩写。</p><p><strong>6.驱动直流有刷电机时你是如何选择PWM的频率和占空比来满足需求</strong>，<strong>如何驱动步进电机以及舵机</strong></p><p><img src="/2024/01/26/Embedded-C-language/image-20250314082719000.png" alt="image-20250314082719000"></p><p>步进电机， 故名思意，按步前进的电机，一般通过驱动器控制，因为配合驱动器可细分步长和调节电流，改变电机的输出功率，提高控制精度。其控制策略为，给予电机一个pwm脉冲，则旋转一步，我们选择的是42步电机，即旋转42步，电机转一圈。因此，给的pwm脉冲越多，电机可以转越多的步，可以转越大的角度，即pwm脉冲数可以控制电机旋转的角度；而pwm波的频率，即一个完整pwm脉冲所用的时间，对应转速，频率越快，一个完整pwm脉冲所用的时间越短，电机转速越快。</p><ol><li>舵机（伺服电机）</li></ol><ul><li>控制原理<br>通过 PWM（脉宽调制）信号 控制角度，脉冲宽度决定位置（通常<strong>脉冲周期20ms，脉宽0.5ms<del>2.5ms对应0°</del>180°</strong>）。</li><li>驱动方式<ul><li>直接输入PWM信号，无需外部驱动器（内部集成控制电路和减速齿轮）。</li><li>需要独立电源供电（大扭矩舵机需外接电源）。</li></ul></li><li>特点<ul><li>内置反馈（电位器或编码器），形成闭环控制，位置精度高。</li><li>输出扭矩大，但转动范围有限（通常0°~180°）。</li></ul></li><li>典型应用<br>机器人关节、航模控制、摄像头云台等需要固定角度的场景。</li></ul><hr><ol start="2"><li>步进电机</li></ol><ul><li>控制原理<br>通过 脉冲信号 控制步进角和转速，每个脉冲对应电机转动一个步距角（如<strong>1.8°&#x2F;步</strong>）。<ul><li>需配合 相位顺序（如全步、半步、微步）驱动线圈。</li></ul></li><li>驱动方式<ul><li>必须外接 步进驱动器（如A4988、TMC2209）处理<strong>电流分配和细分控制</strong>。</li><li>控制信号包括<strong>脉冲（PUL）、方向（DIR）和使能（EN）</strong>。</li></ul></li><li>特点<ul><li>开环控制，依赖脉冲计数定位，无累积误差。</li><li><strong>细分驱动可提高精度</strong>（如16细分下1.8°步距角变为0.1125°）。</li><li>低速扭矩大，但高速易失步，需合理选择驱动电流。</li></ul></li><li>典型应用<br>3D打印机、CNC机床、精密仪器等需要高精度定位的场景。</li></ul><hr><ol start="3"><li>直流有刷电机</li></ol><ul><li>控制原理<br>通过 <strong>电压极性 控制转向</strong>，电压幅值或<strong>PWM占空比 调节转速</strong>。</li><li>驱动方式<ul><li>需使用 H桥电路（如L298N、TB6612）实现正反转和调速。</li><li>PWM频率需匹配电机特性（通常<strong>1kHz~20kHz</strong>）。</li></ul></li><li>特点<ul><li>开环控制，无内置反馈，需外接编码器实现闭环。</li><li>结构简单、成本低，但电刷易磨损。</li><li>高速性能好，但低速扭矩较小。</li></ul></li><li>典型应用<br>玩具车、风扇、无人机螺旋桨等需要连续旋转和调速的场景。</li></ul><hr><p><strong>7.继电器，电磁阀，气泵是如何连接工作的****？</strong>（详见毕设）</p><p>对于继电器，电源线与继电器的公共端和常开引脚分别连接，未通电时不导通，当给其信号引脚发高电平时继电器的公共端与常开引脚吸合，电路导通，从而实现给用电器供电。</p><p>对于电磁阀和气泵，用一个两路继电器控制常开型二位三通电磁阀以及气泵，电磁阀断电，气泵通电时，气泵和吸盘所连接的两个气路是导通的，可以直接吸取物品，当对电磁阀通电时，吸盘所连接气路与电磁阀另一气路导通，与外界大气压直接接通，破坏了其真空环境从而释放箱体。</p><p>所谓常开两位三通电磁阀</p><ul><li>两位：指阀芯有两个工作位置（例如通电&#x2F;断电状态）。</li><li>三通：阀门有三个流体接口（通常标记为P-供压口、A-输出口、R-排气口）。</li><li>电磁阀：通过电磁线圈的通断电控制阀芯运动，从而切换流路。</li><li>常开：未通电时阀门打开，气泵与吸盘气路接通。</li></ul><p><strong>8.编码器你是如何使用的，它的工作原理是什么</strong></p><p>使用增量式霍尔编码器，13线，4倍频，在一定周期内读取CNT值随后清0，累加可得到总脉冲数，可用于电机位置闭环控制。</p><p>工作原理：</p><p><strong>9.麦克纳姆轮怎么安装的，怎么驱动它</strong></p><p>安装方式分为X型安装和O型安装，X型安装会导致旋转力矩很小或者无法旋转的情况发生，因此一般用O型安装。</p><p>前后行驶</p><img src="/2024/01/26/Embedded-C-language/image-20250314223316869.png" alt="image-20250314223316869" style="zoom:50%;"><p>左右平移：</p><img src="/2024/01/26/Embedded-C-language/image-20250314222721385.png" alt="image-20250314222721385" style="zoom:50%;"><p>原地旋转：  </p><img src="/2024/01/26/Embedded-C-language/image-20250314222752523.png" alt="image-20250314222752523" style="zoom:50%;"><p><strong>10.你在项目中遇到的最大挑战是什么？怎么解决的？</strong></p><p><strong>11.你本科期间做了这么多比赛，你都学习到了什么东西？</strong></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C language programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/01/22/hello-world/"/>
      <url>/2024/01/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hello World!</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>前路漫漫亦灿灿</title>
      <link href="/gallery/college.html"/>
      <url>/gallery/college.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-container" data-type="data" data-button>      <div class="gallery-data">[{"url":"./college/49-1706344694822-120.jpg","alt":"49"},{"url":"./college/48-1706344708682-122.jpg","alt":"48"},{"url":"./college/47-1706344716685-124.jpg","alt":"47"},{"url":"./college/46-1706344721866-126.jpg","alt":"46"},{"url":"./college/45-1706344637895-118.jpg","alt":"45"},{"url":"./college/39-1706345196130-209.jpg","alt":"39"},{"url":"./college/37-1706345211163-211.jpg","alt":"37"},{"url":"./college/33-1706345229054-213.jpg","alt":"33"},{"url":"./college/29-1706345235414-215.jpg","alt":"29"},{"url":"./college/19-1706345257443-217.jpg","alt":"19"},{"url":"./college/12-1706345274915-219.jpg","alt":"12"},{"url":"./college/13-1706345280346-221.jpg","alt":"13"},{"url":"./college/14-1706345293624-223.jpg","alt":"14"},{"url":"./college/31-1706345317371-225.jpg","alt":"31"},{"url":"./college/43-1706345325834-227.jpg","alt":"43"},{"url":"./college/41-1706345332395-229.jpg","alt":"41"},{"url":"./college/38-1706345344631-231.jpg","alt":"38"},{"url":"./college/30-1706345352332-233.jpg","alt":"30"},{"url":"./college/32-1706345365438-235.jpg","alt":"32"},{"url":"./college/50.jpg","alt":"50"},{"url":"./college/34-1706345374354-237.jpg","alt":"34"},{"url":"./college/51.jpg","alt":"51"},{"url":"./college/52.jpg","alt":"52"},{"url":"./college/35-1706345381156-239.jpg","alt":"35"},{"url":"./college/20-1706345398048-241.jpg","alt":"20"},{"url":"./college/25-1706345411044-243.jpg","alt":"25"},{"url":"./college/24-1706345419521-245.jpg","alt":"24"},{"url":"./college/23-1706345425445-247.jpg","alt":"23"},{"url":"./college/17-1706345438446-249.jpg","alt":"17"},{"url":"./college/9-1706345445647-251.jpg","alt":"9"},{"url":"./college/8-1706345461721-257.jpg","alt":"8"},{"url":"./college/26-1706345477181-259.jpg","alt":"26"},{"url":"./college/16-1706345482816-261.jpg","alt":"16"},{"url":"./college/7-1706345489413-263.jpg","alt":"7"},{"url":"./college/6-1706345496102-265.jpg","alt":"6"},{"url":"./college/4-1706345502454-267.jpg","alt":"4"},{"url":"./college/3-1706345507417-269.jpg","alt":"3"},{"url":"./college/2-1706345515116-271.jpg","alt":"2"},{"url":"./college/1-1706345519911-273.jpg","alt":"1"}]</div>      <div class="gallery-items">      </div>    </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>尽吾志也而不能至者，可以无悔矣</title>
      <link href="/gallery/crane.html"/>
      <url>/gallery/crane.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-container" data-type="data" data-button>      <div class="gallery-data">[{"url":"./crane/19-1706339747403-43.jpg","alt":"19"},{"url":"./crane/18-1706339819893-45.jpg","alt":"18"},{"url":"./crane/17-1706339835479-47.jpg","alt":"17"},{"url":"./crane/16-1706339842391-49.jpg","alt":"16"},{"url":"./crane/4-1706339853690-51.jpg","alt":"4"},{"url":"./crane/6-1706339861221-53.jpg","alt":"6"},{"url":"./crane/12-1706339867143-55.jpg","alt":"12"},{"url":"./crane/7-1706339875488-57.jpg","alt":"7"},{"url":"./crane/13.jpg","alt":"13"},{"url":"./crane/15-1706339890044-60.jpg","alt":"15"},{"url":"./crane/9-1706339896866-62.jpg","alt":"9"},{"url":"./crane/3-1706339904800-64.jpg","alt":"3"},{"url":"./crane/5-1706339910791-66.jpg","alt":"5"}]</div>      <div class="gallery-items">      </div>    </div><div id="music-page"></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>路虽远行则将至，事虽难做则必成</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>欲买桂花同载酒，终不似，少年游</title>
      <link href="/gallery/robocon.html"/>
      <url>/gallery/robocon.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-container" data-type="data" data-button>      <div class="gallery-data">[{"url":"./robocon/5.jpg","alt":"5"},{"url":"./robocon/4.jpg","alt":"4"},{"url":"./robocon/IMG_20221026_171356.jpg","alt":"IMG_20221026_171356"},{"url":"./robocon/IMG_20230226_160022.jpg","alt":"IMG_20230226_160022"},{"url":"./robocon/IMG_20230226_181211.jpg","alt":"IMG_20230226_181211"},{"url":"./robocon/IMG_20230522_191254.jpg","alt":"IMG_20230522_191254"},{"url":"./robocon/IMG_20230614_211620.jpg","alt":"IMG_20230614_211620"},{"url":"./robocon/IMG_20230707_132558.jpg","alt":"IMG_20230707_132558"},{"url":"./robocon/IMG_20230707_184452.jpg","alt":"IMG_20230707_184452"},{"url":"./robocon/IMG_20230707_205101.jpg","alt":"IMG_20230707_205101"},{"url":"./robocon/mmexport98bdd9d9588b4cdaa855aa0ae3d7dce5_1688707161464.jpeg","alt":"mmexport98bdd9d9588b4cdaa855aa0ae3d7dce5_1688707161464"},{"url":"./robocon/Screenshot_20230413_121149.jpg","alt":"Screenshot_20230413_121149"},{"url":"./robocon/Screenshot_20230708_105442.jpg","alt":"Screenshot_20230708_105442"},{"url":"./robocon/1f808d0f5874cda9.jpg","alt":"1f808d0f5874cda9"},{"url":"./robocon/62ed118391dafe0a.jpg","alt":"62ed118391dafe0a"},{"url":"./robocon/274a1c04a632f15c.jpg","alt":"274a1c04a632f15c"},{"url":"./robocon/-757c3e143b47490f.jpg","alt":"-757c3e143b47490f"}]</div>      <div class="gallery-items">      </div>    </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-group-main">    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="/./images/7.jpg" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">我的大学</div>  <p>我的奋斗</p>  <a href="/gallery/college"></a>  </figcaption>  </figure>      <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="/./images/6.jpg" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Robocon</div>  <p>WUST ROBOCON 2023</p>  <a href="/gallery/robocon"></a>  </figcaption>  </figure>      <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="/./images/8.jpg" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">起重机</div>  <p>命运的齿轮开始转动</p>  <a href="/gallery/crane"></a>  </figcaption>  </figure>  </div>    ]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/message/index.html"/>
      <url>/message/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>zhixiong&#39;s page</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Vscode&amp;Keil</title>
      <link href="/vscode-keil/index-1.html"/>
      <url>/vscode-keil/index-1.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>vscode&amp;keil</title>
      <link href="/vscode-keil/index.html"/>
      <url>/vscode-keil/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
