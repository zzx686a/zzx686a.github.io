<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vscode&amp;Keil</title>
      <link href="/2024/01/30/vscode-keil/"/>
      <url>/2024/01/30/vscode-keil/</url>
      
        <content type="html"><![CDATA[<p>前言：之前一直用的keil软件开发stm32的工程，越来越觉得keil的界面模糊不好看，于是尝试转移到vscode平台，目前实现的功能是cubemx生成工程文件后可用vscode打开并编译烧录，如果有调试需求还是在keil上。使用Vscode搭配keil，更加优雅的进行开发</p><p>对比图：</p><img src="/2024/01/30/vscode-keil/image-20240131162907970.png" alt="image-20240131162907970" style="zoom:67%;"><img src="/2024/01/30/vscode-keil/image-20240131162933189.png" alt="image-20240131162933189" style="zoom:60%;"><h1 id="1-安装MinGW"><a href="#1-安装MinGW" class="headerlink" title="1.安装MinGW"></a>1.安装MinGW</h1><p>把MinGW压缩包解压到常用的一个位置，</p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;新建-&gt;添加，将MinGW的bin文件夹路径复制到新建的环境变量中。</p><h1 id="2-安装Keil-Assistant插件"><a href="#2-安装Keil-Assistant插件" class="headerlink" title="2.安装Keil Assistant插件"></a>2.安装Keil Assistant插件</h1><p>安装后，右键点击扩展设置，将你的keil软件的UV4.exe的路径粘贴上去</p><p><img src="/2024/01/30/vscode-keil/image-20240130220057873.png" alt="image-20240130220057873"></p><p>然后如果安装成功的话，vscode左栏就会出现</p><p><img src="/2024/01/30/vscode-keil/image-20240130220235274.png" alt="image-20240130220235274"></p><p>依次为编译，烧录，重编译</p><h1 id="3-遇到的问题"><a href="#3-遇到的问题" class="headerlink" title="3.遇到的问题"></a>3.遇到的问题</h1><p>1.点击编译后出现</p><p>“文件名，目录或卷标语法不正确”</p><p>然后发现是在添加路径到Keil Assistant时路径开头写错了</p><p>2.修复第一个问题后，再次编译，出现</p><p><img src="/2024/01/30/vscode-keil/%7BWEJS9SE%25J%7BMGCUP6EYHMG.png" alt="{WEJS9~SE%J{MGCUP6EYHMG"></p><p>解决：先打开settings.json文件</p><p><img src="/2024/01/30/vscode-keil/image-20240130221023430.png" alt="image-20240130221023430"></p><p>把代码中的[U+202A]删掉即可，到此，可以正常编译和烧录。</p><p>目前的功能满足现在的使用需求，后面有时间可以学习下用GCC编译链开发STM32，学习下makefile,cmake,openocd相关的知识。</p><p><a href="https://www.bilibili.com/video/BV1Hi4y1r7b3/?spm_id_from=333.999.0.0&vd_source=a9d487fcf1a579639c6348eb5a9321db">https://www.bilibili.com/video/BV1Hi4y1r7b3/?spm_id_from=333.999.0.0&amp;vd_source=a9d487fcf1a579639c6348eb5a9321db</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vscode&amp;Keil </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Robotics learning path</title>
      <link href="/2024/01/30/Robotics/"/>
      <url>/2024/01/30/Robotics/</url>
      
        <content type="html"><![CDATA[<p>转载自</p><p>机器人工程师学习计划 - YY硕的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/22266788">https://zhuanlan.zhihu.com/p/22266788</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>很多朋友私信问我对机器人和人工智能感兴趣，该怎么展开学习。最近稍微有点空，我写写我的看法。</p><p>两年前，我在知乎回答<a href="https://www.zhihu.com/question/20435673/answer/29927998">如何定义「机器人」？ - YY硕的回答</a>中试图给机器人做出一个比较仔细的定义，我觉得机器人和人工智能最大的区别在于是否要和物理世界进行交互。今年初在另一篇知乎回答里<a href="https://www.zhihu.com/question/36653316/answer/85774195">对机器人或人工智能的研究会帮助我们更好的了解人类自己吗？ - YY硕的回答</a>我说到传感器是和物理世界交互的基础。后来，我又在知乎回答<a href="https://www.zhihu.com/question/45766810/answer/100301388">有哪些与控制、机器人等相关的 quotes？ - YY硕的回答</a>中提到莫拉维克悖论（<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Moravec%27s_paradox">Moravec’s paradox</a>），谈到了机器人学里公认的难题是在物理世界中实现类人的活动能力。</p><p>把之前的回答再翻出来是为了支持以下观点：机器人学的核心问题是做好和物理世界的交互。现在主流的机器人学分支里，处理与物理世界的交互的学科分为三类：传感器和处理算法（激光雷达，多目视觉，融合算法）；多刚体系统动力学控制（工业机器人动力学控制和接触力控制）；机器人自主移动（locomotion不知道该怎么翻译，轮式、足式、飞行等移动机器人的研究）。我建议对机器人学有兴趣的同学着重在这几个问题上面。</p><p>另外，根据世界第一的机器人教育机构卡耐基梅隆大学的机器人学博士的课程分类方式（</p><p><a href="https://link.zhihu.com/?target=https://www.ri.cmu.edu/wp-content/uploads/2017/01/COSAug2016.pdf">https://www.ri.cmu.edu/wp-content/uploads/2017/01/COSAug2016.pdfwww.ri.cmu.edu/wp-content/uploads/2017/01/COSAug2016.pdf</a></p><p>），机器人学有四个核心领域：</p><ol><li>感知。视觉传感器、图像传感器、触觉和力传感器、惯导等。</li><li>认知。人工智能、知识表达、规划、任务调度、机器学习等。</li><li>行为。运动学、动力学、控制、manipulation和locomotion等。</li><li>数学基础。最优估计、微分几何、计算几何、运筹学等。</li></ol><p>结合卡耐基梅隆大学的核心课程要求，我觉得我定义的机器人学核心问题算是基本没跑偏的。本文后面谈到的机器人项目都是以上述观点和课程要求为基础。</p><p>一些可能有争议性的观点：</p><ol><li>机器人学是富人的活动。虽然工业越来越发达，但好的开发板和电机还是非常贵。如果要下定决心学习机器人学并且做出实物，你必须找到做实物出来的资金。要么是自己花钱，要么就得找学校的机器人社团，或者找什么愿意资助年轻人学习的贵人。另外现在没有任何一本完整的书可以教你怎么造一个四旋翼空中机器人或者大狗机器人，你需要参考十几本不同的教科书，这些书不管中文版还是英文版都很贵。</li><li>机器人学是屠龙之术。这话是Ninebot创始人说的。虽然最近几年，平衡车、扫地机器人、多旋翼飞行器让机器人学开始进入人们的生活，但是可行的商业应用还是很少，而且已有的机器人和理论都还很难解决好与物理世界交互这件事情。所以一定要确保自己在机器人学这个道路上同时练好了能去其他行当吃饭的技能，比如编程、机械设计和硬件设计。也要做好心理准备，接受自己有可能在学会屠龙之术以后几年都造不出对社会有用的东西的事实。</li><li>基于上述所说的观点，如果是已经工作之后才想要学习机器人的话，可能已经太迟了，因为很可能<strong>兴趣战胜不了客观限制因素</strong>。如果作为兴趣去学习，只能学到做巡线小车和舵机机械臂什么的，可能也满足不了中二病的创造欲。</li></ol><p>个人认为机器人学是一个艰苦的道路，想要成为一个独挡一面的机器人工程师需要多年理论和实践的同步训练。理论学习和动手实践的过程还要互相排好时间表，在做某个实践项目的同时去学习最相关理论往往可以达到事半功倍的效果，但是同时那些不太相关的理论会看起来非常枯燥，因此如何妥善安排自己的实践项目也是很重要的事情。</p><p>这篇文章里我计划介绍一个电子工程、机械工程和计算机专业学生从大学一年级到研究生二年级的机器人学习计划，基本是我对自己过去学习方式的一个总结。按照这个方法来学习，能够成为一个能力全面，但是稍微偏软件一点的机器人工程师。这个六年的学习计划，估算下来，全年中每天在上课和完成课程要求之外要投入学习时间6-8个小时，这些时间一方面用于阅读课程知识的英文教材，一方面用于阅读其他学科的教材，一方面用于实践项目。</p><p>机器人工程师在大型项目里的定位类似于飞机系统里的总体设计师。和机械工程师、硬件工程师、软件工程师、算法工程师、控制工程师比起来，机器人工程师参与某个具体技术的时间较少，但是能够听得懂所有工程师说的话，能够作为不同模块间的协调人，带领整个团队去攻坚。当然如果机器人工程师能够在一个领域达到那个领域的工程师的优秀水平，肯定更好。</p><p>由于时间仓促，再加上个人水平有限，文章中如有纰漏和错误，恭请读者指出，谢谢。如果同学还有什么想知道的内容和教材，也欢迎留言交流。</p><h2 id="大一"><a href="#大一" class="headerlink" title="大一"></a><strong>大一</strong></h2><p>刚上大一，你的机器人生涯开始了。先看看学校的校园网能不能翻墙，不能的话自己去买个一年一百多块钱的VPN，先确保自己能上Google，不要心疼VPN的钱，这能让你在之后的职业生涯里节省上万块钱。然后去注册一个gmail账号，再注册stackoverflow账号，再注册github的账号，再注册CSDN账号，注册完登录上去逛逛，暂时先不要问为什么。</p><p>英语水平一定程度上会是机器人工程师水平的限制因素，英语是同学们在大学最该努力学的一门课，而且不止要把它当成课，要当成一种技能，当成生活的一部分。当你开始努力学习一些高级的机器人知识以后，有可能会非常难以找到中文的参考资料，这个时候如果啃不下英文的资料，进步速度和眼界就会受到很大影响。因此大一的时候要多看看红宝书，看看美剧。</p><p>不管是什么专业背景的同学，大学一年级一定要上好的课是微积分和线性代数。线性代数的重要性需要特别强调。一般来说，<strong>优秀的工程师和科学家在职业生涯中要学至少五次线性代数</strong>，大一学一遍、学凸优化的时候学一遍、学线性系统的时候学一遍、学机器学习的时候学一遍……如果在第一遍学的时候就看到对的书，刷到对的题，那么以后的学习会轻松很多。</p><p>网上有很多对于如何学好线性代数的讨论，比如知乎问题<a href="https://www.zhihu.com/question/20534668">如何理解线性代数？ - 数学学习</a>。Matrix67大神的文章<a href="https://link.zhihu.com/?target=http://www.matrix67.com/blog/archives/4294">随记：我们需要怎样的数学教育？</a>也很有启发。我个人对学习线性代数的建议是两本书，一本叫做《Linear Algebra Done Right》，另一本叫做《Linear Algebra Done Wrong》（<a href="https://link.zhihu.com/?target=https://www.math.brown.edu/~treil/papers/LADW/book.pdf">https://www.math.brown.edu/~treil&#x2F;papers&#x2F;LADW&#x2F;book.pdf</a>），我比较喜欢的是Done Wrong这本书，第一它是免费的，第二只需要读前6章两百页就够了，第三它页边距很大，打印出来有很多空白做练习题。另外一个较好的教材是<a href="https://link.zhihu.com/?target=http://open.163.com/special/opencourse/daishu.html">麻省理工公开课：线性代数</a>。不论如何，学线性代数一定要用国外的教材，千万不要用国内的教材。啃英文书很累，但是考虑到之后还要啃更多的英文书，线性代数已经算是很入门的了，一定要啃下来，同时还要刷足够多的课后题。</p><p>学完线性代数以后，一个自然而然的问题就是怎么能用计算机自己去计算矩阵的乘法、向量的乘法、向量的内积。因此引入了编程的学习。</p><p>不管同学的专业是什么，一定要在大学一年级尽早开始学编程。至于用哪种语言开始学习编程，我推荐Python，比较好的教材是<a href="https://link.zhihu.com/?target=http://open.163.com/special/opencourse/bianchengdaolun.html">麻省理工学院公开课：计算机科学及编程导论</a>，比较好的Python开发学习环境是Anacoda (<a href="https://link.zhihu.com/?target=http://www.continuum.io/downloads">http://www.continuum.io/downloads</a>)。熟悉Python以后，同学就可以开始玩玩Python的数值计算包Numpy，这个时候线性代数题基本上也刷的差不多，可以通过Numpy帮助自己解决线性代数问题了。</p><p>对任何人来说，Python是一把瑞士军刀，你可以用他干很多东西，比如自动回复邮件、自动收集信息。但是真要去造机器人，合适的工具并不是瑞士军刀，而是C&#x2F;C++这样简单粗暴的锤子和螺丝刀般的工具。在学习Python学到一定程度的时候（比如你听说有一种叫做cython的东西），最好开始学习C，而且要强迫自己练习用C的一维数组和指针来实现矩阵的加法、乘法、求逆等操作。之所以有高级的Python或者Java（不要问我Java哪里高级了）这些语言以后我们还需要去学C，是因为机器人上常用的不是完整的电脑，而是计算量有局限的嵌入式系统，嵌入式系统开发基本只能用C或者更低级的语言。</p><p>学习C我个人入门用的是清华大学出版的《<a href="https://link.zhihu.com/?target=http://product.dangdang.com/8880276.html">C++语言程序设计</a>》。虽然这个书标题是C++，但其实没什么太大问题。不过国内的C语言教材都有个巨大的问题是不引导学生去用Linux。近年来更好的一个教材是<a href="https://link.zhihu.com/?target=http://songjinshan.com/akabook/zh/index.html">http://songjinshan.com/akabook/zh/index.html</a>，这个网站的教材非常好，因为他教育学生用Linux环境作为程序编译的环境，而且还引入了一些计算机体系结构的介绍。</p><p>IT行业的程序员都会争论高级语言和低级语言哪个好，Linux和Windows哪个好，而对于机器人工程师来说，从现在到可预见的未来里，C是最好的语言，Linux是最好的操作系统，这都毋庸置疑。甚至对于Linux的发行版该选哪个，我们都是很少有质疑的：Ubuntu（<a href="https://link.zhihu.com/?target=http://www.ubuntu.com/global">The leading OS for PC, tablet, phone and cloud</a>）。原因是机器人操作系统ROS（<a href="https://link.zhihu.com/?target=http://www.ros.org/">ROS.org | Powering the world’s robots</a>）是基于Ubuntu开发的，因此在Ubuntu上运行最稳定。注意Ubuntu出了一个中文版叫做Kylin，个人感觉比较坑，建议大家不要装中文版。Ubuntu 作为一个开源操作系统，总是在快速迭代，2016年8月比较稳定的版本是14.04和16.04，建议同学安装14.04。</p><p>当你把C学得差不多，开始要学写包含多个头文件的程序时，一定要同时学习makefile的知识。这时候要上网去搜“Makefile详解”（<a href="https://link.zhihu.com/?target=http://tieba.baidu.com/p/591519800">Makefile详解（超级好）_mingw吧</a>）这篇文章看。</p><p>我自己在大学一年级的时候还学习了HTML和Javascript，到大一结束的时候已经能够熟练用Javascript手写一些动态页面。我个人觉得HTML和Javascript也是机器人工程师必备的技术，而不只是软件工程师的玩具。这是因为web技术实际上已经渗透到了编程的方方面面，比如json开始是Javascript里的一种object定义的方式，但现在已经成为了一种很标准的数据交互、参数配置的格式。另外AJAX能够帮助初学者理解一定的网络技术原理，而网络技术也是机器人工程师必备的技能。再者，制作GUI（图形用户界面）是常规debug的办法，而近年来一个流行的趋势是用webkit嵌入程序用HTML和Javascript作为图形界面的后端，而在机器人操作系统ROS（<a href="https://link.zhihu.com/?target=http://www.ros.org/">ROS.org | Powering the world’s robots</a>）里，通过rosbridge可以非常方便地把机器人程序的数据传递到websocket上，这句话看不懂没关系，反正你知道学学HTML和Javascript很重要就是了。更重要的是，HTML文档背后的DOM (Document Object Model)深刻地体现了面向对象的思想。大学中的面向对象程序设计一般都讲C++，在我看来应该讲HTML和Javascript。这一点不细说了，如果同学们去学习HTML和Javascript，自然会体会到。学习HTML和Javascript比较好的资料是<a href="https://link.zhihu.com/?target=http://www.w3schools.com/">http://www.w3schools.com/</a>，把网站左侧的“Learn HTML”、“Learn CSS”、“Learn Javascript”和“Learn JQuery”学完就行，别的部分还有很多花哨的技术，没有必要去学了。为了培养自己对Javascript的兴趣，可以上<a href="https://link.zhihu.com/?target=http://threejs.org/examples/">three.js &#x2F; examples</a>跪着看看热闹。</p><p>以上介绍的这些知识点、书和资料应该在大一期间就全部看完，然后利用大一的暑假好好巩固这些知识。比如开始用HTML和Javascript做一个自己的个人主页，刷一刷编程的题目，学用Python的奇技淫巧（比方说做一个自己的个人主页）。另外还可以抽时间学学数学知识，比如开始看看代数和离散数学。我大一的时候看到了两篇文章，认识到了数学的重要性，一个是MIT的CV大牛林达华写的[<a href="https://link.zhihu.com/?target=https://www.douban.com/group/topic/11115261/">转]MIT牛人解说数学体系</a>，另一个是前Goolge研究员吴军博士写的《数学之美》（<a href="https://link.zhihu.com/?target=https://book.douban.com/subject/10750155/">数学之美 (豆瓣)</a>）。当时林达华还在MIT读博士，而《数学之美》还没有成书。两篇文章看完以后我感觉自己整个人对数学的认识上了一个新的层次，此后一直在注意提高自己的数学水平，几年下来觉得收益很大。在之后的介绍里我还会多次强调需要学的数学知识和对应的教材。</p><h2 id="大二"><a href="#大二" class="headerlink" title="大二"></a><strong>大二</strong></h2><p>上大二的时候，你已经会了基本的编程知识和基本的数学知识。大二这一年应该投入在嵌入式系统的学习中，同时继续拓展自己多方面的能力。学校的机器人社团，比如做Robocon，RoboMasters的团队应该在招新了，赶快去加入，有了学长学姐的指导以及同辈朋友的鞭策，应该会进步的快一点。</p><p>大二应该掌握的技能：Solidworks画基本的机械图，基本的数字电路知识、数模转换，51单片机、AVR单片机、STM32单片机原理，UART、SPI、I2C、CAN等协议的原理和数据收发，STM32开发板的使用，电机转动和驱动的原理，PID的原理，调试四轮机器人底盘的移动，基本的传感器如陀螺仪、码盘、红外线、超声波的原理和读取方式，网络知识如配置IP配置路由器等，微电子焊接，金工技术。我在知乎回答<a href="https://www.zhihu.com/question/34670420/answer/59676472">如果程序员每天都浅尝辄止地学一些不同的新技术，长久以往，人会变成什么样子呢？ - YY硕的回答</a>里谈过机器人工程师需要的技能数量是IT行业全栈工程师技能数量的三倍以上，这些技能的基础都应该在大二开始积累。</p><p>如果同学们的专业是机械工程相关，那么大二的时候要深入学习solidworks做图，买机械加工手册学习各种机械的奇技淫巧。你的专业知识还不足以让你进行缜密的受力分析，不过你可以尽量多做一些机械结构出来感受它们的乐趣。</p><p>如果同学们的专业是硬件、电路相关，那么大二的时候要深入学习Altium Designer做图、制板、焊板。你要从现在开始，就给自己积累一个工作记录，可以就是简单的txt文件，记录你做过所有板子的bug、解决方案、学到的原理图、PCB layout的注意事项等等。积累很多年以后，你的这个工作记录会值很多钱。</p><p>学习这些技能的最好的方式，就是参加自己学校机器人社团的训练和方案设计。一般来说，学校的机器人社团招新之后会有训练和测试，让新人分组去做机器人，这个过程中如果愿意努力学，提高得会很快。如果你所在的大学是机器人比赛强校，比如西安交通大学，电子科技大学，哈尔滨工业大学，华中科技大学，东北大学等等（排名不分先后，没有提到你们学校名字的话我表示抱歉），那么你很幸运，你们学校的机器人社团有很好的积淀，有很多资源可以帮助你学习。基本上只要天天泡实验室，保证自己每天只睡6-7个小时（但还是要多去跑步、游泳保持身体健康），勤于向学长学姐请教，那么一定会提高得很快。</p><p>大二阶段特别要强调的是对动手能力的培养，包括机械材料的加工、电路焊接、制作导线和接头、连接路由器、配置网络、做网线等等。机械加工的工具有螺丝刀、锯、钻、锤子、车床、铣床、钻床，进阶选手可以学一下氧焊，这个比较危险，我没尝试过；电路焊接的工具有焊机、焊锡、洗板水、松香、吸锡器；制作导线的工具有剪子、剥线钳、夹头钳、网线钳各种钳；网络配置就是连连路由器插插网线，但是Linux系统下配置网络有时会非常麻烦，一定要多积累这方面的知识，因为将来你造的机器人多半会顶着一个无线路由器跑来跑去，甚至有的机器人上各个模块自己就能组起一个小局域网。这些技能的熟练掌握需要你花很多时间去做真正能用的机器人来练手。</p><p>对于该选择造一个怎么样的“真正能用的机器人”练手，最好的选择肯定是机器人比赛中的机器人。如果参加Robocon，你会跟着学长学姐们学着造有人那么高的巨大机械；如果参加RoboMasters，你会学着造比汽车还要灵活的机器人以及快速发弹的机构。其他一些小型的比赛比如飞思卡尔智能车，也是很好的训练，因为飞思卡尔智能车已经发展得很成熟，参加这个比赛的参赛资料就够学一阵子的，学完以后能够获得比较多的机器人技能。</p><p>如果没有太多学校机器人社团的资源，同学们还有一些小型的比赛比如挑战杯、大创比赛等等可以选择，以三五个人的小团队参与这些比赛。如果同学所在的学校连这些比赛都不组织大家参与，那就只好自己花钱了。国内开源机器人社区有很多资源可以利用来学习，比如自己买<a href="https://link.zhihu.com/?target=http://www.makeblock.com/">Arduino STEM educational Robot kits Building Platform</a>的各种开发套件做简单的机器人。Arduino的开发环境可能有些人不喜欢，因为它对硬件做了一级封装，如果更希望接触到单片机的本质，可以自己买STM32开发板学习。俗话说，没有什么嵌入式系统是一块STM32实现不了的，如果有，就用两块。STM32是ARM Cortex‑M家族中最为广泛应用的一款单片机，在网上也有很多的教材和开发板可供选择。在国内著名的电子论坛<a href="https://link.zhihu.com/?target=http://www.amobbs.com/forum-3020-1.html">STM32&#x2F;8 分论坛帖子清单 (amoBBS 阿莫电子论坛)</a>上，有很多参考资料，有问题也可以在这里和大家讨论学习。</p><p>如果你很想参加机器人比赛，身边也恰好有一些志同道合的小伙伴，但是学校不支持。没关系，来找我，我尽量通过大疆的关系说服你们学校支持你们参加RoboMasters。</p><p>虽然你是以机器人比赛为主线在探索机器人技术，但是要时刻记得，机器人比赛给你的理论方面的训练很差，还会让你养成一些坏习惯，比如凡事都希望用一些糙猛快的办法来解决。由于通常整个团队都没有太多的项目管理经验，到比赛前一段时间才会加紧功夫去做机器人，很多时候就会用“山寨”的办法去处理机器人的故障。比如说某个承重结构用久了会弯，为了赶比赛的进度，就拿锤子敲直了、再加一条辅助的结构在旁边继续用，而没有细致地去做建模、受力分析，思考是什么原因导致承重结构会变形。再比如说调PID参数就是生调乱改，而没有基于机器人的动力学模型去估测参数的大概范围。</p><p>大二的暑假，有可能你跟着学校的机器人队参加了一些机器人比赛。这是一个反思总结的好时机，为什么机器人队取得了这样那样的成绩？整个团队怎样才能更有效率？明年如何继续招新？暑假要把时间花在技术积累上面，这个时候可以回头思考思考之前准备比赛时用糙猛快的办法解决的问题如何能够细致地去解决。</p><p>如果大二的暑假没有参加机器人比赛，可以做一个舵机机器人，比如6条腿的蜘蛛，比如码垛机器人。舵机是机器人工程师的好朋友，一定要好好掌握。</p><p>另外你其他方面的能力也不能落下。大二结束的时候，你的Linux应该用的很熟练了，除了makefile，你也用起了cmake。你也应该开始理解Github存在的意义，因为你已经上去读了很多别人的代码，你也把自己的一些课程设计和小项目放在了Github上面。另外大二基本上了本专业一些比较难的基础课程，比如自动控制原理、机器学习、概率统计、材料和力学等课程，同学们会看到这些课程里又用到了线性代数和微积分的知识，以及建模的知识。这时候可以把大一的物理、线性代数和微积分再翻出来看看。</p><p>同学的学校应该给大二到大三的学生有开设面向对象的程序设计，一般用Java或C++教授。在面向对象的程序课里面，一定要积累3000行左右的代码的开发经验。经典的面向对象程序设计的练习通常是写游戏，比如俄罗斯方块，吃豆人等等，一定要自己能够做到完全手写一个完整的项目出来。</p><p>另外你可以开始学习Matlab当中的神器Simulink了。在大二这一年的学习中，你可能在不少课程里多多少少用到了Matlab。假设你已经在我的推荐下喜欢上了Python，你可能会觉得Matlab的计算工具没有比Python强多少；假设你自己在别人的推荐下喜欢上了mathematica（<a href="https://www.zhihu.com/question/27834147">Mathematica 到底有多厉害？ - Wolfram Mathematica</a>），你可能会觉得和Mathematica这种神一样的语言比起来，Matlab弱爆了。但是要注意的是，Matlab最强大的工具是Simulink，通过它你几乎可以仿真一切的物理系统和控制系统。我建议同学可以通过Simulink实现一个倒立摆，然后理解Matlab的强大之处。对此我强烈推荐一个很好的教材（<a href="https://link.zhihu.com/?target=http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction&section=SimulinkControl">http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction§ion=SimulinkControl</a>），它详细介绍了一些经典的控制系统如何分析以及用Simulink实现。然后我再强烈推荐一个讲Simulink里面一个更加和物理仿真贴近的工具Simscape（<a href="https://link.zhihu.com/?target=http://www.mathworks.com/help/control/examples/control-of-an-inverted-pendulum-on-a-cart.html">Control of an Inverted Pendulum on a Cart</a>）的文章。阅读并实现了这两篇文章里的内容，同学应该会对倒立摆有了比较深刻的认识。倒立摆是机器人学中一个非常重要的模型，因为火箭、导弹、双足机器人、四足机器人，基本都是倒立摆的变形。你自己实现出来的simulink模型一定要存好，以后可能还会再拿出来仔细看。</p><p>如果你按照我之前说的方法探索了一些HTML和Javascript的技术，那么JQuery，bootstrap，AngularJS你已经多多少少知道是怎么回事了。web后端的技术，比如PHP和MySQL，也可以了解一下，LAMP要学会怎么配置。如果有同学找你帮忙写小网站，尽量去帮个忙，帮别人做网站是提高自己系统编程能力的好练习。在做网站的过程中你可能还会顺便学一学如何用Photoshop和Illustrator让网站显得更漂亮。这些技能有最好，没空学也没关系。</p><h2 id="大三"><a href="#大三" class="headerlink" title="大三"></a><strong>大三</strong></h2><p>大三开始的时候，你可以在学校的机器人队里担任重要角色了，或者能够带领一个小团队参加小型的机器人比赛。你在系里甚至院里都小有名气了，可能有的人叫你大神，有的人觉得你技术还不错。但是一定要记得你现在的水平放到别的地方应该不算什么。每年我都往大疆的RoboMasters夏令营招进100个和你现在的水平相当的同学。</p><p>大三一定要培养出自己一个人独立造出一个完整机器人的能力，比如一个Robocon水平的机器人，或者一个RoboMasters的战车，或者一个四旋翼飞行器。</p><p>Robocon水平的机器人，涉及大量的机械设计，单片机开发，电机驱动的开发，码盘和超声波等传感器的读取，底盘运动学的计算，PID调试，任务调度逻辑的调试，舵机控制。RoboMasters的战车的机械部分简单一些，但是还需要进行云台的控制、发弹系统的控制、功率控制等方面的知识，另外你也可以不搞这些部分，学习学习视觉识别和自动打击，那么就要开始研究OpenCV（<a href="https://link.zhihu.com/?target=http://opencv.org/">OpenCV | OpenCV</a>）了。</p><p>四旋翼飞行器的机械部分最简单，但是算法比较复杂。对于大三学生来说，从零开始一步到位写一个稳定的飞控比较困难，因为飞控里面有很多细小的知识点要注意。目前我没有发现什么比较好的书籍推荐，已有的一些关于四旋翼系统的书要么太浅（上来就教你焊电路），要么太深（上来就教你state estimation），听说 <a href="https://www.zhihu.com/people/liu-top">@Liu Top</a>的exbot小组在写一个教材，我是非常期待的。学习四旋翼飞行器有下面几个步骤：</p><p>第一步：自己调一个小四轴飞起来</p><p>现在开源社区的人言必pixhawk，其实我觉得从学习的角度来说，pixhawk太贵，而且不适合学习，我比较推荐的是 <a href="https://link.zhihu.com/?target=https://chiplab7.taobao.com/">首页-第七实验室</a> 这家淘宝店卖的STM32F405飞控，买回来以后自己再随便买个机架（比如大疆F450）、接收机和遥控，就能按照飞控板附带的学习资料、调试软件飞起来。</p><p>第二步：看硬件图、读代码</p><p>chiplab7的飞控板附带一大堆学习资料，对加速度计、陀螺和磁感计都有很仔细的解释，硬件链路图也很详细。chiplab7淘宝掌柜的又很认真负责，我学用的时候，发现代码有bug和看不懂的地方，都可以直接找掌柜问。</p><p>看完代码以后，对一个飞控系统的基本模块：姿态解算、控制解算、混控输出、遥控器处理、嵌入式处理就很明白了。然而这里面有很多技术是需要另外学习的。除了基本的嵌入式编程以外，还有要把大二大三学的信号处理方面的知识再捡起来看看。因为飞行器在空中有振动，会让加速度计产生噪声，为了把这些噪声去除掉，需要对加速度计给出的信号做低通滤波处理，如何选择滤波器的参数呢？如果滤波滤得太狠，延迟就会比较大，对控制的表现会有影响；如果滤波滤得不够，可能会有一些低频的噪声偶尔会出现，导致加速度计的观测不能用。另外最重要的是要理解姿态解算和控制解算这两块知识。chiplab7的飞控板的代码采用的是最简单的互补滤波算法做为姿态解算模块，然后控制解算是对欧拉角的三个角度做闭环PID控制，基本都是基础的基础了。</p><p>第三步：小修小改加深理解</p><p>chiplab7的飞控是靠气压计定高的，飞行效果非常奔放。这时候可以淘宝买个20块钱的超声波模块，然后自己写个高度环去稳定飞控的定高表现。</p><p>我觉得这个过程至关重要，因为高度控制相对来说是个比较直观理解PID控制的方式，而且chiplab7的飞控加高度控制非常好加。工作量不大，因为改善效果很显著，所以可以让人很有成就感，加深继续学习的乐趣。</p><p>第四步：理解核心的数学和控制知识</p><p>这一部分大三是肯定来不及学的，但是我还是在这里列出来，因为这些知识你之后都需要慢慢学，我也会在之后不断重复提到这些知识点。</p><p>姿态解算和控制解算涉及的知识有：</p><ol><li>刚体姿态的表示、运动学方程和动力学方程。主要是对牛顿-欧拉方程的认识和理解、刚体姿态的欧拉角表示法、姿态与角速度的关系等等。</li></ol><p>这部分说复杂不复杂，说简单也不简单，我同样是没有找到一本完整的书全都介绍过的，是学了好几个不同的书和论文以后搞明白的。现在看起来是从维基百科入手比较靠谱。</p><ol start="2"><li>自动控制原理。讲PID的书和文章就多了去了，没有太多复杂的书。</li><li>线性估计基本原理。其实就是互补滤波：<a href="https://link.zhihu.com/?target=http://www.pieter-jan.com/node/11">Reading a IMU Without Kalman: The Complementary Filter</a> 。拿这个关键词百度各种搜就会了。</li></ol><p>第五步：重头开始造轮子</p><p>知乎著名网友vczh曾经说过，学习要抱着勇于造轮子的心态才能进步。所以在熟悉了别人飞控基础上，可以自己重头造一个飞控的轮子。可以自己从芯片开始重新画一个飞控板，读读STM32的芯片手册、读读各种传感器的芯片手册，自己手画一个飞控的原理图、做PCB layout、制板自己焊元件，全套花不了1000块钱，能够加深很多对硬件的理解。这一部分如果大三没空，也可以不搞了。</p><p>制造整个机器人的过程中要特别重视文档的积累。在你大三末期，你可能随着学校的机器人队备战比赛，你可能主力负责一台机器人。你应该自己列一个excel表格，把机器人用了几颗螺丝，几根导线，每个零件的规格是什么，都列出来。这个表格一方面可以用来帮助团队管理机器人的物料，一方面也是你自己的经验技术积累，将来你做的其他机器人可能多多少少都是Robocon、RoboMasters机器人的变形。</p><p>另一个积累是建一个自己的buglist，buglist包括什么呢，可以像冷大这样：<a href="https://www.zhihu.com/question/46824735/answer/115202408?from=profile_answer_card">做控制、机器人等算法工程师是怎样一种体验？ - 冷哲的回答</a>，就简单把一些自己的发生过的问题和最后的解决办法罗列下来。比如说“杜邦线接插位不稳固容易脱开，接好后应该用电工胶布再裹一圈”，“外发给淘宝加工的机械图纸，要特别注意和加工商沟通有没有漏掉一些细节，如沉头螺丝孔，关键的倒角”等等。你也可以帮其他机器人的问题也做这样的记录。buglist可以就是一个简单的文本文件，如果你一直往里面积累自己工作中的记录，等你将来工作了，这个文件可能会值很多钱。</p><p>大三的时候学校应该会开设软件工程的课程。不管你是不是这个专业，上不上这门课，都应该主动去听一听，甚至跟着课程的设计作业一起做一做。软件工程我觉得是机器人工程师必须具备的意识，因为一个机器人系统里涉及大量的硬件系统和软件功能，软件的部分往往还会涉及不同的语言、不同的编译环境、不同的开发工具链。几个人合作的话，大家的专业背景、编程习惯都不相同，这就导致不同的代码和模块之间的协议沟通非常复杂，必须尽早用UML和其他软件工程的工具帮助团队理解和互相沟通。</p><p>大三的时候学校应该还会开设操作系统原理和嵌入式系统原理的课程，而大二的时候讲过计算机组成原理（所谓的微机原理）。从大三开始同学需要开始体会实时操作系统和非实时操作系统的区别、原理以及使用时需要注意的地方。这是一个比较杂的知识点，我目前没有找到很好的教材去介绍。在STM32上，有freeRTOS，uCOS，Vxworks这么几种实时操作系统；Linux是一种非实时操作系统，但是可以通过打补丁变成实时操作系统。这些操作系统的细节在机器人开发中都会多多少少被涉及到，同学们可以随时上Google和CSDN去查大神们的介绍。</p><p>另外特别重要的一点是机器人系统里的嵌入式平台都有烧坏的可能性，有可能在某个嵌入式Linux平台上面辛辛苦苦写了一个多月代码，这个平台突然烧坏了，代码也就丢了。因此你的机器人如果有嵌入式Linux系统在里面，一定要尽早顶起来路由器，代码定时提交SVN或者git。</p><p>大三的暑假你可能会作为学校机器人队的主力去参赛了。备战比赛和参赛是一件磨练心性的事情。我在学生时代体会过和胜利擦肩而过的痛苦，体会过没机会再来一年的遗憾；也在负责大疆RoboMasters比赛的过程中被那些痛苦和遗憾的学生当做发泄的对象，非常有感触。我觉得参加机器人比赛，很努力，然后失败了，是一件让人快速成长的事情。同学如果有机会，一定应该参加至少一届机器人比赛。</p><p>大三的暑假你也可以选择来参加大疆的RoboMasters夏令营，关于夏令营大家可以看这个知乎问答了解更多：<a href="https://www.zhihu.com/question/49986388">参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新</a>。每年我们都在全国范围内寻找有一定技术基础的学生，让他们一起分组做一个自动机器人的挑战。这个夏令营，作为组织负责人，不谦虚地说，我觉得应该是全世界范围内最好的技术类夏令营。</p><p>大三的暑假有一件很重要的事情就是思考自己大四应该干什么。一般来说，你现在的能力保本校研究生肯定没有问题，当然你也可以选择考其他学校的研究生或者出国留学。虽然说你现在能力已经很全面了，但是你还需要2-3年的时间全面提升自己更多的能力，才能迈向卓越之路。不管是出国还是保研，最重要的目的是给自己争取到未来2-3年能够在一个优秀的环境中安心提升自己，有比较好的学习资源，能够参与到一些不错的项目中去。可能其他有些行当，出国留学始终是比在国内待着更好的选择，但是机器人行业并不是这样。我们国家这两年在机器人方面提高也很快，而且我们国家现在比较有钱。就像我开始说的那样，机器人是富人的活动，现在你在国内也能找到一些很有钱的实验室可以造比较牛逼的机器人。另外国外很多比较强的机器人公司也都在做比较敏感的军方项目，去找实习可能比较受限制。</p><p>出国去学机器人学方面的知识你有很多不错的选择，比如世界第一的机器人研究院卡耐基梅隆大学，或者麻省理工学院的CSAIL实验室。北美传统计算机四大名校（麻省理工学院，卡耐基梅隆大学，斯坦福大学，加州大学伯克利分校）里，除了斯坦福大学热火朝天在搞人工智能以外，其他几个学校的机器人研究都很不错。除了四大名校，你还有很多其他的选择，就像我开始说的那样，机器人是富人的活动，如果想接触到最好的机器人资源，你要选择有钱的实验室，而不是有名的实验室。</p><p>另外你还需要在大三的尾巴上选定自己将来的细分研究方向，而且开始往这个方向深挖，也就是我在文章开始提到的感知、认知、行为几个方向。当然同时你也不能放松其他方面的知识，尤其是数学基础。我在大三的暑假专门找数学系的同学给我开了个数学小讲座，学习了一点抽象代数的知识，对我后来学习密码学帮助很大。同时我也读了一些拓扑方面的教材（有一本很神奇的书叫做Topopogy Without Tears <a href="https://link.zhihu.com/?target=http://www.topologywithouttears.net/">http://www.topologywithouttears.net/</a>），这样才理解了为什么数学分析要用奇怪的符号去解释一些看起来很浅显的道理。</p><p>大三阶段的机器人工程师该学什么基础数学是众说纷纭的，在我看来，你要基本掌握“群是什么”，能够用代数的眼光去证明”det(AB) &#x3D; det(A)det(B)”，还要能理解“用一张纸就可以变出克莱因瓶”（当然是在四维空间里）。另外，你这个时候也要能够意识到自己需要再学一遍线性代数。</p><h2 id="大四"><a href="#大四" class="headerlink" title="大四"></a><strong>大四</strong></h2><p>大四开始了，你可以开始深挖自己的研究方向，同时也要开始学一些高级一点的通用技术和理论，这时候你和一般的机械、电子、计算机学生就不太一样了，你虽然也在狂编程，但也在狂学习物理和数学。通用技术包括ROS，simulink，gazebo和Vrep等工具。通用理论包括，再学一遍线性代数，学学凸优化、数值计算、旋转表示法等方面的知识。这些知识你在大四仅仅只能开一个头，因为你的大四要实习、毕业、考研、毕设，你会非常地忙。有些人会在大四进实验室和老师发论文，我个人觉得发论文这件事没必要操之过急。你的整个大学期间应该用在广泛涉猎各种各样的知识上面，而不是深入某一个细小的研究问题。</p><p>大四可以开始读一些著名入门书籍，我把这些书不分先后地列出来，你没有必要全部去读，而且每本书先读前几章就够了，能读多少尽量读多少。</p><ol><li>概率机器人学，<a href="https://link.zhihu.com/?target=https://www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623">https://www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623</a></li><li>凸优化，<a href="https://link.zhihu.com/?target=https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf">https://web.stanford.edu/~boyd&#x2F;cvxbook&#x2F;bv_cvxbook.pdf</a></li><li>线性系统理论，<a href="https://link.zhihu.com/?target=https://www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579">https://www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579</a></li><li>Multiple View Geometry in Computer Vision，<a href="https://link.zhihu.com/?target=http://www.robots.ox.ac.uk/~vgg/hzbook/">Multiple View Geometry in Computer Vision</a></li><li>线性估计，<a href="https://link.zhihu.com/?target=https://www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642">https://www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642</a></li><li>《机器学习》，周志华老师的书。</li><li>An Invitation to 3-D Vision，<a href="https://link.zhihu.com/?target=https://www.eecis.udel.edu/~cer/arv/readings/old_mkss.pdf">https://www.eecis.udel.edu/~cer&#x2F;arv&#x2F;readings&#x2F;old_mkss.pdf</a></li><li>Modern Control Systems，<a href="https://link.zhihu.com/?target=https://www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580">https://www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580</a></li><li>Rigid Body Dynamics，<a href="https://link.zhihu.com/?target=http://authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf">http://authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf</a>。说实话刚体动力学理论我没有找到特别好的书。但是刚体动力学理论很重要。</li><li>Feedback Systems: An Introduction for Scientists and Engineers，<a href="https://link.zhihu.com/?target=http://www.cds.caltech.edu/~murray/amwiki/index.php/Main_Page">FBSwiki</a></li></ol><p>就像我开始说的那样，这些书，大部分特别贵，还好有一些业界良心的作者放出了他们书的电子版。当然你也可以去一些名字都不能说的网站去找影印版。</p><p>在读上面这些书的时候，matlab，python都要放在手边，然后把书里面的知识尽量实践出来。很多教科书里都会在章节后面的习题里放一些写明是用matlab做的习题，要尽量多做一些这样的题。</p><p>你可能早就听说了ROS的大名，但是最好不要在大四之前去碰它。因为ROS用了很多操作系统和网络的底层技术。我在知乎回答<a href="https://www.zhihu.com/question/21958225/answer/20255931">高手可以谈谈ROS机器人操作平台开发的一些经验吗？ - YY硕的回答</a>里有简单的介绍。ROS的设计目标是把机器人的控制和传感器处理的软件和它的硬件隔离开，用上ROS以后，你可以方便地用到很多能直接跑的软件代码。但是ROS从入门到精通需要至少一年以上的时间，你必须不断地用，不断地尝试新的代码和硬件，才能对它熟悉起来。</p><p>ROS的可视化工具Rviz里面对于机器人旋转的表示用的是四元数，而在你之前研究四旋翼飞行器时，里面的代码表示旋转用的是欧拉角，做姿态解算用的可能是四元数。这个时候要开始有意识地去学习旋转表示法之间的区别和联系。</p><p>要重视大四期间的实习和毕业设计。很多大四的学生毕业设计都会非常颓地做一下，我觉得是不好的。要把做毕业设计的过程看做一个正式的项目。这个项目除了做好技术方面的工作，也要做好展示方面的工作。中国工程师的一大特点是，不会表达自己，可能做的东西水平很高，但是做出PPT就会犯字体花哨不正式、一页上面字太多，图文没有联系等表达上的问题。通过PPT介绍、展示自己的成果在工程师的职业生涯的任何一个阶段都非常重要，它甚至也一定程度上限制了机器人工程师能够达到的高度。只有能够把自己的成果清晰地表达给自己的团队，才能获得其他人的反馈、通过沟通提高团队的整体凝聚力和知识水平，这样自己在团队能够获得更多的认可，有助于团队整体工作效率的提高。我每年去参加几次学术会议，都在会议上感觉到一些中国的科研人员走到国际上以后，演讲能力很差就会导致他们的科研成果不受重视。当然其他国家的科研人员也是这样。</p><p>为了写出美观的技术报告和毕业论文，你可以开始学习Latex。Latex作为国际国内第一写作神器，学习资料在网上有很多。Latex的学习和使用同样也是需要不断地熟能生巧，多写多练就熟悉了。写毕业论文有个问题是怎么做出精美的矢量图，我推荐<a href="https://link.zhihu.com/?target=https://inkscape.org/en/">Draw Freely | Inkscape</a>，一个比Illustrator更轻量化、但是有些功能反而更强大的免费软件。</p><p>对于那些想申请出国留学的同学，你要做一个自己个人的成果展示，用网页的形式呈现比较好。把自己Github链接（如果你按我说的，大学第一天就申请Github账号，现在已经是一个三年的老油条了）、做过的机器人视频、写过的技术报告和文章（最好是英文的）放在上面。</p><p>关于毕业设计的选题，我推荐这么几个：</p><ol><li>手写双目视觉里程计。涉及到图像处理、特征匹配、位置解算、空间变换等等。</li><li>手写四旋翼飞行器基于GPS的轨迹规划。涉及到深挖四旋翼飞行器的运动原理、IMU原理、轨迹生成和优化等。</li><li>造一个被推了也不会倒的双足舵机机器人。涉及到舵机控制、倒立摆建模、动力学分析、PID控制、IMU原理等。</li><li>深度学习训练一个小车追人跑。涉及到深度学习工具包使用、数据集采集、数据集分析、小车控制等。</li><li>机械臂给人端茶倒水。这个相对来说土豪一点，因为能直接拿来用的机械臂都很贵，这个要看实验室有没有条件了。涉及到多自由度机械臂原理的学习、工具包的使用、轨迹规划等等。</li></ol><p>这几个项目要做好，都要持续投入三个月以上的时间以及一定的资金，每一个都是理论多于实践。当然同学们自己也可以自己选择自己的毕业设计题目，但是最好还是选做出来能跑能飞的东西，同时避免选择需要花大量时间去拧螺丝、焊板子的题目，尽量买现成的电机、开发板、3D打印结构，大四要多给自己留时间去看书和写代码。</p><p>大四到研究生之前的暑假，最好去一些比较不错的机器人公司实习一下，比如说大疆。当然你也可以继续做机器人比赛，比如RoboMasters和大疆的飞行器比赛。</p><h2 id="研究生一年级"><a href="#研究生一年级" class="headerlink" title="研究生一年级"></a><strong>研究生一年级</strong></h2><p>研究生的时候，你的目标比较清晰了，就是做一种机器人至少两年时间，并从中发掘出可以发表论文的知识点。上面我给出的书单里面，你要开始精读里面的几本。</p><p>如果做机器人视觉定位、传感器融合方面的研究，1、4、5、7四本书一定要精读。</p><p>如果做控制系统的研究，3、8、9、10一定要精读。</p><p>如果做规划算法的研究，那么还要读其他偏CS一些的书，比如讲A* search，random forest，图论方面知识的教材。由于我在这方面造诣不深，就不托大了。</p><p>如果学习随机系统的控制和最优控制，除了1、2、3，还要读一本神书Stochastic models estimation and control（<a href="https://link.zhihu.com/?target=https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf">https://www.cs.unc.edu/~welch&#x2F;kalman&#x2F;media&#x2F;pdf&#x2F;maybeck_ch1.pdf</a>）。</p><p>如果研究机器人视觉定位，几种常用的定位算法：PTAM（<a href="https://link.zhihu.com/?target=http://www.robots.ox.ac.uk/~gk/PTAM/">Parallel Tracking and Mapping for Small AR Workspaces (PTAM)</a>），ROS的标配VO（<a href="https://link.zhihu.com/?target=http://wiki.ros.org/viso2_ros">viso2_ros - ROS Wiki</a>），SVO（<a href="https://link.zhihu.com/?target=https://github.com/uzh-rpg/rpg_svo">GitHub - uzh-rpg&#x2F;rpg_svo: Semi-direct Visual Odometry</a>），LSD-SLAM（<a href="https://link.zhihu.com/?target=http://vision.in.tum.de/research/vslam/lsdslam">http://vision.in.tum.de/research/vslam/lsdslam</a>）ORB-SLAM（<a href="https://link.zhihu.com/?target=https://github.com/raulmur/ORB_SLAM2">GitHub - raulmur&#x2F;ORB_SLAM2: Real-Time SLAM for Monocular, Stereo and RGB-D Cameras, with Loop Detection and Relocalization Capabilities</a>），都必须自己学习之后全部跑一遍。只会用OpenCV的函数和这些工具包并不能说明你会视觉定位，必须要能自己手写出一个能用的才算。国内有一个很厉害的SLAM专家叫高翔，他的博客要关注一下：<a href="https://link.zhihu.com/?target=http://www.cnblogs.com/gaoxiang12/tag/%E6%9C%BA%E5%99%A8%E4%BA%BA/">机器人 - 标签</a>。由于SLAM这两年很火，研究的人很多，所以网上可以参考的资料也很多，比如<a href="https://link.zhihu.com/?target=https://github.com/hcdth011/ROS-Hydro-SLAM">https://github.com/hcdth011/ROS-Hydro-SLAM</a>，就在ROS上实现了几种定位算法的对比。</p><p>我现在非常不建议同学们选择从四旋翼飞行器的动力学控制里找问题作为研究课题。因为四旋翼飞行器的特点已经被研究透了。目前国际上对多旋翼飞行器的研究主要集中在造一些奇葩形状的飞行器，以及给多旋翼飞行器上安装一个机械臂去做力控制，这样做就对多旋翼飞行器控制的动力学造成了一些影响。因此需要同学对动力学和多自由度机械臂控制有比较深的认识。</p><p>自动导航和驾驶是这两年的热点，一方面汽车的自动化是大势所趋，另一方面多旋翼飞行器异军突起，产生了很多对自动飞行的需求。除了机器人视觉定位算法以外，同学还需要学习其他的传感器，以及这些传感器与视觉定位算法怎么融合。这里面有很多坑，比如计算量的问题，怎么保证融合算法不崩，怎么处理传感器的延时等等，都需要同学结合自己的项目去踩，坑踩得多了才能成长。如果大家想找一个多旋翼飞行器平台研究自动导航，我推荐大疆的M100，我已经在知乎回答<a href="https://www.zhihu.com/question/31586826/answer/65274168">RoboMasters2015夏令营是怎样的？ - YY硕的回答</a>里吹过一波M100，前面说过的今年夏令营的知乎回答<a href="https://www.zhihu.com/question/49986388">参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新</a>里也有人帮我吹了一波。</p><p>一些大学里学过的知识点，是必须结合研究生期间的项目的需求弄得很清楚的，比如三大变换（傅里叶变换，拉普拉斯变换，Z变换），旋转表示法（欧拉角、四元数、旋转矩阵），数值计算怎么防止矩阵出现数值问题等等。除了自己的项目，还需要把凸优化、卡尔曼滤波还有多自由度机械臂的控制学习一下。这三个领域的知识，是任何一种机器人都会用的到比较难的知识。</p><p>凸优化和凸优化的各种变形是非常重要的知识，因为各行各业里的研究问题，多半是会建立一个优化问题去解决的。上面提到的《Convex Optimization》<a href="https://link.zhihu.com/?target=https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf">https://web.stanford.edu/~boyd&#x2F;cvxbook&#x2F;bv_cvxbook.pdf</a>，也是一本神书，同学们一定要认真读一读。Matlab、Python、C++都有一些现成的工具包可以帮助你解优化问题，不过最好同学们能自己手写一些基本的优化算法，比如gradient descend，barrier method等等。另外现在主流的SLAM算法，后端都是通过一种叫做g2o的优化算法来出效果的。而且g2o能够整合bundle adjustment 和structure-from-motion这两大计算机视觉里的关键问题，可以说是一种很好的计算思想了，非常有必要学习一下g2o。</p><p>卡尔曼滤波在上面书单里的1和3都有提到，同时在神书Stochastic models estimation and control（<a href="https://link.zhihu.com/?target=https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf">https://www.cs.unc.edu/~welch&#x2F;kalman&#x2F;media&#x2F;pdf&#x2F;maybeck_ch1.pdf</a>）也有相当多的篇幅。卡尔曼滤波有好几种证明的方法，同学最好能自己学会1-2种。</p><p>多自由度的机械臂的难点在于机械臂的运动学正反解、运动学控制和动力学控制，基本是一个建模分析和数值算法实现的问题。如果你所在的学校没有一个财力雄厚的机器人实验室的话，你基本上没有机会接触到多自由度的机械臂。这时候之前学到的Simulink和就要学的Gazebo就派上用场了，你可以用Simscape里面的刚体搭一个多自由度机械臂，然后通过Simulink仿真去学习机械臂的控制；也可以用Gazebo的URDF语言写一个机械臂，然后通过Gazebo和ROS的接口去控制机械臂；也可以用ROS里面的著名工具包<a href="https://link.zhihu.com/?target=http://moveit.ros.org/">MoveIt! Motion Planning Framework</a>，不过MoveIt的问题是，他只能仿真运动学，而不能仿真动力学。工业领域对多自由度的机械臂控制通常用一个叫做D-H表示法的建模工具（<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters">Denavit</a>），这个东西我并不太会。我只会向同学们推荐我导师的著作《A mathematical introduction to robotic manipulation》（<a href="https://link.zhihu.com/?target=http://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf">http://www.cds.caltech.edu/~murray&#x2F;books&#x2F;MLS&#x2F;pdf&#x2F;mls94-complete.pdf</a>）。</p><p>有一个非常神奇的事实：《A mathematical introduction to robotic manipulation》这本机械臂控制领域的著名教材的第二章和计算机视觉领域的著名教材《An Invitation to 3-D Vision》的第二章基本是一样的，都在讲旋转表示法。这是因为所有的旋转表示法都可以归纳为一种优雅的李群结构：SO(3)群。而计算机视觉和机械臂控制都涉及到理解刚体的旋转，事实上用计算系统去观测和控制所有的刚体构成的系统，理解旋转都是很关键的问题。旋转表示法应该作为研究生阶段的一个重要学习的知识点。</p><p>李群和李代数是刚体旋转表示背后的数学理论，如果想要深挖一些，可以看这篇文章An elementary introduction to groups and representations的前50页（<a href="https://link.zhihu.com/?target=http://www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf">http://www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf</a>）。这是我自己读着觉得最好的文章，当然网上也有很多其他的介绍。</p><p>研究生阶段还要培养的一个能力是借助各种工具仿真机器人系统的能力。显然地，很多机器人系统真的造出来的话造价昂贵，需要在实际制造之前写一个比较真实的仿真系统出来测试算法。我觉得做仿真系统的能力直接衡量了机器人工程师的技术水平。当你开始要搭一个仿真系统的时候，第一步是通过欧拉方程和牛顿方程确定刚体的运动特点，甚至要自己写刚体二阶微分方程；第二步是确定刚体之间的互联关系，设计不同类型的关节，如果有软性连接需要加入弹簧阻尼模型；第三步是确定被仿真的刚体系统会不会和外界产生碰撞或者其他形式的力，如果有的话，需要设计合适的接触力和摩擦力仿真的模型。多旋翼飞行器的仿真是很简单的，不需要考虑什么接触力。但是多自由度机械臂基本都需要仿真接触力，不和物理世界去交互的机械臂只有很小的实用意义。而能够自行运动locomotion系统，比如双足、多足机器人，则涉及到更多的接触力，多到接触力都会影响仿真系统的数值稳定性。搭建一个仿真系统需要很强的系统建模能力和数值分析的能力，虽然Simulink、Gazebo、Vrep提供了不同程度的工具简化你的工作，但是要让仿真系统能够稳定运行，必须要能深入其中的细节。有些看起来很高大上的仿真工具，比如Nvida的PhysX，在仿真的时候是忽略掉科里奥利力的，如果不理解仿真的本质，可能就会忽略这一个重要的缺陷。</p><h2 id="研究生二年级"><a href="#研究生二年级" class="headerlink" title="研究生二年级"></a><strong>研究生二年级</strong></h2><p>你的学习计划接近尾声。现在你已经进入了一个很好的状态：看到一个机器人，能够很果断地分析出它用了什么传感器、执行器、计算平台大概是什么量级，他的执行机构能够承受多少力量。看到一个新的算法，能够大约判断清楚它的执行流程，在什么环节做了优化。看到一个新的没学过的知识，能够分析出它和你以前学过的什么知识有联系，你还需要再学什么才能弄明白这个知识点。</p><p>研究生二年级要深化第一年学到的那些技术和知识，要做到完整地读过四五本书，五十篇以上的论文。你已经积累了几万行代码的经验，也能熟练地谈论谁家的电机回差小，谁家的电机线性程度好。</p><p>你这个时候可以去写作一些论文，也可以开始学习一些更高级的技术和工具，比如用FPGA和GPU优化算法、魔改Linux内核、玩玩液压系统、了解更多机器学习的知识比如强化学习等等。你也可以从计算机图形学或者计算力学里面找到一些帮助你更好进行机器人仿真和系统分析的工具。由于你懂很多机器人方面的知识，你可以给学校的机器人队做指导，或者带队参加一些比较有挑战性的机器人比赛。</p><p>写到这里，我就不可能给出很多不同领域的指导了，因为随着学习的进一步深化，我自己熟悉的领域也在收缩。我只能对几个领域给出我的意见。</p><p>对视觉定位和传感器融合来说，SLAM急需新的突破，目前通过几何约束去实现loop closure看起来已经走入了死路，没法有更多的发展了，下一步可行的方向是与深度学习进行结合。具体的一些介绍可以阅读行业中大牛的一篇文章<a href="https://link.zhihu.com/?target=http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html">http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html</a>，记述了几个业界大牛们最新的观点。传感器融合技术，目前还有很多问题可以探索，因为传感器的延时、不均匀的信号，会给定位系统造成困扰，如何去除这些干扰，需要建立比较复杂的非线性优化问题，具体可以关注香港科技大学Shaojie Shen的工作。</p><p>对于多自由度机械手和机器人的locomotion来说，这里面还有非常多可以探索的研究问题。我前面提过接触力和摩擦力很难仿真，大神告诉我现在没有任何一种工具和理论能把接触力和摩擦力正确仿真出来，因此如何在机器人系统里妥善处理对这些力的控制，就是很难的问题了。现在业界的一个前沿发展方向，也是利用机器学习技术来帮助机器人学会处理这些外力，不过人类目前最优秀的多自由度机器人系统，Berkeley的Brett机器人，叠几块积木就要用十分钟（<a href="https://link.zhihu.com/?target=http://news.berkeley.edu/2015/05/21/deep-learning-robot-masters-skills-via-trial-and-error/">New ‘deep learning’ technique enables robot mastery of skills via trial and error</a>），显然还有很多提升的空间。这方面的问题同学可以关注知乎大神</p><p><a href="https://www.zhihu.com/people/70bcce80353eccd2938cbfa2ac856aab">@戴泓楷</a></p><p><a href="https://www.zhihu.com/people/0eeca981bb238839881694643181fa91">@周佳骥</a></p><p>。</p><p>最后我想再强调一遍表达能力的重要性。你可以从自己带的课程和机器人队入手，把自己这几年来学过的知识做成PPT讲给学生们听，然后让他们给你反馈。多做这样的练习，提升自己做演讲的能力，这将来会让你受益匪浅。</p><p>研究生二年级之后，你可以准备进机器人公司工作了，也可以根据你自己感兴趣的研究方向申请博士接着努力。由于你已经掌握了广博的知识和技能，你的职业生涯将会大有作为。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a><strong>结束语</strong></h2><p>我从2008年展开自己的机器人生涯。那一年波士顿动力刚刚发布他们的大狗机器人，Python还是很小众的语言，Ubuntu 8.04还很不稳定，Chrome还没有多少人知道。在之后的几年中我目击了深度神经网络的复兴，看到波士顿动力的机器人日渐强大，经历了ROS的起源和繁荣，帮助了大疆的崛起，深深为这个产业的未来感到激动。我希望这篇文章能够帮助更多的年轻人进入机器人学的海洋，为未来机器人学的继续发展贡献力量。</p>]]></content>
      
      
      <categories>
          
          <category> Robotics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Robotics learning path </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS</title>
      <link href="/2024/01/29/FreeRTOS/"/>
      <url>/2024/01/29/FreeRTOS/</url>
      
        <content type="html"><![CDATA[<p>文档：</p><p><a href="https://rtos.100ask.net/zh/FreeRTOS/DShanMCU-F103/chapter6.html">https://rtos.100ask.net/zh/FreeRTOS/DShanMCU-F103/chapter6.html</a></p><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a><strong>项目介绍</strong></h1><p>裸机:</p><img src="/2024/01/29/FreeRTOS/image-20240116111924666.png" alt="image-20240116111924666" style="zoom:35%;"><p>freerots:</p><img src="/2024/01/29/FreeRTOS/image-20240116112000983.png" alt="image-20240116112000983" style="zoom:35%;"><img src="/2024/01/29/FreeRTOS/image-20240116112750136.png" alt="image-20240116112750136" style="zoom:67%;"><p>涉及到三个项目：音乐播放        打砖块游戏，汽车游戏</p><p><img src="/2024/01/29/FreeRTOS/image-20240116193203709.png" alt="image-20240116193203709"></p><p><img src="/2024/01/29/FreeRTOS/image-20240116201310758.png" alt="image-20240116201310758"></p><p>2-2,2-3讲自己创建一个freertos工程</p><p>从3.1开始正式讲freertos</p><h2 id="创建第一个多任务程序"><a href="#创建第一个多任务程序" class="headerlink" title="创建第一个多任务程序"></a>创建第一个多任务程序</h2><p>不同的嵌入式操作系统，如freertos,rt-thread,它们对相同的一个操作的函数名称不同，为了统一起来，增加了一个接口层cmsis_os ,我们直接用这个文件的函数就行了，这个函数会根据不同的操作系统进行选择相应的代码，这样你写出来的代码既可以运行在freertos也可以在rt-thread上。</p><p>创建工程时默认生成的任务，osThreadNew为cmsis_os中定义的函数</p><p><img src="/2024/01/29/FreeRTOS/image-20240117222125768.png" alt="image-20240117222125768"></p><p>我们要等会要用的是freertos的原生代码去创建任务</p><p><img src="/2024/01/29/FreeRTOS/image-20240117223144328.png" alt="image-20240117223144328"></p><p>在此创建自己的任务函数</p><p><img src="/2024/01/29/FreeRTOS/image-20240117224413771.png" alt="image-20240117224413771"></p><p>在此处创建自己的任务</p><p><img src="/2024/01/29/FreeRTOS/image-20240117224427446.png" alt="image-20240117224427446"></p><h1 id="ARM架构简明教程-硬件架构与汇编指令"><a href="#ARM架构简明教程-硬件架构与汇编指令" class="headerlink" title="ARM架构简明教程_硬件架构与汇编指令"></a>ARM架构简明教程_硬件架构与汇编指令</h1><p>我们去创建一个任务的时候，为什么要指定栈，你理解了栈之后，才能深入理解RTOS的本质，要想理解栈，你得对处理器的架构有所了解</p><p><img src="/2024/01/29/FreeRTOS/image-20240117225222942.png" alt="image-20240117225222942"></p><h2 id="ARM架构"><a href="#ARM架构" class="headerlink" title="ARM架构"></a>ARM架构</h2><p>CPU(计算)， 内存（RAM） ，FLSAH</p><p><strong>RISC</strong></p><p>ARM芯片属于精简指令集计算机(RISC：Reduced Instruction Set Computing)，它所用的指令比较简单，有如下特点：</p><p>① 对<strong>内存</strong>只有<strong>读、写</strong>指令</p><p>② 对于数据的<strong>运算</strong>是在<strong>CPU</strong>内部实现</p><p>③ 使用RISC指令的CPU复杂度小一点，易于设计</p><p><img src="/2024/01/29/FreeRTOS/09_arm.png" alt="09_arm"></p><p>对于上图所示的乘法运算a &#x3D; a * b，</p><p>在RISC中要使用4条汇编指令：</p><p>① 读内存a</p><p>② 读内存b</p><p>③ 计算a*b</p><p>④ 把结果写入内存</p><p><strong>提出问题</strong></p><p>问题：在CPU内部，用什么来保存a、b、a*b ？</p><p><strong>CPU内部寄存器</strong></p><p>CPU, 内存 , FLASH</p><p><img src="/2024/01/29/FreeRTOS/10_cpu.png" alt="10_cpu"></p><p>无论是cortex-M3&#x2F;M4，</p><p>还是cortex-A7，</p><p>CPU内部都有R0、R1、……、R15寄存器；</p><p>它们可以用来“暂存”数据。</p><p><img src="/2024/01/29/FreeRTOS/11_regs.png" alt="11_regs"></p><p>对于R13、R14、R15，还另有用途：</p><p>R13：别名<strong>SP</strong>(Stack Pointer)，栈指针</p><p>R14：别名<strong>LR</strong>(Link Register)，用来保存返回地址</p><p>R15：别名<strong>PC</strong>(Program Counter)，程序计数器，表示当前指令地址，写入新值即可跳转（往PC寄存器写入某个值，它就会跳过去执行对应的代码）</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><ul><li><p>读内存：Load</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line">LDR  R0, [R1, #4]  ; 读地址&quot;R1+4&quot;, 得到的4字节数据存入R0</span><br></pre></td></tr></table></figure></li><li><p>写内存：Stroe</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line">STR  R0, [R1, #4]  ; 把R0的4字节数据写入地址&quot;R1+4&quot;</span><br></pre></td></tr></table></figure></li><li><p>加减</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD R0, R1, R2  ; R0=R1+R2</span><br><span class="line">ADD R0, R0, #1  ; R0=R0+1</span><br><span class="line">SUB R0, R1, R2  ; R0=R1-R2</span><br><span class="line">SUB R0, R0, #1  ; R0=R0-1</span><br></pre></td></tr></table></figure></li><li><p>比较</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMP R0, R1  ; 结果保存在PSR(程序状态寄存器)</span><br></pre></td></tr></table></figure></li><li><p>跳转 (调用函数)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B  main  ; Branch, 直接跳转</span><br><span class="line">BL main  ; Branch and Link, 先把返回地址保存在LR寄存器里再跳转 （1.LR=返回地址（下一条指令），2.PC=调用函数的地址。 往PC寄存器写入某个值，它就会跳过去执行对应的代码）</span><br></pre></td></tr></table></figure><p>局部变量都保存在栈里。</p></li></ul><h3 id="C函数的反汇编"><a href="#C函数的反汇编" class="headerlink" title="C函数的反汇编"></a>C函数的反汇编</h3><p>C函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> a, <span class="keyword">volatile</span> <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> sum;</span><br><span class="line">    sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让Keil生成反汇编：（通过反汇编码，更好的理解栈）</p><p><img src="/2024/01/29/FreeRTOS/默认放置文件夹/Freertos/DShanMCU-F103开发板资料/5_程序源码/02_FreeRTOS程序/04_视频配套的文档/pic/12_keil_dis.png" alt="image-20230822132428937"></p><p>为例方便复制，制作反汇编的指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fromelf  --text  -a -c  --output=xxx.dis  xxx.axf</span><br></pre></td></tr></table></figure><p>C函数add的反汇编代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i.add</span><br><span class="line">add</span><br><span class="line">    0x08002f34:    b503        ..      PUSH     &#123;r0,r1,lr&#125;</span><br><span class="line">    0x08002f36:    b081        ..      SUB      sp,sp,#4</span><br><span class="line">    0x08002f38:    e9dd0101    ....    LDRD     r0,r1,[sp,#4]</span><br><span class="line">    0x08002f3c:    4408        .D      ADD      r0,r0,r1</span><br><span class="line">    0x08002f3e:    9000        ..      STR      r0,[sp,#0]</span><br><span class="line">    0x08002f40:    bd0e        ..      POP      &#123;r1-r3,pc&#125;</span><br></pre></td></tr></table></figure><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><h3 id="堆（heap）"><a href="#堆（heap）" class="headerlink" title="堆（heap）"></a>堆（heap）</h3><p>所谓堆，就是一块空闲的内存，你也可以管理这块内存，从其中取出（malloc）一部分，用完之后再把它释放(free)回去。</p><p>堆，heap，就是一块空闲的内存，需要提供管理函数 </p><ul><li>malloc：从堆里划出一块空间给程序使用</li><li>free：用完后，再把它标记为”空闲”的，可以再次使用</li></ul><h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 (stack)"></a>栈 (stack)</h3><p>栈是RTOS的基础,也是一块内存空间，CPU的SP寄存器指向它，可以用于<strong>函数调用，局部变量，多任务系统里保存现场</strong>，每一个任务都会有自己的栈。栈在内存（RAM）中。</p><p>栈，stack，函数调用时局部变量保存在栈中，当前程序的环境也是保存在栈中 </p><ul><li>可以从堆中分配一块空间用作栈</li></ul><p>提问1：LR被覆盖了，怎么办？</p><img src="/2024/01/29/FreeRTOS/image-20240118193830901.png" alt="image-20240118193830901" style="zoom:80%;"><p>答：在C入口，会首先划分出自己的栈，保存LR进栈里，保存局部变量，在每个函数的入口都会保存LR 以及必要的寄存器，以防后面操作将其覆盖</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g_cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">b_func</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">  a+=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">c_func</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">  a+=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">a_func</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  g_cnt=b_func(a);</span><br><span class="line">  g_cnt=c_func(g_cnt);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i=<span class="number">99</span>;</span><br><span class="line">a_func(i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码里，进入main函数后先调用a函数，然后在a函数中分别调用b,c函数</p><p>下面是对应的反汇编代码</p><p>第9行 BL a_func</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i.main</span><br><span class="line">    main</span><br><span class="line">        0x08000188:    b508        ..      PUSH     &#123;r3,lr&#125;</span><br><span class="line">        0x0800018a:    2063        c       MOVS     r0,#0x63</span><br><span class="line">        0x0800018c:    9000        ..      STR      r0,[sp,#0]</span><br><span class="line">        0x0800018e:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">        0x08000190:    f7ffffde    ....    BL       a_func ; 0x8000150</span><br><span class="line">        0x08000194:    2000        .       MOVS     r0,#0</span><br><span class="line">        0x08000196:    bd08        ..      POP      &#123;r3,pc&#125;</span><br></pre></td></tr></table></figure><p>a_func: 调用了b_func ,c_func</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a_func</span><br><span class="line">    0x08000150:    b501        ..      PUSH     &#123;r0,lr&#125;</span><br><span class="line">    0x08000152:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">    0x08000154:    f000f80c    ....    BL       b_func ; 0x8000170</span><br><span class="line">    0x08000158:    4904        .I      LDR      r1,[pc,#16] ; [0x800016c] = 0x20000004</span><br><span class="line">    0x0800015a:    6008        .`      STR      r0,[r1,#0]</span><br><span class="line">    0x0800015c:    4608        .F      MOV      r0,r1</span><br><span class="line">    0x0800015e:    6800        .h      LDR      r0,[r0,#0]</span><br><span class="line">    0x08000160:    f000f80c    ....    BL       c_func ; 0x800017c</span><br><span class="line">    0x08000164:    4901        .I      LDR      r1,[pc,#4] ; [0x800016c] = 0x20000004</span><br><span class="line">    0x08000166:    6008        .`      STR      r0,[r1,#0]</span><br><span class="line">    0x08000168:    bd08        ..      POP      &#123;r3,pc&#125;</span><br></pre></td></tr></table></figure><p>b_func</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b_func</span><br><span class="line">    0x08000170:    b501        ..      PUSH     &#123;r0,lr&#125;</span><br><span class="line">    0x08000172:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">    0x08000174:    1c80        ..      ADDS     r0,r0,#2</span><br><span class="line">    0x08000176:    9000        ..      STR      r0,[sp,#0]</span><br><span class="line">    0x08000178:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">    0x0800017a:    bd08        ..      POP      &#123;r3,pc&#125;</span><br></pre></td></tr></table></figure><p>c_func</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c_func</span><br><span class="line">        0x0800017c:    b501        ..      PUSH     &#123;r0,lr&#125;</span><br><span class="line">        0x0800017e:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">        0x08000180:    1c80        ..      ADDS     r0,r0,#2</span><br><span class="line">        0x08000182:    9000        ..      STR      r0,[sp,#0]</span><br><span class="line">        0x08000184:    9800        ..      LDR      r0,[sp,#0]</span><br><span class="line">        0x08000186:    bd08        ..      POP      &#123;r3,pc&#125;</span><br></pre></td></tr></table></figure><p>对应的栈区域以及里面的内容</p><img src="/2024/01/29/FreeRTOS/image-20240118204432237.png" alt="image-20240118204432237" style="zoom:80%;"><p>提问2：<strong>局部变量</strong>在栈中是如何分配的？</p><p><img src="/2024/01/29/FreeRTOS/image-20240118231052162.png" alt="image-20240118231052162"></p><p>变量ch,buf,uch这三个变量没加volatile，它们优先使用寄存器来表示（随着变量越来越多，寄存器不够用，就在栈里分配空间）；变量i用了volatile,它在栈里给你分配了空间</p><p>提问3：为什么每个RTOS任务都有自己的栈？</p><p>每个任务都有自己的调用关系，自己的局部变量和现场</p><p><img src="/2024/01/29/FreeRTOS/image-20240119153109460.png" alt="image-20240119153109460"></p><p>​           </p><p>恢复现场：找到任务的结构体，得到任务的栈，SP地址，将寄存器的值从栈里恢复到CPU里面</p><h1 id="FreeRTOS源码结构概述"><a href="#FreeRTOS源码结构概述" class="headerlink" title="FreeRTOS源码结构概述"></a>FreeRTOS源码结构概述</h1><h2 id="FreeRTOS目录结构"><a href="#FreeRTOS目录结构" class="headerlink" title="FreeRTOS目录结构"></a>FreeRTOS目录结构</h2><p>使用STM32CubeMX创建的FreeRTOS工程中，FreeRTOS相关的源码如下:</p><p><img src="/2024/01/29/FreeRTOS/image1.png" alt="img"></p><p>主要涉及2个目录：</p><ul><li>Core <ul><li>Inc目录下的FreeRTOSConfig.h是配置文件</li><li>Src目录下的freertos.c是STM32CubeMX创建的默认任务</li></ul></li><li>Middlewares\Third_Party\FreeRTOS\Source <ul><li>根目录下是<strong>核心文件</strong>，这些文件是通用的</li><li>portable目录下是移植时需要实现的文件 <ul><li>目录名为：[compiler]&#x2F;[architecture]</li><li>比如：RVDS&#x2F;ARM_CM3，这表示cortexM3架构在RVDS工具上的移植文件</li></ul></li></ul></li></ul><p>7.2核心文件 FreeRTOS的<strong>最核心</strong>文件只有2个：</p><ul><li><p>FreeRTOS&#x2F;Source&#x2F;tasks.c</p></li><li><p>FreeRTOS&#x2F;Source&#x2F;list.c</p><p>其他文件的作用也一起列表如下：</p><p><img src="/2024/01/29/FreeRTOS/image2.jpg" alt="image2"></p></li></ul><h2 id="移植时涉及的文件"><a href="#移植时涉及的文件" class="headerlink" title="移植时涉及的文件"></a>移植时涉及的文件</h2><p>移植FreeRTOS时涉及的文件放在 <strong>FreeRTOS&#x2F;Source&#x2F;portable&#x2F;[compiler]&#x2F;[architecture]</strong> 目录下，比如：RVDS&#x2F;ARM_CM3，这表示cortexM3架构在RVDS或Keil工具上的移植文件。 里面有2个文件：</p><ul><li>port.c</li><li>portmacro.h</li></ul><h2 id="头文件相关"><a href="#头文件相关" class="headerlink" title="头文件相关"></a><strong>头文件相关</strong></h2><p> 头文件目录</p><p>FreeRTOS需要3个头文件目录：</p><ul><li>FreeRTOS本身的头文件：</li></ul><p>Middlewares\Third_Party\FreeRTOS\Source\include</p><ul><li>移植时用到的头文件：</li></ul><p>Middlewares\Third_Party\FreeRTOS\Source\portable[compiler][architecture]</p><ul><li>含有配置文件FreeRTOSConfig.h的目录：Core\Inc</li></ul><p> 头文件</p><p>列表如下：</p><p><img src="/2024/01/29/FreeRTOS/image3.jpg" alt="image3"></p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong>内存管理</strong></h2><p>文件在Middlewares\Third_Party\FreeRTOS\Source\portable\MemMang下，它也是放在“portable”目录下，表示你可以提供自己的函数。</p><p>源码中默认提供了5个文件，对应内存管理的5种方法。</p><p>后续章节会详细讲解。</p><p><img src="/2024/01/29/FreeRTOS/image4.jpg" alt="image4"></p><h2 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h2><p>在Core\Src\main.c的main函数里，初始化了FreeRTOS环境、创建了任务，然后启动调度器。源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Init scheduler */</span></span><br><span class="line">  osKernelInitialize();  <span class="comment">/* 初始化FreeRTOS运行环境 */</span></span><br><span class="line">  MX_FREERTOS_Init();    <span class="comment">/* 创建任务 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Start scheduler */</span></span><br><span class="line">  osKernelStart();       <span class="comment">/* 启动调度器 */</span></span><br></pre></td></tr></table></figure><h2 id="数据类型和编程规范"><a href="#数据类型和编程规范" class="headerlink" title="数据类型和编程规范"></a>数据类型和编程规范</h2><p><strong>数据类型</strong></p><p>每个移植的版本都含有自己的portmacro.h头文件，里面定义了2个数据类型：</p><ul><li>TickType_t： <ul><li>FreeRTOS配置了一个周期性的时钟中断：Tick Interrupt</li><li>每发生一次中断，中断次数累加，这被称为tick count</li><li>tick count这个变量的类型就是TickType_t</li><li>TickType_t可以是16位的，也可以是32位的</li><li>FreeRTOSConfig.h中定义configUSE_16_BIT_TICKS时，TickType_t就是uint16_t</li><li>否则TickType_t就是uint32_t</li><li>对于32位架构，建议把TickType_t配置为uint32_t</li></ul></li><li>BaseType_t： <ul><li>这是该架构最高效的数据类型</li><li>32位架构中，它就是uint32_t</li><li>16位架构中，它就是uint16_t</li><li>8位架构中，它就是uint8_t</li><li><strong>BaseType_t通常用作简单的返回值的类型，还有逻辑值，比如pdTRUE&#x2F;pdFALSE</strong></li><li><strong>在 RTOS 中，函数的返回值不仅仅局限于0、1和-1这样的简单逻辑值，它还可能表示优先级、任务句柄等多种信息，这些信息在某些情况下可能需要用到较大的数据宽度。因此，使用 <code>BaseType_t</code> 可以灵活适应各种情况。</strong></li></ul></li></ul><p><strong>变量名</strong></p><p>变量名有前缀：</p><p><img src="/2024/01/29/FreeRTOS/image5.jpg" alt="image5"></p><p><strong>函数名</strong></p><p>函数名的前缀有2部分：返回值类型、在哪个文件定义。</p><p><img src="/2024/01/29/FreeRTOS/image6.jpg" alt="image6"></p><p><strong>宏的名</strong></p><p>宏的名字是大小，可以添加小写的前缀。前缀是用来表示：宏在哪个文件中定义。</p><p><img src="/2024/01/29/FreeRTOS/image7.jpg" alt="image7"></p><p>通用的宏定义如下：</p><p><img src="/2024/01/29/FreeRTOS/image8.jpg" alt="image8"></p><h2 id="内存分配（栈）"><a href="#内存分配（栈）" class="headerlink" title="内存分配（栈）"></a>内存分配（栈）</h2><p>为了让FreeRTOS更容易使用，这些内核对象一般都是动态分配：用到时分配，不使用时释放。使用内存的动态管理功能，简化了程序设计：不再需要小心翼翼地提前规划各类对象，简化API函数的涉及，甚至可以减少内存的使用。</p><p>注意：我们经常”堆栈”混合着说，其实它们不是同一个东西：</p><ul><li><p>堆，heap，就是一块空闲的内存，需要提供管理函数 </p><ul><li>malloc：从堆里划出一块空间给程序使用</li><li>free：用完后，再把它标记为”空闲”的，可以再次使用</li></ul></li><li><p>栈，stack，函数调用时局部变量保存在栈中，当前程序的环境也是保存在栈中 </p><ul><li>可以从堆中分配一块空间用作栈</li></ul><img src="/2024/01/29/FreeRTOS/Temp\Temp\image1.png" alt="image1" style="zoom:80%;"></li></ul><p>FreeRTOS中内存管理的接口函数为：pvPortMalloc 、vPortFree，对应于C库的malloc、free。</p><p>cubemx中关于栈的配置：</p><img src="/2024/01/29/FreeRTOS/image-20240120112427199.png" alt="image-20240120112427199" style="zoom:67%;"><p><img src="/2024/01/29/FreeRTOS/image-20240120113241290.png" alt="image-20240120113241290"></p><p>用一个ucHeap数组来表示堆</p><p><img src="/2024/01/29/FreeRTOS/image-20240120112644538.png" alt="image-20240120112644538"></p><img src="/2024/01/29/FreeRTOS/image-20240120113523411.png" alt="image-20240120113523411" style="zoom:80%;"><p>heap4会合并相邻的空闲buffer，所以可解决碎片问题，一般都有heap4，如果有多块内存用heap5</p><p><img src="/2024/01/29/FreeRTOS/image-20240120114435751.png" alt="image-20240120114435751"></p><p>比如你想知道你分配的3072字节的栈空间够不够用，你可以让程序跑一段时间，然后调用这个函数来看看，如果它接近个位数或十位数，则容量很危险，我们要把栈空间分配大一点</p><h1 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h1><p>三要素：函数，栈，优先级</p><p>TCB:任务控制块（任务结构体）</p><p>任务控制块(TCB)通常包含了以下内容：</p><ul><li>任务堆栈指针：指向任务堆栈的顶部。</li><li>任务优先级：表示该任务的优先级等级。</li><li>任务状态：如运行、就绪、阻塞、挂起等。</li><li>延时计数器和超时时间：用于处理任务延时和超时唤醒。</li><li>其他可能的信息：如任务入口函数地址、任务ID或名称等。</li></ul><p>当创建一个新任务时，FreeRTOS会为该任务分配并初始化一个TCB，并返回这个TCB的指针作为任务句柄。这样，在后续操作中，通过任务句柄就能间接访问和修改对应任务的所有信息。</p><h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><p>a.动态分配</p><p><img src="/2024/01/29/FreeRTOS/image-20240120162524684.png" alt="image-20240120162524684"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">( TaskFunction_t pxTaskCode, <span class="comment">// 函数指针, 任务函数</span></span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, <span class="comment">// 任务的名字</span></span></span><br><span class="line"><span class="params">                        <span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="comment">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class="line"><span class="params">                        <span class="type">void</span> * <span class="type">const</span> pvParameters, <span class="comment">// 调用任务函数时传入的参数</span></span></span><br><span class="line"><span class="params">                        UBaseType_t uxPriority,    <span class="comment">// 优先级</span></span></span><br><span class="line"><span class="params">                        TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span>; <span class="comment">// 任务句柄, 以后使用它来操作这个任务</span></span><br></pre></td></tr></table></figure><p>pxTaskCode: 函数指针，指向我们的任务函数，在这里写我们自己写的任务函数的函数名。</p><p>pcName：任务名，没啥用，自己随便取，eg:  “LightTask”</p><p>usStackDepth: 栈大小，单位为字(word),一个字的大小取决于计算机处理器的位数。在大多数现代计算机中，一个字的大小通常是32位或64位，也就是说，一个字的大小通常是4个字节或8个字节。</p><p>pvParameters: 调用任务函数时传入的参数，即pxTaskCode的参数，如果它没有参数，直接写NULL就行</p><p>uxPriority：优先级范围：0~(configMAX_PRIORITIES – 1) 数值越小优先级越低， 如果传入过大的值，xTaskCreate会把它调整为(configMAX_PRIORITIES – 1)</p><p>pxCreatedTask：用于保存 xTaskCreate 的输出结果，即任务的句柄（task handle）。如果以后需要对该任务进行操作，如修改优先级，则需要使用此句柄。如果不需要使用该句柄，可以传入 NULL。</p><p>返回值：成功时返回 pdPASS，失败时返回 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY ，<strong>BaseType_t</strong>通常用作简单的返回值的类型、</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t xSoundTaskHandle;<span class="comment">//任务句柄</span></span><br><span class="line">BaseType_t ret;<span class="comment">//分辨任务的返回值,判断任务是否创建成功</span></span><br><span class="line"></span><br><span class="line">ret=xTaskCreate(PlayMusic,<span class="string">&quot;SoundTask&quot;</span>,<span class="number">128</span>,<span class="literal">NULL</span>,osPriorityNormal,xSoundTaskHandle);</span><br></pre></td></tr></table></figure><p>b.静态分配</p><p><img src="/2024/01/29/FreeRTOS/image-20240120162811825.png" alt="image-20240120162811825"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t <span class="title function_">xTaskCreateStatic</span> <span class="params">( </span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,   <span class="comment">// 函数指针, 任务函数</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,   <span class="comment">// 任务的名字</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth, <span class="comment">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * <span class="type">const</span> pvParameters,   <span class="comment">// 调用任务函数时传入的参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,      <span class="comment">// 优先级</span></span></span><br><span class="line"><span class="params">    StackType_t * <span class="type">const</span> puxStackBuffer, <span class="comment">// 静态分配的栈，就是一个buffer</span></span></span><br><span class="line"><span class="params">    StaticTask_t * <span class="type">const</span> pxTaskBuffer <span class="comment">// 静态分配的任务结构体的指针，用它来操作这个任务</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>pxTaskCode: 函数指针，指向我们的任务函数，在这里写我们自己写的任务函数的函数名。</p><p>pcName：任务名，没啥用，自己随便取，eg:  “LightTask”</p><p>ulStackDepth: 栈大小，值是你提前分配的栈（puxStackBuffer）所对应的大小,单位为字；<code>ulStackDepth</code>  在FreeRTOS中的单位通常根据具体平台和编译器的字长来确定。在32位架构下，一个“字”通常是32位，在16位架构下，则是16位。因此，当提到任务堆栈深度时，如果没有特别说明，可以根据目标处理器架构默认为该架构下的“字”长度。例如，在32位架构中，如果 <code>ulStackDepth</code> 设置为100，则意味着为任务分配了400字节（100 * 4）的堆栈空间。</p><p>pvParameters: 调用任务函数时传入的参数，即pxTaskCode的参数，如果它没有参数，直接写NULL就行</p><p>uxPriority：优先级范围：0~(configMAX_PRIORITIES – 1) 数值越小优先级越低， 如果传入过大的值，xTaskCreate会把它调整为(configMAX_PRIORITIES – 1)</p><p>puxStackBuffer:一个指向预分配的静态任务堆栈缓冲区的指针。这意味着开发者需要自己管理内存，而不是由系统动态分配。比如可以传入一个数组， 它的大小是usStackDepth*4。</p><p>pxTaskBuffer: 指向一个静态任务控制块（TCB）结构体的指针（StaticTask_t 是一个<strong>结构体</strong>类型，它就是TCB））。同样，这里要求开发者预先分配好存储TCB的空间。</p><p>返回值：成功时返回 pdPASS，失败时返回 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY ，<strong>BaseType_t</strong>通常用作简单的返回值的类型</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> StackType_t g_pucStackOfLightTask[<span class="number">128</span>*<span class="number">4</span>?];</span><br><span class="line"><span class="type">static</span> StaticTask_t g_TCBofLightTask;</span><br><span class="line"><span class="type">static</span> TaskHandle_t xLightTaskHandle;<span class="comment">//任务句柄</span></span><br><span class="line"></span><br><span class="line">xLightTaskHandle=xTaskCreateStatic(Led_Test,<span class="string">&quot;LightTask&quot;</span>,<span class="number">128</span>,<span class="literal">NULL</span>,osPriorityNormal,g_pucStackOfLightTask,&amp;g_TCBofLightTask);</span><br></pre></td></tr></table></figure><p><em><strong>疑惑：ulStackDepth和puxStackBuffer值的关系？</strong></em></p><h3 id="估算栈的大小"><a href="#估算栈的大小" class="headerlink" title="估算栈的大小"></a>估算栈的大小</h3><p>确定栈的大小并不容易，通常是根据估计来设定。精确的办法是查看反汇编代码。</p><p><strong>栈里面保存的东西：</strong></p><p><em><strong>1.返回地址LR寄存器，其它寄存器</strong></em>：取决于<strong>函数调用深度</strong>，一般选取最复杂的调用关系来计算</p><p><strong>理论上最多要保存的寄存器（9个）：</strong></p><p><img src="/2024/01/29/FreeRTOS/image-20240130114439040.png" alt="image-20240130114439040"></p><p>可以通过汇编代码查看函数保存的寄存器：</p><p><img src="/2024/01/29/FreeRTOS/image-20240130114341787.png" alt="image-20240130114341787"></p><p>eg: A-&gt;B-&gt;C-&gt;D-&gt;E       5级调用*（被调用者寄存器R4~R11 共8个，LR寄存器，总计9个）</p><p>5x9x4&#x3D;180</p><p>我们可以得出：调用深度越深，需要的栈越大。</p><p>但是用到栈最大的情况不一定是在最深的调用关系这里出现，可能一个函数里定义了一个巨大的局部变量，你得去看你的代码，找到使用局部变量最多的函数</p><p><em><strong>2.局部变量：</strong></em>取决于你的代码，比如你用了一个char buf[1000]</p><p><em><strong>3.现场：</strong></em>16x4 &#x3D;64 (16个寄存器)</p><p>通过1，2，3 你就可以大概估计出你这个程序用到的栈最大有多少，当然最精确的就是去看反汇编。</p><p>实例估计：</p><p><img src="/2024/01/29/FreeRTOS/image-20240130115953696.png" alt="image-20240130115953696"></p><p>4层调用:4x9x4&#x3D;144</p><p>局部变量： MUSI_Analysis()函数里有两个局部变量，4个字节，PassiveBuzzer_Set_Freq_Duty函数里有一个结构体，28字节。共计32字节</p><img src="/2024/01/29/FreeRTOS/image-20240130120203126.png" alt="image-20240130120203126" style="zoom:50%;"><p>现场：64字节</p><p>用到的栈约等于：144+32+64&#x3D;250字节</p><p>我们提供的栈是128字，即128*4字节&gt;250，所以粗略估算是够用的。</p><p><img src="/2024/01/29/FreeRTOS/image-20240130120504361.png" alt="image-20240130120504361"></p><p>精确计算栈的大小以后再说。</p><h3 id="创建任务-使用任务参数"><a href="#创建任务-使用任务参数" class="headerlink" title="创建任务_使用任务参数"></a>创建任务_使用任务参数</h3><p>创建两个任务，使用同一个函数，在LCD上打印不一样的信息</p><p><img src="/2024/01/29/FreeRTOS/image-20240131094453190.png" alt="image-20240131094453190"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  <span class="type">uint8_t</span> x;</span><br><span class="line">  <span class="type">uint8_t</span> y;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task1Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;Task1&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task2Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;Task2&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> <span class="title">g_Task3Info</span> =</span> &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="string">&quot;Task3&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_LCDCanUse = <span class="number">1</span>;<span class="comment">/*定义一个全局变量来互斥访问LCD*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdPrintTask</span><span class="params">(<span class="type">void</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TaskPrintInfo</span> *<span class="title">pInfo</span> =</span> params;</span><br><span class="line">  <span class="type">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*打印信息*/</span></span><br><span class="line">    <span class="keyword">if</span> (g_LCDCanUse)</span><br><span class="line">    &#123;</span><br><span class="line">      g_LCDCanUse = <span class="number">0</span>;</span><br><span class="line">      len = LCD_PrintString(pInfo-&gt;x, pInfo-&gt;y, pInfo-&gt;name);</span><br><span class="line">      len += LCD_PrintString(len, pInfo-&gt;y, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">      LCD_PrintSignedVal(len, pInfo-&gt;y, cnt++);</span><br><span class="line">      g_LCDCanUse = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mdelay(<span class="number">500</span>);<span class="comment">//没有添加这句时，其他任务没办法在屏幕上打印信息，比如任务3执行到中间被切换出去，此时g_LCDCanUse是0，其他任务进来也无法执行打印，当任务3执行完g_LCDCanUse=1,由于没有延时，瞬间g_LCDCanUse再次被赋值为0.这样当切换到其他任务时，还是不能运行，就导致只有一个task3执行了打印任务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xTaskCreate(LcdPrintTask, <span class="string">&quot;task1&quot;</span>, <span class="number">128</span>, &amp;g_Task1Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">xTaskCreate(LcdPrintTask, <span class="string">&quot;task2&quot;</span>, <span class="number">128</span>, &amp;g_Task2Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">xTaskCreate(LcdPrintTask, <span class="string">&quot;task3&quot;</span>, <span class="number">128</span>, &amp;g_Task3Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>提问：如何互斥地访问LCD?使用全局变量，大概率可以，但不是万无一失</p><p>提问：为何是后面创建的task3先运行？</p><h3 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h3><p>用遥控器删除任务</p><p>功能为：</p><p>当监测到遥控器的播放按键按下时，创建音乐播放任务</p><p>当监测到遥控器的Power案件按下后，删除音乐播放任务</p><p>删除任务时使用的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t xTaskToDelete )</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>pvTaskCode</td><td>任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。 也可传入NULL，这表示删除自己。</td></tr></tbody></table><p>怎么删除任务？举个不好的例子：</p><ul><li>自杀：vTaskDelete(NULL)</li><li>被杀：别的任务执行vTaskDelete(pvTaskCode)，pvTaskCode是自己的句柄</li><li>杀人：执行vTaskDelete(pvTaskCode)，pvTaskCode是别的任务的句柄</li></ul><p>一句话就是你要删除哪个任务，就传入这个任务的句柄到该函数s</p><p>提问：频繁的创建，删除任务，好吗？有什么坏处？</p><p>频繁的动态分配内存，释放内存，容易产生内存碎片，多次执行之后可能就分配不到内存了</p><p>不能简单的删除一个任务，然后就不管一些后续的清理工作了，要初始化到原来的状态。实际上一般删除任务用的较少，可以直接让任务读取这遥控器，让它自己去停止，做一些清除工作。</p><h3 id="优先级与阻塞"><a href="#优先级与阻塞" class="headerlink" title="优先级与阻塞"></a>优先级与阻塞</h3><p>前言：</p><p>在之前的程序里，播放音乐的时候效果都比较差，会慢半拍，比较卡顿，只要我们把其它任务注释掉就比较顺畅。</p><p>提高音乐播放器的优先级，使用<strong>vTaskDelay</strong>进行延时，就可以改善播放器效果，同时让其它任务不受影响s。</p><p>首先，我们让音乐播放的优先级+1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = xTaskCreate(PlayMusic, <span class="string">&quot;SoundTask&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, osPriorityNormal+<span class="number">1</span>, &amp;xSoundTaskHandle);</span><br></pre></td></tr></table></figure><p>现象：其他任务都不动了，而且按power键删除不了播放音乐任务</p><p>这是因为我们创建了一个高优先级的任务，它一直在运行，独占CPU</p><p>我们要修改这个高优先级的任务，让它在运行过程中主动放弃CPU资源，不再参与调度</p><p>将mdelay替换为vTaskDelay,在延时的过程中它不会参与调度。</p><p>内部机制：</p><h2 id="（重要）任务状态与调度理论"><a href="#（重要）任务状态与调度理论" class="headerlink" title="（重要）任务状态与调度理论"></a>（重要）任务状态与调度理论</h2><p>eg:实现音乐的暂停与继续播放</p><h3 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h3><p><strong>Running</strong>运行状态</p><p><strong>Ready</strong>就绪状态：当创建一个任务后，它就处于就绪状态</p><p><strong>Blocked</strong>阻塞状态(等待某些event) : 一个处于running状态的函数，当用vTaskDelay时，变成Blocked阻塞状态</p><p><strong>Suspend</strong>暂停状态：可以自己调用（必处于running状态）vTaskSuspend()函数，把自己放入暂停状态，或者由别的任务来调用该函数，把你放入暂停状态，别人处于running状态，你处于ready或blocked状态</p><p><img src="/2024/01/29/FreeRTOS/image13.png" alt="image13"></p><h3 id="任务管理与调度机制"><a href="#任务管理与调度机制" class="headerlink" title="任务管理与调度机制"></a>任务管理与调度机制</h3><p>P22 这节是很重要的<strong>理论</strong>介绍，好好体会</p><p><strong>调度：</strong></p><p>1.相同优先级的任务轮流运行。</p><p>2.最高优先级的任务先运行。</p><p><strong>高优先级的任务未执行完，低优先级的任务则无法运行</strong></p><p><strong>一旦高优先级的任务就绪，会马上运行，低优先级任务立刻停止</strong></p><p><strong>最高优先级的任务有多个，则它们轮流运行</strong></p><p>核心：<em><strong>链表</strong></em></p><img src="/2024/01/29/FreeRTOS/image-20240131203358178.png" alt="image-20240131203358178" style="zoom:67%;"><img src="/2024/01/29/FreeRTOS/image-20240131203658884.png" alt="image-20240131203658884" style="zoom:67%;"><p>pxReadyTasksLists[N],存放优先级为N的处于Ready&#x2F;Running状态的任务的TCB结构体</p><p><img src="/2024/01/29/FreeRTOS/image-20240131211122969.png" alt="image-20240131211122969"></p><p>阅读代码会发现有一个全局指针pxCurrentTCB,每创建一个任务时该指针都指向它，启动调度器后，由于全局指针指向的是最后创建的这个任务，所以先从它这里执行（这就是06节后面创建的task3反而先运行的原因）</p><p><strong>TICK中断</strong>：FREERTOS定义了一个时钟，TICK_RATE_HZ，cubemx中可以看到频率为1000，即1ms产生一次中断（Tick中断）</p><p>中断里会发生：</p><p>   1.cnt++ </p><p>   2.判断DelayedTaskList里任务是否可以恢复，如果时间到了，就把它移到就绪链表，发起调度</p><p>   3.发起调度</p><p><strong>发起调度</strong>：从高优先级到低来开始遍历链表数组，直到找到一个非空链表，找到下一个要运行的任务（当前指针所指向任务的下一个），然后运行该任务，直到1ms后再次发生TICK中断。</p><p>当StartfaultTask检测到播放按键被按下，创建了一个优先级更高的任务，则该任务会立即运行，当执行到<strong>vTaskDelay</strong>(2)，则进入<strong>阻塞</strong>状态，阻塞2个TICK，它被从ReadyTaskList链表数组中删除，放到xDelayedTaskList链表数组中，主动放弃运行了，则触发调度，又去遍历链表数组，链表里有一个记录项index，会记录上一次运行的任务，则会从下一个任务来运行。当两个TICK到了，会判断DelayTaskList里任务是否可恢复，把他移出去，重新放入ReadList[25],然后开始发起调度。当被<strong>suspend挂起</strong>时，它会把你从ReadyTaskList链表里移出来,放到xSuspendedTaskList,当Resume时，则移出xSuspendTaskList，重新放到ReadyList</p><p><img src="/2024/01/29/FreeRTOS/image-20240131214952447.png" alt="image-20240131214952447"></p><p><img src="/2024/01/29/FreeRTOS/image-20240131215227772.png" alt="image-20240131215227772"></p>]]></content>
      
      
      <categories>
          
          <category> embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog Building</title>
      <link href="/2024/01/28/blog-building/"/>
      <url>/2024/01/28/blog-building/</url>
      
        <content type="html"><![CDATA[<p>前言：之前一直想搭个博客，但是本身自己专业也不是学计算机的，从0开始搭建网站对于我的学习成本较高，就不了了之了，偶然发现了基于hexo框架+github的方式来搭建博客，参考了很多教程及视频，不是一帆风顺，也有好几次要放弃了，最后还是遇到问题就解决问题，到网上查资料，经过几天的努力,最后搭建了这个博客，目前差不多是个雏形，后面还会继续优化，在此写下这篇文档，记录下当时参考的一些资料文档。</p><h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><p>参考教程</p><p><a href="http://t.csdnimg.cn/ocJp5">http://t.csdnimg.cn/ocJp5</a></p><p><a href="http://t.csdnimg.cn/8707P">http://t.csdnimg.cn/8707P</a></p><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  <span class="comment">//清除缓存文件（包括生成的静态文件和草稿）。</span></span><br><span class="line"></span><br><span class="line">hexo g     <span class="comment">//生成静态文件，即将你的文章、页面等转换为 HTML 等静态文件。</span></span><br><span class="line">    </span><br><span class="line">hexo s<span class="comment">//启动服务器，用于预览博客效果。</span></span><br><span class="line"></span><br><span class="line">hexo d<span class="comment">//部署博客到指定的服务器，比如 GitHub Pages 或者 CSDN 等。</span></span><br></pre></td></tr></table></figure><h2 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h2><p>参考教程：</p><p><a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><p><a href="https://blog.csdn.net/mjh1667002013/article/details/129290903">https://blog.csdn.net/mjh1667002013/article/details/129290903</a></p><p>【使用Hexo搭建个人博客手摸手教学(8)|butterfly主题页面配置】 <a href="https://www.bilibili.com/video/BV1Fb4y1r7ja/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1Fb4y1r7ja/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></p><p>【【Hexo】2023年零基础玩转Hexo全网最全系列】 <a href="https://www.bilibili.com/video/BV1QD4y1F7pc/?share_source=copy_web&vd_source=4eaa4760820b4cda603e510d556578ac">https://www.bilibili.com/video/BV1QD4y1F7pc/?share_source=copy_web&amp;vd_source=4eaa4760820b4cda603e510d556578ac</a></p><h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><h4 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;我的第一篇博客&quot;</span> <span class="comment">//新建一篇文章。</span></span><br></pre></td></tr></table></figure><p>​然后打开D:\Hexo\source\ _posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。<br>​你可以会直接在vscode里面编写这个markdown文件，可以实时预览，也可以用用其他编辑md文件的软件的工具编写。<br>​编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p><h4 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h4><p>修改<strong>主题</strong>配置文件 <code>_config.butterfly.yml</code>（在你用的那个主题的文件夹里的config文件修改）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">menu:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">list||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">    <span class="attr">link:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">    <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br><span class="line">  <span class="attr">Picture:</span> <span class="string">/gallery</span> <span class="string">||</span> <span class="string">fa-solid</span> <span class="string">fa-image</span></span><br></pre></td></tr></table></figure><p>最左侧的即是展示在网站右上侧的导航栏的各栏的名称,右边是对应的md文件,可以在其中修改该界面的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: zhixiong<span class="number">&#x27;</span>s page<span class="comment">//网页标题</span></span><br><span class="line">date: <span class="number">2024</span><span class="number">-01</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">30</span>:<span class="number">52</span></span><br><span class="line">type: <span class="string">&quot;tags&quot;</span></span><br><span class="line">top_img: <span class="string">&quot;./images/3.jpg&quot;</span> <span class="comment">//该网页最上方的图片</span></span><br></pre></td></tr></table></figure><p>然后后面的fa fa-link这种，是导航栏各个栏目的图标, 以及侧方个人信息栏社交图标，可在<a href="https://fontawesome.com/">https://fontawesome.com/</a> 查找使用。</p><h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><p><strong>上传图像</strong></p><p><em>网页图像</em></p><p>例 archive_img: <a href="http://www.xf5z.com/uploads/2013010764676533.jpg">http://www.xf5z.com/uploads/2013010764676533.jpg</a>   (右键图片，点击复制图片地址)</p><p><em>本地图像</em></p><p>index_img: “.&#x2F;images&#x2F;1.jpg”   (在source里建了个images文件夹，里面存放图片)</p><p><strong>Typora与hexo图片上传问题</strong></p><p><a href="https://www.cnblogs.com/yinyoupoet/p/13287385.html">https://www.cnblogs.com/yinyoupoet/p/13287385.html</a></p><p><strong>相册</strong></p><p><a href="https://www.bilibili.com/video/BV1Fw411Q7pS/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=a9d487fcf1a579639c6348eb5a9321db">https://www.bilibili.com/video/BV1Fw411Q7pS/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&amp;vd_source=a9d487fcf1a579639c6348eb5a9321db</a></p><p><a href="https://butterfly.js.org/posts/4aa8abbe/#Gallery%E7%9B%B8%E5%86%8A%E5%9C%96%E5%BA%AB">https://butterfly.js.org/posts/4aa8abbe/#Gallery%E7%9B%B8%E5%86%8A%E5%9C%96%E5%BA%AB</a></p><h4 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h4><p><a href="https://blog.csdn.net/qq_45173404/article/details/122877378">https://blog.csdn.net/qq_45173404/article/details/122877378</a></p><p>取消当前页面评论:</p><p>在md文件中加上comments: false</p><h4 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a>音乐播放器</h4><p><a href="https://butterfly.js.org/posts/507c070f/?highlight=apla">https://butterfly.js.org/posts/507c070f/?highlight=apla</a></p><h4 id="自定义侧边栏"><a href="#自定义侧边栏" class="headerlink" title="自定义侧边栏"></a>自定义侧边栏</h4><p><a href="https://butterfly.js.org/posts/ea33ab97/#widget-%E6%8E%92%E5%BA%8F">https://butterfly.js.org/posts/ea33ab97/#widget-%E6%8E%92%E5%BA%8F</a></p><h4 id="动态彩带"><a href="#动态彩带" class="headerlink" title="动态彩带"></a>动态彩带</h4><p>好看的彩带背景，会飘动。<br> 修改主题配置文件<code>_config.butterfly.yml</code>。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">canvas_fluttering_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># false 手机端不显示 true 手机端显示</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="文章分类"><a href="#文章分类" class="headerlink" title="文章分类"></a>文章分类</h4><p><a href="http://t.csdnimg.cn/Uc0Uy">http://t.csdnimg.cn/Uc0Uy</a></p><p>把文章归入分类只需在文章的顶部标题下方添加<code>categories</code>字段，即可自动创建分类名并加入对应的分类中。</p><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>把文章添加标签只需在文章的顶部标题下方添加<code>tags</code>字段，即可自动创建标签名并归入对应的标签中 。</p><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">title: Embedded C language</span><br><span class="line">date: <span class="number">2024</span><span class="number">-01</span><span class="number">-26</span> <span class="number">19</span>:<span class="number">04</span>:<span class="number">36</span></span><br><span class="line">description: C语言在单片机编程的一些重要应用</span><br><span class="line">comments: <span class="literal">true</span></span><br><span class="line">categories:</span><br><span class="line">- embedded</span><br><span class="line">tags:</span><br><span class="line">- C language programming</span><br></pre></td></tr></table></figure><h4 id="文章加密"><a href="#文章加密" class="headerlink" title="文章加密"></a>文章加密</h4><p>首先安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install –save hexo-blog-encrypt</span><br></pre></td></tr></table></figure><p>然后在hexo全局配置文件_config.yml 中启用该插件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Security</span><br><span class="line">encrypt:</span><br><span class="line">    enable: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后在需要加密的文章头部添加所要求的字段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章加密</span><br><span class="line">date: 2020-06-04 9:46:03</span><br><span class="line">password: 123</span><br><span class="line">abstract: 这是一篇加密博文，请输入密码后查看</span><br><span class="line">message: 这里需要密码才能访问。</span><br><span class="line">wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Embedded C language</title>
      <link href="/2024/01/26/Embedded-C-language/"/>
      <url>/2024/01/26/Embedded-C-language/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式C语言与算法"><a href="#嵌入式C语言与算法" class="headerlink" title="嵌入式C语言与算法"></a>嵌入式C语言与算法</h1><p><img src="/2024/01/26/Embedded-C-language/image-20240115231828910.png" alt="image-20240115231828910"></p><p><img src="/2024/01/26/Embedded-C-language/image-20240115232323794.png" alt="image-20240115232323794"></p><p>简述C语言中的基础知识<br>    1).数据类型(常用char, short, int , long, signed, unsigned, float, double, sizeof)<br>    2).运算和控制( &#x3D;, +, -, *, while, do-while, if, else, switch, case, continue, break)<br>    3).数据存储(static, extern, const, volatile)<br>    4).结构(struct, enum, union, typedef)<br>    5).位操作和逻辑运算(&lt;&lt;, &gt;&gt;, &amp;, |, ~, ^)<br>    6).预处理(#define, #include, #if…#elif…#else…#endif等)</p><img src="/2024/01/26/Embedded-C-language/image-20240119170447733.png" alt="image-20240119170447733" style="zoom:67%;"><h2 id="1-char-short-int数据类型"><a href="#1-char-short-int数据类型" class="headerlink" title="1.char short int数据类型"></a>1.char short int数据类型</h2><p>对于单片机开发来说，是至关重要的。因为单片机有8位、16位、32位。如果不注意数据类型，不注意数据长度，那么在编写代码的时候，很容易就会造成数据溢出，导致程序出现bug，而且还很难发现原因。</p><p>如果熟悉stm32单片机开发的同学，看官方的例程时，使用的数据类型往往都是重新定义过的类型，很少有直接使用原始数据类型的，比如GPIOIO口设置。</p><p>为什么要这样做吗？不嫌麻烦吗？自己平时写程序的时候，往往都是直接使用数据类型的默认名，也依然可以正常使用，没什么问题。但是官方为什么一定要重新定义一次数据类型呢？</p><p>个说白了就是大局观的问题，因为官方比我们个人更具有大局观。个人面对的可能也只有几个平台和几款单片机。而官方面对的是多个平台和多种单片机的，这就不得不考虑数据兼容问题了。比如在32位单片机上的算法移植到8位单片机上，代码运行起来后，到处都是数据溢出。要挨个去修改变量的数据类型，那么这时候，作为开发者来说，奔溃不奔溃？抓狂不抓狂？</p><p>所以为了解决这个问题，官方就会在每个平台下，给数据类型，重新命名一次，如果需要更换平台，那么只需要替换这个数据重命名的头文件即可。</p><p>在32位单片机中int是32位，而在8位单片机中long 才是32位。那么在32位单片机上的int型变量，如果直接移植到8位单片机上的话，那么肯定就会出现数据溢出的问题。</p><p>那么如果使用了重命名后的新变量类型 uint32_t ，不论在8位和32位的单片机上，这个数据都会是32位，这样通过数据类型的重定义，就避免了，同样的数据类型，在不同平台上长度不一致的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br></pre></td></tr></table></figure><p>不同平台数据类型所占字节对比：</p><p>（1个字节有8位）</p><p><img src="/2024/01/26/Embedded-C-language/image-20240113193817299.png" alt="image-20240113193817299"></p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>见”union共同体”章节</p><h4 id="实例应用"><a href="#实例应用" class="headerlink" title="实例应用"></a>实例应用</h4><p>1.<em>智能家居：网关协议，mac地址上报？</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *mac=<span class="string">&quot;192.168.31.84&quot;</span></span><br><span class="line"><span class="type">char</span> mac_array[<span class="number">4</span>]=&#123;<span class="number">192</span>,<span class="number">168</span>,<span class="number">31</span>,<span class="number">84</span>&#125;</span><br></pre></td></tr></table></figure><p>mac地址如上所示为”192.168.31.84”，为了将其上传到服务器，在定通讯协议时，会和服务器的同事沟通好，收到下面这样一个mac_array数组时，就在每两个数之间加一个小数点来表示mac地址。</p><p>即我们将mac地址转化为一个char类型的数组上传到服务器。</p><p>提问：<strong>为什么mac_array数组的类型用char,而不用int等数据类型？</strong></p><p>答：你可以把数据类型当成一个容器来存放数字，只是它们的容量不同，比如</p><p>char占用1个字节的内存空间，一个字节有8位，能存放0~255之间的数字，因此char类型很适合表示0-255之间的整数，这个范围完全满足IP地址中每个字段的需求。</p><p>如果使用int类型，它通常占用4个字节的内存空间，0-65535，对于用来储存仅需0-255之间的数值而言过于庞大，将浪费大量存储空间，因此在这种情况下，使用char类型更为合适</p><p>2.<em>奶茶机器人：温度采集，小数点如何上报云端？</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> temp = <span class="number">37.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> temp_array[<span class="number">2</span>] = &#123;<span class="number">37</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>服务器发过来unix时间戳 :1607143247，一般是发的hex，即发的是5FCB0F4F，我们接受这串数据，并将其重新解析为时间</p><p>5FCB0F4F  {0x5F,0xCB,0x0F,0x4F} </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> time_buffer[<span class="number">4</span>]=&#123;<span class="number">0x5F</span>,<span class="number">0xCB</span>,<span class="number">0x0F</span>,<span class="number">0x4F</span>&#125;;<span class="comment">//十六进制的一位等于四位二进制</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> time;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">u8Tou32B</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (((((((<span class="type">unsigned</span> <span class="type">int</span>)buffer[<span class="number">0</span>])&lt;&lt;<span class="number">8</span>)|buffer[<span class="number">1</span>])&lt;&lt;<span class="number">8</span>)|buffer[<span class="number">2</span>])&lt;&lt;<span class="number">8</span>)|buffer[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    time=u8Tou32B(time_buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time =%ld s\n&quot;</span>,time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5FCB0F4F  {0x5F,0xCB,0x0F,0x4F} </p><p>u8Tou32B函数的作用是将一个包含四个字节的unsigned char数组转换成一个unsigned int类型的32位无符号整数，就是把5F,CB,0F,4F拼起来。</p><p>继续对上面的u8Tou32B函数进行优化得</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">u8Tou32B_optimized</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;result, buffer, <span class="keyword">sizeof</span>(result));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    time = u8Tou32B_optimized(time_buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time = %u s\n&quot;</span>, time); <span class="comment">// 使用%u正确打印无符号整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-位操作"><a href="#2-位操作" class="headerlink" title="2.位操作"></a>2.位操作</h2><h3 id="位，字节，进制"><a href="#位，字节，进制" class="headerlink" title="位，字节，进制"></a>位，字节，进制</h3><p>1个字节&#x3D;8个二进制位</p><h4 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h4><p>0b开头，只有0，1，一个字节有8位，该字节能表示的最大数字是把所有位都设置为1：(11111111)&#x3D;256,因此1字节可储存0~255范围内的数字。</p><p>通常unsignedchar 用1字节表示的范围是0<del>255，而signed char 用1字节表示的范围是-128</del>+127.</p><h4 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h4><p>0x开头，用0~15表示数字（0-9，10-15为A-F）</p><p><em><strong>每个十六进制位都对应一个4位的二进制数（即4个二进制位）</strong></em>（2^4&#x3D;16,即一个四位的二进制数可以表示从0到15的所有整数值），那么两个十六进制位恰好对应一个8位字节。第一个十六进制表示前4位，第2个十六进制位表示后4位</p><p>不同类型数据的转换可见union共同体章节</p><h3 id="位逻辑运算符"><a href="#位逻辑运算符" class="headerlink" title="位逻辑运算符"></a>位逻辑运算符</h3><p><img src="/2024/01/26/Embedded-C-language/image-20240113211004993.png" alt="image-20240113211004993"> </p><p>位与&amp;:对于每个位，只有两个对象中相应的位都为1时，结果才为1        &amp;&#x3D;</p><p>（10010011）&amp;（00111101）&#x3D;（00010001）</p><p>常见用法: ch&amp;&#x3D;0xff(0xff二进制形式是11111111，这个掩码保持ch中最后8位不变，其它位都设置为0)   </p><p>位或|:只要有一个1就为1       |&#x3D;</p><p>（10010011）|（00111101）&#x3D;（10111111）</p><p>0x20|0x0C&#x3D;0x2C</p><p>位异或^:</p><p>取反~:把0变为1，1变为0</p><p>在c语言中，<code>!</code>和<code>~</code>均表示取反。</p><p>这两个符号的区别在于：</p><ul><li><strong><code>!</code></strong> : 代表<strong>逻辑取反</strong>，即：把非0的数值变为0，0变为1;</li><li><em><strong>*<code>~</code>*</strong></em> : 表示<strong>按位取反</strong>，即在数值的二进制表示方式上,将0变为1，将1变为0。</li></ul><h3 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h3><p>按位与运算符常用于掩码（mask）。所谓掩码指的是一些设置为开（1）或关（0）的位组合</p><p>常见用法: ch&amp;&#x3D;0xff(0xff二进制形式是11111111，这个掩码保持ch中最后8位不变，其它位都设置为0)</p><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>左移&lt;&lt;:  将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）</p><p>（10001010）&lt;&lt;2&#x3D;(001010000)</p><p>右移&gt;&gt;:  (10001010)&gt;&gt;2&#x3D;(00100010)</p><h4 id="从较大单元中提取一些位"><a href="#从较大单元中提取一些位" class="headerlink" title="从较大单元中提取一些位"></a>从较大单元中提取一些位</h4><p>此处可链接到“十六进制”章节中</p><p>（<em><strong>每个十六进制位都对应一个4位的二进制数（即4个二进制位）</strong></em>（2^4&#x3D;16,即一个四位的二进制数可以表示从0到15的所有整数值），那么两个十六进制位恰好对应一个8位字节。第一个十六进制表示前4位，第2个十六进制位表示后4位）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE_MASK 0xff</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> color =<span class="number">0x002a162f</span>;<span class="comment">//一个十六进制位对应四个二进制位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> blue,green,red;</span><br><span class="line"></span><br><span class="line">red=color&amp;BYTE_MASK;<span class="comment">//取color低8位</span></span><br><span class="line">green=(color&gt;&gt;<span class="number">8</span>)&amp;BYTE_MASK;<span class="comment">//将color右移8位（8个二进制位），再用掩码取低8位，则可使green取color中间8位</span></span><br><span class="line">blue=(color&gt;&gt;<span class="number">16</span>)&amp;BYTE_MASK;<span class="comment">//将color右移16位（16个二进制位)，再用掩码取低8位，则可使blue取color高8位</span></span><br></pre></td></tr></table></figure><p><img src="/2024/01/26/Embedded-C-language/image-20240114140043073.png" alt="image-20240114140043073"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_SET_INPUT_POS:</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(data, &amp;(odrive_set-&gt;input_pos), <span class="number">4</span>);<span class="comment">//4个字节 32位 ，input_pos也是32位，复制到data数组中  uint8_t data[8]  ，yi会将数组前四位补齐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//odrive_set-&gt;vel_ff  vel_ff有16位 两个字节 ,data的一个元素的类型是uint8_t,有8位</span></span><br><span class="line">       data[<span class="number">4</span>] = odrive_set-&gt;vel_ff &amp; <span class="number">0x00FF</span>;<span class="comment">//保留低8位</span></span><br><span class="line"><span class="comment">//packetlength &amp; 0x00FF中的&amp;是先把&amp;两边的值转换成二进制形式，然后在进行按位运算</span></span><br><span class="line">       data[<span class="number">5</span>] = odrive_set-&gt;vel_ff &gt;&gt; <span class="number">8</span>;<span class="comment">//取高8位</span></span><br><span class="line"></span><br><span class="line">       data[<span class="number">6</span>] = odrive_set-&gt;current_ff &amp; <span class="number">0x00FF</span>;</span><br><span class="line">       data[<span class="number">7</span>] = odrive_set-&gt;current_ff &gt;&gt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       header.RTR = CAN_RTR_DATA;</span><br><span class="line">       header.DLC = <span class="number">8</span>;</span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h2><p>float candy[365];&#x2F;<em>内含365个float类型元素的数组</em>&#x2F;</p><h2 id="4-结构体struct"><a href="#4-结构体struct" class="headerlink" title="4.结构体struct"></a>4.结构体struct</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><strong>结构</strong>体是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p><p>结构体中的数据成员可以是基本数据类型（如 int、float、char 等），也可以是其他结构体类型、指针类型等。</p><p>关键字–struct, union, typedef</p><p>运算符: . ,-&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title function_">xxx</span><span class="params">(标签，这个结构体的名字)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​xxx(变量定义);</span><br><span class="line"></span><br><span class="line">&#125;xxx(结构变量);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明结构类型</span></span><br><span class="line"><span class="comment">/*1*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> daty;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span>;</span><span class="comment">/*定义某种结构类型的变量*/</span></span><br><span class="line"><span class="comment">/*2*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;p1,p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*3*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;p1,p2;</span><br><span class="line"><span class="comment">/*4*/</span></span><br><span class="line"><span class="keyword">typedef</span> &#123;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> daty;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;today;</span><br><span class="line"></span><br><span class="line">today Today1;</span><br></pre></td></tr></table></figure><p>在一般情况下，标签、变量定义，结构变量这 3 部分至少要出现 2 个</p><h4 id="tyepedef-struct"><a href="#tyepedef-struct" class="headerlink" title="tyepedef struct"></a>tyepedef struct</h4><p>typedef是类型定义的意思。typedef <a href="https://so.csdn.net/so/search?q=struct&spm=1001.2101.3001.7020">struct</a> 是为了使用这个结构体方便。</p><p>具体区别在于:<br> 若struct <a href="https://so.csdn.net/so/search?q=node&spm=1001.2101.3001.7020">node</a> {}这样来定义结构体的话。在申请node 的变量时，需要这样写，struct node n;<br> 若用typedef，可以这样写，typedef struct node{}NODE; 。在申请变量时就可以这样写，NODE n;<br> 区别就在于使用时，是否可以省去struct这个关键字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;Stu;</span><br><span class="line">于是在声明变量的时候就可：Stu stu1;</span><br><span class="line">如果没有<span class="keyword">typedef</span>就必须用<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>;</span>来声明</span><br><span class="line">这里的Stu实际上就是<span class="class"><span class="keyword">struct</span> <span class="title">Student</span>的别名。</span></span><br></pre></td></tr></table></figure><h4 id="例-odrive-stm32驱动代码（可作为使用结构体时的模板）"><a href="#例-odrive-stm32驱动代码（可作为使用结构体时的模板）" class="headerlink" title="例 odrive&amp;stm32驱动代码（可作为使用结构体时的模板）"></a>例 odrive&amp;stm32驱动代码（可作为使用结构体时的模板）</h4><p>建立结构声明（模板），定义结构变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*odrive.h*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> axis_error;</span><br><span class="line">  <span class="type">uint32_t</span> axis_current_state;</span><br><span class="line">  <span class="type">uint32_t</span> motor_error;</span><br><span class="line">  <span class="type">uint32_t</span> encoder_error;</span><br><span class="line">  <span class="type">uint32_t</span> sensorless_error;</span><br><span class="line">  <span class="type">float</span> encoder_pos_estimate;</span><br><span class="line">  <span class="type">float</span> encoder_vel_estimate;</span><br><span class="line">  <span class="type">int32_t</span> encoder_shadow_count;</span><br><span class="line">  <span class="type">int32_t</span> encoder_cpr_count;</span><br><span class="line">  <span class="type">float</span> iq_setpoint;</span><br><span class="line">  <span class="type">float</span> iq_measured;</span><br><span class="line">  <span class="type">float</span> sensorless_pos_estimate;</span><br><span class="line">  <span class="type">float</span> sensorless_vel_estimate;</span><br><span class="line">  <span class="type">float</span> vbus_voltage;</span><br><span class="line">&#125; OdriveAxisGetState_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把odrive_set_axis0()声明为一个OdriveAxisSetState_t（在odrive.h定义的结构体）类型的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*odrive.c*/</span></span><br><span class="line">OdriveAxisSetState_t odrive_set_axis0;</span><br><span class="line">OdriveAxisSetState_t odrive_set_axis1;</span><br></pre></td></tr></table></figure><h4 id="结构的初始化"><a href="#结构的初始化" class="headerlink" title="结构的初始化"></a>结构的初始化</h4><p>struct date today&#x3D;{07,31,2014};</p><h4 id="结构成员"><a href="#结构成员" class="headerlink" title="结构成员"></a>结构成员</h4><p>在C语言中，访问结构体成员时选择使用.或-&gt;主要取决于你当前操作的对象是<strong>结构体实例本身</strong>还是<strong>指向该结构体的指针</strong>：</p><p>•使用.（点号）的情况：当直接操作一个已知的结构体变量时，通过.来访问其内部成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>;</span></span><br><span class="line">stu1.name=<span class="string">&#x27;&#x27;John Doe&#x27;</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string">stu1.age = 20;</span></span><br></pre></td></tr></table></figure><p>•使用-&gt;（箭头）的情况：当操作的是指向结构体的指针时，用-&gt;来访问该指针所指向的结构体的成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">stuP</span>;</span></span><br><span class="line">stuP = &amp;stu1; <span class="comment">// 或者 stuP = malloc(sizeof(struct Student));</span></span><br><span class="line"></span><br><span class="line">stuP-&gt;name = <span class="string">&quot;Jane Smith&quot;</span>; <span class="comment">// 使用 -&amp;gt; 访问结构体指针 stuP 所指向的结构体的成员</span></span><br><span class="line">stuP-&gt;age = <span class="number">22</span>;</span><br></pre></td></tr></table></figure><p>简而言之，如果你有一个结构体变量名，就用.；如果你有一个指向结构体的指针，就用-&gt;。</p><h4 id="结构指针"><a href="#结构指针" class="headerlink" title="结构指针"></a>结构指针</h4><p>和数组不同，结构变量的名字不是结构变量的地址，必须使用&amp;运算符</p><h4 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h4><p>向函数传递结构体的信息：1.传递结构体成员  2.传递结构体地址  3.传递结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  GPIO_PIN_RESET = <span class="number">0</span>,</span><br><span class="line">  GPIO_PIN_SET</span><br><span class="line">&#125;GPIO_PinState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> MODER;    <span class="comment">/*!&lt; GPIO port mode register,               Address offset: 0x00      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> OTYPER;   <span class="comment">/*!&lt; GPIO port output type register,        Address offset: 0x04      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> OSPEEDR;  <span class="comment">/*!&lt; GPIO port output speed register,       Address offset: 0x08      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> PUPDR;    <span class="comment">/*!&lt; GPIO port pull-up/pull-down register,  Address offset: 0x0C      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> IDR;      <span class="comment">/*!&lt; GPIO port input data register,         Address offset: 0x10      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ODR;      <span class="comment">/*!&lt; GPIO port output data register,        Address offset: 0x14      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> BSRR;     <span class="comment">/*!&lt; GPIO port bit set/reset register,      Address offset: 0x18      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> LCKR;     <span class="comment">/*!&lt; GPIO port configuration lock register, Address offset: 0x1C      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AFR[<span class="number">2</span>];   <span class="comment">/*!&lt; GPIO alternate function registers,     Address offset: 0x20-0x24 */</span></span><br><span class="line">&#125; GPIO_TypeDef;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*传递结构体地址*/</span></span><br><span class="line">GPIO_PinState <span class="title function_">HAL_GPIO_ReadPin</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span><span class="comment">//第一位GPIO_TypeDef* GPIOx是传入结构体的地址，以便在这个函数中使用这个结构体</span></span><br><span class="line">&#123;</span><br><span class="line">  GPIO_PinState bitstatus;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GPIO_PIN(GPIO_Pin));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((GPIOx-&gt;IDR &amp; GPIO_Pin) != (<span class="type">uint32_t</span>)GPIO_PIN_RESET)<span class="comment">//操作对象是指向结构体的指针，访问该结构体成员时用-&gt;</span></span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = GPIO_PIN_SET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = GPIO_PIN_RESET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bitstatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p><em><strong>typedef 在 MDK 用得最多的就是定义结构体的类型别名和枚举类型了。</strong></em>(typedef struct, typedef enum)</p><p>利用typedef可以为某一类型自定义名称(为现有类型创建一个名称)，它没有创建任何新类型，只是为某个已存在的类型增加了一个方便使用的标签。</p><p>1.为经常出现的类型创建一个方便，易识别的类型名。</p><p>2.常用于给复杂的类型命名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用BYTE表示1字节的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> BYTE</span><br><span class="line"><span class="comment">//随后可以用BYTE来定义变量</span></span><br><span class="line">BYTE x,y[<span class="number">10</span>],*z;</span><br><span class="line"><span class="comment">//#define也可发挥上面同样的功能</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE unsigned char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以把typedef用于结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span></span><br><span class="line">    <span class="type">float</span> real;</span><br><span class="line">    <span class="type">float</span> imag;</span><br><span class="line">&#125;COMPLEX;</span><br><span class="line"><span class="comment">//然后可用COMPLEX类型代替complex结构</span></span><br><span class="line">用<span class="keyword">typedef</span>来命名一个结构类型时，可以省略该结构的标签。（见例odrive&amp;stm32驱动代码）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以为结体定义一个别名 GPIO_TypeDef，这样我们就可以在其他地方通过别名 GPIO_TypeDef 来定义结构体变量了。</p><p>方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> __IO <span class="type">uint32_t</span> CRL;</span><br><span class="line"> __IO <span class="type">uint32_t</span> CRH;</span><br><span class="line">…</span><br><span class="line">&#125; GPIO_TypeDef;</span><br></pre></td></tr></table></figure><p>Typedef 为结构体定义一个别名 GPIO_TypeDef。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_TypeDef _GPIOA,_GPIOB;</span><br></pre></td></tr></table></figure><p>GPIO_TypeDef 就跟 struct _GPIO 是等同的作用了</p><h3 id="enum枚举"><a href="#enum枚举" class="headerlink" title="enum枚举"></a>enum枚举</h3><p>enum枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。（一个被命名的整形常数的集合 ）</p><p>枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure><p>我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MON  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TUE  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WED  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THU  4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRI  5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAT  6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUN  7</span></span><br></pre></td></tr></table></figure><h4 id="声明枚举类型"><a href="#声明枚举类型" class="headerlink" title="声明枚举类型"></a>声明枚举类型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="枚举变量的定义"><a href="#枚举变量的定义" class="headerlink" title="枚举变量的定义"></a>枚举变量的定义</h4><p>我们可以通过以下三种方式来定义枚举变量</p><p><strong>1、先定义枚举类型，再定义枚举变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">day</span>;</span></span><br></pre></td></tr></table></figure><p><strong>2、定义枚举类型的同时定义枚举变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure><p><strong>3、省略枚举名称，直接定义枚举变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure><h4 id="typedef-enum"><a href="#typedef-enum" class="headerlink" title="typedef enum"></a>typedef enum</h4><p>是不是感觉和enum没什么区别，确实在一般的使用中两个的结果是差不多的。</p><p>但是如果你想定义一个和DAY类型一样的集合的情况下，使用typedef enum更方便</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">举例子：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> &#123;</span> MON, TUE=<span class="number">2</span>, WED, THU, FRI, SAT, SUN  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">workday</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">restday</span>;</span></span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> &#123;</span> MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN  &#125;DAY_TYPE; </span><br><span class="line"></span><br><span class="line">DAY_TYPE workday,restday;</span><br></pre></td></tr></table></figure><p>（此处用法与typedef struct一样）</p><p>枚举（enum）成员的值默认是整型，并且从0开始递增。虽然枚举类型本身不直接支持十六进制的声明方式，但你可以手动为枚举成员赋值，这个值可以是任何整数常量，当然包括十六进制表示的整数</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  MSG_CO_NMT_CTRL = <span class="number">0x000</span>,      <span class="comment">// CANOpen NMT Message REC</span></span><br><span class="line">  MSG_SET_INPUT_POS = <span class="number">0x00C</span>,    <span class="comment">// 输入的电机目标位置</span></span><br><span class="line">  MSG_SET_INPUT_VEL = <span class="number">0x00D</span>,    <span class="comment">// 输入的电机目标转速-------###</span></span><br><span class="line">  MSG_CLEAR_ERRORS = <span class="number">0x018</span>,     <span class="comment">// 清除错误</span></span><br><span class="line">  MSG_CO_HEARTBEAT_CMD = <span class="number">0x700</span>, <span class="comment">// CANOpen NMT Heartbeat SEND</span></span><br><span class="line">&#125; Odrive_Commond;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用于switch case中：</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">odrv_write_msg</span><span class="params">(Axis_t axis, Odrive_Commond cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">switch</span>(cmd)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> MSG_GET_ENCODER_COUNT:</span><br><span class="line">        header.RTR = CAN_RTR_REMOTE;  <span class="comment">//数据帧的优先级大于远程帧，当有多个设备向一个ID同时发送数据时，用远程帧可以有效地避免总线冲突，即ID收到消息后会先回发数据帧，再处理远程帧</span></span><br><span class="line">        header.DLC = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MSG_SET_CONTROLLER_MODES:</span><br><span class="line">        data[<span class="number">0</span>] = odrive_set-&gt;control_mode;</span><br><span class="line">        data[<span class="number">4</span>] = odrive_set-&gt;input_mode;</span><br><span class="line">        header.RTR = CAN_RTR_DATA;</span><br><span class="line">        header.DLC = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MSG_SET_TRAJ_ACCEL_LIMITS:</span><br><span class="line">        <span class="built_in">memcpy</span>(data, &amp;(odrive_set-&gt;traj_accel_limit), <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp_word, &amp;(odrive_set-&gt;traj_decel_limit), <span class="number">4</span>);</span><br><span class="line">        data[<span class="number">4</span>] = tmp_word[<span class="number">0</span>];</span><br><span class="line">        data[<span class="number">5</span>] = tmp_word[<span class="number">1</span>];</span><br><span class="line">        data[<span class="number">6</span>] = tmp_word[<span class="number">2</span>];</span><br><span class="line">        data[<span class="number">7</span>] = tmp_word[<span class="number">3</span>];</span><br><span class="line">        header.RTR = CAN_RTR_DATA;</span><br><span class="line">        header.DLC = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//enum枚举常用于状态表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NORMAL,</span><br><span class="line">    CHANGE,</span><br><span class="line">&#125; FSMMode_e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PASSIVE = <span class="number">1</span>,    <span class="comment">// 阻尼</span></span><br><span class="line">    FALL = <span class="number">2</span>,       <span class="comment">// 卧倒</span></span><br><span class="line">    FIXEDSTAND = <span class="number">3</span>, <span class="comment">// 固定站立</span></span><br><span class="line">    FREESTAND = <span class="number">4</span>,  <span class="comment">// 自由站立</span></span><br><span class="line">    TROTING = <span class="number">5</span>,    <span class="comment">// 对角步态</span></span><br><span class="line">    WALKING = <span class="number">6</span>,    <span class="comment">// 行走步态</span></span><br><span class="line">    JUMP = <span class="number">7</span>,       <span class="comment">// 跳跃</span></span><br><span class="line">    JUMP2 = <span class="number">8</span>,      <span class="comment">// 跳跃2</span></span><br><span class="line">    JUMPL = <span class="number">9</span>,</span><br><span class="line">    JUMPL2 = <span class="number">10</span>,</span><br><span class="line">    JUMPR = <span class="number">11</span>,</span><br><span class="line">    JUMPR2 = <span class="number">12</span>,</span><br><span class="line">    catJUMP = <span class="number">13</span>,</span><br><span class="line">    catJUMP2 = <span class="number">14</span>,</span><br><span class="line">&#125; FSMState_e;</span><br></pre></td></tr></table></figure><h2 id="5-指针"><a href="#5-指针" class="headerlink" title="5.指针"></a>5.指针</h2><h3 id="指针偏移"><a href="#指针偏移" class="headerlink" title="指针偏移"></a>指针偏移</h3><p>指针可以作为数组用，数组号表示指针基地址偏移，很多代码都这么用的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span>  <span class="title function_">test</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">buffer[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第16行，memcpy函数从packet[1]的地址开始复制，数据依次复制到packet[1],packet[2],packet[3],packet[4]中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> floatVal;</span><br><span class="line">    <span class="type">uint8_t</span> byteVal[<span class="keyword">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">  &#125; data;</span><br><span class="line"></span><br><span class="line">  data.floatVal = val;<span class="comment">//共同体 val给共同体的data.floatVal后 如果用data.byteVal 共同体内data.floatVal中的数据会转变为byteVal[sizeof(float)]类型</span></span><br><span class="line">  <span class="built_in">memcpy</span>(bytes, data.byteVal, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//共同体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendPacket</span><span class="params">(<span class="type">float</span> angle, <span class="type">float</span> x, <span class="type">float</span> y)</span> &#123;<span class="comment">//float有4个字节，32位</span></span><br><span class="line">  <span class="type">uint8_t</span> packet[<span class="number">14</span>];   <span class="comment">// 数据包共14个字节</span></span><br><span class="line">  <span class="comment">// 填充帧头</span></span><br><span class="line">  packet[<span class="number">0</span>] = FRAME_HEADER;</span><br><span class="line">  <span class="comment">// 填充数据</span></span><br><span class="line">  floatToBytes(angle, &amp;packet[<span class="number">1</span>]);</span><br><span class="line">  floatToBytes(x, &amp;packet[<span class="number">5</span>]);</span><br><span class="line">  floatToBytes(y, &amp;packet[<span class="number">9</span>]);</span><br><span class="line">  <span class="comment">// 填充帧尾</span></span><br><span class="line">  packet[<span class="number">13</span>] = FRAME_TAIL;</span><br><span class="line">  <span class="comment">// 使用串口发送数据包</span></span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, packet, <span class="keyword">sizeof</span>(packet), HAL_MAX_DELAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>所谓函数指针即定义一个<em><strong>指向函数的指针变量</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span> x, <span class="type">int</span>  y);  <span class="comment">//注意：这里的括号不能掉，因为括号()的运算优先级比解引用运算符*高</span></span><br></pre></td></tr></table></figure><p>这个函数的类型是有两个整型参数，返回值是个整型。对应的函数指针类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*) (<span class="type">int</span> a, <span class="type">int</span> b);  </span><br></pre></td></tr></table></figure><p>对应的函数指针<strong>定义</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span> x, <span class="type">int</span>  y);  <span class="comment">//参数名可以去掉，并且通常都是去掉的。这样指针p就可以保存函数类型为两个整型参数，返回值是整型的函数地址了。</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>我们一般可以这么使用，通过函数指针调用函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxValue</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;    </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = <span class="literal">NULL</span>;  <span class="comment">//定义一个与maxValue兼容的指针</span></span><br><span class="line">p = maxValue;<span class="comment">//将这个指针指向maxValue函数</span></span><br><span class="line">p(<span class="number">20</span>, <span class="number">45</span>);  <span class="comment">//通过指针调用</span></span><br></pre></td></tr></table></figure><p><strong>应用案例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FSMMode_e mode;</span><br><span class="line">    FSMState_e currentState;</span><br><span class="line">    FSMState_e nextState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回调函数</span></span><br><span class="line">    <span class="type">void</span> (*enter)(<span class="type">void</span>);<span class="comment">/*函数指针*/</span>  </span><br><span class="line">    <span class="type">void</span> (*run)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">exit</span>)(<span class="type">void</span>);</span><br><span class="line">&#125; FSM_t;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FSM_t FSM ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (FSM.nextState)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FIXEDSTAND:</span><br><span class="line">        FSM.enter = FixedStand_Enter;<span class="comment">//将FSM.enter这个指针指向FixedStand_Enter函数</span></span><br><span class="line">        FSM.run = FixedStand_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = FixedStand_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">case</span> TROTING:</span><br><span class="line">        FSM.enter = Troting_Enter;</span><br><span class="line">        FSM.run = Troting_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Troting_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> WALKING:</span><br><span class="line">        FSM.enter = Walking_Enter;</span><br><span class="line">        FSM.run = Walking_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Walking_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> JUMP:</span><br><span class="line">        FSM.enter = Jump_Enter;</span><br><span class="line">        FSM.run = Jump_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Jump_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在C语言中，void (*enter)(void);、void (*run)(void); 和 void (*exit)(void); 这三个成员是函数指针类型。</p><p>具体解释如下：</p><ol><li><pre><code class="c">void (*enter)(void);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这是一个指向无参数且返回值为 void 的函数的指针。在结构体 FSM_t 中，它表示一个函数指针，当 FSM（有限状态机）进入某个状态时，可以通过调用这个函数指针指向的函数来执行相应的“进入”动作。</span><br><span class="line"></span><br><span class="line"> 2. ```c</span><br><span class="line">    void (*run)(void);</span><br></pre></td></tr></table></figure></code></pre></li></ol><p>同样是一个指向无参数且返回值为 void 的函数的指针。在状态机中，当处于某个状态并需要运行该状态的行为或处理逻辑时，可以调用这个“run”函数指针指向的函数。</p><ol start="3"><li><pre><code class="c">void (*exit)(void);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">依然是一个函数指针，指向无参数且返回值为 void 的函数。当 FSM 状态机从当前状态退出时，会调用这个“exit”函数指针指向的函数，用于执行离开状态时所需的动作或清理工作。</span><br><span class="line"></span><br><span class="line">因此，在实现一个基于此结构体的状态机时，你需要为每个状态分别定义对应的 enter、run 和 exit 函数，并将它们的地址赋给相应状态的 FSM_t 结构体实例中的这三个函数指针成员。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在C语言中，结构体（struct）可以包含各种数据类型，包括**基本数据类型、指针类型**等。在这个特定的FSM_t（有限状态机）结构体定义中，使用函数指针的主要原因是为了实现灵活且可扩展的设计。</span><br><span class="line"></span><br><span class="line">​1.灵活性：***通过将函数作为成员变量（以指针形式存在），可以在不同的实例中为这些函数赋予不同的具体实现，使得状态机的行为可以根据需求动态改变。***</span><br><span class="line"></span><br><span class="line">​2.扩展性：在设计模式上，这种方式符合面向对象编程中的“多态”思想。***每个状态可以有自己的enter、run和exit行为，只需要提供相应的函数实现即可。***</span><br><span class="line"></span><br><span class="line">​3.解耦合：函数指针将函数的具体实现与结构体（状态机）的定义解耦合，使得状态机的定义更简洁，逻辑更清晰，也方便后期维护和扩展。</span><br><span class="line"></span><br><span class="line">​4.高效性：虽然使用函数指针调用会引入一次间接寻址，但在很多情况下，这并不会对性能造成显著影响，而带来的设计优势远大于此微小的性能损耗。总结一下，这里使用函数指针而非直接定义函数，主要是为了构建一个更加灵活、可扩展、高内聚低耦合的状态机模型。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在C语言中，结构体（struct）不能直接包含函数。函数在C语言中不是一种数据类型，因此无法像变量那样存储在结构体中。但是，可以通过存储函数的指针来达到类似的效果，就像上述FSM_t结构体中的enter、run和exit成员那样。</span><br><span class="line"></span><br><span class="line">所以，准确地说，结构体内不能直接定义函数，但可以存储函数的地址，即函数指针，间接实现调用关联函数的功能。</span><br><span class="line"></span><br><span class="line">#### 回调函数</span><br><span class="line"></span><br><span class="line">应用：</span><br><span class="line">1.*送餐机器人：底盘移动到目标位置后，通知应用程序*</span><br><span class="line"></span><br><span class="line">2.*智能音箱：网络状态改变后，通知应用程序*</span><br><span class="line"></span><br><span class="line">3.*四足机器人项目FSM状态机也有用到回调函数的思想*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">//工具代码</span><br><span class="line">typedef struct&#123;</span><br><span class="line">int status;</span><br><span class="line">void (*statusChange)(); //存储后续要调用的回调函数地址</span><br><span class="line">&#125;T_Device;</span><br><span class="line"></span><br><span class="line">T_Device g_ Device;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">名称：回调函数</span><br><span class="line">作用：将传入的用户函数的地址赋给g_Device.statusChange,当满足条件时，执行该用户函数</span><br><span class="line">*/</span><br><span class="line">//void (*pstatusChange)(int status) 定义了一个指向函数的指针变量 pstatusChange，该函数没有返回值，并且接受一个整型参数 status。</span><br><span class="line">void addCallbackFunc(void (*pstatusChange)(int status))&#123;//将函数的地址传入并赋给g_Device.statusChange，这样g_Device.statusChange指向函数的入口地址</span><br><span class="line">g_Device.statusChange = pstatusChange ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void run()&#123;</span><br><span class="line">g_Device.status = 10;</span><br><span class="line">    if(g_Device.status == 10)&#123;</span><br><span class="line">        if(g_Device . statusChange != NULL)&#123;</span><br><span class="line">        g_Device.statusChange(g_Device.status);//callBack(10);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//用户代码</span><br><span class="line">void callBack(int status )&#123;&#125;</span><br><span class="line">    printf(&quot;callBack\n&quot;);</span><br><span class="line">    printf(&quot;status = %d\n&quot; ,status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    addCallbackFunc(callBack);//将 `callBack` 函数的地址作为参数传递给了 `addCallbackFunc` 函数，</span><br><span class="line">    run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><p>在 <code>main</code> 函数中调用 <code>addCallbackFunc(callBack);</code> 时，发生了以下事件：</p><ol><li><code>callBack</code> 是用户定义的一个函数，其原型为 <code>void callBack(int status)</code>。</li><li>当调用 <code>addCallbackFunc(callBack)</code> 时，将 <code>callBack</code> 函数的地址作为参数传递给了 <code>addCallbackFunc</code> 函数。</li><li>在 <code>addCallbackFunc</code> 函数内部，这个传入的参数 <code>pstatusChange</code> 被赋值给全局变量 <code>g_Device</code> 的成员 <code>statusChange</code>，即 <code>g_Device.statusChange = pstatusChange;</code>。因此，现在 <code>g_Device.statusChange</code> 指向了 <code>callBack</code> 函数的入口地址。</li><li>这样一来，就实现了回调函数的注册。当设备状态改变且满足触发条件时（如在 <code>run</code> 函数中），可以通过调用 <code>g_Device.statusChange(g_Device.status);</code> 来执行 <code>callBack</code> 函数，<strong>并将设备状态作为参数传递进去，从而实现对状态变化的响应和处理。</strong></li></ol><p>提问：为什么不能直接用if(g_Device.status&#x3D;&#x3D;10)，而非要用回调函数，这是多此一举吗</p><p>使用回调函数并不一定是在做无用功，它在某些情况下具有以下优点：</p><ol><li><strong>解耦合</strong>：通过回调函数，我们可以将处理状态变化的逻辑从设备状态管理代码中分离出来。这样可以使代码结构更加清晰，也<strong>更容易维护和扩展</strong>。例如，在本例中，具体的设备状态改变后的处理行为（即<code>callBack</code>函数中的内容）可以由用户自定义，而不是硬编码在<code>run</code>函数里。</li><li><strong>灵活性</strong>：当设备状态改变时，不同的应用程序可能需要执行不同的操作。使用回调函数允许我们在运行时动态地根据需要来指定要执行的操作，增加了程序的灵活性。</li><li><strong>事件驱动编程</strong>：回调函数是事件驱动编程模型的重要组成部分。在这种模式下，当某个特定事件（如设备状态改变）发生时，系统调用预先注册好的回调函数，<strong>而非直接在触发事件的地方编写处理逻辑。</strong></li></ol><p>所以，并不是多此一举，而是为了实现更灵活、解耦的软件设计和开发。当然，在简单场景下，如果状态改变后的处理逻辑固定且无需复用，直接写在<code>if(g_Device.status==10)</code>判断后也是可行的，但在复杂项目或者需要扩展性的情况下，回调函数就显得尤为重要了。</p><h3 id="void-修饰指针使用规则"><a href="#void-修饰指针使用规则" class="headerlink" title="void 修饰指针使用规则"></a>void 修饰指针使用规则</h3><p>void *</p><p>void 指针可以指向任意类型的数据，就是说可以用任意类型的指针对 void 指针对 void <a href="https://so.csdn.net/so/search?q=%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC&spm=1001.2101.3001.7020">指针赋值</a>。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a；</span><br><span class="line"><span class="type">void</span> *p；</span><br><span class="line">p=a；</span><br></pre></td></tr></table></figure><p>void 指针可以任意类型的数据，可以在程序中给我们带来一些好处，函数中形为指针类型时，我们可以将其定义为 void 指针，这样函数就可以接受任意类型的指针。如：</p><pre><code>void * memcpy(void *dest, const void *src, size_t len);void * memset ( void * buffer, int c, size_t num );</code></pre><p>这样，任何类型的指针都可以传入 memcpy 和 memset 中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型。</p><h2 id="6-常见关键词"><a href="#6-常见关键词" class="headerlink" title="6.常见关键词"></a>6.常见关键词</h2><h3 id="define宏定义关键词"><a href="#define宏定义关键词" class="headerlink" title="define宏定义关键词"></a>define宏定义关键词</h3><p>语法：<code>#define 标识符 字符串</code></p><ul><li><p>“标识符”为所定义的<strong>宏名</strong></p></li><li><p>“字符串”可以是<strong>常数</strong>、<strong>表达式</strong>、<strong>格式串</strong>等</p><p>#define SYSCLK_FREQ_72MHz 72000000</p></li></ul><h3 id="ifdef-条件编译"><a href="#ifdef-条件编译" class="headerlink" title="ifdef 条件编译"></a>ifdef 条件编译</h3><p>当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 标识符</span></span><br><span class="line">程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>作用是：当标识符已经被定义过(一般是用#define 命令定义)，则对程序段 1 进行编译，否则编译程序段 2。 其中#else 部分也可以没有，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span></span></span><br><span class="line">程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="extern变量声明"><a href="#extern变量声明" class="headerlink" title="extern变量声明"></a>extern变量声明</h3><p>在一个文件中定义的全局变量，如果在其它文件里想使用，需要在前面加上extern</p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>有时候，我们希望函数中局部变量的值在函数调用结束之后不会消失，而仍然保留其原值。即它所占用的存储单元不释放，在下一次调用该函数时，其局部变量的值仍然存在，也就是上一次函数调用结束时的值。这时候，我们就应该将该局部变量用关键字 static 声明为“<strong>静态局部变量</strong>”。</p><p>静态变量的作用：<strong>保持变量内容的持久性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt;= <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">            count();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">count</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*声明一个静态局部变量*/</span></span><br><span class="line">    <span class="type">static</span> num = <span class="number">0</span>;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该代码中，我们通过在 count() 函数里声明一个静态局部变量 num 来作为计数器。因为静态局部变量是在编译时赋初值的，且只赋初值一次，在程序运行时它已有初值。以后在每次调用函数时就<em><strong>不再重新赋初值，而是保留上次函数调用结束时的值</strong></em>。这样，count() 函数每次被调用的时候，静态局部变量 num 就会保持上一次调用的值，然后再执行自增运算，这样就实现了计数功能。同时，它又避免了使用全局变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_ChangeState</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C语言中，当一个函数前加上 static 关键字时，意味着该函数具有内部链接性（internal linkage），即该函数的作用范围被限制在当前编译单元内。对于这个函数而言，这意味着只有定义它的源文件以及包含它所在的头文件的其他源文件可以访问此函数，不会成为外部全局符号，从而避免不同编译单元之间产生符号冲突。</p><h3 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h3><p>程序开发人员可以在变量定义后，在程序的其他位置引用和修改变量。但程序中定义的一些变量，如圆周率PI&#x3D;3.14，黄金分割比例 g&#x3D;0.618，<em><strong>这些变量只需要被引用，不应该被修改</strong></em>。C语言中可以使用 const关键字修饰变量。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> pi = <span class="number">3.141592612</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,pi);</span><br></pre></td></tr></table></figure><h3 id="IO-volatile"><a href="#IO-volatile" class="headerlink" title="__IO(volatile)"></a>__IO(<strong>volatile</strong>)</h3><p><strong>volatile</strong>的含义为 <code>允许硬件改变变量的数值</code> 。告诉编译器不要优化这些代码</p><p><a href="https://blog.csdn.net/QWQ_DIODA/article/details/116712401">volatile 形变量可以被硬件改变</a>，在需要<strong>硬件</strong>改变变量的场合中不可或缺！！</p><p><img src="/2024/01/26/Embedded-C-language/image-20240114110255039.png" alt="image-20240114110255039"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__IO <span class="type">uint16_t</span> ADC_ConvertedValue;  <span class="comment">// 用于保存转换后的ADC值 </span></span><br><span class="line"><span class="comment">// 中断服务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (ADC_GetITStatus(ADCx,ADC_IT_EOC)==SET) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 读取ADC的转换值</span></span><br><span class="line">ADC_ConvertedValue = ADC_GetConversionValue(ADCx);</span><br><span class="line">&#125;</span><br><span class="line">ADC_ClearITPendingBit(ADCx,ADC_IT_EOC);<span class="comment">//清除ADCx的中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="union共同体（联合体）"><a href="#union共同体（联合体）" class="headerlink" title="union共同体（联合体）"></a>union共同体（联合体）</h3><h4 id="实现不同类型数据的转换"><a href="#实现不同类型数据的转换" class="headerlink" title="实现不同类型数据的转换"></a>实现不同类型数据的转换</h4><p><strong>C语言的union联合体，可实现不同类型数据的转换</strong></p><p>结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。联合体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</p><p><em>简单说就是你给联合体的一个变量赋值，然后表示联合体其中的另一个变量，之前那个赋值了的变量会自动赋给你要表示的这个量，从而实现不同类型数据的转换。</em></p><p><img src="/2024/01/26/Embedded-C-language/image-20240114200704804.png" alt="image-20240114200704804"></p><p><img src="/2024/01/26/Embedded-C-language/image-20240114192714039.png" alt="image-20240114192714039"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memcpy函数有三个参数，第一个是目标地址（通常是数组的某一位的地址，即将数据从数组的这一位开始复制），第二个是源地址，第三个是数据长度。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> floatVal;</span><br><span class="line">    <span class="type">uint8_t</span> byteVal[<span class="keyword">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">  &#125; data;</span><br><span class="line"></span><br><span class="line">  data.floatVal = val;<span class="comment">//共同体 val给共同体的data.floatVal后 如果用data.byteVal 共同体内data.floatVal中的数据会转变为byteVal[sizeof(float)]类型</span></span><br><span class="line">  <span class="built_in">memcpy</span>(bytes, data.byteVal, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//共同体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *destin, <span class="type">void</span> *source, <span class="type">unsigned</span> n)</span>;</span><br></pre></td></tr></table></figure><p><strong>以source指向的地址为起点，将连续的n个字节数据，复制到以destin指向的地址为起点的内存中。</strong><br>函数有三个参数，第一个是目标地址（通常是数组的某一位的地址，即将数据从数组的这一位开始复制），第二个是源地址，第三个是数据长度。<br>数据长度（第三个参数）的单位是字节（1byte &#x3D; 8bit）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> floatVal;</span><br><span class="line">    <span class="type">uint8_t</span> byteVal[<span class="keyword">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">  &#125; data;</span><br><span class="line"></span><br><span class="line">  data.floatVal = val;<span class="comment">//共同体 val给共同体的data.floatVal后 如果用data.byteVal 共同体内data.floatVal中的数据会转变为byteVal[sizeof(float)]类型</span></span><br><span class="line">  <span class="built_in">memcpy</span>(bytes, data.byteVal, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//共同体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendPacket</span><span class="params">(<span class="type">float</span> angle, <span class="type">float</span> x, <span class="type">float</span> y)</span> &#123;<span class="comment">//float有4个字节，32位</span></span><br><span class="line">  <span class="type">uint8_t</span> packet[<span class="number">14</span>];   <span class="comment">// 数据包共14个字节</span></span><br><span class="line">  <span class="comment">// 填充帧头</span></span><br><span class="line">  packet[<span class="number">0</span>] = FRAME_HEADER;</span><br><span class="line">  <span class="comment">// 填充数据</span></span><br><span class="line">  floatToBytes(angle, &amp;packet[<span class="number">1</span>]);<span class="comment">//从packet[1]的地址开始复制，数据依次复制到packet[1],packet[2],packet[3],packet[4]中</span></span><br><span class="line">  floatToBytes(x, &amp;packet[<span class="number">5</span>]);</span><br><span class="line">  floatToBytes(y, &amp;packet[<span class="number">9</span>]);</span><br><span class="line">  <span class="comment">// 填充帧尾</span></span><br><span class="line">  packet[<span class="number">13</span>] = FRAME_TAIL;</span><br><span class="line">  <span class="comment">// 使用串口发送数据包</span></span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, packet, <span class="keyword">sizeof</span>(packet), HAL_MAX_DELAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_ChangeState</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​1.static：</p><p>​在C语言中，当一个函数前加上 static 关键字时，意味着该函数具有内部链接性（internal linkage），即该函数的作用范围被限制在当前编译单元内。对于这个函数而言，这意味着只有定义它的源文件以及包含它所在的头文件的其他源文件可以访问此函数，不会成为外部全局符号，从而避免不同编译单元之间产生符号冲突。</p><p>​2.inline：</p><p>​inline 关键字提示编译器尝试将函数体直接插入到每个调用该函数的地方（即“内联”），而不是通过正常的函数调用机制（如压栈、跳转等）。这样做的目的是减少函数调用的开销，尤其是当<em><strong>函数体较小且频繁调用时，能够提高程序运行效率。</strong></em><br>​注意，尽管有 inline 关键字，但是否真正进行内联处理由编译器决定，编译器会根据实际情况判断是否采纳程序员的建议。</p><p>综合上述解释，在状态机的上下文中，static inline void FSM_ChangeState() 函数可能用于快速切换状态，由于其内联特性，编译器可能会将状态切换的相关操作直接嵌入到调用处，以提升代码执行速度，并且由于是静态函数，其使用和实现细节被隐藏在当前编译单元内，不对外部模块可见，有助于封装和管理复杂度。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p><img src="/2024/01/26/Embedded-C-language/image-20240114192455610.png" alt="image-20240114192455610"></p><h2 id="7-串口数据包通讯协议"><a href="#7-串口数据包通讯协议" class="headerlink" title="7.串口数据包通讯协议"></a>7.串口数据包通讯协议</h2><p>uint8_t packet[14];  &#x2F;&#x2F;packet数组的一位是一个字节,此packet含14个字节</p><p>串口接收鲁棒性高，采用校验帧头、帧尾以及数据长度的方式，确保接收数据的稳定性。</p><p>之前一直没用过帧头帧尾，主要是之前用串口传输的数据量都不大，如果要传输多种数据，就需要用帧头帧尾确保数据传输的准确性</p><p>(STM32通讯系列–串口通讯】使用标准库、HAL库实现任意长度数据的收发（包含帧头、帧尾校验，配套完整开源程序）</p><p><a href="https://blog.csdn.net/qq_44343584/article/details/125654421?ops_request_misc=%7B%22request_id%22:%22166299541816800182785614%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=166299541816800182785614&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-125654421-null-null.142">https://blog.csdn.net/qq_44343584/article/details/125654421?ops_request_misc=%7B%22request%5Fid%22%3A%22166299541816800182785614%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=166299541816800182785614&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-125654421-null-null.142</a> )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//packet.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;packet.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> host 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> host<span class="comment">//发送数据包</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> packet_received = <span class="literal">false</span>;<span class="comment">//是否收到完整的数据包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转换单精度浮点数为字节</span></span><br><span class="line"><span class="comment">//@param1:浮点数</span></span><br><span class="line"><span class="comment">//@param2:字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> floatVal;</span><br><span class="line">    <span class="type">uint8_t</span> byteVal[<span class="keyword">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">  &#125; data;</span><br><span class="line"></span><br><span class="line">  data.floatVal = val;<span class="comment">//共同体 val给共同体的data.floatVal后 如果用data.byteVal 共同体内data.floatVal中的数据会转变为byteVal[sizeof(float)]类型</span></span><br><span class="line">  <span class="built_in">memcpy</span>(bytes, data.byteVal, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//共同体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* memcpy用法:</span></span><br><span class="line"><span class="comment">void *memcpy(void *destin, void *source, unsigned n);</span></span><br><span class="line"><span class="comment">以source指向的地址为起点，将连续的n个字节数据，复制到以destin指向的地址为起点的内存中。</span></span><br><span class="line"><span class="comment">函数有三个参数，第一个是目标地址，第二个是源地址，第三个是数据长度。</span></span><br><span class="line"><span class="comment">数据长度（第三个参数）的单位是字节（1byte = 8bit）。</span></span><br><span class="line"><span class="comment">一个float类型的函数有4个字节</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendPacket</span><span class="params">(<span class="type">float</span> angle, <span class="type">float</span> x, <span class="type">float</span> y)</span> &#123;</span><br><span class="line">  <span class="type">uint8_t</span> packet[<span class="number">14</span>];   <span class="comment">// 数据包共14个字节</span></span><br><span class="line">  <span class="comment">// 填充帧头</span></span><br><span class="line">  packet[<span class="number">0</span>] = FRAME_HEADER;</span><br><span class="line">  <span class="comment">// 填充数据</span></span><br><span class="line">  floatToBytes(angle, &amp;packet[<span class="number">1</span>]);</span><br><span class="line">  floatToBytes(x, &amp;packet[<span class="number">5</span>]);</span><br><span class="line">  floatToBytes(y, &amp;packet[<span class="number">9</span>]);</span><br><span class="line">  <span class="comment">// 填充帧尾</span></span><br><span class="line">  packet[<span class="number">13</span>] = FRAME_TAIL;</span><br><span class="line">  <span class="comment">// 使用串口发送数据包</span></span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, packet, <span class="keyword">sizeof</span>(packet), HAL_MAX_DELAY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析数据包</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// 定义缓冲区大小  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义缓冲区和指针</span></span><br><span class="line"><span class="type">uint8_t</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">uint8_t</span>* p_buffer = buffer;<span class="comment">//指向buffer缓冲区首地址的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义标志位，表示是否接收到完整的数据包</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> packet_received = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析数据包的函数 将数据包中数据赋给 angle x y</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ParseDataPacket</span><span class="params">(DataPacket* packet)</span> &#123;</span><br><span class="line">  <span class="type">uint8_t</span>* p = buffer + <span class="number">1</span>; <span class="comment">// 跳过帧头</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;packet-&gt;angle, p, <span class="keyword">sizeof</span>(<span class="type">float</span>)); <span class="comment">//buffer[1] buffer[2] buffer[3] buffer[4]</span></span><br><span class="line">  p += <span class="keyword">sizeof</span>(<span class="type">float</span>);<span class="comment">//指向buffer[5]</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;packet-&gt;x, p, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//buffer[5] buffer[6] buffer[7] buffer[8]</span></span><br><span class="line">  p += <span class="keyword">sizeof</span>(<span class="type">float</span>);<span class="comment">//指向buffer[9]</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;packet-&gt;y, p, <span class="keyword">sizeof</span>(<span class="type">float</span>));<span class="comment">//buffer[9] buffer[10] buffer[11] buffer[12]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在串口接收中断中调用此函数，将接收到的数据存入缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HandleReceivedData</span><span class="params">(<span class="type">uint8_t</span> data)</span> &#123;</span><br><span class="line">  <span class="comment">// 如果缓冲区已满，清空缓冲区</span></span><br><span class="line">  <span class="keyword">if</span> (p_buffer &gt;= buffer + BUFFER_SIZE) &#123;</span><br><span class="line">    p_buffer = buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将数据存入缓冲区</span></span><br><span class="line">  *p_buffer++ = data;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断是否接收到完整的数据包</span></span><br><span class="line">  <span class="keyword">if</span> (p_buffer - buffer &gt;= <span class="keyword">sizeof</span>(DataPacket) + <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查帧头和帧尾是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (buffer[<span class="number">0</span>] ==FRAME_HEADER &amp;&amp; buffer[<span class="keyword">sizeof</span>(DataPacket) + <span class="number">1</span>] == FRAME_TAIL) &#123;</span><br><span class="line">      <span class="comment">// 接收到完整的数据包</span></span><br><span class="line">      packet_received = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空缓冲区</span></span><br><span class="line">    p_buffer = buffer;<span class="comment">//指针重新指向buffer数组首地址</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主函数中调用此函数，处理接收到的数据包</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ProcessReceivedData</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 如果接收到完整的数据包，则解析数据包</span></span><br><span class="line">  <span class="keyword">if</span> (packet_received) &#123;</span><br><span class="line">    DataPacket packet;</span><br><span class="line">    ParseDataPacket(&amp;packet);<span class="comment">//处理之后定义的packet中angle x y就有数据了 可以直接调用 eg: packet.angle</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理解析后的数据包，例如将数据包的内容显示到LCD屏幕上</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除标志位</span></span><br><span class="line">    packet_received = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**********************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 在主函数中循环调用此函数，以处理接收到的数据</span></span><br><span class="line"><span class="comment">//void Loop() &#123;</span></span><br><span class="line"><span class="comment">//  // 处理接收到的数据包</span></span><br><span class="line"><span class="comment">//  ProcessReceivedData();</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//  // 继续执行其他任务</span></span><br><span class="line"><span class="comment">//  // ...</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在中断中</span></span><br><span class="line"><span class="comment">//void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    // 读取接收数据寄存器</span></span><br><span class="line"><span class="comment">//    uint8_t data = (uint8_t)(huart-&gt;Instance-&gt;RDR &amp; 0xFF);</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    // 处理接收到的数据</span></span><br><span class="line"><span class="comment">//    HandleReceivedData(data);</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    // 继续启动接收中断</span></span><br><span class="line"><span class="comment">//    HAL_UART_Receive_IT(huart, &amp;data, 1);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PACKET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRAME_HEADER 0x7E   <span class="comment">// 帧头</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRAME_TAIL 0x7F     <span class="comment">// 帧尾</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> angle;</span><br><span class="line">  <span class="type">float</span> x;</span><br><span class="line">  <span class="type">float</span> y;</span><br><span class="line">&#125; DataPacket;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">floatToBytes</span><span class="params">(<span class="type">float</span> val, <span class="type">uint8_t</span>* bytes)</span>;<span class="comment">//转换单精度浮点数为字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendPacket</span><span class="params">(<span class="type">float</span> angle, <span class="type">float</span> x, <span class="type">float</span> y)</span>;<span class="comment">//发送数据包</span></span><br><span class="line"><span class="comment">//bool parsePacket(uint8_t* packet, float* angle, float* x, float* y);//解析数据包</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ParseDataPacket</span><span class="params">(DataPacket* packet)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ProcessReceivedData</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*PACKET_H*/</span></span></span><br></pre></td></tr></table></figure><h2 id="8-基于状态机"><a href="#8-基于状态机" class="headerlink" title="8.基于状态机"></a>8.基于状态机</h2><p>当“喂一口饭”、“回一个信息”都需要花很长的时间，无论使用前面的哪种设计模式，都会退化到轮询模式的缺点：函数相互之间有影响。可以使用状态机来解决这个缺点，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态机</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        喂一口饭();</span><br><span class="line">        回一个信息();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main函数里，还是使用轮询模式依次调用2个函数。</p><p>关键在于这2个函数的内部实现：<strong>使用状态机，每次只执行一个状态的代码，减少每次执行的时间</strong>，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 喂一口饭(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 舀饭 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 喂饭 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 舀菜 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 喂菜 */</span></span><br><span class="line">            <span class="comment">/* 恢复到初始状态 */</span></span><br><span class="line">            state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> 回一个信息(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 查看信息 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 打字 */</span></span><br><span class="line">            <span class="comment">/* 进入下一个状态 */</span></span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 发送 */</span></span><br><span class="line">            <span class="comment">/* 恢复到初始状态 */</span></span><br><span class="line">            state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以“喂一口饭”为例，函数内部拆分为4个状态：舀饭、喂饭、舀菜、喂菜。每次执行“喂一口饭”函数时，都只会执行其中的某一状态对应的代码。以前执行一次“喂一口饭”函数可能需要4秒钟，现在可能只需要1秒钟，就<strong>降低了对后面“回一个信息”的影响。</strong></p><p>同样的，“回一个信息”函数内部也被拆分为3个状态：查看信息、打字、发送。每次执行这个函数时，都只是执行其中一小部分代码，降低了对“喂一口饭”的影响。</p><p><strong>使用状态机模式，可以解决裸机程序的难题：假设有A、B两个都很耗时的函数，怎样降低它们相互之间的影响。但是很多场景里，函数A、B并不容易拆分为多个状态，并且这些状态执行的时间并不好控制。所以这并不是最优的解决方法，需要使用多任务系统。</strong></p><h2 id="9-FSM状态机"><a href="#9-FSM状态机" class="headerlink" title="9.FSM状态机"></a>9.FSM状态机</h2><p>首先初始化FSM状态机，FSM_Init(PASSIVE);</p><p>在一个while(1)中运行FSM_Run();</p><p>在外部触发条件下使用FSM_SetState( )来设置想切换的模式;此过程中FSM模式变为CHANGE模式（FSM.mode &#x3D; CHANGE;）</p><p>FSM的下一个状态变为FSM.nextState &#x3D; state；  </p><p>这样在FSM_Run();中 首先运行FSM.exit();  即当前的状态的exit函数，然后使用FSM_ChangeState();函数将FSM的进入，运行，退出函数改成要切换的状态所对应的  （每一个状态写一个单独的.c.h文件，然后所有.h文件放到FSM.h中，FSM.c文件直接用FSM.h就行）</p><p>​    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FSM.enter = Passive_Enter;</span><br><span class="line"></span><br><span class="line">FSM.run = Passive_Run;</span><br><span class="line"></span><br><span class="line">FSM.<span class="built_in">exit</span> = Passive_Exit;</span><br></pre></td></tr></table></figure><p>然后就是该状态的进入函数，此时切换状态这一过程已经结束了，FSM模式变为NOMARL模式，然后运行该状态的运行函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*FSM.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FSM.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">FSM_t FSM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态切换 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_ChangeState</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 当前状态为下一个状态 */</span></span><br><span class="line">    FSM.currentState = FSM.nextState;</span><br><span class="line">    <span class="comment">/* 设置当前函数指针 */</span></span><br><span class="line">    <span class="keyword">switch</span> (FSM.nextState)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FIXEDSTAND:</span><br><span class="line">        FSM.enter = FixedStand_Enter;</span><br><span class="line">        FSM.run = FixedStand_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = FixedStand_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">case</span> TROTING:</span><br><span class="line">        FSM.enter = Troting_Enter;</span><br><span class="line">        FSM.run = Troting_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Troting_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WALKING:</span><br><span class="line">        FSM.enter = Walking_Enter;</span><br><span class="line">        FSM.run = Walking_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Walking_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> JUMP:</span><br><span class="line">        FSM.enter = Jump_Enter;</span><br><span class="line">        FSM.run = Jump_Run;</span><br><span class="line">        FSM.<span class="built_in">exit</span> = Jump_Exit;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 有限状态机初始化 */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_Init</span><span class="params">(FSMState_e state)</span></span><br><span class="line">&#123;</span><br><span class="line">    FSM.currentState = state;</span><br><span class="line">    FSM.nextState = state;</span><br><span class="line">    FSM_ChangeState();</span><br><span class="line">    FSM.enter();</span><br><span class="line">    FSM.mode = NORMAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 有限状态机运行 */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_Run</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (FSM.mode == NORMAL)</span><br><span class="line">    &#123;</span><br><span class="line">        FSM.run(); <span class="comment">// In normal mode, run current state.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (FSM.mode == CHANGE)</span><br><span class="line">    &#123;</span><br><span class="line">        FSM.<span class="built_in">exit</span>(); <span class="comment">// In changing mode, run the exit function for previous state,</span></span><br><span class="line">        FSM_ChangeState();</span><br><span class="line">        </span><br><span class="line">        FSM.enter(); <span class="comment">// and run the enter function for next state.</span></span><br><span class="line">        FSM.mode = NORMAL;</span><br><span class="line">        FSM.run(); <span class="comment">// then run the run function for current state.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 有限状态机设置状态 */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">FSM_SetState</span><span class="params">(FSMState_e state)</span></span><br><span class="line">&#123;</span><br><span class="line">    FSM.mode = CHANGE;</span><br><span class="line">    FSM.nextState = state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*FSM.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FSM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_FixedStand.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Passive.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Troting.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Fall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Walking.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Jump.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_Jump2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_JumpL.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_JumpL2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_JumpR.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_JumpR2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_catJump.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;State_catJump2.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NORMAL,</span><br><span class="line">    CHANGE,</span><br><span class="line">&#125; FSMMode_e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PASSIVE = <span class="number">1</span>,    <span class="comment">// 阻尼</span></span><br><span class="line">    FALL = <span class="number">2</span>,       <span class="comment">// 卧倒</span></span><br><span class="line">    FIXEDSTAND = <span class="number">3</span>, <span class="comment">// 固定站立</span></span><br><span class="line">    FREESTAND = <span class="number">4</span>,  <span class="comment">// 自由站立</span></span><br><span class="line">    TROTING = <span class="number">5</span>,    <span class="comment">// 对角步态</span></span><br><span class="line">    WALKING = <span class="number">6</span>,    <span class="comment">// 行走步态</span></span><br><span class="line">    JUMP = <span class="number">7</span>,       <span class="comment">// 跳跃</span></span><br><span class="line">    JUMP2 = <span class="number">8</span>,      <span class="comment">// 跳跃2</span></span><br><span class="line">    JUMPL = <span class="number">9</span>,</span><br><span class="line">    JUMPL2 = <span class="number">10</span>,</span><br><span class="line">    JUMPR = <span class="number">11</span>,</span><br><span class="line">    JUMPR2 = <span class="number">12</span>,</span><br><span class="line">    catJUMP = <span class="number">13</span>,</span><br><span class="line">    catJUMP2 = <span class="number">14</span>,</span><br><span class="line">&#125; FSMState_e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FSMMode_e mode;</span><br><span class="line">    FSMState_e currentState;</span><br><span class="line">    FSMState_e nextState;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*enter)(<span class="type">void</span>); <span class="comment">//函数指针，见前面章节</span></span><br><span class="line">    <span class="type">void</span> (*run)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">exit</span>)(<span class="type">void</span>);</span><br><span class="line">&#125; FSM_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> FSM_t FSM;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FSM_Init</span><span class="params">(FSMState_e state)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FSM_Run</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FSM_SetState</span><span class="params">(FSMState_e state)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><img src="/2024/01/26/Embedded-C-language/image-20240116005300807.png" alt="image-20240116005300807"></p><h2 id="10-PID算法"><a href="#10-PID算法" class="headerlink" title="10.PID算法"></a>10.PID算法</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>PID，就是“比例（proportional）、积分（integral）、微分（derivative）</p><p>它可以将需要控制的物理量带到目标附近</p><p>它可以“预见”这个量的变化趋势</p><p>它也可以消除因为散热、阻力等因素造成的静态误差</p><p><strong>kP</strong></p><p>实际写程序时，<strong>就让偏差（目标减去当前）与调节装置的“调节力度”，建立一个一次函数的关系</strong>，就可以实现最基本的“比例”控制了~<br>kP越大，调节作用越激进，kP调小会让调节作用更保守。</p><p>刚才我们有了P的作用。你不难发现，只有P好像不能让平衡车站起来，水温也控制得晃晃悠悠，好像整个系统不是特别稳定，总是在“抖动”。</p><p><strong>kD</strong> </p><p><em><strong>阻尼</strong></em>， kD参数越大，向速度相反方向刹车的力道就越强。</p><p><strong>KI</strong> </p><p>设置一个积分量。只要偏差存在，就不断地对偏差进行积分（累加），并反应在调节力度上。</p><p>I的作用就是，减小静态情况下的误差（消除稳态误差），让受控物理量尽可能接近目标值。</p><p>在使用时还有个问题：需要设定积分限制。防止在刚开始加热时，就把积分量积得太大，难以控制。</p><p><em><strong>使用</strong></em></p><p><em><strong>需要及时更新数据，一般是写个while循环使用pid_calc，延时几毫秒更新1次</strong></em></p><p>1.DJ</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PID.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PID初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PID_Init</span><span class="params">(PID_t *pid, <span class="type">float</span> kp, <span class="type">float</span> ki, <span class="type">float</span> kd, <span class="type">float</span> max_out, <span class="type">float</span> max_iout)</span></span><br><span class="line">&#123;</span><br><span class="line">    pid-&gt;Kp = kp;</span><br><span class="line">    pid-&gt;Ki = ki;</span><br><span class="line">    pid-&gt;Kd = kd;</span><br><span class="line">    pid-&gt;max_out = max_out;</span><br><span class="line">    pid-&gt;max_iout = max_iout;</span><br><span class="line">    pid-&gt;err[<span class="number">0</span>] = pid-&gt;err[<span class="number">1</span>] = <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PID计算, 输入反馈值和预期值</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">PID_Calc</span><span class="params">(PID_t *pid, <span class="type">float</span> fdb, <span class="type">float</span> <span class="built_in">set</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pid-&gt;<span class="built_in">set</span> = <span class="built_in">set</span>;</span><br><span class="line">    pid-&gt;fdb = fdb;</span><br><span class="line">    pid-&gt;err[<span class="number">1</span>] = pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">    pid-&gt;err[<span class="number">0</span>] = pid-&gt;<span class="built_in">set</span> - pid-&gt;fdb;</span><br><span class="line"></span><br><span class="line">    pid-&gt;Pout = pid-&gt;Kp * pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">    pid-&gt;Iout += pid-&gt;Ki * pid-&gt;err[<span class="number">0</span>];</span><br><span class="line">    pid-&gt;Dout = pid-&gt;Kd * pid-&gt;err[<span class="number">0</span>] - pid-&gt;err[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid-&gt;Iout &gt; pid-&gt;max_iout)</span><br><span class="line">    &#123;</span><br><span class="line">        pid-&gt;Iout = pid-&gt;max_iout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid-&gt;Iout &lt; -pid-&gt;max_iout)</span><br><span class="line">    &#123;</span><br><span class="line">        pid-&gt;Iout = -pid-&gt;max_iout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid-&gt;out = pid-&gt;Pout + pid-&gt;Iout + pid-&gt;Dout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid-&gt;out &gt; pid-&gt;max_out)</span><br><span class="line">    &#123;</span><br><span class="line">        pid-&gt;out = pid-&gt;max_out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid-&gt;out &lt; -pid-&gt;max_out)</span><br><span class="line">    &#123;</span><br><span class="line">        pid-&gt;out = -pid-&gt;max_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pid-&gt;out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PID_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PID_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">float</span> Kp;</span><br><span class="line">    <span class="type">float</span> Ki;</span><br><span class="line">    <span class="type">float</span> Kd;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> max_out;  <span class="comment">// 最大输出</span></span><br><span class="line">    <span class="type">float</span> max_iout; <span class="comment">// 最大积分输出</span></span><br><span class="line">    <span class="type">float</span> err[<span class="number">2</span>];   <span class="comment">// 误差及上一次误差</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="type">float</span> fdb;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> out;</span><br><span class="line">    <span class="type">float</span> Pout;</span><br><span class="line">    <span class="type">float</span> Iout;</span><br><span class="line">    <span class="type">float</span> Dout;</span><br><span class="line">&#125; PID_t;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PID_Init</span><span class="params">(PID_t *pid, <span class="type">float</span> kp, <span class="type">float</span> ki, <span class="type">float</span> kd, <span class="type">float</span> max_out, <span class="type">float</span> max_iout)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">PID_Calc</span><span class="params">(PID_t *pid, <span class="type">float</span> fdb, <span class="type">float</span> <span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.电机位置环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*pid.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_pid.h&quot;</span></span></span><br><span class="line"><span class="comment">//1 0.10 0.1</span></span><br><span class="line"><span class="type">float</span> Position_KP=<span class="number">0.5</span>,Position_KI=<span class="number">0.00</span>,Position_KD=<span class="number">0.09</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Position_PID</span><span class="params">(<span class="type">int</span> reality,<span class="type">int</span> target)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> Bias,Pwm,Last_Bias,Integral_bias;</span><br><span class="line">     </span><br><span class="line">    Bias=target-reality;                            <span class="comment">/* 计算偏差 */</span></span><br><span class="line">    Integral_bias+=Bias;                        <span class="comment">/* 偏差累积 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Integral_bias&gt; <span class="number">3000</span>) Integral_bias = <span class="number">3000</span>;   <span class="comment">/* 积分限幅 */</span></span><br><span class="line">    <span class="keyword">if</span>(Integral_bias&lt;<span class="number">-3000</span>) Integral_bias =<span class="number">-3000</span>;</span><br><span class="line">    </span><br><span class="line">    Pwm = (Position_KP*Bias)                        <span class="comment">/* 比例环节 */</span></span><br><span class="line">         +(Position_KI*Integral_bias)               <span class="comment">/* 积分环节 */</span></span><br><span class="line">         +Position_KD*(Bias-Last_Bias);             <span class="comment">/* 微分环节 */</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(Pwm&gt;<span class="number">4000</span>) Pwm=<span class="number">4000</span>;</span><br><span class="line"><span class="keyword">if</span>(Pwm&lt;<span class="number">-4000</span>) Pwm=<span class="number">-4000</span>;</span><br><span class="line"><span class="comment">/*if(Pwm&gt;0&amp;&amp;Pwm&lt;1000)</span></span><br><span class="line"><span class="comment">Pwm=1000;</span></span><br><span class="line"><span class="comment">if(Pwm&lt;0&amp;&amp;Pwm&gt;-1000)</span></span><br><span class="line"><span class="comment">Pwm=-1000;*/</span></span><br><span class="line"></span><br><span class="line">    Last_Bias=Bias;                                 <span class="comment">/* 保存上次偏差 */</span></span><br><span class="line">    <span class="keyword">return</span> Pwm;                                     <span class="comment">/* 输出结果 */</span>              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><p><strong>循迹</strong>（写的不太好，看看就行）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_linewalking2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">bsp_GetLineWalking1(&amp;SADC1);</span><br><span class="line"><span class="keyword">if</span>(SADC1)</span><br><span class="line">&#123;</span><br><span class="line">Systick_Delay_ms(<span class="number">5</span>);</span><br><span class="line">bsp_GetLineWalking1(&amp;SADC1);</span><br><span class="line"><span class="keyword">if</span>(SADC1)</span><br><span class="line">&#123;</span><br><span class="line">car_STOP();</span><br><span class="line">Systick_Delay_ms(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Car_Run(<span class="number">10</span>,<span class="number">0.5</span>,<span class="number">3000</span>,<span class="number">3000</span>,<span class="number">3000</span>,<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Car_Run</span><span class="params">(<span class="type">float</span> kp,<span class="type">float</span> kd, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">MOTOR1_state(GO);       </span><br><span class="line">MOTOR2_state(GO);</span><br><span class="line">MOTOR4_state(GO);</span><br><span class="line">MOTOR3_state(GO);       </span><br><span class="line"></span><br><span class="line">Speed_1(PWMA(kp,kd,a));Speed_2(PWMB(kp,kd,b));Speed_3(PWMC(kp,kd,c));Speed_4(PWMD(kp,kd,d));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">PWMA</span> <span class="params">(u16 kp,u16 kd, u16 basic)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> error;</span><br><span class="line"><span class="type">double</span> mistake;</span><br><span class="line"><span class="type">double</span> fix1speed;</span><br><span class="line">u16 fix2speed;</span><br><span class="line">u16 olderror;</span><br><span class="line">u16 der;</span><br><span class="line"><span class="type">int</span> PWM;</span><br><span class="line"><span class="type">int</span> P;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  mistake= Get_Adc(ADC_CHANNE_ML) - Get_Adc(ADC_CHANNE_MR);<span class="comment">//左-右 F7-F9</span></span><br><span class="line">mistake=mistake/<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (mistake&gt;<span class="number">200</span>) error=<span class="number">200</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mistake==<span class="number">200</span>) error=<span class="number">200</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mistake&gt;<span class="number">0</span>&amp;&amp;mistake&lt;<span class="number">200</span>)error = mistake;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mistake&lt;<span class="number">0</span>&amp;&amp;mistake&gt;<span class="number">-200</span>) error=-mistake;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mistake==<span class="number">-200</span>) error=<span class="number">200</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mistake&lt;<span class="number">-200</span>) error=<span class="number">200</span>;</span><br><span class="line">  fix1speed = kp*error;</span><br><span class="line">olderror=error;</span><br><span class="line">der=error-olderror;</span><br><span class="line">fix2speed= kd*der;</span><br><span class="line"><span class="keyword">if</span> (Get_Adc(ADC_CHANNE_ML)&gt;Get_Adc(ADC_CHANNE_MR)) PWM = basic + fix1speed+fix2speed;  <span class="comment">//左边大于右边 说明黑线靠右  左轮应加速</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Get_Adc(ADC_CHANNE_ML)&lt;Get_Adc(ADC_CHANNE_MR)) PWM = basic - <span class="number">1</span>* (fix1speed+fix2speed);<span class="comment">//   黑线偏左   左轮应减速    3是电机正转和反转在相同pwm下速度不同</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Get_Adc(ADC_CHANNE_ML)== Get_Adc(ADC_CHANNE_MR)) PWM =basic;</span><br><span class="line"><span class="keyword">if</span> (PWM&lt;<span class="number">0</span>) PWM=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> PWM=PWM;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> PWM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>电机位置环</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Pos_ctrl_ML</span><span class="params">(<span class="type">float</span> rotationNum)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Moto = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Target_Position=Num_Encoder_Cnt(rotationNum,ENCODER_RESOLUTION,MOTOR_REDUCTION_RATIO);</span><br><span class="line">Read_Encoder(<span class="number">5</span>);</span><br><span class="line">Encoder_Cnt+=Encoder_cnt;<span class="comment">//每次读完清空是为了累加从每次起始点开始的脉冲数</span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">if</span>(Encoder_Cnt==Target_Position)</span><br><span class="line">    &#123;</span><br><span class="line">      Set_PWM_ML(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      Moto = Position_PID(Encoder_Cnt,Target_Position); </span><br><span class="line">      Set_PWM_ML(Moto);</span><br><span class="line">      Set_PWM_MR(Moto);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;Encoder_Cnt=%d\tTarget_Position=%d\tccr=%d\t\r\n&quot;,Encoder_Cnt,Target_Position,Moto);</span></span><br><span class="line">HAL_Delay(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*pid.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_pid.h&quot;</span></span></span><br><span class="line"><span class="comment">//1 0.10 0.1</span></span><br><span class="line"><span class="type">float</span> Position_KP=<span class="number">0.5</span>,Position_KI=<span class="number">0.00</span>,Position_KD=<span class="number">0.09</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Position_PID</span><span class="params">(<span class="type">int</span> reality,<span class="type">int</span> target)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> Bias,Pwm,Last_Bias,Integral_bias;</span><br><span class="line">     </span><br><span class="line">    Bias=target-reality;                            <span class="comment">/* 计算偏差 */</span></span><br><span class="line">    Integral_bias+=Bias;                        <span class="comment">/* 偏差累积 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Integral_bias&gt; <span class="number">3000</span>) Integral_bias = <span class="number">3000</span>;   <span class="comment">/* 积分限幅 */</span></span><br><span class="line">    <span class="keyword">if</span>(Integral_bias&lt;<span class="number">-3000</span>) Integral_bias =<span class="number">-3000</span>;</span><br><span class="line">    </span><br><span class="line">    Pwm = (Position_KP*Bias)                        <span class="comment">/* 比例环节 */</span></span><br><span class="line">         +(Position_KI*Integral_bias)               <span class="comment">/* 积分环节 */</span></span><br><span class="line">         +Position_KD*(Bias-Last_Bias);             <span class="comment">/* 微分环节 */</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(Pwm&gt;<span class="number">4000</span>) Pwm=<span class="number">4000</span>;</span><br><span class="line"><span class="keyword">if</span>(Pwm&lt;<span class="number">-4000</span>) Pwm=<span class="number">-4000</span>;</span><br><span class="line"><span class="comment">/*if(Pwm&gt;0&amp;&amp;Pwm&lt;1000)</span></span><br><span class="line"><span class="comment">Pwm=1000;</span></span><br><span class="line"><span class="comment">if(Pwm&lt;0&amp;&amp;Pwm&gt;-1000)</span></span><br><span class="line"><span class="comment">Pwm=-1000;*/</span></span><br><span class="line"></span><br><span class="line">    Last_Bias=Bias;                                 <span class="comment">/* 保存上次偏差 */</span></span><br><span class="line">    <span class="keyword">return</span> Pwm;                                     <span class="comment">/* 输出结果 */</span>              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C language programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/01/22/hello-world/"/>
      <url>/2024/01/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hello World!</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>尽吾志也而不能至者，可以无悔矣</title>
      <link href="/gallery/crane.html"/>
      <url>/gallery/crane.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-container" data-type="data" data-button>      <div class="gallery-data">[{"url":"./crane/19-1706339747403-43.jpg","alt":"19"},{"url":"./crane/18-1706339819893-45.jpg","alt":"18"},{"url":"./crane/17-1706339835479-47.jpg","alt":"17"},{"url":"./crane/16-1706339842391-49.jpg","alt":"16"},{"url":"./crane/4-1706339853690-51.jpg","alt":"4"},{"url":"./crane/6-1706339861221-53.jpg","alt":"6"},{"url":"./crane/12-1706339867143-55.jpg","alt":"12"},{"url":"./crane/7-1706339875488-57.jpg","alt":"7"},{"url":"./crane/13.jpg","alt":"13"},{"url":"./crane/15-1706339890044-60.jpg","alt":"15"},{"url":"./crane/9-1706339896866-62.jpg","alt":"9"},{"url":"./crane/3-1706339904800-64.jpg","alt":"3"},{"url":"./crane/5-1706339910791-66.jpg","alt":"5"}]</div>      <div class="gallery-items">      </div>    </div><div id="music-page"></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-group-main">    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="/./images/7.jpg" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">我的大学</div>  <p>我的奋斗</p>  <a href="/gallery/college"></a>  </figcaption>  </figure>      <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="/./images/6.jpg" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Robocon</div>  <p>WUST ROBOCON 2023</p>  <a href="/gallery/robocon"></a>  </figcaption>  </figure>      <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="/./images/8.jpg" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">起重机</div>  <p>命运的齿轮开始转动</p>  <a href="/gallery/crane"></a>  </figcaption>  </figure>  </div>    ]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>路虽远行则将至，事虽难做则必成</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>zhixiong&#39;s page</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/message/index.html"/>
      <url>/message/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>欲买桂花同载酒，终不似，少年游</title>
      <link href="/gallery/robocon.html"/>
      <url>/gallery/robocon.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-container" data-type="data" data-button>      <div class="gallery-data">[{"url":"./robocon/5.jpg","alt":"5"},{"url":"./robocon/4.jpg","alt":"4"},{"url":"./robocon/IMG_20221026_171356.jpg","alt":"IMG_20221026_171356"},{"url":"./robocon/IMG_20230226_160022.jpg","alt":"IMG_20230226_160022"},{"url":"./robocon/IMG_20230226_181211.jpg","alt":"IMG_20230226_181211"},{"url":"./robocon/IMG_20230522_191254.jpg","alt":"IMG_20230522_191254"},{"url":"./robocon/IMG_20230614_211620.jpg","alt":"IMG_20230614_211620"},{"url":"./robocon/IMG_20230707_132558.jpg","alt":"IMG_20230707_132558"},{"url":"./robocon/IMG_20230707_184452.jpg","alt":"IMG_20230707_184452"},{"url":"./robocon/IMG_20230707_205101.jpg","alt":"IMG_20230707_205101"},{"url":"./robocon/mmexport98bdd9d9588b4cdaa855aa0ae3d7dce5_1688707161464.jpeg","alt":"mmexport98bdd9d9588b4cdaa855aa0ae3d7dce5_1688707161464"},{"url":"./robocon/Screenshot_20230413_121149.jpg","alt":"Screenshot_20230413_121149"},{"url":"./robocon/Screenshot_20230708_105442.jpg","alt":"Screenshot_20230708_105442"},{"url":"./robocon/1f808d0f5874cda9.jpg","alt":"1f808d0f5874cda9"},{"url":"./robocon/62ed118391dafe0a.jpg","alt":"62ed118391dafe0a"},{"url":"./robocon/274a1c04a632f15c.jpg","alt":"274a1c04a632f15c"},{"url":"./robocon/-757c3e143b47490f.jpg","alt":"-757c3e143b47490f"}]</div>      <div class="gallery-items">      </div>    </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>前路漫漫亦灿灿</title>
      <link href="/gallery/college.html"/>
      <url>/gallery/college.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-container" data-type="data" data-button>      <div class="gallery-data">[{"url":"./college/49-1706344694822-120.jpg","alt":"49"},{"url":"./college/48-1706344708682-122.jpg","alt":"48"},{"url":"./college/47-1706344716685-124.jpg","alt":"47"},{"url":"./college/46-1706344721866-126.jpg","alt":"46"},{"url":"./college/45-1706344637895-118.jpg","alt":"45"},{"url":"./college/39-1706345196130-209.jpg","alt":"39"},{"url":"./college/37-1706345211163-211.jpg","alt":"37"},{"url":"./college/33-1706345229054-213.jpg","alt":"33"},{"url":"./college/29-1706345235414-215.jpg","alt":"29"},{"url":"./college/19-1706345257443-217.jpg","alt":"19"},{"url":"./college/12-1706345274915-219.jpg","alt":"12"},{"url":"./college/13-1706345280346-221.jpg","alt":"13"},{"url":"./college/14-1706345293624-223.jpg","alt":"14"},{"url":"./college/31-1706345317371-225.jpg","alt":"31"},{"url":"./college/43-1706345325834-227.jpg","alt":"43"},{"url":"./college/41-1706345332395-229.jpg","alt":"41"},{"url":"./college/38-1706345344631-231.jpg","alt":"38"},{"url":"./college/30-1706345352332-233.jpg","alt":"30"},{"url":"./college/32-1706345365438-235.jpg","alt":"32"},{"url":"./college/50.jpg","alt":"50"},{"url":"./college/34-1706345374354-237.jpg","alt":"34"},{"url":"./college/51.jpg","alt":"51"},{"url":"./college/52.jpg","alt":"52"},{"url":"./college/35-1706345381156-239.jpg","alt":"35"},{"url":"./college/20-1706345398048-241.jpg","alt":"20"},{"url":"./college/25-1706345411044-243.jpg","alt":"25"},{"url":"./college/24-1706345419521-245.jpg","alt":"24"},{"url":"./college/23-1706345425445-247.jpg","alt":"23"},{"url":"./college/17-1706345438446-249.jpg","alt":"17"},{"url":"./college/9-1706345445647-251.jpg","alt":"9"},{"url":"./college/8-1706345461721-257.jpg","alt":"8"},{"url":"./college/26-1706345477181-259.jpg","alt":"26"},{"url":"./college/16-1706345482816-261.jpg","alt":"16"},{"url":"./college/7-1706345489413-263.jpg","alt":"7"},{"url":"./college/6-1706345496102-265.jpg","alt":"6"},{"url":"./college/4-1706345502454-267.jpg","alt":"4"},{"url":"./college/3-1706345507417-269.jpg","alt":"3"},{"url":"./college/2-1706345515116-271.jpg","alt":"2"},{"url":"./college/1-1706345519911-273.jpg","alt":"1"}]</div>      <div class="gallery-items">      </div>    </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Vscode&amp;Keil</title>
      <link href="/vscode-keil/index-1.html"/>
      <url>/vscode-keil/index-1.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>vscode&amp;keil</title>
      <link href="/vscode-keil/index.html"/>
      <url>/vscode-keil/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
